<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Rinevard</title>
  
  
  <link href="http://rinevard.github.io/atom.xml" rel="self"/>
  
  <link href="http://rinevard.github.io/"/>
  <updated>2025-03-05T11:02:56.578Z</updated>
  <id>http://rinevard.github.io/</id>
  
  <author>
    <name>Rinevard</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>第二章——计算机内的信息表示</title>
    <link href="http://rinevard.github.io/wiki/learning/open-course/CMU-15-213/Notes/Chapter2-data-representation/"/>
    <id>http://rinevard.github.io/wiki/learning/open-course/CMU-15-213/Notes/Chapter2-data-representation/</id>
    <published>2025-03-25T10:36:28.000Z</published>
    <updated>2025-03-05T11:02:56.578Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，在32位机器上和64位机器上，相同的C语言数据类型可能占用不同的字节数：</p><table><thead><tr><th>C declaration</th><th></th><th>Bytes</th><th></th></tr></thead><tbody><tr><td>Signed</td><td>Unsigned</td><td>32-bit</td><td>64-bit</td></tr><tr><td>[signed] char</td><td>unsigned char</td><td>1</td><td>1</td></tr><tr><td>short</td><td>unsigned short</td><td>2</td><td>2</td></tr><tr><td>int</td><td>unsigned</td><td>4</td><td>4</td></tr><tr><td>long</td><td>unsigned long</td><td>4</td><td>8</td></tr><tr><td>int32_t</td><td>uint32_t</td><td>4</td><td>4</td></tr><tr><td>int64_t</td><td>uint64_t</td><td>8</td><td>8</td></tr><tr><td>char *</td><td></td><td>4</td><td>8</td></tr><tr><td>float</td><td></td><td>4</td><td>4</td></tr><tr><td>double</td><td></td><td>8</td><td>8</td></tr></tbody></table><h1 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h1><h2 id="表示"><a href="#表示" class="headerlink" title="表示"></a>表示</h2><p>这里真的有什么值得记笔记的吗？总之整数的表示可以分为unsigned和signed，前者只能表示非负数，后者可以表示整数。下面是各个整数类型<strong>占用的字节数</strong>：</p><table><thead><tr><th>C declaration</th><th></th><th>Bytes</th><th></th></tr></thead><tbody><tr><td>Signed</td><td>Unsigned</td><td>32-bit</td><td>64-bit</td></tr><tr><td>short</td><td>unsigned short</td><td>2</td><td>2</td></tr><tr><td>int</td><td>unsigned</td><td>4</td><td>4</td></tr><tr><td>long</td><td>unsigned long</td><td>4</td><td>8</td></tr></tbody></table><p>众所周知，signed的表示采用补码表示，就是模 $2^m$ 意义下对应的最小正数的二进制表示，其中 $m$ 是耗费的 bits 数。听起来有点抽象？这是写给自己看的笔记，我不觉得自己应该忘掉这个！</p><p>不过考虑到失忆的可能，我还是再讲解一下。</p><p>下面的例子中类型是signed short，$15213$ 的表示就是它的二进制表示，而 $-15213$ 的表示实际上是 $-15213 + 2^{16<br>}$ 的二进制表示。</p><table><thead><tr><th></th><th>Decimal</th><th>Hex</th><th>Binary</th></tr></thead><tbody><tr><td>x</td><td>15213</td><td>3B 6D</td><td>00111011 01101101</td></tr><tr><td>y</td><td>-15213</td><td>C4 93</td><td>11000100 10010011</td></tr></tbody></table><p>让我们假设二进制表示为 $b_{w-1},b_{w-2},…,b_1,b_0$，那么如果是unsigned，其值为</p><p>$$<br>\sum_{k&#x3D;0}^{w-1}2^{k}b_k<br>$$</p><p>如果是signed，当 $b_{w-1}$ 即最高位不为 1 时，把二进制转换成十进制即可。</p><p>当最高位为 1 时，其值为</p><p>$$<br>-2^{w}+\sum_{k&#x3D;0}^{w-1}2^{k}b_k<br>$$</p><p>不难注意到能表示的整数有<strong>上下限</strong>，参考下表：</p><table><thead><tr><th>Signed</th><th>Unsigned</th><th>64-bit</th></tr></thead><tbody><tr><td>short [-32768, 32767]</td><td>unsigned short [0, 65535]</td><td>2</td></tr><tr><td>int [-2^31, 2^31-1]</td><td>unsigned int [0, 2^32-1]</td><td>4</td></tr><tr><td>long [-2^63, 2^63-1]</td><td>unsigned long [0, 2^64-1]</td><td>8</td></tr></tbody></table><h2 id="加法，乘法，左右移"><a href="#加法，乘法，左右移" class="headerlink" title="加法，乘法，左右移"></a>加法，乘法，左右移</h2><p>加法和乘法就是模意义下的加法和乘法，所以你喜欢的运算规律都符合。“溢出”也只是模了一下。</p><p>而<strong>左右移</strong>呢？左移不难理解，把它的表示统一往左边移动，移出范围了就扔掉，最低位填充0. </p><p><code>x &lt;&lt; m</code> 实际上是在做 $2^{m}x<br>(\text{mod $2^w$})$.</p><p>右移则分为逻辑右移和算术右移，前者是在右移后在最高位上填充0，后者在最高位上填充符号位。</p><p>对unsigned来说它们没有区别，毕竟unsigned不考虑符号，但对signed来说就不一样了。</p><p>大多数C编译器对有符号整数实现的是算术右移，<code>x &gt;&gt; m</code> 实际上是在做 $\lfloor \frac{x}{2^m} \rfloor$.</p><h2 id="不同类型的整数一起运算会发生什么？"><a href="#不同类型的整数一起运算会发生什么？" class="headerlink" title="不同类型的整数一起运算会发生什么？"></a>不同类型的整数一起运算会发生什么？</h2><p>核心思想是，在<strong>尽量保证值不变</strong>的前提下把数进行扩展。</p><p>把一个signed short整数和signed int相加会发生什么呢？我们会进行“符号扩展”，把signed short扩展成signed int再做加法，返回一个signed int。</p><p>那，什么是<strong>符号扩展</strong>呢？如果short值是正数，高位会用0填充；如果是负数，高位会用1填充（符号扩展）。uh actually 🤓☝️这是在保证值不变的前提下把short转换成int。</p><p>把一个unsigned int整数和signed long相加会发生什么呢？我们会把unsigned int扩展为 signed long（即在前面加0）再做加法，返回一个signed long。</p><p>当然，也有不能保证值不变的情况。比如unsigned int和signed int相加时，我们会把signed转换成unsigned再求和。</p><p>所以说，拜托不要写这种奇怪的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">signed</span> <span class="type">int</span> a = <span class="number">-1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> b = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a &lt; b) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a &lt; b\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a &gt;= b\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码会输出 $a\geq b$，你这是在破坏数学的世界观！</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>unsigned很可能造成错误。对下面的代码，你觉得哪个是对的？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> i; </span><br><span class="line"><span class="keyword">for</span> (i = cnt<span class="number">-2</span>; i &lt; cnt; i--) </span><br><span class="line">a[i] += a[i+<span class="number">1</span>]</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> i; </span><br><span class="line"><span class="keyword">for</span> (i = cnt<span class="number">-2</span>; i &gt;= <span class="number">0</span>; i--) </span><br><span class="line">a[i] += a[i+<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>答案是前者，因为对后者来说，<code>i = 0</code> 以后 <code>i--</code> 会让 <code>i</code> 溢出变为正数，导致无限循环。不过能不能过编译我不确定，我这里是能过的。</p><p>反正不要写这样的代码，你这是在破坏数学的世界观！</p><h1 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h1><h2 id="表示-1"><a href="#表示-1" class="headerlink" title="表示"></a>表示</h2><p>按照 IEEE 标准，浮点数的表示如下：</p><p><img src="/images/learning/open-course/CMU-15213/Notes/Chapter2/float-representation.png"></p><p>其中 s 是符号位，0表示正数，1表示负数</p><p>计算方式大致为</p><p>$$<br>(-1)^s \times 2^{\text{exp}-\text{bias}}\times(1\text{.frac})<br>$$</p><p>之所以说是“大致”，是因为还存在几种特殊情况。</p><p>如果 exp 全是 0，我们称其为非规格化数（denormalized），使用下面的公式计算：</p><p>$$<br>(-1)^s \times 2^{1-\text{bias}}\times(1\text{.frac})<br>$$</p><p>如果 exp 全是 1，frac全是0，我们认为表示的是infin. 至于是 $+\inf$ 还是 $-\inf$ 由符号位决定。</p><p>如果 exp 全是 1，frac不为0，表示NaN（not a number）.</p><p>看起来确实是很奇怪的标准！这涌现出的结果是，能表示的值在靠近 0 的位置比较密集，在远离 0 的位置比较稀疏。（下图以 exp 占 3 bits，frac占 2 bits为例）</p><p><img src="/images/learning/open-course/CMU-15213/Notes/Chapter2/float-line.png"></p><h2 id="舍入（四舍五入）"><a href="#舍入（四舍五入）" class="headerlink" title="舍入（四舍五入）"></a>舍入（四舍五入）</h2><p>既然浮点数的表示这么奇怪，那如果我把两个浮点数相加，是不是可能得到不精确的结果？真聪明，确实如此！我们一般采取“round-to-even”的策略，即先考虑舍入到更近的那个数，如果两个数一样近，把得到的结果向着更“偶数”的方向去舍入，对二进制表示来说，就是希望它被舍入到结尾为0的那个数上.</p><p>来个例子：</p><p>10.000112 10.002 (&lt;1&#x2F;2—down)<br>10.001102 10.012 (&gt;1&#x2F;2—up)<br>10.111002 11.002 ( 1&#x2F;2—up)<br>10.101002 10.102 ( 1&#x2F;2—down)</p><p>主要好处是减少统计偏差。如果我们采取round up，在统计时统计出的值可能偏高；如果选择round down，统计出的值可能偏低。</p><h2 id="加法，乘法"><a href="#加法，乘法" class="headerlink" title="加法，乘法"></a>加法，乘法</h2><p>浮点数的加法和乘法性质并不良好，我直接把课件复制过来吧：</p><p><strong>浮点数加法：</strong></p><ol><li><strong>封闭性</strong>：是<ul><li>但可能生成无穷大(infinity)或非数值(NaN)</li></ul></li><li><strong>交换律</strong>：是<ul><li>a + b &#x3D; b + a</li></ul></li><li><strong>结合律</strong>：否<ul><li>由于溢出和舍入的不精确性</li><li>例如：(3.14+1e10)-1e10 &#x3D; 0，而3.14+(1e10-1e10) &#x3D; 3.14</li></ul></li><li><strong>零元素</strong>：是<ul><li>0是加法单位元</li></ul></li><li><strong>逆元素</strong>：几乎是<ul><li>除了无穷大和NaN外，每个元素都有加法逆元</li></ul></li><li><strong>单调性</strong>：几乎是<ul><li>a ≥ b ⇒ a+c ≥ b+c</li><li>但对无穷大和NaN例外</li></ul></li></ol><p><strong>浮点数乘法：</strong></p><ol><li><strong>封闭性</strong>：是<ul><li>但可能生成无穷大或NaN</li></ul></li><li><strong>乘法交换律</strong>：是<ul><li>a × b &#x3D; b × a</li></ul></li><li><strong>乘法结合律</strong>：否<ul><li>由于溢出和舍入的不精确性</li><li>例如：(1e20×1e20)×1e-20 &#x3D; inf，而1e20×(1e20×1e-20) &#x3D; 1e20</li></ul></li><li><strong>单位元</strong>：是<ul><li>1是乘法单位元</li></ul></li><li><strong>分配律</strong>：否<ul><li>由于溢出和舍入的不精确性</li><li>例如：1e20×(1e20-1e20) &#x3D; 0.0，而1e20×1e20 - 1e20×1e20 &#x3D; NaN</li></ul></li><li><strong>单调性</strong>：几乎是<ul><li>a ≥ b 且 c ≥ 0 ⇒ a×c ≥ b×c</li><li>但对无穷大和NaN例外</li></ul></li></ol><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>double&#x2F;float → int：对浮点数（无论是单精度还是双精度）来说，把它们转换成int相当于 rounding toward zero，即舍去小数后面的部分。我觉得这应该主要是实现起来方便，我们在datalab里实现了这种转换。如果转换后超出了int的可表示范围，这种转换行为未定义（一般会设为TMin，type minimum，能表示的最小值）。</p><p>int → float：根据rounding mode进行四舍五入，毕竟存在一些float不能表示的int值。</p><p>int → double：精确转换，毕竟double的frac有52个bits，能够表示所有可能的int值。</p><h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1><h2 id="大端法和小端法"><a href="#大端法和小端法" class="headerlink" title="大端法和小端法"></a>大端法和小端法</h2><p>多字节对象在内部存储的字节顺序表示上也有大端法和小端法之分，即最高有效字节在前面还是后面。比如把十六进制的0x01234567存储为01 23 45 67还是67 45 23 01。</p><p><img src="/images/learning/open-course/CMU-15213/Notes/Chapter2/endian.png"></p><p>我们可以用下面的代码检查自己的机器使用的是大端法还是小端法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">is_little_endian</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 将整数的地址转换为字符指针，访问其第一个字节</span></span><br><span class="line">    <span class="type">char</span> *c = (<span class="type">char</span>*) &amp;x;</span><br><span class="line">    <span class="comment">// 如果第一个字节是1，则为小端；如果是0，则为大端</span></span><br><span class="line">    <span class="keyword">return</span> *c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (is_little_endian()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;系统是小端(Little Endian)\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;系统是大端(Big Endian)\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们知道，在32位机器上和64位机器上，相同的C语言数据类型可能占用不同的字节数：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;C declaration&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;Bytes&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thea</summary>
      
    
    
    
    <category term="学习" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="公开课" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/"/>
    
    <category term="CMU-15-213" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/"/>
    
    <category term="Notes" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/Notes/"/>
    
    
  </entry>
  
  <entry>
    <title>技巧的分类，冰山之下的深度</title>
    <link href="http://rinevard.github.io/wiki/game-design/%E5%86%B0%E5%B1%B1%E4%B9%8B%E4%B8%8B%E7%9A%84%E6%B7%B1%E5%BA%A6/"/>
    <id>http://rinevard.github.io/wiki/game-design/%E5%86%B0%E5%B1%B1%E4%B9%8B%E4%B8%8B%E7%9A%84%E6%B7%B1%E5%BA%A6/</id>
    <published>2025-03-08T04:22:38.000Z</published>
    <updated>2025-03-08T04:25:31.525Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/game-design/%E5%86%B0%E5%B1%B1%E4%B9%8B%E4%B8%8B%E7%9A%84%E6%B7%B1%E5%BA%A6/the-iceberg-theory.png"></p><p>《体验引擎》里提到，“深度游戏能够通过高水平的技巧创造有意义的玩法。深度（depth）这个概念用于描述游戏中需要学习的内容有多少。”在这里，我们将探讨一下如何对技巧的类型进行区分，以及如何创造这些技巧来提高游戏深度，同时不让游戏门槛过高。</p><p>既然要求有深度，那游戏里必然有很多技巧。我们有必要对技巧做一个区分——技巧可以被分为“<strong>规则涌现的技巧</strong>”和“<strong>预设的技巧</strong>”。围棋的各种技巧就是前者的一个很好的例子（uh actually☝️🤓数学是更好的例子），而“炸弹能炸开有裂缝的墙”就是后者的一个例子。</p><h1 id="基于规则的技巧"><a href="#基于规则的技巧" class="headerlink" title="基于规则的技巧"></a>基于规则的技巧</h1><p>创造“基于规则的技巧”是相对困难的，因为这要求我们创造能涌现出许多技巧的规则。这种纯粹的创造性活动恐怕没有什么经验可以写，我能说的也只是<strong>多去学学不同领域的知识</strong>。如果要做出有灵性的规则，当然不能只是玩各个游戏并尝试“学习经验”（你学的都是别人做过的规则！），而是要更多去看看自己从未见过的领域。比如说，比起盯着《baba is you》学，不如去学学编程。编程的“赋值”被baba做掉了，但编程的“语句执行顺序”是不是就可以做成noita的魔杖？编程的“抽象”思想会不会也可以做成另一个有趣的规则？</p><p>虽然说“这种创造性活动恐怕没什么经验可写”，但还是写了一堆东西。我确实对基于规则的技巧更感兴趣，这完美实现了“冰山之下的深度”（我在这里点题了！）。不过接下来我们还是聊聊没有灵感时也能做的东西吧。</p><h1 id="预设的技巧"><a href="#预设的技巧" class="headerlink" title="预设的技巧"></a>预设的技巧</h1><p>比起创造基于规则的技巧，创造预设的技巧则简单很多。我们可以随便口胡一些预设的技巧，比如“土狼跳”、“攻击过程中按冲刺能取消攻击”、“在开启技能的前摇时移动来消除前摇而直接开启技能”（唉，取消），实际上为了保证手感，几乎所有游戏都用了大量的预设的技巧。对预设的技巧来说，实际难点在于如何把深度藏在冰山之下，不让玩家因直面大量技巧而感到无所适从。</p><p>把深度藏在冰山之下听着很高大上，实际上最好用的藏深度的做法就是<strong>把预设的技巧逐渐呈现给玩家</strong>。每过几关给玩家一个新能力就是这种做法。更巧妙的做法是<strong>把多个预设的技巧融入到同一个操作之中</strong>，用恰当的关卡设计让技巧逐渐呈现出来。典型的例子是《闰跃之年》，开局跳一下就死了，那怎样跳才能活下来呢？这就是被藏在冰山下的预设的技巧了。</p><p>有的游戏还会<strong>把预设的技巧伪装成规则涌现的技巧</strong>，这让技巧显得更优雅，但实际上不是很本质的改进。我能想到的最好的例子就是《蔚蓝》。蔚蓝把蹭墙跳、凌波微步这些预设的技巧藏在了“惯性”的后面，让各个技巧看起来都是涌现的。虽然这些技巧看起来都和惯性有联系，但实际上玩家并不能根据规则本身推理出这些技巧的存在，因此这是”把预设的技巧伪装成规则涌现的技巧“。</p><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>基于规则的技巧和预设的技巧实际上并非截然对立。大多数情况下，我们都逐渐学到所有的预设的技巧，再把预设的技巧作为规则组合起来形成基于规则的技巧。</p><p>还要注意的是，这种技巧的区分是在呈现给玩家的层面上，而非在实现层面上。如果你硬编码出noita的所有可能的法术搭配并写出对应效果，这在实现层面上显然是“预设”的，但对玩家来说，这仍然是“基于规则”的，毕竟玩家可以基于规则推理出可能的技巧。相较而言，如果我们设计一个和法术相关的游戏，每个法术在代码层面上都是几个小法术的组合，但玩家看到的只是组合好的各个法术而不能自己去组合法术，这在实现层面上是“基于规则”的，但对玩家来说是“预设”的。</p><p>多说一句，“在实现层面上基于规则，但呈现出来的效果是预设的”实际上是很适合做成探索类游戏的。核心思路是，首先把大量的预设的现象呈现给玩家，再让玩家逐步探索现象背后的规则。这种思路在别的游戏里也有，不过全是解谜游戏，我们完全可以做一个更有趣的探索类游戏。比如说玩家看到了火球术，之后我们逐渐引导玩家发现火球术本质上是火焰魔法+移动魔法，玩家就能进而基于规则构建出新魔法了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/game-design/%E5%86%B0%E5%B1%B1%E4%B9%8B%E4%B8%8B%E7%9A%84%E6%B7%B1%E5%BA%A6/the-iceberg-theory.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;《体验引擎》里提到，“</summary>
      
    
    
    
    <category term="游戏设计" scheme="http://rinevard.github.io/categories/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="技巧" scheme="http://rinevard.github.io/categories/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E6%8A%80%E5%B7%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>这里有什么？</title>
    <link href="http://rinevard.github.io/wiki/learning/%E8%BF%99%E6%98%AF%E5%93%AA%E9%87%8C/"/>
    <id>http://rinevard.github.io/wiki/learning/%E8%BF%99%E6%98%AF%E5%93%AA%E9%87%8C/</id>
    <published>2025-03-02T06:28:38.000Z</published>
    <updated>2025-03-05T11:04:37.397Z</updated>
    
    <content type="html"><![CDATA[<p>本来只打算在博客里写杂谈和游戏设计相关文章的，不过想想看把学习笔记在这里记一记似乎也不错。那这里就是学习记录了，主要是写给未来的自己用的。🫠</p><p>应该只有朋友们（cyber friends）会看到这个网站，所以记录一下也是在表明我还在认真学习，没有进入摸鱼态。读者也别忘了终身学习。</p><p>更新（2025.3.5），今天试着加了篇笔记上来，但似乎浏览效果很一般，总之就把这些笔记当作我在学习的证明吧！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本来只打算在博客里写杂谈和游戏设计相关文章的，不过想想看把学习笔记在这里记一记似乎也不错。那这里就是学习记录了，主要是写给未来的自己用的。🫠&lt;/p&gt;
&lt;p&gt;应该只有朋友们（cyber friends）会看到这个网站，所以记录一下也是在表明我还在认真学习，没有进入摸鱼态。读</summary>
      
    
    
    
    <category term="学习" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>Bomblab感想</title>
    <link href="http://rinevard.github.io/wiki/learning/open-course/CMU-15-213/Labs/Bomblab/"/>
    <id>http://rinevard.github.io/wiki/learning/open-course/CMU-15-213/Labs/Bomblab/</id>
    <published>2025-03-02T06:28:38.000Z</published>
    <updated>2025-03-05T10:57:21.211Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>bomblab 比起 datalab 更友好一些，除了考察对汇编代码的理解以外，也在锻炼我们的 gdb 调试技能。用时共计 2+2+0.8+0.5+1.5+4 &#x3D; 10.8h，比 datalab 用时略少一点。刚开始拆弹的时候是很兴奋的，做到后面倒是感觉有点无聊了，我感觉 attacklab 可能更有趣一些（虽然我还没做）。</p><h1 id="拆弹记录"><a href="#拆弹记录" class="headerlink" title="拆弹记录"></a>拆弹记录</h1><p>首先肯定要对 bomb 进行反汇编，我是用 objdump 来反汇编，并把结果保存到了 txt 文件中。拿到汇编以后随便翻翻找到 phase 们，之后就进入拆弹阶段了。</p><h2 id="第一个炸弹"><a href="#第一个炸弹" class="headerlink" title="第一个炸弹"></a>第一个炸弹</h2><p>phase_1 简单易懂，只是判断输入是否与某个字符串相等。我一开始以为字符串就是“0x402400”，后面才想到这是那个字符串的地址。用 gdb 设置断点即可得知字符串。<br>（别看我说得那么轻松，也是折腾了两小时多，毕竟完全没有 gdb 经验 🫠）</p><h2 id="第二个炸弹"><a href="#第二个炸弹" class="headerlink" title="第二个炸弹"></a>第二个炸弹</h2><p>这也是一个不难的炸弹，把汇编代码往下读就能解决，喜欢的话可以加点注释帮助自己理解。<br>不过我仍然做了两个小时，主要在疑惑 read_six_numbers 后数字被读到了哪里。还有个有趣的犯蠢的地方，我一开始把 400f35 处的 0x18 当成了十进制 18，疑惑了很久 4n 怎么可能等于 18，后面猛然惊醒发现那是十六进制。🤣</p><p>在这里我用到了这些新指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">si  # 单步执行</span><br><span class="line">x/10xw $sp          # 查看栈指针(sp)处的10个字(word)，以十六进制(x)显示</span><br><span class="line">x/10i $pc      # 查看当前位置之后的10条指令</span><br><span class="line">i registers eax     # 查看寄存器值</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="第三个炸弹"><a href="#第三个炸弹" class="headerlink" title="第三个炸弹"></a>第三个炸弹</h2><p>用时 50 分钟（有进步！），这次有了更系统的拆弹方法——先把代码分段，然后分析代码提出若干个猜测和问题，随着解答问题就逐渐做掉了。🫠<br>我们可以轻松注意到输入的数字不能少于一个，再往下读就会 400f75 这一行，算一算就会很自然地猜测：输入要求我们选一个选项，跳过去然后 cmp。</p><p>这里是我拆弹时提出的问题以及解答：</p><ol><li>输入按怎样的格式存储起来？存储在哪里？<br>分析栈后发现，看起来是读取了两个数字，存储在栈中</li><li>400f6a 那行是怎么比较的？0x8(%rsp)是什么，输入值吗？猜测这是要求输入的选项值只能在 0-7 之间？<br>设一个断点就能回答这个问题了。</li><li>400f75 跳到了哪里？是根据选项跳跃吗？<br>根据选项跳跃</li><li>从选项跳到了 400fbe 后，0xc(%rsp)是定值还是会根据输入变化？<br>0xc(%rsp)是输入的第二个值。由于 8 对齐，我们需要用 0xc(%rsp)而非 0x10(%rsp)来得到第二个值。</li></ol><h2 id="第四个炸弹"><a href="#第四个炸弹" class="headerlink" title="第四个炸弹"></a>第四个炸弹</h2><p>用时半小时，我连 func4 都不想读，直接用 gdb 来执行 func4，找到返回 0 的输入就行了。这种解法感觉有逃课的嫌疑，不过你就说快不快吧！<br>在这里我用到了这个新指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) call (int)func4(11, 0, 14)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="第五个炸弹"><a href="#第五个炸弹" class="headerlink" title="第五个炸弹"></a>第五个炸弹</h2><p>用时 1.5h，做到这里，我比起刚开始时已经对汇编代码熟悉不少了。首先把代码分成若干个小部分，然后猜测并验证每个部分的功能就能解决这个炸弹。比较有趣的地方是这里加入了一个金丝雀，我还疑惑了一阵子这是什么，后来才想到这是书上讲的金丝雀。</p><h2 id="第六个炸弹"><a href="#第六个炸弹" class="headerlink" title="第六个炸弹"></a>第六个炸弹</h2><p>用时 4h，对这个炸弹，我感觉“根据运行时的状况猜代码的作用”比“分析代码”更加重要。一开始同样是把代码分成多个小局部，然后分段猜作用。这里引入了链表，还挺有趣。</p><p>彩蛋？什么彩弹？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;bomblab 比起 datalab 更友好一些，除了考察对汇编代码的理解以外，也在锻炼我们的 gdb 调试技能。用时共计 </summary>
      
    
    
    
    <category term="学习" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="公开课" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/"/>
    
    <category term="CMU-15-213" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/"/>
    
    <category term="Labs" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/Labs/"/>
    
    
  </entry>
  
  <entry>
    <title>Datalab解析</title>
    <link href="http://rinevard.github.io/wiki/learning/open-course/CMU-15-213/Labs/Datalab/"/>
    <id>http://rinevard.github.io/wiki/learning/open-course/CMU-15-213/Labs/Datalab/</id>
    <published>2025-02-21T12:14:28.000Z</published>
    <updated>2025-03-08T04:18:11.571Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>Datalab 的难度很高。它的难度主要体现在技巧性上，这在整数部分尤其明显。整数部分至少有一半题目我花了一小时以上才做出来，相较而言，浮点数的题目虽然分类讨论起来更麻烦，但更为平易近人，每道我花了四十分钟左右。</p><p>如果有某道题做不出来，不建议一直死磕。我们可以换一道题或是离开屏幕散散心，我相信这会有帮助。</p><p>做完以后，感觉自己已经是位运算领域大神了！</p><h1 id="整数部分"><a href="#整数部分" class="headerlink" title="整数部分"></a>整数部分</h1><p>整数部分的技巧性很强，不建议在某道题上死磕，做不出来就换一道，以后再来。</p><h2 id="bitXor"><a href="#bitXor" class="headerlink" title="bitXor"></a>bitXor</h2><p>本题要求用 ‘~’ 和 ‘&amp;’ 实现 ‘^’，简单列个关于 ‘^’ 的真值表：</p><table><thead><tr><th>x</th><th>y</th><th>x^y</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>0</td></tr></tbody></table><p>关注 x^y 为 1 时 x 和 y 的取值，可以发现 x^y &#x3D;&#x3D; ((<del>x) &amp; y) | (x &amp; (</del>y))，再用德摩根律把 ‘|’ 换成 ‘~’ 和 ‘&amp;’ 即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * bitXor - x^y using only ~ and &amp;</span></span><br><span class="line"><span class="comment"> *   Example: bitXor(4, 5) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp;</span></span><br><span class="line"><span class="comment"> *   Max ops: 14</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bitXor</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* x Xor y = (~x &amp; y) | (x &amp; ~y)</span></span><br><span class="line"><span class="comment">    a | b = ~(~a &amp; ~b)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">return</span> ~(~(x &amp; ~y) &amp; ~(~x &amp; y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="tmin"><a href="#tmin" class="headerlink" title="tmin"></a>tmin</h2><p>这是熟知的结论，tmin &#x3D; $-2^{31}$ &#x3D; 1 &lt;&lt; 31</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * tmin - return minimum two&#x27;s complement integer</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 4</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tmin</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* use left shift to compute tmin */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="isTmax"><a href="#isTmax" class="headerlink" title="isTmax"></a>isTmax</h2><p>这种“判断 x 是否等于 y”的题目的做法有很多种：</p><ol><li>创建一个 y，把 x 和 y 相减（x - y &#x3D;&#x3D; x + ((~y) + 1)），然后判断结果是否为 0.</li><li>创建一个 y，return !(x^y)</li></ol><p>我这里是直接构建了 -Tmax &#x3D; 100…01，然后检查 x-Tmax 是否为 0.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * isTmax - returns 1 if x is the maximum, two&#x27;s complement number,</span></span><br><span class="line"><span class="comment"> *     and 0 otherwise</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | +</span></span><br><span class="line"><span class="comment"> *   Max ops: 10</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isTmax</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* create a &#x27;0&#x27; and use &#x27;!&#x27; */</span></span><br><span class="line">  <span class="keyword">return</span> !(x + <span class="number">1</span> + (<span class="number">1</span> &lt;&lt; <span class="number">31</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="allOddBits"><a href="#allOddBits" class="headerlink" title="allOddBits"></a>allOddBits</h2><p>这道题我想了很久。后来根据尝试性地构造了 1010…1010，然后试出了 (x &amp; mask) ^ mask 的写法。大致的思路是，既然我们只在乎奇数位的值，就先用 &amp; 把偶数位的值去掉，后来惊奇地发现再做个 ‘^’ 和 ‘!’ 就能得到结果了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * allOddBits - return 1 if all odd-numbered bits in word set to 1</span></span><br><span class="line"><span class="comment"> *   where bits are numbered from 0 (least significant) to 31 (most significant)</span></span><br><span class="line"><span class="comment"> *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">allOddBits</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* (x^y) == 0 &lt;=&gt; x == y */</span></span><br><span class="line">  <span class="type">int</span> y = <span class="number">0xAA</span>; <span class="comment">// 0xAA 就是二进制的 1010 1010</span></span><br><span class="line">  <span class="type">int</span> mask = y + (y &lt;&lt; <span class="number">8</span>) + (y &lt;&lt; <span class="number">16</span>) + (y &lt;&lt; <span class="number">24</span>);</span><br><span class="line">  <span class="keyword">return</span> !((x &amp; mask) ^ mask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="negate"><a href="#negate" class="headerlink" title="negate"></a>negate</h2><p>这是熟知的结果，本质是 $x + \sim x + 1 \equiv<br> 0(\text{mod $2^{32}$})$</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * negate - return -x</span></span><br><span class="line"><span class="comment"> *   Example: negate(1) = -1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 5</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">negate</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* well known result */</span></span><br><span class="line">  <span class="keyword">return</span> ~x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="isAsciiDigit"><a href="#isAsciiDigit" class="headerlink" title="isAsciiDigit"></a>isAsciiDigit</h2><p>这道题我想了很久。后来分析了输入的形式，发现它只能形如 0000 … 0011 0yyy 或是 0000 … 0011 100y，于是决定把自由的位置右移掉，然后用 mask。</p><p>做完后复盘发现还有一种基于比较的方法，直接计算 x - 0x30 和 x - 0x39 并判断其符号位。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters &#x27;0&#x27; to &#x27;9&#x27;)</span></span><br><span class="line"><span class="comment"> *   Example: isAsciiDigit(0x35) = 1.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x3a) = 0.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x05) = 0.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 15</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isAsciiDigit</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* x 只能形如下面两种形式：</span></span><br><span class="line"><span class="comment">   * 1. 0000 ... 0011 0yyy</span></span><br><span class="line"><span class="comment">   * 2. 0000 ... 0011 100y</span></span><br><span class="line"><span class="comment">   * 这里的 y 可以是 0 或 1</span></span><br><span class="line"><span class="comment">   * 我们用右移去掉未知的 y, 然后用 mask即可</span></span><br><span class="line"><span class="comment">   * 构造两个 mask, 一个是 0000 ... 0000 0110, 另一个是 0000 ... 0001 1100</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">int</span> mask1 = <span class="number">0x06</span>;</span><br><span class="line">  <span class="type">int</span> mask2 = <span class="number">0x1C</span>;</span><br><span class="line">  <span class="keyword">return</span> !((x &gt;&gt; <span class="number">3</span>) ^ mask1) | !((x &gt;&gt; <span class="number">1</span>) ^ mask2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="conditional"><a href="#conditional" class="headerlink" title="conditional"></a>conditional</h2><p>这道题我也想了好久。一开始为了方便，我先用 !!x 把 x 归到了 0 或 1. 之后的思路是想构造满足类似 f(0, y) &#x3D; 0，f(1, y) &#x3D; y 的条件的函数 f，然后返回 f(x, y) + f(!x, z). 稍加思考，便发现 ‘&amp;’ 和这里的 f 很像，于是就写下去了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * conditional - same as x ? y : z</span></span><br><span class="line"><span class="comment"> *   Example: conditional(2,4,5) = 4</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 16</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">conditional</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* 为了方便, 先限制 x 只取 0 或 1</span></span><br><span class="line"><span class="comment">   * 我们一开始的思路是找到函数满足 f(x, b) = b if x == 1, 0 if x == 0</span></span><br><span class="line"><span class="comment">   * 然后用 f(x, y) + f(!x, z) 即可得到结果</span></span><br><span class="line"><span class="comment">   * 中途发现 11...1 &amp; b = b, 0 &amp; b = 0, 和我们希望的结果很像</span></span><br><span class="line"><span class="comment">   * 于是就这么写了</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">int</span> mask = (~(!x)) + <span class="number">1</span>; <span class="comment">// x为0时得到全1，x非0时得到0</span></span><br><span class="line">  <span class="keyword">return</span> ((~mask) &amp; y) + (mask &amp; z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="isLessOrEqual"><a href="#isLessOrEqual" class="headerlink" title="isLessOrEqual"></a>isLessOrEqual</h2><p>好吧，这道题我还是想了很久，毕竟我在做之前对位运算几乎一无所知。这道题更多是分类讨论，分为 xy 同号和 xy 异号的两种情况就行，连溢出都不会有。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0</span></span><br><span class="line"><span class="comment"> *   Example: isLessOrEqual(4,5) = 1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 24</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isLessOrEqual</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* 若xy同号(最高位相同), return 1 if y - x &gt;= 0 else 0</span></span><br><span class="line"><span class="comment">   * 若xy异号, return 1 if y的二进制表示最高位为0 else 0</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">int</span> signX = x &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  <span class="type">int</span> signY = y &gt;&gt; <span class="number">31</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> diffSign = (signX &amp; !signY); <span class="comment">// (异号且 y &gt;= 0, x &lt; 0) ? 1 : 0</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> diff = y + (~x + <span class="number">1</span>);                                <span class="comment">// y - x</span></span><br><span class="line">  <span class="type">int</span> sameSign = (!(signX ^ signY)) &amp; ((diff &gt;&gt; <span class="number">31</span>) + <span class="number">1</span>); <span class="comment">// (同号且 y - x &gt;= 0) ? 1 : 0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> diffSign | sameSign;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="logicalNeg"><a href="#logicalNeg" class="headerlink" title="logicalNeg"></a>logicalNeg</h2><p>这道题是我感觉第二难的题目，我的核心思路是“非 0 的 x 的二进制表示中至少有一个 1”，于是我就构造了 11…1 即 -1 这个特殊值，并期盼它能给我一些有趣的结果。</p><p>对正数 x 来说，x + (-1) 的最高位必然是 0，这能把正数和 0 区分开来，因为 0 + (-1) 的最高位是 1.</p><p>但负数怎么办呢？负数要分类讨论，很麻烦。于是我就想取输入值的绝对值，然后用 abs + (-1) 来区分非 0 值和 0. 我这里的代码采用的是类似的思路，不过当时没想到怎么求 abs，就写得更复杂了一些。</p><p>后来复盘时发现非 0 值 x 一定满足 (x | (~x)) 的最高位为 1，用这个方法更简单。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * logicalNeg - implement the ! operator, using all of</span></span><br><span class="line"><span class="comment"> *              the legal operators except !</span></span><br><span class="line"><span class="comment"> *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">logicalNeg</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 先思考怎么表示 &#x27;x非0&#x27;, 注意到 x非0 &lt;=&gt; x的二进制表示中至少有一个1</span></span><br><span class="line"><span class="comment">   * 考虑用 -1(它的二进制表示全是1) + x 来得到一些中间量</span></span><br><span class="line"><span class="comment">   * 接下来分类讨论, 如果 x为0, 则 -1 + x = -1,</span></span><br><span class="line"><span class="comment">   * 如果 x为正数, -1 + x 的二进制表示以 0 开头</span></span><br><span class="line"><span class="comment">   * 如果 x为负数, 要分类讨论 Tmin的情况, 处理起来不方便</span></span><br><span class="line"><span class="comment">   * 至此, 正数和 0 就能通过 (-1 + x) &gt;&gt; 31 区分开来了, 正数得到 0, 0 得到 -1</span></span><br><span class="line"><span class="comment">   * 接下来把负数整合进来</span></span><br><span class="line"><span class="comment">   * 考虑到负数的负是正数, 我们自然就会考虑把负数转化成正数，再用 | 或者 &amp; 来连接</span></span><br><span class="line"><span class="comment">   * ((((~0) + x) &gt;&gt; 31)) &amp; ((((~0) + negtivex) &gt;&gt; 31)) 就能把正数和负数都变成0, 0变成 -1</span></span><br><span class="line"><span class="comment">   * 再 &amp; 1 就能得到 !x 了</span></span><br><span class="line"><span class="comment">   * 代码里又进一步简化了一下结果, 不过核心思路还是&quot;把负数和正数统一起来&quot;</span></span><br><span class="line"><span class="comment">   * 这里的 (((~0) + x) &amp; ((~0) + negtivex)) 把 &amp; 提前到了移位前,</span></span><br><span class="line"><span class="comment">   * 直接 &amp; 了二进制表示的最高位(之前的先 &gt;&gt; 再 &amp; 是 &amp; 了二进制表示的最低位)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">int</span> negtivex = (~x) + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> ((((((~<span class="number">0</span>) + x) &amp; ((~<span class="number">0</span>) + negtivex)) &gt;&gt; <span class="number">31</span>)) &amp; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="howManyBits"><a href="#howManyBits" class="headerlink" title="howManyBits"></a>howManyBits</h2><p>这道题是我感觉最难的题目。首先我们画出这个函数的图像（留给读者作为练习），会发现它关于 -0.5 对称，这表明 x 和 -x-1 耗费的位数相同，接下来我们就只要考虑非负数就行了。</p><p>找到非负数的最小 bits 数倒是不难，稍微写几个非负数就能发现，只要找到它值为 1 的最高位数，设其为 k，k + 1 即为结果。</p><p>之后的难点就是，如何找到这个非负数的“值为 1 的最高位数”了。线性搜索显然是可行的，我们可以用 $\sum_{m&#x3D;0}^{31}!!(x &gt;&gt; m)$ 来得到这个位数，然而这样做耗费的操作数超出了限制。既然线性耗费的操作数太多，那我们自然就会想到二分。</p><p>但怎么做二分呢？这里的代码更多是我试出来的，没有什么清晰的理论指导，我们直接看图吧。</p><p><img src="/images/learning/open-course/CMU-15213/Labs/Datalab/binary-search.png"></p><p>怎么做到“砍掉一半”呢？砍掉右边半段用右移就行，所以我们会从 x &gt;&gt; 16 开始，再用 !!(x &gt;&gt; 16) 是 0 还是 1 来判断 1 在右半边还是左半边。</p><p>之后的代码就真的纯粹是试出来的了，我们肯定能在数学上解释我们的操作，但具体的构思纯粹是试错+直觉试出来的，没什么好说的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* howManyBits - return the minimum number of bits required to represent x in</span></span><br><span class="line"><span class="comment"> *             two&#x27;s complement</span></span><br><span class="line"><span class="comment"> *  Examples: howManyBits(12) = 5</span></span><br><span class="line"><span class="comment"> *            howManyBits(298) = 10</span></span><br><span class="line"><span class="comment"> *            howManyBits(-5) = 4</span></span><br><span class="line"><span class="comment"> *            howManyBits(0)  = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(-1) = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(0x80000000) = 32</span></span><br><span class="line"><span class="comment"> *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *  Max ops: 90</span></span><br><span class="line"><span class="comment"> *  Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">howManyBits</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* 简单画下这个函数的图像, 注意到 x 与 -x - 1(即~x) 耗费位数相同, 那就先统一转换成非负数,</span></span><br><span class="line"><span class="comment">   * 然后找到最高的值为1的位数, 设其为 k, k + 1 即为结果</span></span><br><span class="line"><span class="comment">   * 比如 0000 ... 0010 0110 的结果为 6 + 1 = 7</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 那怎么找到最高的值为1的位数呢?</span></span><br><span class="line"><span class="comment">   * 一种想法是 sum([!!(alternatex &gt;&gt; k) for k in range(32)]), 但这样用的操作就超过限制了</span></span><br><span class="line"><span class="comment">   * 所以我们借助二分的思想</span></span><br><span class="line"><span class="comment">   * 让我们举个例子, 假设我们在处理 0010 1101,</span></span><br><span class="line"><span class="comment">   * 我们可以先把它右移4, 发现仍然大于0, 就令ans += 4, 此时值为 0010 (扔掉右半部分)</span></span><br><span class="line"><span class="comment">   * 然后右移2, 发现等于0, 则不在数据上真正移动, 值为 10 (扔掉左半部分)</span></span><br><span class="line"><span class="comment">   * 再右移1, 发现大于0, 令 ans += 1, 此时值为 1 (扔掉右半部分)</span></span><br><span class="line"><span class="comment">   * 当前的值不为0, ans +=1 (ans之前加了&quot;被移除的部分的长度&quot;, 这里还要加上&quot;剩余的部分的长度&quot;)</span></span><br><span class="line"><span class="comment">   * 综上, 0010 1101 的最高的值为1的位数为6</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 首先我们要能够检查右移后值是否为0, 用!!(x &gt;&gt; k) 即可, !!(x &gt;&gt; k) == (x 右移后值为0) ? 0 : 1</span></span><br><span class="line"><span class="comment">   * 然后为了方便在值上进行移动, 我们希望有 f(x) = (x 右移后值为0) ? 0 : 右移长度</span></span><br><span class="line"><span class="comment">   * 因此使用形如 !!(x &gt;&gt; (2**k)) &lt;&lt; k 的东西</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">int</span> signX = x &gt;&gt; <span class="number">31</span>;                                  <span class="comment">// (x &gt;= 0) ? 00...0 : 11...1</span></span><br><span class="line">  <span class="type">int</span> alternatex = ((~(signX)) &amp; x) + ((signX) &amp; (~x)); <span class="comment">// (x &gt;= 0) ? x : -x-1</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> bit16 = (!!(alternatex &gt;&gt; <span class="number">16</span>)) &lt;&lt; <span class="number">4</span>; <span class="comment">// (alternatex &gt;= 2**16) ? 16 : 0</span></span><br><span class="line">  alternatex = alternatex &gt;&gt; bit16;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> bit8 = (!!(alternatex &gt;&gt; <span class="number">8</span>)) &lt;&lt; <span class="number">3</span>;</span><br><span class="line">  alternatex = alternatex &gt;&gt; bit8;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> bit4 = (!!(alternatex &gt;&gt; <span class="number">4</span>)) &lt;&lt; <span class="number">2</span>;</span><br><span class="line">  alternatex = alternatex &gt;&gt; bit4;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> bit2 = (!!(alternatex &gt;&gt; <span class="number">2</span>)) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">  alternatex = alternatex &gt;&gt; bit2;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> bit1 = (!!(alternatex &gt;&gt; <span class="number">1</span>));</span><br><span class="line">  alternatex = alternatex &gt;&gt; bit1;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> bit0 = (!!alternatex);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> bit16 + bit8 + bit4 + bit2 + bit1 + bit0 + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="浮点数部分"><a href="#浮点数部分" class="headerlink" title="浮点数部分"></a>浮点数部分</h1><p>浮点数部分比起整数部分简单得多，只要仔细地分类讨论就行了。</p><h2 id="floatScale2"><a href="#floatScale2" class="headerlink" title="floatScale2"></a>floatScale2</h2><p>分类讨论即可。这里比较有趣的是 exp &#x3D;&#x3D; 0（denormalized case）的情况，无论 frac 部分是否超过 23 位，处理的代码都是一样的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * floatScale2 - Return bit-level equivalent of expression 2*f for</span></span><br><span class="line"><span class="comment"> *   floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Both the argument and result are passed as unsigned int&#x27;s, but</span></span><br><span class="line"><span class="comment"> *   they are to be interpreted as the bit-level representation of</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   When argument is NaN, return argument</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">floatScale2</span><span class="params">(<span class="type">unsigned</span> uf)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* 取出 exp 的部分, 分三种情况讨论.</span></span><br><span class="line"><span class="comment">   * 1. NaN or infin, 直接返回输入值</span></span><br><span class="line"><span class="comment">   * 2. denormalized case, 主要修改 frac 部分, 如果修改导致 frac</span></span><br><span class="line"><span class="comment">   * 部分多于 23 位, 还要修改 exp 部分</span></span><br><span class="line"><span class="comment">   * 3. normalized case, 修改 exp 部分</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="built_in">exp</span> = (uf &gt;&gt; <span class="number">23</span>) &amp; <span class="number">0xFF</span>; <span class="comment">// 00...0 exp</span></span><br><span class="line">  <span class="comment">// 如果 exp == 二进制(1111 1111), uf为 NaN 或 infin, 直接返回uf</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0xFF</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> uf;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果 exp == 0, 就是 denormalized case</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">unsigned</span> frac = (uf &lt;&lt; <span class="number">9</span>) &gt;&gt; <span class="number">9</span>; <span class="comment">// 0 00000000 frac</span></span><br><span class="line">    <span class="comment">// 如果 frac 部分最高值为1, 进位; 如果不为1, 把 frac 部分乘二即可</span></span><br><span class="line">    <span class="comment">// 两种情况都能用下面的代码来表示</span></span><br><span class="line">    frac = frac &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ((uf &gt;&gt; <span class="number">23</span>) &lt;&lt; <span class="number">23</span>) + frac; <span class="comment">// (s exp 00...0) + (0 00000000 frac)</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// normalized case</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// exp不会溢出8位, 因为前面的 if 分支已经处理了 exp == 0xFF的情况</span></span><br><span class="line">    <span class="built_in">exp</span> += <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> expmask = (~<span class="number">0</span>) ^ (<span class="number">0xFF</span> &lt;&lt; <span class="number">23</span>); <span class="comment">// 1 00000000 11...1</span></span><br><span class="line">    <span class="keyword">return</span> (uf &amp; expmask) + (<span class="built_in">exp</span> &lt;&lt; <span class="number">23</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="floatFloat2Int"><a href="#floatFloat2Int" class="headerlink" title="floatFloat2Int"></a>floatFloat2Int</h2><p>同样是分类讨论。一开始我把 NaN、infin 单独写了一种情况处理，后面发现操作数太多超出了限制，于是把它和绝对值太大的情况统一了起来，毕竟它们的返回值一样。</p><p>这里要仔细考虑的是 Tmin 落入的分支，在我的代码里，Tmin 落入了第一个 if 分支。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * floatFloat2Int - Return bit-level equivalent of expression (int) f</span></span><br><span class="line"><span class="comment"> *   for floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Argument is passed as unsigned int, but</span></span><br><span class="line"><span class="comment"> *   it is to be interpreted as the bit-level representation of a</span></span><br><span class="line"><span class="comment"> *   single-precision floating point value.</span></span><br><span class="line"><span class="comment"> *   Anything out of range (including NaN and infinity) should return</span></span><br><span class="line"><span class="comment"> *   0x80000000u.</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">floatFloat2Int</span><span class="params">(<span class="type">unsigned</span> uf)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> <span class="built_in">exp</span> = (uf &gt;&gt; <span class="number">23</span>) &amp; <span class="number">0xFF</span>;    <span class="comment">// 00...0 exp</span></span><br><span class="line">  <span class="type">unsigned</span> frac = (uf &lt;&lt; <span class="number">9</span>) &gt;&gt; <span class="number">9</span>; <span class="comment">// 00...0 frac</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 绝对值太大的情况</span></span><br><span class="line">  <span class="comment">// 注意 NaN, infin也在这种情况中, 此时 exp == 0xFF</span></span><br><span class="line">  <span class="comment">// -2^(31) 也在这种情况中, 此时 exp == 127 + 31, frac == 0</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">exp</span> &gt;= <span class="number">127</span> + <span class="number">31</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; <span class="number">31</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 绝对值太小的情况</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">exp</span> &lt; <span class="number">127</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 绝对值位于 [0, 2^(31) - 1] 的情况</span></span><br><span class="line">  <span class="comment">// 该分支中, 0 &lt;= exp - 127 &lt; 31</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> e = <span class="built_in">exp</span> - <span class="number">127</span>;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">abs</span>;</span><br><span class="line">    frac += (<span class="number">1</span> &lt;&lt; <span class="number">23</span>);</span><br><span class="line">    <span class="comment">// 如果 e 足够大, 保留 frac 里的所有数字, 否则舍弃后几位数字</span></span><br><span class="line">    <span class="keyword">if</span> (e &gt;= <span class="number">23</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">abs</span> = frac &lt;&lt; (e - <span class="number">23</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">abs</span> = frac &gt;&gt; (<span class="number">23</span> - e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据正负返回不同值</span></span><br><span class="line">    <span class="comment">// positive case</span></span><br><span class="line">    <span class="keyword">if</span> ((uf &gt;&gt; <span class="number">31</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">abs</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// negative case</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> (~<span class="built_in">abs</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="floatPower2"><a href="#floatPower2" class="headerlink" title="floatPower2"></a>floatPower2</h2><p>还是分类讨论，不多说了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * floatPower2 - Return bit-level equivalent of the expression 2.0^x</span></span><br><span class="line"><span class="comment"> *   (2.0 raised to the power x) for any 32-bit integer x.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   The unsigned value that is returned should have the identical bit</span></span><br><span class="line"><span class="comment"> *   representation as the single-precision floating-point number 2.0^x.</span></span><br><span class="line"><span class="comment"> *   If the result is too small to be represented as a denorm, return</span></span><br><span class="line"><span class="comment"> *   0. If too large, return +INF.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">floatPower2</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* float 可以表示的 2的幂次的范围为 [2^(-149), 2^(127)],</span></span><br><span class="line"><span class="comment">   * 其中 [2^(-149), 2^(-127)] 由 denormalized case 表示,</span></span><br><span class="line"><span class="comment">   * [2^(-126), 2^(127)] 由 normalized case 表示</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (x &lt; <span class="number">-149</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// denormalized case</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (x &lt;= <span class="number">-127</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; (x + <span class="number">149</span>); <span class="comment">// 只处理 frac 部分</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// normalized case</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (x &lt;= <span class="number">127</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> (x + <span class="number">127</span>) &lt;&lt; <span class="number">23</span>; <span class="comment">// 只处理 exp 部分</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0xFF</span> &lt;&lt; <span class="number">23</span>); <span class="comment">// +INF</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;Datalab 的难度很高。它的难度主要体现在技巧性上，这在整数部分尤其明显。整数部分至少有一半题目我花了一小时以上才做出来</summary>
      
    
    
    
    <category term="学习" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="公开课" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/"/>
    
    <category term="CMU-15-213" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/"/>
    
    <category term="Labs" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/Labs/"/>
    
    
  </entry>
  
  <entry>
    <title>写完了datalab，突然感觉好孤单</title>
    <link href="http://rinevard.github.io/wiki/others/thoughts/%E5%86%99%E5%AE%8C%E4%BA%86datalab%EF%BC%8C%E7%AA%81%E7%84%B6%E6%84%9F%E8%A7%89%E5%A5%BD%E5%AD%A4%E5%8D%95/"/>
    <id>http://rinevard.github.io/wiki/others/thoughts/%E5%86%99%E5%AE%8C%E4%BA%86datalab%EF%BC%8C%E7%AA%81%E7%84%B6%E6%84%9F%E8%A7%89%E5%A5%BD%E5%AD%A4%E5%8D%95/</id>
    <published>2025-02-21T11:49:30.000Z</published>
    <updated>2025-03-01T10:08:57.724Z</updated>
    
    <content type="html"><![CDATA[<p>一个寒假过去，把手头上最喜欢的设计简单做了个原型，确实不错。不过由于代码水平太低，另一个同样喜欢的设计没能实现出来。原本想在这学期做一个比较完整的游戏的，但认真想了想，凭我现在的代码水平，恐怕根本做不了。还是要提高一下自己的代码水平才行，于是这学期打算认真打打基础，从 15213 开始。</p><p>今天写掉了 datalab。凭借自己的努力做完了一个很难的作业，当然会感到很欢喜，可站起来准备回寝时，突然感到很孤单。“没有学分，没有绩点，没有老师，没有同学，只有一个信念 —— 你在变强。”或许吧，我在变强。变强之后呢？应该就能写出更漂亮的代码，不带妥协地实现自己的想法了吧。</p><p>更新：今天（2025.3.1）在寝室写完了 bomblab，感觉很开心，并没有什么孤单的感觉。顺便看了看母鸡卡的新假药，萌战吧的吧友们即使在滑坡大环境下也坚持造药，这就是我们的黄金精神！</p><style>/* 隐藏草书 */.hidden-text {    font-size: 18px;    text-align: center;    margin: 20px 0;    /* padding: 20px; */    line-height: 1.5;    color: transparent;    cursor: default}.hidden-fancy-text::selection {    color: black;    background: white;}</style><div class="hidden-text">凝视我曾凝视的光芒，触摸你将触摸的远方。</div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一个寒假过去，把手头上最喜欢的设计简单做了个原型，确实不错。不过由于代码水平太低，另一个同样喜欢的设计没能实现出来。原本想在这学期做一个比较完整的游戏的，但认真想了想，凭我现在的代码水平，恐怕根本做不了。还是要提高一下自己的代码水平才行，于是这学期打算认真打打基础，从 15</summary>
      
    
    
    
    <category term="杂谈" scheme="http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    <category term="碎碎念" scheme="http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
  </entry>
  
  <entry>
    <title>母鸡卡的各种神奇假药</title>
    <link href="http://rinevard.github.io/wiki/others/animation/%E6%AF%8D%E9%B8%A1%E5%8D%A1%E7%9A%84%E5%90%84%E7%A7%8D%E7%A5%9E%E5%A5%87%E5%81%87%E8%8D%AF/"/>
    <id>http://rinevard.github.io/wiki/others/animation/%E6%AF%8D%E9%B8%A1%E5%8D%A1%E7%9A%84%E5%90%84%E7%A7%8D%E7%A5%9E%E5%A5%87%E5%81%87%E8%8D%AF/</id>
    <published>2025-02-15T13:31:31.000Z</published>
    <updated>2025-03-02T06:39:33.065Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/others/animation/mujica/%E5%81%87%E8%8D%AF%E5%86%B0%E5%B1%B1.png" alt="假药冰山图"></p><p>整理一下我觉得很有趣的假药，太真的和我不感兴趣的就不放进来了。</p><h1 id="关于整体走向的假药"><a href="#关于整体走向的假药" class="headerlink" title="关于整体走向的假药"></a>关于整体走向的假药</h1><h2 id="时间轮回说"><a href="#时间轮回说" class="headerlink" title="时间轮回说"></a>时间轮回说</h2><p><a href="https://tieba.baidu.com/p/9534562175">时间轮回</a> 是第九集出现的假药</p><p>第九集灾难般的爆爆爆让许多假药的讨论度都大幅下降，不过时间乱序说重新登场，更是出现了时间轮回说。（致敬传奇第十话——我的战场不在这里）</p><p>我感觉时间轮回不太可能，不过这个想法太酷了！至于时间乱序，最明显的证据是第九集 18:40 和第二集 13:34 能连起来。或许可以结合瞳孔变化说来看看第二集是 mortis 还是睦头？</p><p>那么贯穿全剧，把时间重排起来的线索是什么呢？一种说法是<a href="https://tieba.baidu.com/p/9512186596">手机电量</a></p><p><img src="/images/others/animation/mujica/%E5%90%BC%E5%A7%86%E6%8B%89.png" alt="造假药的大家，如此闪耀！"></p><h2 id="叙诡说"><a href="#叙诡说" class="headerlink" title="叙诡说"></a>叙诡说</h2><p><a href="https://www.bilibili.com/video/BV1gxffYTEWF/">叙诡说</a> 是第二集出现的假药，在三四集得到完善，第五集后讨论度大幅下降。</p><p>前四集剧情跳跃、旁白由初华声优念出是因为这是初华在叙述故事！那么，是在对谁讲述呢？</p><p>一种假药是初华对失忆的祥子讲述故事，在叙述中美化自己，好让祥子待在自己身边。理由是祥子在前四集唯独对初华态度比较好，这是初华对自己的美化。</p><p>另一种是初华对自己讲述故事，只是在自我欺骗“乐队依然存在”，因此剧本漏洞百出。但无论叙述多少次，乐队都逃不掉解散的结局。</p><p>上面的蓝色链接是“初华对自己讲述故事”。</p><p><img src="/images/others/animation/mujica/HerStory.png" alt="怀揣着秘密的她的故事"></p><h2 id="内鬼"><a href="#内鬼" class="headerlink" title="内鬼"></a>内鬼</h2><p><a href="https://www.bilibili.com/video/BV1YxFZe3Edg">内鬼说</a> 是第四集出现的假药，主要用于解释观感奇怪的解散。</p><p>母鸡卡解散的剧情逻辑混乱，这是因为队里有内鬼，内鬼只要把队解散掉就行了。由于我比较喜欢祥子，所以我接下来讲全队内鬼，祥子 1vn 的剧情。</p><p>整个事务所都是丰川家族安排的内鬼，上到其他乐队成员下到工作人员，都对“丰川家希望祥子回家”这件事或多或少有了解，因此工作人员浑水摸鱼，除了祥子以外的乐队成员都不在乎乐队。祥子 1vn 硬生生把母鸡卡带到了武道馆，不愧是美强惨大女主，数值太高了。</p><p>这太数值怪啦，不合理的！不过内鬼说还是很有趣而且很靠谱的，我觉得比较真的是初华喵梦内鬼，睦和海玲知情。</p><p><img src="/images/others/animation/mujica/%E6%B5%B7%E7%8E%B2%E6%9A%97%E7%A4%BA.png" alt="丰川同学，是你不关注其他成员才没有发现有内鬼吧"></p><h2 id="人偶"><a href="#人偶" class="headerlink" title="人偶"></a>人偶</h2><p><a href="https://tieba.baidu.com/p/9497289560">人偶说</a> 是第七集出现的假药。</p><p>mujica 结尾全员人偶化。“在 mujica 的短暂月光下，五个人偶短暂的复活了，在舞台上高歌一曲。给出了一场完美 live。”</p><p><img src="/images/others/animation/mujica/%E4%BA%BA%E5%81%B6.png" alt="初华好看捏"></p><h1 id="关于个人的假药"><a href="#关于个人的假药" class="headerlink" title="关于个人的假药"></a>关于个人的假药</h1><h2 id="初华"><a href="#初华" class="headerlink" title="初华"></a>初华</h2><h3 id="蜘蛛侠"><a href="#蜘蛛侠" class="headerlink" title="蜘蛛侠"></a>蜘蛛侠</h3><p><a href="https://www.bilibili.com/video/BV1JuFcedEih">蜘蛛侠</a></p><p>其实初华的真实身份是蜘蛛侠，各种蜘蛛意象是暗示初华被蜘蛛咬过。能力越大，责任越大，蜘蛛侠要打击犯罪，所以既不去 Mujica 排练，也不去 sumimi 排练，还说自己忙。初华让祥子在门口等 10 秒其实是在藏蜘蛛战衣，她 10 秒就能收拾好房间、第三集隔着几十米听到祥子和睦的对话都是因为她有超能力。众所周知祥子是蓝色章鱼，初华把祥子带到自己家实际上是为了监视章鱼博士。而且，既然有双面人睦、企鹅人高松灯、章鱼博士祥子，有蜘蛛侠初华也不奇怪。</p><p><img src="/images/others/animation/mujica/%E8%9C%98%E8%9B%9B%E4%BE%A0.png" alt="难道说......被发现真实身份了吗？"></p><h3 id="叙诡"><a href="#叙诡" class="headerlink" title="叙诡"></a>叙诡</h3><p><a href="https://tieba.baidu.com/p/9408382939">叙诡说</a> 之前已经提过，这里的链接是第二集播出后的初版假药。</p><p>之前已经说过了，旁白由初华的声优念出、前几集逻辑诡异，都是因为这是初华讲述的故事。初华是母鸡卡故事的叙述者。</p><p><img src="/images/others/animation/mujica/%E4%B8%89%E8%A7%92%E5%88%9D%E5%8D%8E.png"></p><h3 id="缓存不足"><a href="#缓存不足" class="headerlink" title="缓存不足"></a>缓存不足</h3><p><a href="https://tieba.baidu.com/p/9441718936">缓存不足说</a> 是第四集出现的假药。</p><p>“初华对某些记忆的深刻程度，可能不会被时间冲淡，而一些日常记忆可能会被很快的忘却。<br>在她心目中，自己和心爱的祥子度过的每个夏天、出道时祥子发来的短信鼓励可能一直占据着她脑内非常非常多的缓存。<br>这些和祥子一起的快乐的记忆对初华来说可能就像是刚刚经历的一样，那份喜悦、甜蜜、饥渴就像冰一样无时无刻不在侵蚀初华的大脑，所以初华才会给人一种难以形容的超重女印象。”</p><p><img src="/images/others/animation/mujica/%E7%BC%93%E5%AD%98%E4%B8%8D%E8%B6%B3.png" alt="CUDA out of memory"></p><h3 id="认知障碍"><a href="#认知障碍" class="headerlink" title="认知障碍"></a>认知障碍</h3><p><a href="https://tieba.baidu.com/p/9395455093">初华认知障碍说</a> 是第一集出现的假药。</p><p>初华的眼里一直都只有祥子，别人的形象在她眼里是扭曲的。众所周知，MyGO 第八集里有初华的回忆，回忆里明显能看出初华见过祥子的人偶。然而在母鸡卡第二集里，她却好像是不认识人偶的样子。答案是初华在小时候将睦认知成了人偶。</p><p><img src="/images/others/animation/mujica/%E4%BA%BA%E5%81%B6%E7%9D%A6.png"></p><h3 id="失忆"><a href="#失忆" class="headerlink" title="失忆"></a>失忆</h3><p><a href="https://tieba.baidu.com/p/9407619606">初华失忆说</a> 是第二集出现的假药。</p><p>为什么初华如此空洞？为什么初华的童年记忆和祥子有偏差？为什么初华忘了祥子的玩偶？因为初华经历过一次失忆。初华拿着以前的日记本，努力扮演“真正的初华”。</p><p><img src="/images/others/animation/mujica/%E8%BF%99%E4%BA%BA%E5%81%B6%E7%9C%9F%E5%8F%AF%E7%88%B1.png" alt="我能在有健忘症的情况下追到祥子吗"></p><h2 id="祥子"><a href="#祥子" class="headerlink" title="祥子"></a>祥子</h2><h3 id="⭐-压抑"><a href="#⭐-压抑" class="headerlink" title="⭐ 压抑"></a>⭐ 压抑</h3><p><a href="https://tieba.baidu.com/p/9501649172">丰川祥子 ⭐ 压抑说</a></p><p>祥子对大雷情有独钟，组乐队是为了接近大雷。</p><p><img src="/images/others/animation/mujica/%E5%93%88%E5%9F%BA%E7%A5%A51.png"><br><img src="/images/others/animation/mujica/%E5%93%88%E5%9F%BA%E7%A5%A52.png"></p><h3 id="人偶-1"><a href="#人偶-1" class="headerlink" title="人偶"></a>人偶</h3><p><a href="https://tieba.baidu.com/p/9492330426">祥子人偶说</a> 是第七集出现的假药，主要用于解释第七集祥子的形象变化。</p><p>第 7 集的祥子为了睦成为了舍弃自我的人偶，她装出了白祥的样子，因为“只要睦能回来就好了”。</p><p><img src="/images/others/animation/mujica/saki-%E6%88%90%E4%B8%BA%E4%BA%BA%E7%B1%BB.png" alt="Sakiko: Become Human"></p><h3 id="祥爹演戏"><a href="#祥爹演戏" class="headerlink" title="祥爹演戏"></a>祥爹演戏</h3><p><a href="https://tieba.baidu.com/p/9456159875">祥爹演戏说</a> 是第五集出现的假药。</p><p>祥爹演戏把祥子气走，让祥子回归家族。</p><p><img src="/images/others/animation/mujica/%E7%A5%A5%E7%88%B9%E6%BC%94%E6%88%8F.png" alt="为了让祥子回家居然做到这种地步，哈基登，你这家伙"></p><h2 id="睦"><a href="#睦" class="headerlink" title="睦"></a>睦</h2><h3 id="装双重人格"><a href="#装双重人格" class="headerlink" title="装双重人格"></a>装双重人格</h3><p><a href="https://tieba.baidu.com/p/9439328406">睦装双重人格说</a> 是第四集出现的假药。</p><p>如题，主要依据是第四集睦在初华车上的第一句“嗯”是睦的声线。</p><p><img src="/images/others/animation/mujica/%E7%9D%A6.png" alt="睦不会这样叫我的......你真的是睦吗？"></p><h3 id="mortis-小小祥"><a href="#mortis-小小祥" class="headerlink" title="mortis 小小祥"></a>mortis 小小祥</h3><p><a href="https://tieba.baidu.com/p/9481715638">mortis 小小祥说</a> 应该是第六集出现的假药。</p><p>睦小时候只有祥子一个朋友，mortis 是睦以白祥为模板塑造的人格，扮演小祥。</p><h2 id="写文章时整理的假药链接"><a href="#写文章时整理的假药链接" class="headerlink" title="写文章时整理的假药链接"></a>写文章时整理的假药链接</h2><ol><li><a href="https://www.bilibili.com/video/BV1gxffYTEWF/">叙诡</a></li><li><a href="https://www.bilibili.com/video/BV1YxFZe3Edg">内鬼说</a></li><li><a href="https://tieba.baidu.com/p/9497289560">人偶说</a></li><li><a href="https://tieba.baidu.com/p/9527674842">睦祥黑手说</a></li><li><a href="https://tieba.baidu.com/p/9470480749">圣经说</a></li><li><a href="https://tieba.baidu.com/p/9470914098">元素说</a></li><li><a href="https://www.bilibili.com/video/BV1JuFcedEih">蜘蛛侠</a></li><li><a href="https://tieba.baidu.com/p/9408382939">叙诡说</a></li><li><a href="https://tieba.baidu.com/p/9441718936">缓存不足说</a></li><li><a href="https://tieba.baidu.com/p/9395455093">初华认知障碍说</a></li><li><a href="https://tieba.baidu.com/p/9407619606">初华失忆说</a></li><li><a href="https://tieba.baidu.com/p/9415281797">祥子失聪说</a></li><li><a href="https://tieba.baidu.com/p/9492330426">祥子人偶说</a></li><li><a href="https://tieba.baidu.com/p/9456159875">祥爹演戏说</a></li><li><a href="https://tieba.baidu.com/p/9439328406">睦装双重人格说</a></li><li><a href="https://tieba.baidu.com/p/9481715638">mortis 小小祥说</a></li><li><a href="https://tieba.baidu.com/p/9477787413">mortis 锡兵说</a></li><li><a href="https://tieba.baidu.com/p/9443944541">雨伞颜色</a></li><li><a href="https://tieba.baidu.com/p/8585068638">祥睦姐妹说</a></li><li><a href="https://tieba.baidu.com/p/9483748562">天天吃假药吃傻了做出来的冰山图</a></li><li><a href="https://tieba.baidu.com/p/9439059383">四演 mortis</a></li><li><a href="https://tieba.baidu.com/p/9439310306">四演祥子</a></li><li><a href="https://tieba.baidu.com/p/9519426290">歌剧魅影说</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/others/animation/mujica/%E5%81%87%E8%8D%AF%E5%86%B0%E5%B1%B1.png&quot; alt=&quot;假药冰山图&quot;&gt;&lt;/p&gt;
&lt;p&gt;整理一下我觉得很有趣的假药，太真的和我不感兴趣的就不放进来了。&lt;/</summary>
      
    
    
    
    <category term="杂谈" scheme="http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    <category term="二次元" scheme="http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/%E4%BA%8C%E6%AC%A1%E5%85%83/"/>
    
    
  </entry>
  
  <entry>
    <title>探索</title>
    <link href="http://rinevard.github.io/wiki/game-design/%E5%AF%B9%E6%8E%A2%E7%B4%A2%E7%B1%BB%E6%B8%B8%E6%88%8F%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>http://rinevard.github.io/wiki/game-design/%E5%AF%B9%E6%8E%A2%E7%B4%A2%E7%B1%BB%E6%B8%B8%E6%88%8F%E7%9A%84%E6%80%9D%E8%80%83/</id>
    <published>2025-02-14T12:36:38.000Z</published>
    <updated>2025-02-15T02:27:03.436Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么要探索呢？"><a href="#为什么要探索呢？" class="headerlink" title="为什么要探索呢？"></a>为什么要探索呢？</h2><p>设想一下，如果我们乘上了飞船，飞入太空，忽然发现一颗行星朝着反方向转动了。这时你会不会想去那里？如果我们在网上发现了一个网站，点开第一个链接发现里面是你的家庭住址（我超，盒！），你会不会想继续翻别的链接？人类探索的动力被命名为好奇心，好奇驱动探索。</p><p>好吧，我们不妨把话说得更明白一些，好奇驱动探索的意思就是：“我相信那里有值得关注的东西，但不确切知道是什么，所以我要去探索。”</p><p>这听起来真的是再平凡不过的事情了，那就来分析一下怎么激发玩家的好奇心，再让好奇驱动探索吧。</p><h2 id="相信有值得关注的东西"><a href="#相信有值得关注的东西" class="headerlink" title="相信有值得关注的东西"></a>相信有值得关注的东西</h2><p>在探索之前，首先要让玩家相信“那里有值得关注的东西”。值得关注的东西并不难做，它们可以是奇观、奖励乃至挑战，关键是怎样让玩家相信“那里有东西”。</p><p>做法很多，我们来找几个例子，看看关注探索感的游戏都是怎么做到这一点的。</p><p>首先来看类银河城游戏，对有经验的玩家，获得新能力就自然想到“以前有个过不去的路能靠这个能力过去”，然后也就想到“那里有值得关注的东西”；看到墙就自然想到假墙，然后就想到“那里有值得关注的东西”了。然而，这种做法过度依赖玩家的先验知识。对一个新接触类银河城的玩家来说，到处迷路才是更可能发生的事情，他们根本不知道“哪里有值得关注的东西”。</p><p>我想这也是类银河城游戏相对小众的原因，它只给有经验的玩家提供了探索感，而给新玩家提供了迷路感。能力锁尚且好说，假墙就实在是不利于探索感的塑造了，毕竟大多数玩家的先验知识是“墙体不可破坏”，根本就不会想到“墙后面有值得关注的东西”。不过假墙并非一无是处，它能给玩家一种“秘密”的感觉，这就是题外话了。所以说如果做类银河城，起码要提醒一下玩家这些设计的存在，而不是盲目地抄别的银河城的做法。在空洞骑士开局的时候，我们必须打碎一面墙才能前进，这就是一个不错的提醒。</p><p>接下来看看清单式开放世界。虽然在地图上到处塞问号的方法为人诟病，但这也确实非常清晰地把“那里有东西”传达给了玩家。那为什么为人诟病呢？主要是因为问号里的东西千篇一律，连“值得关注的东西”都没做到。那如果把每个问号都塞一个精美的支线，会好点吗？恐怕也不一定，因为被动地接受问号和主动发现问号带来的“值得关注感”是不一样的。自己找到的东西，就算再无聊也会想看完。</p><p>这里就不谈塞尔达了。说起来不太好意思，但我在玩的时候确实没感到什么探索欲望。一是我没感觉到哪里有东西，二是因为我也没感觉有什么值得我关注的东西。（球球了，不要开除我的玩家籍）</p><p>然后谈谈星际拓荒吧，这篇文章可以说就是为了星际拓荒而写的。星际拓荒的做法主要有两种，一种是奇观，另一种是非常直白地用文字告诉你“那里有东西”。前者不必多说，后者的文字描述本身也足以让玩家觉得那里“值得关注”。</p><h2 id="不确切知道有什么"><a href="#不确切知道有什么" class="headerlink" title="不确切知道有什么"></a>不确切知道有什么</h2><p>这一点看起来不难实现，但和前一点结合起来就很难了。玩家玩了一段时间游戏后，很快就会对奖励有一定预期，如果做不到打破这种预期，就会让玩家丧失好奇心，丧失探索欲。</p><p>这一点在有经验的玩家身上体现的尤其明显。对一个普普通通的探索类游戏，他们对一切几乎都有预期，因此也会丧失探索欲。</p><p>其实，绝大多数游戏都让玩家丧失了探索欲，让我们以清单式开放世界为例，看看问号是如何让玩家失去探索欲的。</p><p>假设我们面前有一个玩家在玩游戏，我们看看会发生什么。玩家到了第一个问号，是一个有趣的战斗！玩家很开心。玩家到了第二个问号，是一个高级武器！玩家很开心。……玩家到了第 16 个问号，是一个已经重复过不知道多少遍的的战斗，在战斗结尾还奖励了一个高级武器！玩家对此早有预期，不再想去下一个问号了。</p><p>看见了吗，玩家就是这样丧失探索欲，沦为清问号机器的。</p><h2 id="开放世界里的问号"><a href="#开放世界里的问号" class="headerlink" title="开放世界里的问号"></a>开放世界里的问号</h2><p>这么说来，把每个问号的内容都换成一个玩家猜不到是什么的精美的支线就能激发探索欲？这确实能改善现状，但也并非全然如此。问号始终没有完全做到让玩家觉得那个地方“值得关注”，毕竟问号是设计师在地图上标出来的，而不是玩家主动标出的。</p><p>许多类银河城里也提供了在地图上打标记的功能，我们可以横向对比一下。很明显，一张全是自己标出的问号的地图和一张全是游戏自带的问号的地图相比，前者更能激发探索欲。究其根本，就在于前者的每个问号都真的让玩家相信“那里有值得关注的东西”。</p><p>那么怎么改进开放世界里的问号呢？我也不确定。说到底问号这个东西根本就没让玩家觉得“那里有值得关注的东西”不是吗？终究要让玩家觉得自己是主动关注到那里的才行，问号还是太被动了。</p><h2 id="文末"><a href="#文末" class="headerlink" title="文末"></a>文末</h2><p>写到这里，关于探索的内容就基本写完了，最后是一些让探索更有趣的小技巧，我随便列一些，不再详谈。</p><ol><li>能力软锁：常见于类银河城。能力软锁不仅是关卡设计手段，也是控制可选路线数量的工具。限制选项数量的重要性不必多说。</li><li>线索：好的秘密需要提示，而非随机乱逛。我实在是欣赏不了到处乱藏东西的银河城。这还会涉及到电波式谜题（我感觉比“点击式谜题”更好理解）和逻辑谜题的差异，不详谈。</li><li>知识积累：游戏应该逐步教会玩家识别探索机会的能力，也被称作“知识锁”。</li><li>一个相当有趣的体验是“新视角”，即发现了过去没有发现的探索机会。能力成长、环境变化、知识积累都能带来新视角。其中我最喜欢的是环境变化和知识积累带来的新视角，大概是因为不常见吧。</li></ol><p>让我们试试一个简单的传达探索的体验的 demo 。我们看到了下面的东西：</p><p><a href="../../../secret/">所以，这就是探索了？</a></p><p>你好奇那里有什么吗？既然你读完了文章，希望你也会好奇作者还能整出什么新活吧。我本来应该在里面放置一些有趣的东西来满足你的好奇心，不过考虑到时间有限，就只能放个普通的彩蛋了。</p><style>/* 隐藏草书 */.hidden-fancy-text {    font-family: 'Brush Script MT', cursive;    font-size: 20px;    /* text-align: center; */    margin: 20px 0;    /* padding: 20px; */    line-height: 1.5;    color: transparent;    cursor: default}.hidden-fancy-text::selection {    color: darkred;    background: white;}</style><div class="hidden-fancy-text">如果作者在认真做游戏的话，我们也应该会见面的。</div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;为什么要探索呢？&quot;&gt;&lt;a href=&quot;#为什么要探索呢？&quot; class=&quot;headerlink&quot; title=&quot;为什么要探索呢？&quot;&gt;&lt;/a&gt;为什么要探索呢？&lt;/h2&gt;&lt;p&gt;设想一下，如果我们乘上了飞船，飞入太空，忽然发现一颗行星朝着反方向转动了。这时你会不会想去那</summary>
      
    
    
    
    <category term="游戏设计" scheme="http://rinevard.github.io/categories/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="体验" scheme="http://rinevard.github.io/categories/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E4%BD%93%E9%AA%8C/"/>
    
    
  </entry>
  
  <entry>
    <title>建站过程</title>
    <link href="http://rinevard.github.io/wiki/about-blog/%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B/"/>
    <id>http://rinevard.github.io/wiki/about-blog/%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B/</id>
    <published>2025-02-06T02:34:53.000Z</published>
    <updated>2025-02-06T05:01:57.758Z</updated>
    
    <content type="html"><![CDATA[<p>本站成功搭建的最大功臣是 Claude-3.5-sonnet，在这类复杂但并不困难的任务上，和 AI 合作真是再合适不过了。本文简要复盘一下整个网站的搭建过程，顺便提醒一下未来的自己一些 Hexo 的基本操作。</p><h1 id="网站搭建"><a href="#网站搭建" class="headerlink" title="网站搭建"></a>网站搭建</h1><p>写完 2024 年度总结之后，就有了重新搭建博客的想法。随便翻了翻几个同学的博客，感觉挺不错的，于是决定去问 Claude 怎么搭博客。这次肯定不会像第一次建站一样随便挑个主题就用上去，也不会像（这次之前的）最后一次建站一样从头开始自己写。认真找找合适的主题，然后用上就好了。</p><p>我的主要诉求是：写作方便、用树状结构收纳文章，小克推荐了 Hexo 的 NexT.Pisces 和 Wikitten 两个主题以及 VitePress。由于有 Hexo 的使用经验，就选了 Hexo。由于一时半会没找到 NexT.Pisces 是什么，就用了 Wikitten.</p><p>写得我都困了，我们的建站过程没有什么<strong>奇幻色彩</strong>吗？</p><p>有的有的，今天早上断网了，把路由器复位了一下才重新开始建站。</p><p>选好了方案之后，就可以按部就班地和 Claude 一起建站了。不懂的就去问 Claude，它都懂的。</p><h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><p>最常用的三件套：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean  <span class="comment"># 清理缓存，似乎在修改了配置文件以后可以用一用</span></span><br><span class="line">hexo g      <span class="comment"># g 是 generate 的缩写。生成静态文件</span></span><br><span class="line">hexo s      <span class="comment"># s 是 server 的缩写。服务器，启动！</span></span><br></pre></td></tr></table></figure><p>增删文章、文件夹设置、部署到 GitHub page：</p><ol><li><strong>删除文章</strong></li></ol><p>直接删除 <code>source/_posts</code> 目录下的对应 .md 文件即可</p><ol start="2"><li><strong>新增文章</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post <span class="string">&quot;我是一只鲤鱼。我是一只鲤鱼吗？我觉得我是。&quot;</span></span><br></pre></td></tr></table></figure><p>这会生成一个标题为”我是一只鲤鱼。我是一只鲤鱼吗？我觉得我是。”的文章。</p><ol start="3"><li><strong>设置多层文件夹</strong></li></ol><p>在文章头部这样写：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 睡觉入门到精通</span><br><span class="line">categories:</span><br><span class="line"><span class="bullet">  -</span> 生活</span><br><span class="line"><span class="section">  - 睡觉技巧</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure><ol start="4"><li><strong>生成和部署</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><p>如果是新建的站，部署前要修改配置文件的 deploy 部分哦，修改过一次以后就不用再改了。不懂问 Claude。</p><p>可以在根目录的 _config.yml 和的 themes 的 _config.yml 里调整配置文件。</p><h1 id="（可能的）后续改进"><a href="#（可能的）后续改进" class="headerlink" title="（可能的）后续改进"></a>（可能的）后续改进</h1><p>我比较关心的改进是侧边栏收缩来全屏浏览笔记、配色调整。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本站成功搭建的最大功臣是 Claude-3.5-sonnet，在这类复杂但并不困难的任务上，和 AI 合作真是再合适不过了。本文简要复盘一下整个网站的搭建过程，顺便提醒一下未来的自己一些 Hexo 的基本操作。&lt;/p&gt;
&lt;h1 id=&quot;网站搭建&quot;&gt;&lt;a href=&quot;#网站搭</summary>
      
    
    
    
    <category term="关于本站" scheme="http://rinevard.github.io/categories/%E5%85%B3%E4%BA%8E%E6%9C%AC%E7%AB%99/"/>
    
    
  </entry>
  
  <entry>
    <title>欢迎！</title>
    <link href="http://rinevard.github.io/wiki/%E6%AC%A2%E8%BF%8E%EF%BC%81/"/>
    <id>http://rinevard.github.io/wiki/%E6%AC%A2%E8%BF%8E%EF%BC%81/</id>
    <published>2025-02-06T02:25:53.000Z</published>
    <updated>2025-02-06T13:41:24.805Z</updated>
    
    <content type="html"><![CDATA[<!-- 调整 themes 里的 config 里的 default_index_file 来修改打开站点时见到的文章 --><p>这是一篇欢迎文章，欢迎来到我的网站！</p><p>网站好像不是很漂亮？我承诺会改改的！让我先为你介绍一下网站的基本布局。</p><p>如你所见，左边是网站的文章列表，以文件夹的形式排布；左上方是几个按钮，“关于”是我的自我介绍，“历史”记录了文章的诞生时间线，如果迷路了，点击“首页”或者左上角的“Rinevard”就能回到这里了。在很多博客里，文章的诞生时间线被叫做“归档”，不过我觉得这个名字并不清晰，于是改成了“历史”。</p><p><img src="/images/%E6%AC%A2%E8%BF%8E/%E5%A5%97%E5%A8%83.png"></p><p>本网站使用了 Hexo 的 <a href="https://github.com/zthxxx/hexo-theme-Wikitten">Wikitten</a> 主题，在我看来，其最大优点是以文件夹的形式排布文章。博客的文章应当成体系且便于检索，而非一篇一篇堆积在网站上，构成凌乱的山。这一功能值得放在最高优先级，因此外表稍微简陋一点也无所谓了。</p><p>我应该主要会在这里放一些杂谈和游戏相关的文章，欢迎来看！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- 调整 themes 里的 config 里的 default_index_file 来修改打开站点时见到的文章 --&gt;

&lt;p&gt;这是一篇欢迎文章，欢迎来到我的网站！&lt;/p&gt;
&lt;p&gt;网站好像不是很漂亮？我承诺会改改的！让我先为你介绍一下网站的基本布局。&lt;/p&gt;
&lt;p&gt;如你</summary>
      
    
    
    
    
  </entry>
  
</feed>
