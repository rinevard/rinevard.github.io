<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Rinevard</title>
  
  
  <link href="http://rinevard.github.io/atom.xml" rel="self"/>
  
  <link href="http://rinevard.github.io/"/>
  <updated>2025-12-02T04:15:32.298Z</updated>
  <id>http://rinevard.github.io/</id>
  
  <author>
    <name>Rinevard</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Lab 7 Lock</title>
    <link href="http://rinevard.github.io/wiki/learning/open-course/MIT-6.S081/Labs/lab7-lock/"/>
    <id>http://rinevard.github.io/wiki/learning/open-course/MIT-6.S081/Labs/lab7-lock/</id>
    <published>2025-12-02T04:15:29.000Z</published>
    <updated>2025-12-02T04:15:32.298Z</updated>
    
    <content type="html"><![CDATA[<p>这个 lab 让我们熟悉对锁的使用。除了 2024 的题外我还顺便做了下 2025 新增的读写锁（2025 年用 Read-write lock 换掉了 Buffer cache），让我们依次来看看这几道题。</p><h1 id="Memory-allocator"><a href="#Memory-allocator" class="headerlink" title="Memory allocator"></a>Memory allocator</h1><p>在 xv6 里，多个进程同时尝试新增 / 释放内存时会在 kalloc.c 的 kmem 上产生激烈的锁竞争，这道题让我们给每个 CPU 设置一个自己的空闲块链表来缓解竞争问题。比较 tricky 的地方是当一个 CPU 的空闲块链表为空时，它要去别的 CPU 那里偷空闲块。</p><p>我们先来看看测试代码在做什么吧，先来看看 test2：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> free0 <span class="token operator">=</span> <span class="token function">countfree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> free1<span class="token punctuation">;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token punctuation">(</span>PHYSTOP <span class="token operator">-</span> KERNBASE<span class="token punctuation">)</span> <span class="token operator">/</span> PGSIZE<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"start test2\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"total free number of pages: %d (out of %d)\n"</span><span class="token punctuation">,</span> free0<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> free0 <span class="token operator">></span> <span class="token number">1000</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"test2 FAILED: cannot allocate enough memory"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">50</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        free1 <span class="token operator">=</span> <span class="token function">countfree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> <span class="token number">10</span> <span class="token operator">==</span> <span class="token number">9</span><span class="token punctuation">)</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>free1 <span class="token operator">!=</span> free0<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"test2 FAIL: losing pages %d %d\n"</span><span class="token punctuation">,</span> free0<span class="token punctuation">,</span> free1<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\ntest2 OK\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里的 countfree 函数在 sbrk 尽可能多的内存，计算一共新增了多少页，然后返回新增的页数。可以看出 test2 就是在检查分配 / 释放内存时有没有丢页。</p><p>test1 则更复杂一些。它把多进程 sbrk 前后锁自旋的总次数存在 m 和 n 中并计算 n - m。如果我们的实现较好，锁就会自旋较少，就能通过 if (n - m &lt; 10) 然后通过测试：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"start test1\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    m <span class="token operator">=</span> <span class="token function">ntas</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 创建 NCHILD 个子进程并让他们不断 sbrk</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> NCHILD<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// ...</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> status <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> NCHILD<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    n <span class="token operator">=</span> <span class="token function">ntas</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> m <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">)</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"test1 OK\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"test1 FAIL\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里的 ntas 很神奇，我花了蛮长时间才弄明白它是怎么获取锁的自旋次数的。感兴趣的话可以看看，不感兴趣的话记住它最终借助了 spinlock.c 的 statslock 来获取锁的自旋总次数就行。</p><p>首先 ntas 调用了 statistics，看向 statistics.c，它在读取 statistics 文件：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">statistics</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token keyword">int</span> sz<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> fd<span class="token punctuation">,</span> i<span class="token punctuation">,</span> n<span class="token punctuation">;</span>    fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"statistics"</span><span class="token punctuation">,</span> O_RDONLY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"stats: open failed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> sz<span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>n <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buf <span class="token operator">+</span> i<span class="token punctuation">,</span> sz <span class="token operator">-</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        i <span class="token operator">+=</span> n<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> i<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那 statistics 文件在哪呢？statistics 文件在 init.c 里被初始化。我们在内核的 stats.c 的 statsinit 里初始化了 STATS，把对它的读设置为调用 statsread，并在 statsread 里调用 spinlock.c 里的 statslock. 注意这里有内核的 stats.c 和用户的 stats.c，我们说的是前者。</p><p>总之 statistics 函数会读取 statistics，对 statistics 的读会调用 statsread，statsread 在 statistics 被读完后会调用 statslock 来更新内容。</p><p>我们当然会问为什么要绕这么大一圈，直接读spinlock.c里的东西不行吗？这是因为用户和内核有隔离。statistics 是用户态的函数，不能也不应该直接读内核的 spinlock.c 里的数据。</p><p><img src="/images/learning/open-course/MIT-6.S081/labs/lab7-lock/user_kernel.png" alt=""></p><p>test3 则是 test1 和 test2 的整合高清重制豪华加强版。我的代码能通过 2023 年和 2025 年版本的完整测试，但不能稳定通过 2024 版本的 test3（大部分时间过不了，运气好能过）。</p><p>2023 年的版本没有这种整合测试，2025 年的版本写的是 n-m &lt; (NCHILD4-1)*10000，感觉 2025 比 2024 的测试更合理，那就认为我的代码已经满足要求了吧。</p><p>然后我们上代码。先放在初始化的部分和 kfree：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">spinlock</span> lock<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">run</span> <span class="token operator">*</span>freelist<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> kmems<span class="token punctuation">[</span>NCPU<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">char</span> kmemlockname<span class="token punctuation">[</span>NCPU<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> STOLEN_NUM <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">kinit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> ncpu<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">snprintf</span><span class="token punctuation">(</span>kmemlockname<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>kmemlockname<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"kmem_%d"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">initlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kmems<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>lock<span class="token punctuation">,</span> kmemlockname<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">freerange</span><span class="token punctuation">(</span>end<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>PHYSTOP<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">freerange</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>pa_start<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>pa_end<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>    p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">PGROUNDUP</span><span class="token punctuation">(</span><span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>pa_start<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> p <span class="token operator">+</span> PGSIZE <span class="token operator">&lt;=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>pa_end<span class="token punctuation">;</span> p <span class="token operator">+=</span> PGSIZE<span class="token punctuation">)</span>        <span class="token function">kfree</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">kfree</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>pa<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">run</span> <span class="token operator">*</span>r<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>pa <span class="token operator">%</span> PGSIZE<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>pa <span class="token operator">&lt;</span> end <span class="token operator">||</span> <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>pa <span class="token operator">>=</span> PHYSTOP<span class="token punctuation">)</span>        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"kfree"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Fill with junk to catch dangling refs.</span>    <span class="token function">memset</span><span class="token punctuation">(</span>pa<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> PGSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    r <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">run</span> <span class="token operator">*</span><span class="token punctuation">)</span>pa<span class="token punctuation">;</span>    <span class="token function">push_off</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> id <span class="token operator">=</span> <span class="token function">cpuid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kmems<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    r<span class="token operator">-></span>next <span class="token operator">=</span> kmems<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">.</span>freelist<span class="token punctuation">;</span>    kmems<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">.</span>freelist <span class="token operator">=</span> r<span class="token punctuation">;</span>    <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kmems<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pop_off</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码思路很清晰，每个 CPU 一个自己的空闲链表，kfree 把释放掉的块加到当前 CPU 的链表上。</p><p>我还试了下在 kinit 结尾打印出每个 CPU 的空闲块链表长度，然后发现所有的空闲块都在一个 CPU 那里。原本我还以为 freerange 的过程中每个 CPU 都会跑一跑 kfree，然后让空闲块均匀分布在各个 CPU 上呢。</p><p>然后我们看看 kalloc：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">kalloc</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// We can consistently pass the 2025 tests, but occasionally fail the 2024</span>    <span class="token comment">// test3. I think this is good enough, so we won't continue further.</span>    <span class="token keyword">struct</span> <span class="token class-name">run</span> <span class="token operator">*</span>r<span class="token punctuation">;</span>    <span class="token function">push_off</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> id <span class="token operator">=</span> <span class="token function">cpuid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kmems<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    r <span class="token operator">=</span> kmems<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">.</span>freelist<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>r<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        kmems<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">.</span>freelist <span class="token operator">=</span> r<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kmems<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// There isn't a fixed acquire order for CPU locks</span>        <span class="token comment">// so release the lock before acquiring other locks to avoid deadlock</span>        <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kmems<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">struct</span> <span class="token class-name">run</span> <span class="token operator">*</span>stolen_head <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">struct</span> <span class="token class-name">run</span> <span class="token operator">*</span>stolen_end <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">// Steal STOLEN_NUM pages from another CPU's free list</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token punctuation">(</span>id <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">+</span> ncpu<span class="token punctuation">)</span> <span class="token operator">%</span> ncpu<span class="token punctuation">;</span> i <span class="token operator">!=</span> id<span class="token punctuation">;</span>             i <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">+</span> ncpu<span class="token punctuation">)</span> <span class="token operator">%</span> ncpu<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kmems<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>kmems<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>freelist<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kmems<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            stolen_head <span class="token operator">=</span> kmems<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>freelist<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">(</span>kmems<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>freelist<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>cnt <span class="token operator">&lt;</span> STOLEN_NUM<span class="token punctuation">)</span><span class="token punctuation">;</span>                 cnt<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                stolen_end <span class="token operator">=</span> kmems<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>freelist<span class="token punctuation">;</span>                kmems<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>freelist <span class="token operator">=</span> stolen_end<span class="token operator">-></span>next<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            stolen_end<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kmems<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>stolen_head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kmems<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>            stolen_end<span class="token operator">-></span>next <span class="token operator">=</span> kmems<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">.</span>freelist<span class="token punctuation">;</span>            kmems<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">.</span>freelist <span class="token operator">=</span> stolen_head<span class="token punctuation">;</span>            r <span class="token operator">=</span> kmems<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">.</span>freelist<span class="token punctuation">;</span>            kmems<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">.</span>freelist <span class="token operator">=</span> r<span class="token operator">-></span>next<span class="token punctuation">;</span>            <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kmems<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">pop_off</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>r<span class="token punctuation">)</span>        <span class="token function">memset</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>r<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> PGSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// fill with junk</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>r<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里比较 trickky 的就是 else 里窃取别的 CPU 的块的部分。首先如我的注释所言，各个 CPU 的 kmem lock 没有固定的获取顺序，所以我们要先释放自己的 kmem lock 再开偷，保证同一时间只拿着一个 CPU 的 kmem lock，不然有死锁风险。</p><p>然后我们从当前 CPU 开始往后遍历，找到合适的 CPU 以后就抓它的锁然后偷 STOLEN_NUM 个块暂存在 stolen_head 这个链表里，偷完以后释放它的锁并抓自己的锁再把链表接到自己头上。</p><p>这样一来窃取和新增块都是原子性的，不会有并发问题。</p><p>我测出来设置 STOLEN_NUM 为 1 或 8 时效果最好，更大反而效果欠佳，挺神奇的。</p><h1 id="Buffer-cache"><a href="#Buffer-cache" class="headerlink" title="Buffer cache"></a>Buffer cache</h1><p>文件系统的缓存层也有一个较激烈的锁竞争，我们可以通过把缓存链表拆分成若干个小的链表，给每个链表设置单独的锁来缓解竞争。</p><p>那么怎么拆分链表呢？我们知道每个 block 有 blockno，因此我们可以把 block 放到编号为 hash(blockno) 的链表中。基本思路就是这样，接下来看代码吧，首先是初始化部分：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">BUCKET_SIZE</span> <span class="token expression"><span class="token number">13</span></span></span><span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">spinlock</span>        steal_lock<span class="token punctuation">;</span> <span class="token comment">// steal lock, only one process is stealing at a time</span>    <span class="token keyword">struct</span> <span class="token class-name">buf</span> buf<span class="token punctuation">[</span>NBUF<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">buf</span> head<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> bcache<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">spinlock</span> lock<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">buf</span> head<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> buckets<span class="token punctuation">[</span>BUCKET_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>uint <span class="token function">hash</span><span class="token punctuation">(</span>uint blockno<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> blockno <span class="token operator">%</span> BUCKET_SIZE<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">binit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">buf</span> <span class="token operator">*</span>b<span class="token punctuation">;</span>    <span class="token function">initlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>bcache<span class="token punctuation">.</span>steal_lock<span class="token punctuation">,</span> <span class="token string">"bcache"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> BUCKET_SIZE<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">initlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buckets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>lock<span class="token punctuation">,</span> <span class="token string">"bcache.bucket"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// Put all buffers into bucket[0] initially</span>    <span class="token keyword">struct</span> <span class="token class-name">buf</span> <span class="token operator">*</span>cur<span class="token punctuation">;</span>    cur <span class="token operator">=</span> <span class="token operator">&amp;</span>buckets<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>head<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>b <span class="token operator">=</span> bcache<span class="token punctuation">.</span>buf<span class="token punctuation">;</span> b <span class="token operator">&lt;</span> bcache<span class="token punctuation">.</span>buf <span class="token operator">+</span> NBUF<span class="token punctuation">;</span> b<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        cur<span class="token operator">-></span>next <span class="token operator">=</span> b<span class="token punctuation">;</span>        b<span class="token operator">-></span>prev <span class="token operator">=</span> cur<span class="token punctuation">;</span>        <span class="token function">initsleeplock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>b<span class="token operator">-></span>lock<span class="token punctuation">,</span> <span class="token string">"buffer"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cur <span class="token operator">=</span> b<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里主要是对链表做了下拆分。这里的 steal_lock 和接下来的 bget 相关，主要是为了防止下面这种情况：</p><ol><li>进程 A 和进程 B 都在请求 blockno，我们令 dest = hash(blockno)</li><li>进程 A 和 B 都没在 buckets[dest] 找到块，开始窃取。</li><li>进程 B 比 A 先窃取到了一个空闲块，把它放进了 buckets[dest] 并填入了数据。</li><li>进程 A 也找到了一个空闲块并把它放入 buckets[dest] 并填入数据。</li><li>这会导致两个 buf 有相同的 blockno，这不是我们想要的。</li></ol><p>这里的 steal_lock 保证同一时间只有一个进程在试图窃取别的 bucket 的 buf. 配合在窃取前再次检查一遍 bucket[dest] 就能避免上述情况的发生。</p><p>我们现在来看看 bget：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">buf</span> <span class="token operator">*</span><span class="token function">bget</span><span class="token punctuation">(</span>uint dev<span class="token punctuation">,</span> uint blockno<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">buf</span> <span class="token operator">*</span>b<span class="token punctuation">;</span>    uint dest <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>blockno<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buckets<span class="token punctuation">[</span>dest<span class="token punctuation">]</span><span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Is the block already cached?</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>b <span class="token operator">=</span> buckets<span class="token punctuation">[</span>dest<span class="token punctuation">]</span><span class="token punctuation">.</span>head<span class="token punctuation">.</span>next<span class="token punctuation">;</span> b<span class="token punctuation">;</span> b <span class="token operator">=</span> b<span class="token operator">-></span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>b<span class="token operator">-></span>dev <span class="token operator">==</span> dev <span class="token operator">&amp;&amp;</span> b<span class="token operator">-></span>blockno <span class="token operator">==</span> blockno<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            b<span class="token operator">-></span>refcnt<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buckets<span class="token punctuation">[</span>dest<span class="token punctuation">]</span><span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">acquiresleep</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>b<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> b<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// --------------------下面是窃取代码--------------------</span>    <span class="token comment">// Not cached.</span>    <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buckets<span class="token punctuation">[</span>dest<span class="token punctuation">]</span><span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>bcache<span class="token punctuation">.</span>steal_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buckets<span class="token punctuation">[</span>dest<span class="token punctuation">]</span><span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// double check, other process might have stolen before we steal</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>b <span class="token operator">=</span> buckets<span class="token punctuation">[</span>dest<span class="token punctuation">]</span><span class="token punctuation">.</span>head<span class="token punctuation">.</span>next<span class="token punctuation">;</span> b<span class="token punctuation">;</span> b <span class="token operator">=</span> b<span class="token operator">-></span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>b<span class="token operator">-></span>dev <span class="token operator">==</span> dev <span class="token operator">&amp;&amp;</span> b<span class="token operator">-></span>blockno <span class="token operator">==</span> blockno<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            b<span class="token operator">-></span>refcnt<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buckets<span class="token punctuation">[</span>dest<span class="token punctuation">]</span><span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>bcache<span class="token punctuation">.</span>steal_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">acquiresleep</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>b<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> b<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buckets<span class="token punctuation">[</span>dest<span class="token punctuation">]</span><span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// steal from another bucket</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> BUCKET_SIZE<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buckets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// iterate through bucket to find a free buf</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>b <span class="token operator">=</span> buckets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>head<span class="token punctuation">.</span>next<span class="token punctuation">;</span> b<span class="token punctuation">;</span> b <span class="token operator">=</span> b<span class="token operator">-></span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>b<span class="token operator">-></span>refcnt <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// remove b from orig bucket</span>                b<span class="token operator">-></span>prev<span class="token operator">-></span>next <span class="token operator">=</span> b<span class="token operator">-></span>next<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>b<span class="token operator">-></span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    b<span class="token operator">-></span>next<span class="token operator">-></span>prev <span class="token operator">=</span> b<span class="token operator">-></span>prev<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                b<span class="token operator">-></span>prev <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                b<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buckets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// put b into dest bucket</span>                <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buckets<span class="token punctuation">[</span>dest<span class="token punctuation">]</span><span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>                b<span class="token operator">-></span>prev <span class="token operator">=</span> <span class="token operator">&amp;</span>buckets<span class="token punctuation">[</span>dest<span class="token punctuation">]</span><span class="token punctuation">.</span>head<span class="token punctuation">;</span>                b<span class="token operator">-></span>next <span class="token operator">=</span> buckets<span class="token punctuation">[</span>dest<span class="token punctuation">]</span><span class="token punctuation">.</span>head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                b<span class="token operator">-></span>prev<span class="token operator">-></span>next <span class="token operator">=</span> b<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>b<span class="token operator">-></span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    b<span class="token operator">-></span>next<span class="token operator">-></span>prev <span class="token operator">=</span> b<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                b<span class="token operator">-></span>dev <span class="token operator">=</span> dev<span class="token punctuation">;</span>                b<span class="token operator">-></span>blockno <span class="token operator">=</span> blockno<span class="token punctuation">;</span>                b<span class="token operator">-></span>valid <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                b<span class="token operator">-></span>refcnt <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token function">acquiresleep</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>b<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buckets<span class="token punctuation">[</span>dest<span class="token punctuation">]</span><span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>bcache<span class="token punctuation">.</span>steal_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> b<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buckets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"bget: no buffers"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也有不加 steal_lock 的写法，可以在填入数据前检查 buckets[dest] 中是否有 blockno 对应的 buf，如果有就不填数据而是把空块加入 buckets[dest]，如果没有再填数据，如下所示：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">buf</span> <span class="token operator">*</span><span class="token function">bget</span><span class="token punctuation">(</span>uint dev<span class="token punctuation">,</span> uint blockno<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">buf</span> <span class="token operator">*</span>b<span class="token punctuation">;</span>    uint dest <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>blockno<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buckets<span class="token punctuation">[</span>dest<span class="token punctuation">]</span><span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Is the block already cached?</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>b <span class="token operator">=</span> buckets<span class="token punctuation">[</span>dest<span class="token punctuation">]</span><span class="token punctuation">.</span>head<span class="token punctuation">.</span>next<span class="token punctuation">;</span> b<span class="token punctuation">;</span> b <span class="token operator">=</span> b<span class="token operator">-></span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>b<span class="token operator">-></span>dev <span class="token operator">==</span> dev <span class="token operator">&amp;&amp;</span> b<span class="token operator">-></span>blockno <span class="token operator">==</span> blockno<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            b<span class="token operator">-></span>refcnt<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buckets<span class="token punctuation">[</span>dest<span class="token punctuation">]</span><span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">acquiresleep</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>b<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> b<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// Not cached.</span>    <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buckets<span class="token punctuation">[</span>dest<span class="token punctuation">]</span><span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// steal from another bucket</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> BUCKET_SIZE<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buckets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// iterate through bucket to find a free buf</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>b <span class="token operator">=</span> buckets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>head<span class="token punctuation">.</span>next<span class="token punctuation">;</span> b<span class="token punctuation">;</span> b <span class="token operator">=</span> b<span class="token operator">-></span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>b<span class="token operator">-></span>refcnt <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// remove b from orig bucket</span>                b<span class="token operator">-></span>prev<span class="token operator">-></span>next <span class="token operator">=</span> b<span class="token operator">-></span>next<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>b<span class="token operator">-></span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    b<span class="token operator">-></span>next<span class="token operator">-></span>prev <span class="token operator">=</span> b<span class="token operator">-></span>prev<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                b<span class="token operator">-></span>prev <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                b<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buckets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// put b into dest bucket</span>                <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buckets<span class="token punctuation">[</span>dest<span class="token punctuation">]</span><span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>                b<span class="token operator">-></span>prev <span class="token operator">=</span> <span class="token operator">&amp;</span>buckets<span class="token punctuation">[</span>dest<span class="token punctuation">]</span><span class="token punctuation">.</span>head<span class="token punctuation">;</span>                b<span class="token operator">-></span>next <span class="token operator">=</span> buckets<span class="token punctuation">[</span>dest<span class="token punctuation">]</span><span class="token punctuation">.</span>head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                b<span class="token operator">-></span>prev<span class="token operator">-></span>next <span class="token operator">=</span> b<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>b<span class="token operator">-></span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    b<span class="token operator">-></span>next<span class="token operator">-></span>prev <span class="token operator">=</span> b<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token comment">// double check, other process might have stolen before we steal</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">buf</span> <span class="token operator">*</span>check <span class="token operator">=</span> buckets<span class="token punctuation">[</span>dest<span class="token punctuation">]</span><span class="token punctuation">.</span>head<span class="token punctuation">.</span>next<span class="token punctuation">;</span> check<span class="token punctuation">;</span>                     check <span class="token operator">=</span> check<span class="token operator">-></span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>check<span class="token operator">-></span>dev <span class="token operator">==</span> dev <span class="token operator">&amp;&amp;</span> check<span class="token operator">-></span>blockno <span class="token operator">==</span> blockno<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        check<span class="token operator">-></span>refcnt<span class="token operator">++</span><span class="token punctuation">;</span>                        <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buckets<span class="token punctuation">[</span>dest<span class="token punctuation">]</span><span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token function">acquiresleep</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>check<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">return</span> check<span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span>                b<span class="token operator">-></span>dev <span class="token operator">=</span> dev<span class="token punctuation">;</span>                b<span class="token operator">-></span>blockno <span class="token operator">=</span> blockno<span class="token punctuation">;</span>                b<span class="token operator">-></span>valid <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                b<span class="token operator">-></span>refcnt <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buckets<span class="token punctuation">[</span>dest<span class="token punctuation">]</span><span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">acquiresleep</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>b<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> b<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buckets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"bget: no buffers"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后几个要改的函数把原本的锁换成 bucket 的锁就可以了。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">brelse</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">buf</span> <span class="token operator">*</span>b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">holdingsleep</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>b<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"brelse"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">releasesleep</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>b<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    uint idx <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>b<span class="token operator">-></span>blockno<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buckets<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    b<span class="token operator">-></span>refcnt<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buckets<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">bpin</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">buf</span> <span class="token operator">*</span>b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    uint idx <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>b<span class="token operator">-></span>blockno<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buckets<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    b<span class="token operator">-></span>refcnt<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buckets<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">bunpin</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">buf</span> <span class="token operator">*</span>b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    uint idx <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>b<span class="token operator">-></span>blockno<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buckets<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    b<span class="token operator">-></span>refcnt<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buckets<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Read-write-lock"><a href="#Read-write-lock" class="headerlink" title="Read-write lock"></a>Read-write lock</h1><p>我还抽空做了下 2025 版本新增的 Read-write lock，这要求我们实现一个读写锁。读写锁把用户分为读者和写者，同一时间可以有多个读者或一个写者持有读写锁。另外在这道题里，如果读者和写者同时在等待，写者优先持锁。</p><p>我的实现思路还是比较朴素的，我们先看数据结构吧：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">rwspinlock</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">spinlock</span> l<span class="token punctuation">;</span>    <span class="token keyword">int</span> readers<span class="token punctuation">;</span>    <span class="token keyword">int</span> writer_active<span class="token punctuation">;</span> <span class="token comment">// 0 or 1</span>    <span class="token keyword">int</span> waiting_writers<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>读者仅在没有写者持锁且没有写者在等待时才能持锁，所以我们需要 writer_active 和 waiting_writers 两个字段；写者仅在没有别的写者持锁且没有读者持锁时才能持锁，所以我们也需要 readers 字段。这里的 spinlock 则是为了保护这些共享数据。</p><p>其实也可以不用 spinlock 而全用原子语句写，但我感觉太难了就没这么做。</p><p>函数的实现思路也比较朴素，可以直接看代码。要注意我们被要求实现自旋版本的读写锁，所以在 acquire 的条件不满足时我们不能 sleep，而应释放锁然后不断循环。</p><p>现实里也存在睡眠版本的读写锁，不过这和我们的 lab 没关系。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">read_acquire_inner</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rwspinlock</span> <span class="token operator">*</span>rwlk<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rwlk<span class="token operator">-></span>l<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>rwlk<span class="token operator">-></span>writer_active <span class="token operator">||</span> rwlk<span class="token operator">-></span>waiting_writers <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rwlk<span class="token operator">-></span>l<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">continue</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    rwlk<span class="token operator">-></span>readers<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rwlk<span class="token operator">-></span>l<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">read_release_inner</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rwspinlock</span> <span class="token operator">*</span>rwlk<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rwlk<span class="token operator">-></span>l<span class="token punctuation">)</span><span class="token punctuation">;</span>  rwlk<span class="token operator">-></span>readers<span class="token operator">--</span><span class="token punctuation">;</span>  <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rwlk<span class="token operator">-></span>l<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">write_acquire_inner</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rwspinlock</span> <span class="token operator">*</span>rwlk<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rwlk<span class="token operator">-></span>l<span class="token punctuation">)</span><span class="token punctuation">;</span>  rwlk<span class="token operator">-></span>waiting_writers<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rwlk<span class="token operator">-></span>l<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rwlk<span class="token operator">-></span>l<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>rwlk<span class="token operator">-></span>readers <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">||</span> rwlk<span class="token operator">-></span>writer_active<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rwlk<span class="token operator">-></span>l<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">continue</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    rwlk<span class="token operator">-></span>waiting_writers<span class="token operator">--</span><span class="token punctuation">;</span>    rwlk<span class="token operator">-></span>writer_active <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rwlk<span class="token operator">-></span>l<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">write_release_inner</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rwspinlock</span> <span class="token operator">*</span>rwlk<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rwlk<span class="token operator">-></span>l<span class="token punctuation">)</span><span class="token punctuation">;</span>  rwlk<span class="token operator">-></span>writer_active <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rwlk<span class="token operator">-></span>l<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里是 initrwlock 的代码</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">initrwlock</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rwspinlock</span> <span class="token operator">*</span>rwlk<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// Replace this with your implementation.</span>  <span class="token function">initlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rwlk<span class="token operator">-></span>l<span class="token punctuation">,</span> <span class="token string">"rwlk"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  rwlk<span class="token operator">-></span>readers <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  rwlk<span class="token operator">-></span>waiting_writers <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  rwlk<span class="token operator">-></span>writer_active <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试时我们遇到了一个神奇的现象，在 make qemu 后第一次运行 rwlktest 总是能通过的，而之后运行总是不能通过的。重新 make qemu 以后还是第一次运行能通过，后续运行无法通过。</p><p>经过漫长的 debug 时光，我们发现问题出在下面的测试函数上：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">rwspinlock_test_step</span><span class="token punctuation">(</span>uint step<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>msg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">static</span> uint barrier<span class="token punctuation">;</span>  <span class="token keyword">const</span> uint ncpu <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>  <span class="token function">__atomic_fetch_add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>barrier<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> __ATOMIC_ACQ_REL<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">__atomic_load_n</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>barrier<span class="token punctuation">,</span> __ATOMIC_RELAXED<span class="token punctuation">)</span> <span class="token operator">&lt;</span> ncpu <span class="token operator">*</span> step<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// spin</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">cpuid</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"rwspinlock_test: step %d: %s\n"</span><span class="token punctuation">,</span> step<span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个函数的设计原意应该是起这两个作用：</p><ol><li>同步 CPU，保证四个 CPU 都到达了这里再继续往下运行</li><li>打印当前运行到的测试编号（step）</li></ol><p>这个函数通过下面的代码实现 CPU 同步。它让 barrier 原子性地加一，表示一个 CPU 跑到了这里，然后如果四个 CPU 中还有人没来就自旋等待。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">__atomic_fetch_add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>barrier<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> __ATOMIC_ACQ_REL<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">__atomic_load_n</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>barrier<span class="token punctuation">,</span> __ATOMIC_RELAXED<span class="token punctuation">)</span> <span class="token operator">&lt;</span> ncpu <span class="token operator">*</span> step<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// spin</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>为了保证 barrier 被四个 CPU 共享，barrier 被设置为静态变量 static uint barrier. 但测试代码又没在测试开始时把它重置为 0，所以就出现了这种第一次测试能通过，之后的测试不能通过的情况。</p><p>第一次测试时，barrier 是初始值 0，所以一切正常；之后的测试里 barrier 保留了之前的值，while 的条件始终为假，于是这种同步功能也就完全失效了。在同步功能失效后，跑得快的 CPU 都跑完 30 个 steps 了，跑得慢的 CPU 可能还在第 8 个 step 挣扎，这就让 rwlktest 也跟着失效了。</p><p>气氛都到这儿了，不给个修复也不好意思🫠🫠用下面的代码就行了</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">rwspinlock_test_step</span><span class="token punctuation">(</span>uint step<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>msg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">static</span> uint count<span class="token punctuation">;</span>  <span class="token keyword">static</span> uint sense<span class="token punctuation">;</span>  <span class="token keyword">const</span> uint ncpu <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> local_sense <span class="token operator">=</span> <span class="token function">__atomic_load_n</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sense<span class="token punctuation">,</span> __ATOMIC_RELAXED<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__atomic_fetch_add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>count<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> __ATOMIC_ACQ_REL<span class="token punctuation">)</span> <span class="token operator">==</span> ncpu <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// Let the last reached CPU reset values and print message</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"rwspinlock_test: step %d: %s\n"</span><span class="token punctuation">,</span> step<span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">__atomic_store_n</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>count<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> __ATOMIC_RELAXED<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">__atomic_store_n</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sense<span class="token punctuation">,</span> <span class="token operator">!</span>local_sense<span class="token punctuation">,</span> __ATOMIC_RELEASE<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">__atomic_load_n</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sense<span class="token punctuation">,</span> __ATOMIC_ACQUIRE<span class="token punctuation">)</span> <span class="token operator">==</span> local_sense<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// spin</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>count 和 sense 是共享的变量，所以要用原子语句读写。__ATOMIC_RELAXED 之类的东西是对内存顺序（memory orders）的限制，这能防止指令重排，具体可以看 <a href="https://gcc.gnu.org/onlinedocs/gcc/_005f_005fatomic-Builtins.html">https://gcc.gnu.org/onlinedocs/gcc/_005f_005fatomic-Builtins.html</a>.</p><p>发现这个 bug 以后我也给 6S081 的官方发了邮件，没想到还真收到回复了！他们说加入了一个类似的修复，会在 2026 年的版本更新。感觉自己对 MIT 的滤镜更厚了（）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这个 lab 让我们熟悉对锁的使用。除了 2024 的题外我还顺便做了下 2025 新增的读写锁（2025 年用 Read-write lock 换掉了 Buffer cache），让我们依次来看看这几道题。&lt;/p&gt;
&lt;h1 id=&quot;Memory-allocator&quot;&gt;&lt;a</summary>
      
    
    
    
    <category term="公开课" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"/>
    
    <category term="MIT-6.S081" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/MIT-6-S081/"/>
    
    <category term="Labs" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/MIT-6-S081/Labs/"/>
    
    
  </entry>
  
  <entry>
    <title>Lab 6 Networking</title>
    <link href="http://rinevard.github.io/wiki/learning/open-course/MIT-6.S081/Labs/lab6-net/"/>
    <id>http://rinevard.github.io/wiki/learning/open-course/MIT-6.S081/Labs/lab6-net/</id>
    <published>2025-11-08T23:41:29.000Z</published>
    <updated>2025-11-08T23:58:14.625Z</updated>
    
    <content type="html"><![CDATA[<p>这个 lab 分两个部分，第一部分是补全 E1000 网卡驱动的数据包收发相关代码，第二部分是添加代码完成 UDP 包的接收。在开始之前，我们应该先去把讲网络的 lecture 看掉，因为里面涉及了很多相关内容。你可能会疑惑为什么课程把 lab 安排在 lec 前面，我在本文的文末吐槽里写了可能的原因。</p><p>让我们进入正题。</p><h1 id="E1000-网卡驱动"><a href="#E1000-网卡驱动" class="headerlink" title="E1000 网卡驱动"></a>E1000 网卡驱动</h1><p>我们在编写代码时要回答两个问题——我们如何借助网卡接收数据，又如何发送数据？我们对照文档第三章来分析一下，然后在分析的结尾分别给出 e1000_recv 和 e1000_transmit 的代码：</p><ol><li><p>我们如何借助网卡接收数据？</p><p> 我们在初始化里设置了 RDTR，这让网卡在收到包时发出中断，这一部分和文档的 3.2.8 Receive Interrupts 有关：</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// ask e1000 for receive interrupts.</span>regs<span class="token punctuation">[</span>E1000_RDTR<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// interrupt after every received packet (no timer)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p> 我们还在初始化里设置了 RDBAL，这让网卡在收到包时把数据放到 rx_ring 中：</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// [E1000 14.4] Receive initialization</span><span class="token function">memset</span><span class="token punctuation">(</span>rx_ring<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>rx_ring<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> RX_RING_SIZE<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    rx_bufs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">kalloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>rx_bufs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"e1000"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    rx_ring<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>addr <span class="token operator">=</span> <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>rx_bufs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>regs<span class="token punctuation">[</span>E1000_RDBAL<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>rx_ring<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 具体来说，它会把包放到 rx_ring[RDH] 里，我们则用 RDT 来读取。</p><p> 下图是 rx_ring 的示意图，硬件可向 [HEAD, TAIL) 中写入内容， TAIL 处留空以区分空环和满环。</p><p> <img src="/images/learning/open-course/MIT-6.S081/labs/lab6-net/rxring.png" alt=""></p><p> 网卡传来的数据格式在 e1000_dev.h 里定义，可参考文档 3.2.3 Receive Descriptor Format：</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">rx_desc</span> <span class="token punctuation">&#123;</span>    uint64 addr<span class="token punctuation">;</span>   <span class="token comment">/* Address of the descriptor's data buffer */</span>    uint16 length<span class="token punctuation">;</span> <span class="token comment">/* Length of data DMAed into data buffer */</span>    uint16 csum<span class="token punctuation">;</span>   <span class="token comment">/* Packet checksum */</span>    uint8 status<span class="token punctuation">;</span>  <span class="token comment">/* Descriptor status */</span>    uint8 errors<span class="token punctuation">;</span>  <span class="token comment">/* Descriptor Errors */</span>    uint16 special<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 网卡发出中断后，内核会调用 e1000_intr，e1000_intr 又会进一步调用 e1000_recv. </p><p> 对照 rx_ring 的示意图，我们就知道 e1000_recv 应该去 rx_ring[RDT + 1] 处读取数据，直到读到无效数据为止。参考文档的 3.2.3.1 Receive Descriptor Status Field，我们可以根据 rx_desc 的 status 的 DD 位得知数据是否有效。</p><p> 总之代码如下所示：</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">e1000_recv</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//</span>    <span class="token comment">// Your code here.</span>    <span class="token comment">//</span>    <span class="token comment">// Check for packets that have arrived from the e1000</span>    <span class="token comment">// Create and deliver a buf for each packet (using net_rx()).</span>    <span class="token comment">//</span>    <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>e1000_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    uint32 idx <span class="token operator">=</span> <span class="token punctuation">(</span>regs<span class="token punctuation">[</span>E1000_RDT<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> RX_RING_SIZE<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>rx_ring<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">.</span>status <span class="token operator">&amp;</span> E1000_RXD_STAT_DD<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">char</span> <span class="token operator">*</span>recv_buf <span class="token operator">=</span> rx_bufs<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> buflen <span class="token operator">=</span> rx_ring<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>        rx_bufs<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">kalloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>rx_bufs<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"e1000"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        rx_ring<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">.</span>addr <span class="token operator">=</span> <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>rx_bufs<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">;</span>        rx_ring<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">.</span>status <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        idx <span class="token operator">=</span> <span class="token punctuation">(</span>idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> RX_RING_SIZE<span class="token punctuation">;</span>        <span class="token comment">// net_rx could call e1000_transmit, so release lock before calling it</span>        <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>e1000_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">net_rx</span><span class="token punctuation">(</span>recv_buf<span class="token punctuation">,</span> buflen<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>e1000_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// set RDT to the last processed index</span>    regs<span class="token punctuation">[</span>E1000_RDT<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>idx <span class="token operator">+</span> RX_RING_SIZE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> RX_RING_SIZE<span class="token punctuation">;</span>    <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>e1000_lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 这里的 <code>regs[E1000_RDT] = (idx + RX_RING_SIZE - 1) % RX_RING_SIZE</code> 可能比较 tricky，总之就是 RDT 应该指在最后一个被取出的描述符处以实现留空。</p></li><li><p>我们如何借助网卡发送数据？</p><p> 如文档 3.4.3 Transmit Interrupts 所写，我们也可以设置网卡在传输完成时发生中断，不过在 xv6 里我们没有这么设置，所以发送成功不会中断。</p><p> 与读取数据要把 rx_ring 的位置告诉网卡类似，我们要把 tx_ring 的位置在初始化里告诉网卡：</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// [E1000 14.5] Transmit initialization</span><span class="token function">memset</span><span class="token punctuation">(</span>tx_ring<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>tx_ring<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> TX_RING_SIZE<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    tx_ring<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>status <span class="token operator">=</span> E1000_TXD_STAT_DD<span class="token punctuation">;</span>    tx_bufs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>regs<span class="token punctuation">[</span>E1000_TDBAL<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>tx_ring<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 我们会把数据放到 tx_ring[TDT] 里，网卡会自动走动 TDH 直到追上 TDT.</p><p> 下图是 rx_ring 的示意图，TAIL 指向硬件能够处理的最后一个描述符之后的位置，这也是软件写入第一个新描述符的位置。与 rx_ring 不同，tx_ring 无留空。</p><p> <img src="/images/learning/open-course/MIT-6.S081/labs/lab6-net/txring.png" alt=""></p><p> 传给网卡的数据结构也在 e1000_dev.h 里定义，可参考文档 3.3.2 Transmit Descriptors：</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">tx_desc</span> <span class="token punctuation">&#123;</span>    uint64 addr<span class="token punctuation">;</span>    uint16 length<span class="token punctuation">;</span>    uint8 cso<span class="token punctuation">;</span>    uint8 cmd<span class="token punctuation">;</span>    uint8 status<span class="token punctuation">;</span>    uint8 css<span class="token punctuation">;</span>    uint16 special<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 对照 tx_ring 的示意图，我们要把数据存在 tx_ring[TDT] 里。要注意如果 TDT 指向的内容已经被网卡成功发送了（可以通过 status 的 DD 位来判断），我们要释放 TDT 指向的内存以避免内存泄漏；另外我们还要更新 cmd 位，具体可以参考 3.3.3.1 Transmit Descriptor Command Field Format. 总之下面是代码：</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">e1000_transmit</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//</span>    <span class="token comment">// Your code here.</span>    <span class="token comment">//</span>    <span class="token comment">// buf contains an ethernet frame; program it into</span>    <span class="token comment">// the TX descriptor ring so that the e1000 sends it. Stash</span>    <span class="token comment">// a pointer so that it can be freed after send completes.</span>    <span class="token comment">//</span>    <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>e1000_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    uint32 idx <span class="token operator">=</span> regs<span class="token punctuation">[</span>E1000_TDT<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>tx_ring<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">.</span>status <span class="token operator">&amp;</span> E1000_TXD_STAT_DD<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>e1000_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// free old buf that has been sent away</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tx_ring<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">.</span>addr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">kfree</span><span class="token punctuation">(</span>tx_bufs<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    tx_bufs<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> buf<span class="token punctuation">;</span>    tx_ring<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">.</span>addr <span class="token operator">=</span> <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>tx_bufs<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">;</span>    tx_ring<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">.</span>length <span class="token operator">=</span> len<span class="token punctuation">;</span>    tx_ring<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">.</span>cmd <span class="token operator">=</span> E1000_TXD_CMD_EOP <span class="token operator">|</span> E1000_TXD_CMD_RS<span class="token punctuation">;</span>    tx_ring<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">.</span>status <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    regs<span class="token punctuation">[</span>E1000_TDT<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> TX_RING_SIZE<span class="token punctuation">;</span>    <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>e1000_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h1 id="UDP-包的接收"><a href="#UDP-包的接收" class="headerlink" title="UDP 包的接收"></a>UDP 包的接收</h1><p>我们先来梳理一下整个收信流程是怎样的：外部会发 packet 给网卡，网卡在收到后会引发中断，内核发现中断由网卡引发就会调用 <code>e1000_intr</code>，之后 packet 会被发给 <code>net_rx</code> 来让内核做进一步处理。如果 <code>net_rx</code> 发现这是一个 IP packet 就会进一步调用 <code>ip_rx</code>，然后就到我们的工作了。</p><p>我们只需要处理 ETH-IP-UDP 嵌套的 packet，让我们回顾一下它的结构：</p><p><img src="/images/learning/open-course/MIT-6.S081/labs/lab6-net/packet.png" alt=""></p><p>具体的 packet header 的定义在 net.h 里。</p><p>总之我们要实现 recv、bind、ip_rx 这三个函数。应用会调用 bind 来监听一个端口，当端口被监听时我们需要保存到达这个端口的数据包，所以要在 <code>net.h</code> 中定义如下的数据结构：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_LISTEN_PORTS</span> <span class="token expression"><span class="token number">128</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PACKET_RING_SIZE</span> <span class="token expression"><span class="token number">16</span> </span><span class="token comment">// for any given port, no more than 16 packets should be saved</span></span><span class="token keyword">struct</span> <span class="token class-name">listener</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> used<span class="token punctuation">;</span>    <span class="token keyword">int</span> port<span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>packet_ring<span class="token punctuation">[</span>PACKET_RING_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> head<span class="token punctuation">;</span> <span class="token comment">// used by writer</span>    <span class="token keyword">int</span> tail<span class="token punctuation">;</span> <span class="token comment">// used by reader</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里的 used 字段可能有点奇怪，我来解释一下：我们希望每当一个应用调用 bind，我们就新增一个 listener，但由于 C 语言实现动态数组很麻烦，所以我们选择创建静态大小的 listeners 数组。那为什么不用链表呢？因为我们新增内存的手段只有 kalloc，而一整个页对一个 listener 来说太大了。</p><p>struct listener 里的 used 字段就是为了判断 listeners 数组里的某个 listener 是否已经被使用。</p><p>我们要在 net.c 里初始化 listeners 数组：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">listener</span> listeners<span class="token punctuation">[</span>MAX_LISTEN_PORTS<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">netinit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">initlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>netlock<span class="token punctuation">,</span> <span class="token string">"netlock"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> MAX_LISTEN_PORTS<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        listeners<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>used <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> PACKET_RING_SIZE<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            listeners<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>packet_ring<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来我们分析一下每个函数要做什么，再给出代码：</p><ol><li><p>recv(int dport, int *src, short *sport, char *buf, int maxlen)</p><p> 接收到达 dport 端口的 UDP packet. 如果到达了多个，取出第一个 packet；如果没有东西到达，等待直到有东西到达。</p><p> 本函数把取出的 packet 里 32 位的源 IP 地址复制到 *src，UDP 源端口号复制到 *sport，payload 的至多 maxlen 个字节复制到 buf. 成功则返回复制的 payload 字节数，失败返回 -1.</p><p> 注意网络字节序和系统字节序不同，要用 <code>ntohs</code> 和 <code>ntohl</code> 来逆转字节序。</p><p> 另外，这里的各个指针是用户空间的虚拟地址，我们要用 copyout 把 packet 里的内容（它们在内核空间）复制到用户空间。</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c">uint64 <span class="token function">sys_recv</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//</span>    <span class="token comment">// Your code here.</span>    <span class="token comment">//</span>    <span class="token keyword">struct</span> <span class="token class-name">proc</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>    <span class="token keyword">int</span> dport<span class="token punctuation">;</span>    uint64 src<span class="token punctuation">;</span>    uint64 sport<span class="token punctuation">;</span>    uint64 buf<span class="token punctuation">;</span>    <span class="token keyword">int</span> maxlen<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">listener</span> <span class="token operator">*</span>listener <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    p <span class="token operator">=</span> <span class="token function">myproc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">argint</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>dport<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">argaddr</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>src<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">argaddr</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>sport<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">argaddr</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">argint</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>maxlen<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// find listener related to dport</span>    <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>netlock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> MAX_LISTEN_PORTS<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        listener <span class="token operator">=</span> <span class="token operator">&amp;</span>listeners<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>listener<span class="token operator">-></span>used <span class="token operator">&amp;&amp;</span> listener<span class="token operator">-></span>port <span class="token operator">==</span> dport<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        listener <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>listener<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">goto</span> bad<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// return the earliest waiting packet or wait until a packet arrives</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>listener<span class="token operator">-></span>packet_ring<span class="token punctuation">[</span>listener<span class="token operator">-></span>tail<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// extract a packet from the ring</span>            <span class="token keyword">char</span> <span class="token operator">*</span>packet <span class="token operator">=</span> listener<span class="token operator">-></span>packet_ring<span class="token punctuation">[</span>listener<span class="token operator">-></span>tail<span class="token punctuation">]</span><span class="token punctuation">;</span>            listener<span class="token operator">-></span>packet_ring<span class="token punctuation">[</span>listener<span class="token operator">-></span>tail<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            listener<span class="token operator">-></span>tail <span class="token operator">=</span> <span class="token punctuation">(</span>listener<span class="token operator">-></span>tail <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> PACKET_RING_SIZE<span class="token punctuation">;</span>            <span class="token comment">// extract data from the packet</span>            <span class="token keyword">struct</span> <span class="token class-name">ip</span> <span class="token operator">*</span>ip_packet <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ip</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>packet <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">eth</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">struct</span> <span class="token class-name">udp</span> <span class="token operator">*</span>udp_packet <span class="token operator">=</span>                <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">udp</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>packet <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">eth</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ip</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">void</span> <span class="token operator">*</span>payload <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>udp_packet<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">udp</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// re-arrange the bytes</span>            uint32 src_ip <span class="token operator">=</span> <span class="token function">ntohl</span><span class="token punctuation">(</span>ip_packet<span class="token operator">-></span>ip_src<span class="token punctuation">)</span><span class="token punctuation">;</span>            uint16 src_port <span class="token operator">=</span> <span class="token function">ntohs</span><span class="token punctuation">(</span>udp_packet<span class="token operator">-></span>sport<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">copyout</span><span class="token punctuation">(</span>p<span class="token operator">-></span>pagetable<span class="token punctuation">,</span> src<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>src_ip<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>src_ip<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span>                <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">kfree</span><span class="token punctuation">(</span>packet<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">goto</span> bad<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">copyout</span><span class="token punctuation">(</span>p<span class="token operator">-></span>pagetable<span class="token punctuation">,</span> sport<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>src_port<span class="token punctuation">,</span>                        <span class="token keyword">sizeof</span><span class="token punctuation">(</span>src_port<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">kfree</span><span class="token punctuation">(</span>packet<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">goto</span> bad<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// copy at most maxlen bytes of the payload and free the packet</span>            uint16 buflen <span class="token operator">=</span> <span class="token function">ntohs</span><span class="token punctuation">(</span>udp_packet<span class="token operator">-></span>ulen<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">udp</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            uint64 cplen <span class="token operator">=</span> <span class="token punctuation">(</span>buflen <span class="token operator">></span> maxlen<span class="token punctuation">)</span> <span class="token operator">?</span> maxlen <span class="token operator">:</span> buflen<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">copyout</span><span class="token punctuation">(</span>p<span class="token operator">-></span>pagetable<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> payload<span class="token punctuation">,</span> cplen<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">kfree</span><span class="token punctuation">(</span>packet<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">goto</span> bad<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token function">kfree</span><span class="token punctuation">(</span>packet<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>netlock<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> cplen<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// wait until a packet arrives</span>            <span class="token function">sleep</span><span class="token punctuation">(</span>listener<span class="token operator">-></span>packet_ring<span class="token punctuation">,</span> <span class="token operator">&amp;</span>netlock<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">goto</span> bad<span class="token punctuation">;</span>bad<span class="token operator">:</span>    <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>netlock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>bind(int port)</p><p> 进程在调用 recv 前应当先调用 bind 来监听特定端口，bind 被调用时应该要初始化 port 对应的待处理区。</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c">uint64 <span class="token function">sys_bind</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//</span>    <span class="token comment">// Your code here.</span>    <span class="token comment">//</span>    <span class="token keyword">int</span> port<span class="token punctuation">;</span>    <span class="token function">argint</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>port<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>netlock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// return error if repeated binding</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> MAX_LISTEN_PORTS<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>listeners<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>used <span class="token operator">&amp;&amp;</span> listeners<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>port <span class="token operator">==</span> port<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">goto</span> bad<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> MAX_LISTEN_PORTS<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>listeners<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>used<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// use the first unused listener for port</span>            listeners<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>used <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            listeners<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>port <span class="token operator">=</span> port<span class="token punctuation">;</span>            listeners<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>head <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            listeners<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>tail <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>netlock<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">goto</span> bad<span class="token punctuation">;</span>bad<span class="token operator">:</span>    <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>netlock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>ip_rx(char *buf, int len)</p><p> e1000_recv 会把 packet 转发给 net_rx，net_rx 在发现收到的 packet 是 IP packet 时会把 packet 转发给 ip_rx.</p><p> 我们需要检查 destination port 是否在正在被监听，如果未监听或待处理区已满就丢弃包，否则存到待处理区。</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">ip_rx</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// don't delete this printf; make grade depends on it.</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> seen_ip <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>seen_ip <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"ip_rx: received an IP packet\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    seen_ip <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">//</span>    <span class="token comment">// Your code here.</span>    <span class="token comment">//</span>    <span class="token keyword">struct</span> <span class="token class-name">udp</span> <span class="token operator">*</span>udp_packet<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">listener</span> <span class="token operator">*</span>listener <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    udp_packet <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">udp</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>buf <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">eth</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ip</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>netlock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> MAX_LISTEN_PORTS<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        listener <span class="token operator">=</span> <span class="token operator">&amp;</span>listeners<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// try best to save packet in listener related to dport</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>listener<span class="token operator">-></span>used <span class="token operator">&amp;&amp;</span> listener<span class="token operator">-></span>port <span class="token operator">==</span> <span class="token function">ntohs</span><span class="token punctuation">(</span>udp_packet<span class="token operator">-></span>dport<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> head <span class="token operator">=</span> listener<span class="token operator">-></span>head<span class="token punctuation">;</span>            <span class="token comment">// if ring is full, drop the incoming packet</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>listener<span class="token operator">-></span>packet_ring<span class="token punctuation">[</span>head<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">kfree</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>netlock<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// save packet in listener</span>            listener<span class="token operator">-></span>packet_ring<span class="token punctuation">[</span>head<span class="token punctuation">]</span> <span class="token operator">=</span> buf<span class="token punctuation">;</span>            listener<span class="token operator">-></span>head <span class="token operator">=</span> <span class="token punctuation">(</span>head <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> PACKET_RING_SIZE<span class="token punctuation">;</span>            <span class="token function">wakeup</span><span class="token punctuation">(</span>listener<span class="token operator">-></span>packet_ring<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>netlock<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">kfree</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>netlock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p>然后我们就下班了！</p><h1 id="杂七杂八小知识"><a href="#杂七杂八小知识" class="headerlink" title="杂七杂八小知识"></a>杂七杂八小知识</h1><h2 id="所有权转移"><a href="#所有权转移" class="headerlink" title="所有权转移"></a>所有权转移</h2><p>看一眼 e1000_recv 的代码，我们会发现它调用了 kalloc，却没有在内部显式释放新建的内存，这是内存泄漏吗？</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">e1000_recv</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//</span>    <span class="token comment">// Your code here.</span>    <span class="token comment">//</span>    <span class="token comment">// Check for packets that have arrived from the e1000</span>    <span class="token comment">// Create and deliver a buf for each packet (using net_rx()).</span>    <span class="token comment">//</span>    <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>e1000_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    uint32 idx <span class="token operator">=</span> <span class="token punctuation">(</span>regs<span class="token punctuation">[</span>E1000_RDT<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> RX_RING_SIZE<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>rx_ring<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">.</span>status <span class="token operator">&amp;</span> E1000_RXD_STAT_DD<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">char</span> <span class="token operator">*</span>recv_buf <span class="token operator">=</span> rx_bufs<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 在这里取出</span>        <span class="token keyword">int</span> buflen <span class="token operator">=</span> rx_ring<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>        rx_bufs<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">kalloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 在这里分配新内存</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>rx_bufs<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"e1000"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        rx_ring<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">.</span>addr <span class="token operator">=</span> <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>rx_bufs<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">;</span>        rx_ring<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">.</span>status <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        idx <span class="token operator">=</span> <span class="token punctuation">(</span>idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> RX_RING_SIZE<span class="token punctuation">;</span>        <span class="token comment">// net_rx could call e1000_transmit, so release lock before calling it</span>        <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>e1000_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">net_rx</span><span class="token punctuation">(</span>recv_buf<span class="token punctuation">,</span> buflen<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 在这里转移所有权</span>        <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>e1000_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// set RDT to the last processed index</span>    regs<span class="token punctuation">[</span>E1000_RDT<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>idx <span class="token operator">+</span> RX_RING_SIZE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> RX_RING_SIZE<span class="token punctuation">;</span>    <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>e1000_lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这并不是内存泄漏，而是一种所有权转移。对每个新建的 <code>rx_bufs[idx] = kalloc()</code>，我们都会在未来通过 <code>recv_buf = rx_bufs[idx]</code> 把它取出，并把其所有权通过 <code>net_rx(recv_buf, buflen)</code> 转移给 <code>net_rx</code>. 也就是说，<code>net_rx</code> 负责释放传入的 buf.</p><p>而 <code>net_rx</code> 也可能把 buf 的所有权转移给 <code>app_rx</code> 或 <code>ip_rx</code>.</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">net_rx</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">eth</span> <span class="token operator">*</span>eth <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">eth</span> <span class="token operator">*</span><span class="token punctuation">)</span>buf<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">>=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">eth</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">arp</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>        <span class="token function">ntohs</span><span class="token punctuation">(</span>eth<span class="token operator">-></span>type<span class="token punctuation">)</span> <span class="token operator">==</span> ETHTYPE_ARP<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">arp_rx</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">>=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">eth</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ip</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>               <span class="token function">ntohs</span><span class="token punctuation">(</span>eth<span class="token operator">-></span>type<span class="token punctuation">)</span> <span class="token operator">==</span> ETHTYPE_IP<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">ip_rx</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token function">kfree</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这和 C++ 里的 move 语义类似，都是“转移所有权”。</p><h2 id="什么是-attribute-packed"><a href="#什么是-attribute-packed" class="headerlink" title="什么是 attribute((packed))"></a>什么是 <strong>attribute((packed))</strong></h2><p>net.h 里有 packet header 的定义，这里 struct eth 里的 <code>__attribute((packed))__</code> 是在告知编译器取消内存对齐优化，让结构体成员紧凑排列。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">eth</span> <span class="token punctuation">&#123;</span>    uint8 dhost<span class="token punctuation">[</span>ETHADDR_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span>    uint8 shost<span class="token punctuation">[</span>ETHADDR_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span>    uint16 type<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span>packed<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还记得对齐优化是什么吗？为了提高 CPU 访问内存的效率，结构体中的每个成员的起始地址相对于结构体起始地址的偏移量需要是该成员自身大小的整数倍。如果不是，编译器会在前一个成员后面填充一些空白字节。</p><p>比如对下面的结构体，sizeof(struct Test) 是 12 字节，而不是成员大小之和的 1 + 4 + 1 = 6 字节。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">Test</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> c1<span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">char</span> c2<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="文末吐槽"><a href="#文末吐槽" class="headerlink" title="文末吐槽"></a>文末吐槽</h1><p>Lab Net 经历了不少变迁，在 2019 和 2020 年它还是课程的最后一个 lab，而从 2021 年开始它就被移到了课程中期，而网络 lec 则一直在课程后期，所以就造成了 lab 和 lec 的错位。</p><p><a href="https://pdos.csail.mit.edu/6.828/2023/labs/net.html">2023 年版本的 Net Lab</a> 只要求实现 Part One 而且标注的难度还是 hard，2024 年就变成了 moderate 还新加了一个 Part Two，果然课程难度也是会通货膨胀的🫠🫠</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这个 lab 分两个部分，第一部分是补全 E1000 网卡驱动的数据包收发相关代码，第二部分是添加代码完成 UDP 包的接收。在开始之前，我们应该先去把讲网络的 lecture 看掉，因为里面涉及了很多相关内容。你可能会疑惑为什么课程把 lab 安排在 lec 前面，我在本</summary>
      
    
    
    
    <category term="公开课" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"/>
    
    <category term="MIT-6.S081" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/MIT-6-S081/"/>
    
    <category term="Labs" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/MIT-6-S081/Labs/"/>
    
    
  </entry>
  
  <entry>
    <title>透过望远镜给月亮拍照</title>
    <link href="http://rinevard.github.io/wiki/others/thoughts/moon/"/>
    <id>http://rinevard.github.io/wiki/others/thoughts/moon/</id>
    <published>2025-11-05T14:10:15.000Z</published>
    <updated>2025-11-05T15:01:12.376Z</updated>
    
    <content type="html"><![CDATA[<p>今天拿出了我耗费 200 元巨资买的森林人望远镜试着看月亮！</p><p><img src="/images/others/random_thoughts/moon/telescope.jpg" alt="7x50"></p><p>在拿起望远镜看向月亮之前真的很难想象，一个两百元的望远镜就能让我看清月海、月陆、第谷环形山。不过如果我只是在这里高谈阔论的话，读者（这篇文章真的存在读者吗）一定感受不到这种奇妙的体验的，那我就上图吧！</p><p><img src="/images/others/random_thoughts/moon/square_moon.png" alt="月亮"></p><p>我们会注意到它是黑一块白一块的。黑的就是月海，它们是古代火山喷发后玄武岩形成的平原，玄武岩颜色较深，反射阳光的能力弱，所以看起来是暗灰色的。而白的则是月陆，主要由一种叫做斜长岩的浅色岩石构成，看起来更明亮。</p><p>而图片五点半方向上的那个辐射状的东西就是第谷坑！（看起来有点像星际拓荒的宇宙之眼呢）</p><p>不过这是 PS 调整后的图，主要是拉高了曝光、拉低了高光、拉高了纹理和清晰度，下面是直接拍出来的图（当然不是原图，原图 20mb 感觉放这里就太大了）：</p><p><img src="/images/others/random_thoughts/moon/moon_origin.jpg" alt="月亮典藏版"></p><p>接下来看看我是怎么拍出来的吧！直接拿着手机对着望远镜拍只能拍出来一个小光球，正确的做法是调到专业模式然后调整参数，我的K80至尊版有这些参数可调：</p><ol><li>S - 快门速度（Shutter Speed）</li><li>ISO - 感光度</li><li>WB - 白平衡</li><li>F - 对焦（Focus）</li></ol><p>直接拍只能拍出小光球是因为手机拍照默认是自动模式，自动模式看到整个画面都是黑色的（众所周知夜空是黑的）就会努力调节自动曝光，最后导致过曝。</p><p>为了避免过曝，我们要在专业模式里把 S 提高、ISO 降低。总之我最后的参数设置是这样的：S: 1/160, ISO: 100, WB: 没调, F: 拉到最右边。然后就能愉快地拍照了！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天拿出了我耗费 200 元巨资买的森林人望远镜试着看月亮！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/others/random_thoughts/moon/telescope.jpg&quot; alt=&quot;7x50&quot;&gt;&lt;/p&gt;
&lt;p&gt;在拿起望远镜看向月亮之前真的很难想象，</summary>
      
    
    
    
    <category term="杂谈" scheme="http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    <category term="碎碎念" scheme="http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
  </entry>
  
  <entry>
    <title>Lab 5 Copy-on-Write Fork</title>
    <link href="http://rinevard.github.io/wiki/learning/open-course/MIT-6.S081/Labs/lab5-cow/"/>
    <id>http://rinevard.github.io/wiki/learning/open-course/MIT-6.S081/Labs/lab5-cow/</id>
    <published>2025-11-03T13:56:22.000Z</published>
    <updated>2025-11-03T13:57:01.187Z</updated>
    
    <content type="html"><![CDATA[<p>这个 Lab 要求我们实现 cow fork，这是一个常见的节省内存的手段。</p><p>总而言之，就是在 fork 时把父子的虚拟内存都映射到原本的父进程的物理内存上，并将其设为“仅读”。当有进程尝试写它会触发 page fault，这时我们才新建物理页，然后调整尝试写的进程的页表，将对应虚拟页映射到新建的物理页上。</p><p>这个 Lab 似乎没有太 tricky 的地方，接下来我会自问自答一下，只要能把这里的答案想明白基本就能写对代码了：</p><ol><li><p>怎么让只读页正确只读，而不能被写？</p><p> 我们通过给 PTE 设置一个 COW 位来判断是否是只读. COW 为 1 表示这个 PTE 原本应该是可写的，但现在被临时标记为只读，因为对应的物理页正在被多个进程共享。</p></li><li><p>什么时候新建物理页？我们会不会多建了不必要的物理页？</p><p> 我们维护对每个物理页的引用计数，当引用计数为 1 时就把 COW 重设为 0（因为这个物理页不再被多个进程共享），把 W 位重新设为 1.</p></li><li><p>什么时候释放物理页？</p><p> 调用 kfree 时，如果引用计数大于 1，将引用计数 -1 然后不动；如果引用计数 == 1，释放物理页。</p></li></ol><p>然后就上代码吧。</p><h1 id="物理内存层的基建代码"><a href="#物理内存层的基建代码" class="headerlink" title="物理内存层的基建代码"></a>物理内存层的基建代码</h1><p>首先在 kalloc.c 里新建一个数据结构：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">spinlock</span> lock<span class="token punctuation">;</span>    <span class="token keyword">int</span> refcnt<span class="token punctuation">[</span>PHYSTOP <span class="token operator">/</span> PGSIZE<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> kref<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这里有锁是因为我们不希望多个进程同时读写 refcnt. 我们要在 kinit 里初始化锁：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">kinit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">initlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kmem<span class="token punctuation">.</span>lock<span class="token punctuation">,</span> <span class="token string">"kmem"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">initlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kref<span class="token punctuation">.</span>lock<span class="token punctuation">,</span> <span class="token string">"kref"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">freerange</span><span class="token punctuation">(</span>end<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>PHYSTOP<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后我们提供三个接口：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">kaddref</span><span class="token punctuation">(</span>uint64 pa<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kref<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    kref<span class="token punctuation">.</span>refcnt<span class="token punctuation">[</span>pa <span class="token operator">/</span> PGSIZE<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kref<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">kdecref</span><span class="token punctuation">(</span>uint64 pa<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kref<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>kref<span class="token punctuation">.</span>refcnt<span class="token punctuation">[</span>pa <span class="token operator">/</span> PGSIZE<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        kref<span class="token punctuation">.</span>refcnt<span class="token punctuation">[</span>pa <span class="token operator">/</span> PGSIZE<span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kref<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">kgetref</span><span class="token punctuation">(</span>uint64 pa<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> ref<span class="token punctuation">;</span>    <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kref<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    ref <span class="token operator">=</span> kref<span class="token punctuation">.</span>refcnt<span class="token punctuation">[</span>pa <span class="token operator">/</span> PGSIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kref<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> ref<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>之后就能修改 kfree 和 kalloc 了，这里我提供的 kfree 是有并发风险的，具体可以看注释：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">kfree</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>pa<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">run</span> <span class="token operator">*</span>r<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>pa <span class="token operator">%</span> PGSIZE<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>pa <span class="token operator">&lt;</span> end <span class="token operator">||</span> <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>pa <span class="token operator">>=</span> PHYSTOP<span class="token punctuation">)</span>        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"kfree"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 这里有潜在的并发风险, 如果多个共享了物理页的进程同时 kfree 这个物理页,</span>    <span class="token comment">// 那么 if (kgetref((uint64)pa) == 0) 下的语句就有可能被多个进程进入.</span>    <span class="token comment">// 想修正也不难, 不调用函数而是手动请求锁, 在和 refcnt 交互完后释放锁就行.</span>    <span class="token comment">// 不过介于测试代码已经过了, 我们就不改动了</span>    <span class="token function">kdecref</span><span class="token punctuation">(</span><span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>pa<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Free physical memory only when no other reference exists</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">kgetref</span><span class="token punctuation">(</span><span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>pa<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// Fill with junk to catch dangling refs.</span>        <span class="token function">memset</span><span class="token punctuation">(</span>pa<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> PGSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>        r <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">run</span> <span class="token operator">*</span><span class="token punctuation">)</span>pa<span class="token punctuation">;</span>        <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kmem<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>        r<span class="token operator">-></span>next <span class="token operator">=</span> kmem<span class="token punctuation">.</span>freelist<span class="token punctuation">;</span>        kmem<span class="token punctuation">.</span>freelist <span class="token operator">=</span> r<span class="token punctuation">;</span>        <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kmem<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">kalloc</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">run</span> <span class="token operator">*</span>r<span class="token punctuation">;</span>    <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kmem<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    r <span class="token operator">=</span> kmem<span class="token punctuation">.</span>freelist<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>r<span class="token punctuation">)</span>        kmem<span class="token punctuation">.</span>freelist <span class="token operator">=</span> r<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kmem<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>r<span class="token punctuation">)</span>        <span class="token function">kaddref</span><span class="token punctuation">(</span><span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>r<span class="token punctuation">)</span>        <span class="token function">memset</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>r<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> PGSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// fill with junk</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>r<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="COW-策略实现"><a href="#COW-策略实现" class="headerlink" title="COW 策略实现"></a>COW 策略实现</h1><p>然后我们看向 trap.c，在 usertrap 里加入页错误的分支：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">r_scause</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// ...</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>which_dev <span class="token operator">=</span> <span class="token function">devintr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// ...</span><span class="token punctuation">&#125;</span> <span class="token comment">// 这里是加入的分支</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">r_scause</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">15</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">writefault</span><span class="token punctuation">(</span>p<span class="token operator">-></span>pagetable<span class="token punctuation">,</span> <span class="token function">r_stval</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// copy on write</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// ...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着我们到 vm.c 里实现 writefault：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// return 0 if error, and physical address if successful.</span>uint64 <span class="token function">writefault</span><span class="token punctuation">(</span><span class="token class-name">pagetable_t</span> pagetable<span class="token punctuation">,</span> uint64 va<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">pte_t</span> <span class="token operator">*</span>pte<span class="token punctuation">;</span>    uint64 pa<span class="token punctuation">;</span>    uint flags<span class="token punctuation">;</span>    <span class="token keyword">int</span> refcnt<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">proc</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token function">myproc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>va <span class="token operator">>=</span> p<span class="token operator">-></span>sz<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    va <span class="token operator">=</span> <span class="token function">PGROUNDDOWN</span><span class="token punctuation">(</span>va<span class="token punctuation">)</span><span class="token punctuation">;</span>    pte <span class="token operator">=</span> <span class="token function">walk</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> va<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pte <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    flags <span class="token operator">=</span> <span class="token function">PTE_FLAGS</span><span class="token punctuation">(</span><span class="token operator">*</span>pte<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> PTE_COW<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// read-only page</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    pa <span class="token operator">=</span> <span class="token function">PTE2PA</span><span class="token punctuation">(</span><span class="token operator">*</span>pte<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>refcnt <span class="token operator">=</span> <span class="token function">kgetref</span><span class="token punctuation">(</span>pa<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// no process ref this page</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>refcnt <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// only one process ref this page, change it to a regular writeable page</span>        <span class="token operator">*</span>pte <span class="token operator">&amp;=</span> <span class="token punctuation">(</span><span class="token operator">~</span>PTE_COW<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">*</span>pte <span class="token operator">|=</span> <span class="token punctuation">(</span>PTE_W<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> pa<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// copy on write</span>        <span class="token keyword">char</span> <span class="token operator">*</span>mem<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>mem <span class="token operator">=</span> <span class="token function">kalloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">memmove</span><span class="token punctuation">(</span>mem<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>pa<span class="token punctuation">,</span> PGSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">*</span>pte <span class="token operator">&amp;=</span> <span class="token punctuation">(</span><span class="token operator">~</span>PTE_V<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// make mappages work</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">mappages</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> va<span class="token punctuation">,</span> PGSIZE<span class="token punctuation">,</span> <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>mem<span class="token punctuation">,</span> flags<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">kfree</span><span class="token punctuation">(</span>mem<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token operator">*</span>pte <span class="token operator">&amp;=</span> <span class="token punctuation">(</span><span class="token operator">~</span>PTE_COW<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">*</span>pte <span class="token operator">|=</span> <span class="token punctuation">(</span>PTE_W<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">kdecref</span><span class="token punctuation">(</span>pa<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> pa<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后在 uvmcopy 里加入把多个虚拟内存映射到相同物理内存的机制：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">uvmcopy</span><span class="token punctuation">(</span><span class="token class-name">pagetable_t</span> old<span class="token punctuation">,</span> <span class="token class-name">pagetable_t</span> new<span class="token punctuation">,</span> uint64 sz<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">pte_t</span> <span class="token operator">*</span>pte<span class="token punctuation">;</span>    uint64 pa<span class="token punctuation">,</span> i<span class="token punctuation">;</span>    uint flags<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> sz<span class="token punctuation">;</span> i <span class="token operator">+=</span> PGSIZE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pte <span class="token operator">=</span> <span class="token function">walk</span><span class="token punctuation">(</span>old<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"uvmcopy: pte should exist"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>pte <span class="token operator">&amp;</span> PTE_V<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"uvmcopy: page not present"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        pa <span class="token operator">=</span> <span class="token function">PTE2PA</span><span class="token punctuation">(</span><span class="token operator">*</span>pte<span class="token punctuation">)</span><span class="token punctuation">;</span>        flags <span class="token operator">=</span> <span class="token function">PTE_FLAGS</span><span class="token punctuation">(</span><span class="token operator">*</span>pte<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">mappages</span><span class="token punctuation">(</span>new<span class="token punctuation">,</span> i<span class="token punctuation">,</span> PGSIZE<span class="token punctuation">,</span> <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>pa<span class="token punctuation">,</span> flags<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">goto</span> err<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> PTE_W<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">pte_t</span> <span class="token operator">*</span>new_pte <span class="token operator">=</span> <span class="token function">walk</span><span class="token punctuation">(</span>new<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">*</span>pte <span class="token operator">&amp;=</span> <span class="token punctuation">(</span><span class="token operator">~</span>PTE_W<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">*</span>new_pte <span class="token operator">&amp;=</span> <span class="token punctuation">(</span><span class="token operator">~</span>PTE_W<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">*</span>pte <span class="token operator">|=</span> <span class="token punctuation">(</span>PTE_COW<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">*</span>new_pte <span class="token operator">|=</span> <span class="token punctuation">(</span>PTE_COW<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">kaddref</span><span class="token punctuation">(</span>pa<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>err<span class="token operator">:</span>    <span class="token function">uvmunmap</span><span class="token punctuation">(</span>new<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> i <span class="token operator">/</span> PGSIZE<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后改改 copyout 就可以下班了：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">copyout</span><span class="token punctuation">(</span><span class="token class-name">pagetable_t</span> pagetable<span class="token punctuation">,</span> uint64 dstva<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>src<span class="token punctuation">,</span> uint64 len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    uint64 n<span class="token punctuation">,</span> va0<span class="token punctuation">,</span> pa0<span class="token punctuation">;</span>    <span class="token class-name">pte_t</span> <span class="token operator">*</span>pte<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>len <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        va0 <span class="token operator">=</span> <span class="token function">PGROUNDDOWN</span><span class="token punctuation">(</span>dstva<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>va0 <span class="token operator">>=</span> MAXVA<span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        pte <span class="token operator">=</span> <span class="token function">walk</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> va0<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pte <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token operator">*</span>pte <span class="token operator">&amp;</span> PTE_V<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token operator">*</span>pte <span class="token operator">&amp;</span> PTE_U<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>pte <span class="token operator">&amp;</span> PTE_W<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>pte <span class="token operator">&amp;</span> PTE_COW<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">writefault</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> va0<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// copy on write</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        pa0 <span class="token operator">=</span> <span class="token function">PTE2PA</span><span class="token punctuation">(</span><span class="token operator">*</span>pte<span class="token punctuation">)</span><span class="token punctuation">;</span>        n <span class="token operator">=</span> PGSIZE <span class="token operator">-</span> <span class="token punctuation">(</span>dstva <span class="token operator">-</span> va0<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">></span> len<span class="token punctuation">)</span>            n <span class="token operator">=</span> len<span class="token punctuation">;</span>        <span class="token function">memmove</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>pa0 <span class="token operator">+</span> <span class="token punctuation">(</span>dstva <span class="token operator">-</span> va0<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> src<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>        len <span class="token operator">-=</span> n<span class="token punctuation">;</span>        src <span class="token operator">+=</span> n<span class="token punctuation">;</span>        dstva <span class="token operator">=</span> va0 <span class="token operator">+</span> PGSIZE<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>等等，先别急着下班，copyout 是做什么的？为什么它看起来独树一帜，要我们手动调用处理写故障的函数，而不是自动触发写故障然后自动被处理？</p><p>看看代码可以发现，它没有通过用户页表来“写”内存，而是通过用户页表拿到物理地址，再通过内核页表写内存。在这里，硬件只检查内核页表的权限，而不检查用户页表 PTE 的 PTE_W/COW，因此自然不会触发写故障。</p><p>总之就下班了，然后放张图图吧</p><p><img src="/images/learning/open-course/MIT-6.S081/labs/lab5-cow/wtf_i_just_want_video_game.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这个 Lab 要求我们实现 cow fork，这是一个常见的节省内存的手段。&lt;/p&gt;
&lt;p&gt;总而言之，就是在 fork 时把父子的虚拟内存都映射到原本的父进程的物理内存上，并将其设为“仅读”。当有进程尝试写它会触发 page fault，这时我们才新建物理页，然后调整尝试写</summary>
      
    
    
    
    <category term="公开课" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"/>
    
    <category term="MIT-6.S081" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/MIT-6-S081/"/>
    
    <category term="Labs" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/MIT-6-S081/Labs/"/>
    
    
  </entry>
  
  <entry>
    <title>Lab 4 Traps</title>
    <link href="http://rinevard.github.io/wiki/learning/open-course/MIT-6.S081/Labs/lab4-traps/"/>
    <id>http://rinevard.github.io/wiki/learning/open-course/MIT-6.S081/Labs/lab4-traps/</id>
    <published>2025-10-30T14:28:22.000Z</published>
    <updated>2025-10-30T14:38:20.127Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RISC-V-assembly"><a href="#RISC-V-assembly" class="headerlink" title="RISC-V assembly"></a><strong>RISC-V assembly</strong></h1><p>在 lab 开始时，我们要简单回答一些问题。这里只简单聊聊最后两道：</p><ol><li><p>下面的代码会打印什么？</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">unsigned</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0x00646c72</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"H%x Wo%s"</span><span class="token punctuation">,</span> <span class="token number">57616</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p> 57616 转换到十六进制是 E110，所以空格前打印的是 HE110.</p><p> RISC-V 使用小端法，所以 <code>i</code> 在内存中的存储是 <code>72 6c 64 00</code>，所以空格后打印的是 rld.</p><p> 总之我们打印了 HE110, World!（以后咱就用这个去水贴</p></li><li><p>下面的代码在 “y=” 后会打印什么？</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"x=%d y=%d"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 我们没有传入第三个参数，所以我们会把寄存器 a2 里的东西当作 int 来打印。</p></li></ol><h1 id="Backtrace"><a href="#Backtrace" class="headerlink" title="Backtrace"></a>Backtrace</h1><p>这里要求我们实现一个 backtrace 函数，打印出当前调用栈。</p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>我们先来回顾一下 xv6 的栈结构：</p><pre class="line-numbers language-none"><code class="language-none">                 .                 .    +-&gt;          .    |   +-----------------+   |    |   | return address  |   |    |   |   previous fp ------+    |   | saved registers |    |   | local variables |    |   |       ...       | &lt;-+    |   +-----------------+   |    |   | return address  |   |    +------ previous fp   |   |        | saved registers |   |        | local variables |   |    +-&gt; |       ...       |   |    |   +-----------------+   |    |   | return address  |   |    |   |   previous fp ------+    |   | saved registers |    |   | local variables |    |   |       ...       | &lt;-+    |   +-----------------+   |    |   | return address  |   |    +------ previous fp   |   |        | saved registers |   |        | local variables |   |$fp --&gt; |       ...       |   |        +-----------------+   |        | return address  |   |        |   previous fp ------+        | saved registers |$sp --&gt; | local variables |        +-----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以概括算法流程如下：</p><ol><li>找到当前 stack frame 的 fp，这在初始化时就是找到寄存器 s0 里存储的指针。</li><li>找到当前 stack frame 的 previous fp，判断 previous fp 和当前 fp 是否在一个 page 内<ol><li>如果在，用 %p 打印这个 frame 存储的跳转值，然后继续循环</li><li>如果不在就结束循环</li></ol></li></ol><p>总之代码如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">backtrace</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    uint64 fp <span class="token operator">=</span> <span class="token function">r_fp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"backtrace:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>uint64 cur_fp <span class="token operator">=</span> fp<span class="token punctuation">;</span> <span class="token function">PGROUNDDOWN</span><span class="token punctuation">(</span>cur_fp<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">PGROUNDDOWN</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>         cur_fp <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>uint64 <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>cur_fp <span class="token operator">-</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        uint64 ret_addr <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>uint64 <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>cur_fp <span class="token operator">-</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>ret_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="和-CSAPP-介绍的栈结构的对比"><a href="#和-CSAPP-介绍的栈结构的对比" class="headerlink" title="和 CSAPP 介绍的栈结构的对比"></a>和 CSAPP 介绍的栈结构的对比</h2><p>我们会注意到 xv6 的栈结构和 CSAPP 里介绍的略有差异，主要是 CSAPP 的栈帧不包含 <code>previous fp</code>。下面的是 CSAPP 介绍的栈结构</p><pre class="line-numbers language-none"><code class="language-none">高地址            |  参数7                |            |  参数8                |            |  ...                 |  ← 调用前push            |  返回地址             |  ← call指令自动push            |  保存的寄存器值        |  ← 刚进入函数时push            |  本地变量1            |            |  本地变量2            |            |  ...                 |   ← 当前rsp指向这里低地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面我们来编译 CSAPP 书中的一段代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">long</span> <span class="token function">caller</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">long</span> arg1 <span class="token operator">=</span> <span class="token number">534</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> arg2 <span class="token operator">=</span> <span class="token number">1057</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> sum <span class="token operator">=</span> <span class="token function">swap_add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arg1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>arg2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> diff <span class="token operator">=</span> arg1 <span class="token operator">-</span> arg2<span class="token punctuation">;</span>    <span class="token keyword">return</span> sum <span class="token operator">*</span> diff<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里是 CSAPP 书上给出的编译结果：</p><pre class="line-numbers language-nasm" data-language="nasm"><code class="language-nasm"><span class="token label function">caller:</span>    subq    <span class="token number">$16</span>, <span class="token operator">%</span><span class="token register variable">rsp</span>       <span class="token comment">; Allocate 16 bytes for stack frame</span>    movq    <span class="token number">$534</span>, (<span class="token operator">%</span><span class="token register variable">rsp</span>)    <span class="token comment">; Store 534 in arg1</span>    movq    <span class="token number">$1057</span>, <span class="token number">8</span>(<span class="token operator">%</span><span class="token register variable">rsp</span>)  <span class="token comment">; Store 1057 in arg2</span>    leaq    <span class="token number">8</span>(<span class="token operator">%</span><span class="token register variable">rsp</span>), <span class="token operator">%</span><span class="token register variable">rsi</span>   <span class="token comment">; Compute &amp;arg2 as second argument</span>    movq    <span class="token operator">%</span><span class="token register variable">rsp</span>, <span class="token operator">%</span><span class="token register variable">rdi</span>      <span class="token comment">; Compute &amp;arg1 as first argument</span>    call    swap_add        <span class="token comment">; Call swap_add(&amp;arg1, &amp;arg2)</span>    movq    (<span class="token operator">%</span><span class="token register variable">rsp</span>), <span class="token operator">%</span><span class="token register variable">rdx</span>    <span class="token comment">; Get arg1</span>    subq    <span class="token number">8</span>(<span class="token operator">%</span><span class="token register variable">rsp</span>), <span class="token operator">%</span><span class="token register variable">rdx</span>   <span class="token comment">; Compute diff = arg1 - arg2</span>    imulq   <span class="token operator">%</span><span class="token register variable">rdx</span>, <span class="token operator">%</span><span class="token register variable">rax</span>      <span class="token comment">; Compute sum * diff</span>    addq    <span class="token number">$16</span>, <span class="token operator">%</span><span class="token register variable">rsp</span>       <span class="token comment">; Deallocate stack frame</span>    ret                     <span class="token comment">; Return</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里则是在 xv6 里得到的编译结果：</p><pre class="line-numbers language-none"><code class="language-none">0000000000000034 &lt;caller&gt;:long caller()  34:1141                addisp,sp,-16  36:e422                sds0,8(sp)  38:0800                addis0,sp,16  3a:000cb537            luia0,0xcb  3e:25d50513            addia0,a0,605 # cb25d &lt;base+0xca24d&gt;  42:6422                lds0,8(sp)  44:0141                addisp,sp,16  46:8082                ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以注意到 CSAPP 只是把局部变量 arg1 和 arg2 存储在了栈中，而 xv6 的 <code>sd s0,8(sp)</code> 把调用者的栈帧指针压入了栈中。</p><p>产生这种差异的原因是编译器的优化，CSAPP 里的编译器认为通过 <code>subq $16, %rsp</code> 和 <code>addq $16, %rsp</code> 就能完成这个函数的工作，所以没有存储栈帧指针；xv6 则为了方便教学，包含了栈帧指针。</p><h1 id="Alarm"><a href="#Alarm" class="headerlink" title="Alarm"></a>Alarm</h1><p>这里我们要实现一个叫做 <code>sigalarm(interval, handler)</code> 的系统调用，它会每隔 interval 个 ticks 调用一次 handler. </p><p>每个 tick 都会产生一个中断，我们要做的就是每中断若干次调用一下 handler.</p><p>我们还需要实现 <code>sigreturn</code>，它是一个辅助 <code>sigalarm</code> 正确工作的系统调用。我们有这样的 promise——用户在调用 <code>sigalram</code> 时提供的 handler 函数必须在结尾调用 <code>sigreturn</code>。总之，<code>sigreturn</code> 的工作主要是把用户进程状态恢复到被中断时的状态。</p><h2 id="开工！"><a href="#开工！" class="headerlink" title="开工！"></a>开工！</h2><p>我们可以按下面的流程完成任务：</p><ol><li><p>在开始之前：</p><p> 在 <code>usys.pl</code> 等地方做一些基建来把两个系统调用加入到系统里</p></li><li><p>每隔若干 ticks 调用一次 handler：</p><p> 在 <code>proc.h</code> 里加入存储 interval、handler 以及距离上一次调用 handler 过去的 ticks 的字段</p><p> 在 <code>sysproc.c</code> 里实现 <code>sys_sigalarm</code>，它记录并存储用户传进来的 interval 和 handler</p><p> 在 <code>trap.c</code> 的 <code>usertrap</code> 里加入对 handler 的调用。还记得吗，当执行 SERT 时，程序计数器 pc 被设置为存储在 sepc 寄存器中的值，所以我们要修改 <code>p-&gt;trapframe-&gt;epc</code>.</p></li><li><p>把用户进程状态恢复到被中断时的状态：</p><p> 我们需要保存的是用户中断时的 <code>struct trapframe</code>. 所以我们需要在 proc.h 里新增 <code>struct trapframe alarm_tf</code> 字段，在 handler 被调用时把 p-&gt;trapframe 复制到 alarm_tf，并在 <code>sys_sigreturn</code> 被调用时把 alarm_tf 复制回 p-&gt;trapframe.</p></li></ol><p>我们就直接放最终代码了。</p><p>首先在 proc.h 的 struct proc 里新增这些字段：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> alarm_freq<span class="token punctuation">;</span>              <span class="token comment">// How many ticks to call alarm_handler once</span>uint64 alarm_handler<span class="token punctuation">;</span>        <span class="token comment">// Handler's user virtual address</span><span class="token keyword">int</span> tick_from_last<span class="token punctuation">;</span>          <span class="token comment">// How many ticks have passed since the last call</span><span class="token keyword">int</span> is_alarming<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">trapframe</span> alarm_tf<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后在 sys_proc.c 里把用户传入的 interval 和 handler 保存下来，并初始化一些和调用 handler 相关的变量：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">uint64 <span class="token function">sys_sigalarm</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> ticks<span class="token punctuation">;</span>    uint64 handler<span class="token punctuation">;</span>    <span class="token function">argint</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ticks<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">argaddr</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>handler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">myproc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span>alarm_freq <span class="token operator">=</span> ticks<span class="token punctuation">;</span>    <span class="token function">myproc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span>alarm_handler <span class="token operator">=</span> handler<span class="token punctuation">;</span>    <span class="token function">myproc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span>tick_from_last <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">myproc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span>is_alarming <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>之后修改 trap.c 完成对 handler 的调用以及对用户进程状态的保存：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>which_dev <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">-></span>alarm_freq <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>p<span class="token operator">-></span>is_alarming <span class="token operator">&amp;&amp;</span> p<span class="token operator">-></span>tick_from_last <span class="token operator">>=</span> p<span class="token operator">-></span>alarm_freq <span class="token operator">&amp;&amp;</span>            p<span class="token operator">-></span>tick_from_last <span class="token operator">%</span> p<span class="token operator">-></span>alarm_freq <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            p<span class="token operator">-></span>is_alarming <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token function">memmove</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token operator">-></span>alarm_tf<span class="token punctuation">,</span> p<span class="token operator">-></span>trapframe<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token operator">-></span>trapframe<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            p<span class="token operator">-></span>trapframe<span class="token operator">-></span>epc <span class="token operator">=</span> p<span class="token operator">-></span>alarm_handler<span class="token punctuation">;</span>            p<span class="token operator">-></span>tick_from_last <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            p<span class="token operator">-></span>tick_from_last <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后在返回时重置用户进程状态：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">uint64 <span class="token function">sys_sigreturn</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">proc</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token function">myproc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memmove</span><span class="token punctuation">(</span>p<span class="token operator">-></span>trapframe<span class="token punctuation">,</span> <span class="token operator">&amp;</span>p<span class="token operator">-></span>alarm_tf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token operator">-></span>trapframe<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    p<span class="token operator">-></span>is_alarming <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> p<span class="token operator">-></span>alarm_tf<span class="token punctuation">.</span>a0<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="一些小想法"><a href="#一些小想法" class="headerlink" title="一些小想法"></a>一些小想法</h2><p>为什么说“Prevent re-entrant calls to the handler——if a handler hasn’t returned yet, the kernel shouldn’t call it again. test2 tests this.”，即不能在上次对 handler 的调用完成前进行下次调用？我猜是因为我们会保存调用前的用户进程状态，而在上次 handler 完成前再次调用 handler 就会保存上次 handler 正在执行时的用户进程状态，这会覆盖最开始的用户进程状态。</p><p>再说句题外话，感觉 Page Tables 的 hard 的难度比这个难不少……果然 All hards are hard, but some hards are harder than others🫠🫠</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;RISC-V-assembly&quot;&gt;&lt;a href=&quot;#RISC-V-assembly&quot; class=&quot;headerlink&quot; title=&quot;RISC-V assembly&quot;&gt;&lt;/a&gt;&lt;strong&gt;RISC-V assembly&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;在</summary>
      
    
    
    
    <category term="公开课" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"/>
    
    <category term="MIT-6.S081" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/MIT-6-S081/"/>
    
    <category term="Labs" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/MIT-6-S081/Labs/"/>
    
    
  </entry>
  
  <entry>
    <title>Lab 3 Page Tables</title>
    <link href="http://rinevard.github.io/wiki/learning/open-course/MIT-6.S081/Labs/lab3-pagetable/"/>
    <id>http://rinevard.github.io/wiki/learning/open-course/MIT-6.S081/Labs/lab3-pagetable/</id>
    <published>2025-10-28T08:28:22.000Z</published>
    <updated>2025-10-28T08:29:01.912Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Inspect-a-user-process-page-table"><a href="#Inspect-a-user-process-page-table" class="headerlink" title="Inspect a user-process page table"></a><strong>Inspect a user-process page table</strong></h1><p>这道题让我们解释一下 <code>print_pgtbl</code> 的打印结果，首先让我们来看看它打印了什么：</p><pre class="line-numbers language-none"><code class="language-none">print_pgtbl startingva 0x0 pte 0x21FCD85B pa 0x87F36000 perm 0x5Bva 0x1000 pte 0x21FD141B pa 0x87F45000 perm 0x1Bva 0x2000 pte 0x21FD1017 pa 0x87F44000 perm 0x17va 0x3000 pte 0x21FD4007 pa 0x87F50000 perm 0x7va 0x4000 pte 0x21FC70D7 pa 0x87F1C000 perm 0xD7va 0x5000 pte 0x0 pa 0x0 perm 0x0va 0x6000 pte 0x0 pa 0x0 perm 0x0va 0x7000 pte 0x0 pa 0x0 perm 0x0va 0x8000 pte 0x0 pa 0x0 perm 0x0va 0x9000 pte 0x0 pa 0x0 perm 0x0va 0xFFFF6000 pte 0x0 pa 0x0 perm 0x0va 0xFFFF7000 pte 0x0 pa 0x0 perm 0x0va 0xFFFF8000 pte 0x0 pa 0x0 perm 0x0va 0xFFFF9000 pte 0x0 pa 0x0 perm 0x0va 0xFFFFA000 pte 0x0 pa 0x0 perm 0x0va 0xFFFFB000 pte 0x0 pa 0x0 perm 0x0va 0xFFFFC000 pte 0x0 pa 0x0 perm 0x0va 0xFFFFD000 pte 0x0 pa 0x0 perm 0x0va 0xFFFFE000 pte 0x21FC94C7 pa 0x87F25000 perm 0xC7va 0xFFFFF000 pte 0x2000184B pa 0x80006000 perm 0x4Bprint_pgtbl: OK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结合 <code>print_pgtbl</code> 的实现，我们可以知道 <code>pgtbltest</code> 遍历了用户进程虚拟地址空间开头和末尾的一些地址，并打印出它们对应的 PTE、物理地址、权限位。让我们先来看看 PTE 的结构：</p><p><img src="/images/learning/open-course/MIT-6.S081/labs/lab3-pagetable/pte.png" alt=""></p><p>然后我们以 <code>va 0x4000 pte 0x21FC70D7 pa 0x87F1C000 perm 0xD7</code> 为例，解析一下其打印的内容。首先我们从 PTE 中提取出 Physical Page Number（PPN）和权限位：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 打印 PPN&#x2F;&#x2F; 虚拟地址的末尾 12 位是 0, 所以物理地址偏移量为 0&#x2F;&#x2F; 物理地址为 ((pte &gt;&gt; 10) &lt;&lt; 12) + 0 即 0x87f1c000(gdb) p &#x2F;x (0x21FC70D7 &gt;&gt; 10)$17 &#x3D; 0x87f1c&#x2F;&#x2F; 构造一个末尾 10 位为 1 的量, 方便后续取出权限位(gdb) set $mask &#x3D; ((1 &lt;&lt; 10) - 1)(gdb) p &#x2F;t $mask$18 &#x3D; 1111111111&#x2F;&#x2F; 分别用二进制和十六进制打印权限位(gdb) p &#x2F;t (0x21FC70D7 &amp; $mask)$19 &#x3D; 11010111(gdb) p &#x2F;x (0x21FC70D7 &amp; $mask)$20 &#x3D; 0xd7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>检验可知和 <code>print_pgtbl</code> 的打印结果一致。对照权限位的末五位 10111 和 PTE 的末尾五位 UXWRV，可知这里是用户内存、不可执行、可写、可读、合法。</p><p>我们可以再检查一下 <code>va 0xFFFFF000 pte 0x2000184B pa 0x80006000 perm 0x4B</code>，会发现它的权限位末五位是 01011，说明这里是非用户内存、可以执行、不可写、可读、合法。</p><p>对照下面的用户进程虚拟内存空间图可知我们分析的第一段虚拟地址 <code>0x4000</code> 大约在开头位置，确实是用户的东西；而分析的第二段 <code>0xFFFFF000</code> 则在接近末尾的位置，用于存储系统调用相关的陷阱代码。</p><p><img src="/images/learning/open-course/MIT-6.S081/labs/lab3-pagetable/user_addr_space.png" alt=""></p><p>我们还可以进一步打印一下内存里的值。启动 gdb，用 <code>file user/_pgtbltest</code> 加载符号表，然后在 <code>main</code> 设置断点，这样我们就能在加载用户页表时打印各个虚拟地址的值：</p><pre class="line-numbers language-none"><code class="language-none">(gdb) p *0x0$7 &#x3D; -335146751(gdb) p *0x1000$8 &#x3D; 72(gdb) p *0x5000Cannot access memory at address 0x5000(gdb) p *0xFFFFE000Cannot access memory at address 0xffffe000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对照最开始的 <code>print_pgtbl</code> 的打印结果（关注其权限位），可以看到我们能正确打印 <code>0x0</code> 和 <code>0x1000</code> ，它们是用户内存、可读、合法的虚拟地址的内容。而 <code>0x5000</code> 是不合法的地址所以无法打印，<code>0xFFFFE000</code> 是非用户内存（内核内存）所以无法打印。</p><h1 id="Speed-up-system-calls"><a href="#Speed-up-system-calls" class="headerlink" title="Speed up system calls"></a>Speed up system calls</h1><p>这道题让我们创建一个特殊的内存页并把进程 pid 存储在里面，这样我们在获取 pid 时就不必做系统调用 <code>getpid</code>，而是可以直接调用 <code>ugetpid</code>，从而无需陷入内核以提高效率。</p><p>提示里说我们创建的这个页面会和 <code>trapframe</code> 有很多相似之处——它们都在进程初始化时自动创建，在进程退出时自动释放。所以我们可以分为以下几步完成任务：</p><ol><li>定义 <code>usyscall</code>：在 <code>struct proc</code> 里添加 <code>struct usyscall *usyscall</code></li><li><p>进程初始化时创建页面：阅读 <code>fork</code> 的代码可以知道我们调用 <code>allocproc</code> 以创建进程。</p><p> 在 <code>allocproc</code> 里，我们用 <code>kalloc</code> 给 <code>trapframe</code> 分配了一个物理页，然后调用 <code>proc_pagetable</code> 来做页表映射。</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">proc</span> <span class="token operator">*</span><span class="token function">allocproc</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// ...</span>    <span class="token comment">// Allocate a trapframe page.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p<span class="token operator">-></span>trapframe <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">trapframe</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">kalloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">freeproc</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// An empty user page table.</span>    p<span class="token operator">-></span>pagetable <span class="token operator">=</span> <span class="token function">proc_pagetable</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// ...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 所以照葫芦画瓢就行，先在 <code>allocproc</code> 里加入给 <code>usyscall</code> 分配物理页的代码（记得把 <code>pid</code> 存进去）：</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// Allocate a usyscall page</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p<span class="token operator">-></span>usyscall <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">usyscall</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">kalloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">freeproc</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>p<span class="token operator">-></span>usyscall<span class="token operator">-></span>pid <span class="token operator">=</span> p<span class="token operator">-></span>pid<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 然后在 <code>proc_pagetable</code> 加入页表映射的代码：</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// map the usyscall page just below the trapframe page, for</span><span class="token comment">// data sharing between userspace and the kernel</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">mappages</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> USYSCALL<span class="token punctuation">,</span> PGSIZE<span class="token punctuation">,</span> <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span><span class="token punctuation">(</span>p<span class="token operator">-></span>usyscall<span class="token punctuation">)</span><span class="token punctuation">,</span>             PTE_R <span class="token operator">|</span> PTE_U<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">uvmunmap</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> TRAPFRAME<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">uvmunmap</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> TRAMPOLINE<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">uvmfree</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>退出时释放：我们知道进程调用 <code>exit</code> 来下班，但其实调用 <code>exit</code> 后进程并没有立即销毁自身，而是进入 ZOMBIE 态等待父进程的 <code>wait</code> 来回收。具体可以看看 <code>proc.c</code>，这里不多赘述。</p><p> 总之看向 <code>wait</code> 函数，可以发现我们调用 <code>freeproc</code> 来释放进程。</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">freeproc</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">proc</span> <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">-></span>trapframe<span class="token punctuation">)</span>        <span class="token function">kfree</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>p<span class="token operator">-></span>trapframe<span class="token punctuation">)</span><span class="token punctuation">;</span>    p<span class="token operator">-></span>trapframe <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">-></span>pagetable<span class="token punctuation">)</span>        <span class="token function">proc_freepagetable</span><span class="token punctuation">(</span>p<span class="token operator">-></span>pagetable<span class="token punctuation">,</span> p<span class="token operator">-></span>sz<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// ...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 对照代码对 <code>trapframe</code> 的处理，我们要在 <code>freeproc</code> 里加入释放物理页的代码：</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">-></span>usyscall<span class="token punctuation">)</span>    <span class="token function">kfree</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>p<span class="token operator">-></span>usyscall<span class="token punctuation">)</span><span class="token punctuation">;</span>p<span class="token operator">-></span>usyscall <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p> 然后修改 <code>proc_freepagetable</code> 以删除页表映射：</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">uvmunmap</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> USYSCALL<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><p>闲着也是闲着，不如和我一起看看 <code>uvmfree</code> 为什么没有自动释放 <code>trapframe</code> 和 <code>usyscall</code>：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">uvmfree</span><span class="token punctuation">(</span><span class="token class-name">pagetable_t</span> pagetable<span class="token punctuation">,</span> uint64 sz<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>sz <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">uvmunmap</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token function">PGROUNDUP</span><span class="token punctuation">(</span>sz<span class="token punctuation">)</span> <span class="token operator">/</span> PGSIZE<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">freewalk</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码调用 <code>uvmunmap</code> 来释放所有在页表里有记录的物理页，然后调用 <code>freewalk</code> 来释放页表自身。</p><p>这里的 <code>uvmunmap(pagetable, 0, PGROUNDUP(sz) / PGSIZE, 1)</code> 表示释放虚拟地址从 <code>0</code> 到 <code>0 + PGROUNDUP(sz) / PGSIZE</code> 的内容，即释放用户内存的内容。</p><p>但 <code>trapframe</code> 和 <code>usyscall</code> 不是用户内存的内容，它们被存放在虚拟地址的顶部（分别在 TRAPFRAME 和 USYSCALL），所以它们没有被释放。</p><h1 id="Print-a-page-table"><a href="#Print-a-page-table" class="headerlink" title="Print a page table"></a>Print a page table</h1><p>先来看看打印结果吧：</p><pre class="line-numbers language-none"><code class="language-none">page table 0x0000000087f22000 ..0x0000000000000000: pte 0x0000000021fc7801 pa 0x0000000087f1e000 .. ..0x0000000000000000: pte 0x0000000021fc7401 pa 0x0000000087f1d000 .. .. ..0x0000000000000000: pte 0x0000000021fc7c5b pa 0x0000000087f1f000 .. .. ..0x0000000000001000: pte 0x0000000021fc701b pa 0x0000000087f1c000 .. .. ..0x0000000000002000: pte 0x0000000021fc6cd7 pa 0x0000000087f1b000 .. .. ..0x0000000000003000: pte 0x0000000021fc6807 pa 0x0000000087f1a000 .. .. ..0x0000000000004000: pte 0x0000000021fc64d7 pa 0x0000000087f19000 ..0xffffffffc0000000: pte 0x0000000021fc8401 pa 0x0000000087f21000 .. ..0xffffffffffe00000: pte 0x0000000021fc8001 pa 0x0000000087f20000 .. .. ..0xffffffffffffd000: pte 0x0000000021fd4c13 pa 0x0000000087f53000 .. .. ..0xffffffffffffe000: pte 0x0000000021fd00c7 pa 0x0000000087f40000 .. .. ..0xfffffffffffff000: pte 0x000000002000184b pa 0x0000000080006000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果比 2024 的作业文档多了一行</p><pre class="line-numbers language-none"><code class="language-none">.. .. ..0x0000000000000000: pte 0x0000000021fc7c5b pa 0x0000000087f1f000<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这是正确表现。2024 的作业文档这里写错了，2025 的版本就加入了这行。</p><p>如提示所言，这个函数和 <code>freewalk</code> 很像，我们先来看看 <code>freewalk</code>：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">freewalk</span><span class="token punctuation">(</span><span class="token class-name">pagetable_t</span> pagetable<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// there are 2^9 = 512 PTEs in a page table.</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">512</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">pte_t</span> pte <span class="token operator">=</span> pagetable<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pte <span class="token operator">&amp;</span> PTE_V<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>pte <span class="token operator">&amp;</span> <span class="token punctuation">(</span>PTE_R <span class="token operator">|</span> PTE_W <span class="token operator">|</span> PTE_X<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// this PTE points to a lower-level page table.</span>            uint64 child <span class="token operator">=</span> <span class="token function">PTE2PA</span><span class="token punctuation">(</span>pte<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">freewalk</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">pagetable_t</span><span class="token punctuation">)</span>child<span class="token punctuation">)</span><span class="token punctuation">;</span>            pagetable<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pte <span class="token operator">&amp;</span> PTE_V<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"freewalk: leaf"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">kfree</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>pagetable<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>它遍历 L0 级页表的 512 个 PTE，对每个 PTE，用 <code>PTE2PA(pte)</code> 找到它指向的次级页表的物理地址，然后递归。它忽略了叶子 PTE，在打印时我们不需要忽略叶子。</p><p>我们再来看看打印结果的形式</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">.</span><span class="token punctuation">.</span> 虚拟地址<span class="token operator">:</span> pte PTE的值 pa 物理地址的值<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>参考 <code>freewalk</code> 我们就能拿到 PTE，调用 <code>PTE2PA</code> 就能得到 <code>pa</code>，但怎么获得虚拟地址呢？我们来看看虚拟地址的翻译：</p><p><img src="/images/learning/open-course/MIT-6.S081/labs/lab3-pagetable/addr_translation.png" alt=""></p><p>从这里可以看出，如果把 Offset 置零，我们需要 L2、L1、L0 页表的 PTE 的索引来确定虚拟地址。但我们当然有办法获得这些索引，我们不是在遍历页表吗，<code>for (int i = 0; i &lt; 512; i++)</code> 里的 <code>i</code> 就是我们需要的索引！所以如果我们的索引是 <code>i, j, k</code>，我们打印的虚拟地址就是 <code>((i &lt;&lt; 30) + (j &lt;&lt; 21) + (k &lt;&lt; 12))</code></p><p>大致思路就是这样。还有一些小细节：</p><ol><li>作业文档里在遍历 L2 和 L1 级页表时也打印了虚拟地址，这里打印的地址是把次级索引当作零算出的地址。比如如果我们在遍历 L1 页表，L2 页表的索引是 <code>i</code>，L1 页表的索引是 <code>j</code>，打印的就是 <code>((i &lt;&lt; 30) + (j &lt;&lt; 21) + (0 &lt;&lt; 12))</code></li><li>为了在递归时得知上一级页表的信息，我们加入了 <code>father_va</code> 用于记录上一级的虚拟地址</li><li>符号拓展用了一些 tricky 的性质，在 255 &lt;&lt; 30 那行的注释里写的应该还算清楚</li></ol><p>总之可以写出下面的代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">int</span> MAX_LEVEL <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">_vmprint_helper</span><span class="token punctuation">(</span><span class="token class-name">pagetable_t</span> pagetable<span class="token punctuation">,</span> uint64 father_va<span class="token punctuation">,</span> <span class="token keyword">int</span> level<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// there are 2^9 = 512 PTEs in a page table.</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">512</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">pte_t</span> pte <span class="token operator">=</span> pagetable<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pte <span class="token operator">&amp;</span> PTE_V<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> level<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> MAX_LEVEL<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" .."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 255 &lt;&lt; 30 is automatically sign extended to 0xffffffffc0000000</span>            uint64 va <span class="token operator">=</span> father_va <span class="token operator">+</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token number">12</span> <span class="token operator">+</span> <span class="token number">9</span> <span class="token operator">*</span> level<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p: pte %p pa %p\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>va<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>pte<span class="token punctuation">,</span>                   <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">PTE2PA</span><span class="token punctuation">(</span>pte<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// this PTE points to a lower-level page table.</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>level <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">_vmprint_helper</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">pagetable_t</span><span class="token punctuation">)</span><span class="token function">PTE2PA</span><span class="token punctuation">(</span>pte<span class="token punctuation">)</span><span class="token punctuation">,</span> va<span class="token punctuation">,</span> level <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">vmprint</span><span class="token punctuation">(</span><span class="token class-name">pagetable_t</span> pagetable<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"page table %p\n"</span><span class="token punctuation">,</span> pagetable<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">_vmprint_helper</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> MAX_LEVEL<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Use-superpages"><a href="#Use-superpages" class="headerlink" title="Use superpages"></a><strong>Use superpages</strong></h1><p>这道题让我们给 xv6 加入超级页。当用户请求一块超过 2MB 的内存，我们就分配超级页而非大量的小页来优化性能。</p><p>我们先来看看普通页和超级页各自是如何翻译虚拟地址的：</p><p><img src="/images/learning/open-course/MIT-6.S081/labs/lab3-pagetable/regular_vs_super.png" alt=""></p><ol><li><p>普通页：</p><p> 普通页在翻译时把虚拟地址分成 L2, L1, L0, Offset 四个部分。前三者用于在不同级别的页表里做偏移找到下一个页的开头的物理地址（一个 Page Directory 也是一个页），Offset 则用于计算最终的物理地址偏移。</p><p> Sv39 规定 PPN 宽度为 44 位，Offset 宽度 12 位，一个普通页的大小就是 $2^{12}$ bytes = 4KB.</p><p> 在找到了 L0 leaf 后，我们就能用 <code>(PPN &lt;&lt; 12) + Offest</code> 来计算虚拟地址对应的物理地址了。</p></li><li><p>超级页：</p><p> 超级页则把虚拟地址分成 L2, L1, Offset 三个部分。</p><p> Sv39 规定超级页的 Offset 为 21 位，这是把原本的 L0 和 Offset 合并成了一个 21 位的 Offset。超级页大小就是 $2^{21}$ bytes 即 2MB.</p><p> 超级页是 2MB 对齐的，所以我们需要 $56 - \log (2097152) = 35$ 位来描述一个超级页的开头，所以超级页对应的 L1 leaf 存储的 PPN 的末尾 9 位为 0. 这里有 $2097152$ 是因为 2MB = 2097152 bytes.</p><p> 在找到 L1 leaf 后，我们同样用 <code>(PPN &lt;&lt; 12) + Offest</code> 来计算虚拟地址对应的物理地址。</p></li></ol><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p>遵循提示，我们先来看看 <code>superpg_test</code> 做了什么。要说明的是，2024 版本的测试不全面而且有 bug——在 <code>supercheck</code> 函数的末尾的 for 循环里，条件应该是 <code>i &lt; 512 * PGSIZE</code> 而非 <code>i &lt; 512</code>，应该改成下面这样：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// check whether different va are mapped to different pa</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">512</span> <span class="token operator">*</span> PGSIZE<span class="token punctuation">;</span> i <span class="token operator">+=</span> PGSIZE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>s <span class="token operator">+</span> i<span class="token punctuation">)</span> <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">512</span> <span class="token operator">*</span> PGSIZE<span class="token punctuation">;</span> i <span class="token operator">+=</span> PGSIZE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>s <span class="token operator">+</span> i<span class="token punctuation">)</span> <span class="token operator">!=</span> i<span class="token punctuation">)</span>        <span class="token function">err</span><span class="token punctuation">(</span><span class="token string">"wrong value"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总之我们下面分析 2025 版本的测试。2025 版本的测试共包括 <code>supercheck</code>、<code>superpg_fork</code> 和 <code>superpg_free</code> 三个函数，我们主要关注 <code>supercheck</code>。<code>supercheck</code> 判断从 <code>end</code> 之后第一个对齐超级页的地址开始是否是超级页，具体的判断方法可以参考下面的注释：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">supercheck</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>end<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">pte_t</span> last_pte <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    uint64 a <span class="token operator">=</span> <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>end<span class="token punctuation">;</span>    uint64 s <span class="token operator">=</span> <span class="token function">SUPERPGROUNDUP</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Check that virtual address up to the next superpage boundary are mapped to PTE</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> a <span class="token operator">&lt;</span> s<span class="token punctuation">;</span> a <span class="token operator">+=</span> PGSIZE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">pte_t</span> pte <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">pte_t</span><span class="token punctuation">)</span><span class="token function">pgpte</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pte <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">err</span><span class="token punctuation">(</span><span class="token string">"no pte"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// Check that all virtual address in the superpage share the same valid PTE</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>uint64 p <span class="token operator">=</span> s<span class="token punctuation">;</span> p <span class="token operator">&lt;</span> s <span class="token operator">+</span> <span class="token number">512</span> <span class="token operator">*</span> PGSIZE<span class="token punctuation">;</span> p <span class="token operator">+=</span> PGSIZE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">pte_t</span> pte <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">pte_t</span><span class="token punctuation">)</span><span class="token function">pgpte</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pte <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token function">err</span><span class="token punctuation">(</span><span class="token string">"no pte"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>last_pte <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> pte <span class="token operator">!=</span> last_pte<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">err</span><span class="token punctuation">(</span><span class="token string">"pte different"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pte <span class="token operator">&amp;</span> PTE_V<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token punctuation">(</span>pte <span class="token operator">&amp;</span> PTE_R<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token punctuation">(</span>pte <span class="token operator">&amp;</span> PTE_W<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">err</span><span class="token punctuation">(</span><span class="token string">"pte wrong"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        last_pte <span class="token operator">=</span> pte<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// Check that different va are mapped to different pa</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">512</span> <span class="token operator">*</span> PGSIZE<span class="token punctuation">;</span> i <span class="token operator">+=</span> PGSIZE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>s <span class="token operator">+</span> i<span class="token punctuation">)</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">512</span> <span class="token operator">*</span> PGSIZE<span class="token punctuation">;</span> i <span class="token operator">+=</span> PGSIZE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>s <span class="token operator">+</span> i<span class="token punctuation">)</span> <span class="token operator">!=</span> i<span class="token punctuation">)</span>            <span class="token function">err</span><span class="token punctuation">(</span><span class="token string">"wrong value"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后我们简要提一下另外两个函数的作用：</p><ol><li><code>superpg_fork</code> 检查超级页在 <code>fork</code> 后是否被正确复制为超级页。</li><li><code>superpg_free</code> 检查 <code>sbrk</code> 能否正确释放整个超级页，以及能否在释放超级页的部分内存时将超级页退化为多个普通页（2024 版本没测试这一点，但这个是很值得做的功能）。</li></ol><h2 id="sbrk-调用链"><a href="#sbrk-调用链" class="headerlink" title="sbrk 调用链"></a>sbrk 调用链</h2><p>接下来我们分析用户在调用 <code>sbrk</code> 时具体调用了哪些函数。这分为两种情况：</p><ol><li>分配：sys_sbrk-&gt;growproc-&gt;uvmalloc -&gt; kalloc/kfree</li><li>释放：sys_sbrk -&gt; growproc -&gt; uvmdealloc -&gt; uvmunmap</li></ol><p>要注意的是当分配内存出错时，<code>uvmalloc</code> 也会调用 <code>uvmdealloc</code>。</p><p>我们从最底层出发，先在 kalloc.c 里完成对超级页的支持。这包括以下步骤：</p><ol><li><p>添加一个超级页链表</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">spinlock</span> lock<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">run</span> <span class="token operator">*</span>superlist<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">run</span> <span class="token operator">*</span>freelist<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> kmem<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>在初始化代码里初始化这个超级页链表</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">int</span> MAX_SUPER <span class="token operator">=</span> <span class="token number">32</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">freerange</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>pa_start<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>pa_end<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>    p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">PGROUNDUP</span><span class="token punctuation">(</span><span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>pa_start<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> sz<span class="token punctuation">;</span>    <span class="token keyword">int</span> super_cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> p <span class="token operator">+</span> PGSIZE <span class="token operator">&lt;=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>pa_end<span class="token punctuation">;</span> p <span class="token operator">+=</span> sz<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>super_cnt <span class="token operator">&lt;</span> MAX_SUPER <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>p <span class="token operator">%</span> SUPERPGSIZE <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>            p <span class="token operator">+</span> SUPERPGSIZE <span class="token operator">&lt;=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>pa_end<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            sz <span class="token operator">=</span> SUPERPGSIZE<span class="token punctuation">;</span>            <span class="token function">superfree</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>            super_cnt <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            sz <span class="token operator">=</span> PGSIZE<span class="token punctuation">;</span>            <span class="token function">kfree</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>添加 superalloc 和 superfree 函数（照抄 kalloc 和 kfree）：</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">superalloc</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">run</span> <span class="token operator">*</span>r<span class="token punctuation">;</span>    <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kmem<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    r <span class="token operator">=</span> kmem<span class="token punctuation">.</span>superlist<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>r<span class="token punctuation">)</span>        kmem<span class="token punctuation">.</span>superlist <span class="token operator">=</span> r<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kmem<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>r<span class="token punctuation">)</span>        <span class="token function">memset</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>r<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> SUPERPGSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// fill with junk</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>r<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">superfree</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>pa<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">run</span> <span class="token operator">*</span>r<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>pa <span class="token operator">%</span> SUPERPGSIZE<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>pa <span class="token operator">&lt;</span> end <span class="token operator">||</span>        <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>pa <span class="token operator">>=</span> PHYSTOP<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"superfree"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// Fill with junk to catch dangling refs.</span>    <span class="token function">memset</span><span class="token punctuation">(</span>pa<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> SUPERPGSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    r <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">run</span> <span class="token operator">*</span><span class="token punctuation">)</span>pa<span class="token punctuation">;</span>    <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kmem<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    r<span class="token operator">-></span>next <span class="token operator">=</span> kmem<span class="token punctuation">.</span>superlist<span class="token punctuation">;</span>    kmem<span class="token punctuation">.</span>superlist <span class="token operator">=</span> r<span class="token punctuation">;</span>    <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kmem<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p>至此，最底层的工作就做完了。</p><h2 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h2><p>回顾内存分配的调用链：sys_sbrk-&gt;growproc-&gt;uvmalloc -&gt; kalloc/kfree，在开始编写代码之前我们先分析一下每一层的职责。</p><ol><li>sys_sbrk 是系统调用，负责系统和用户的交互</li><li>grow_proc 是进程抽象的一个接口，负责管理进程状态</li><li>uvmalloc 是虚拟内存层，负责管理进程眼中的“内存”，管理虚拟到物理的映射</li><li>kalloc 和 kfree 则是物理内存层，管理物理内存</li></ol><p>我们在这里要修改的是 uvmalloc. 简单读下它原本的代码可以发现它主要调用的是 kalloc 和 mappages. 在超级页中，前者对应 superalloc，而对后者我自己写了一个 mapsuperpages 作为对应。为了让 mapsuperpages 跑起来，我还写了个 l1walk 函数用于找到一个虚拟地址对应的 L1 PTE. 先来看看 l1walk：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">pte_t</span> <span class="token operator">*</span><span class="token function">l1walk</span><span class="token punctuation">(</span><span class="token class-name">pagetable_t</span> pagetable<span class="token punctuation">,</span> uint64 va<span class="token punctuation">,</span> <span class="token keyword">int</span> alloc<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>va <span class="token operator">>=</span> MAXVA<span class="token punctuation">)</span>        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"walk"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">pte_t</span> <span class="token operator">*</span>pte <span class="token operator">=</span> <span class="token operator">&amp;</span>pagetable<span class="token punctuation">[</span><span class="token function">PX</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> va<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>pte <span class="token operator">&amp;</span> PTE_V<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        pagetable <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">pagetable_t</span><span class="token punctuation">)</span><span class="token function">PTE2PA</span><span class="token punctuation">(</span><span class="token operator">*</span>pte<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">&amp;</span>pagetable<span class="token punctuation">[</span><span class="token function">PX</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> va<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>alloc <span class="token operator">||</span> <span class="token punctuation">(</span>pagetable <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">pde_t</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">kalloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> PGSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">*</span>pte <span class="token operator">=</span> <span class="token function">PA2PTE</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">)</span> <span class="token operator">|</span> PTE_V<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">&amp;</span>pagetable<span class="token punctuation">[</span><span class="token function">PX</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> va<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>它和 walk 函数基本一致，不过 walk 是返回 leaf，而这里的 l1walk 返回 L1 PTE.</p><p>然后看看 mapsuperpages：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">mapsuperpages</span><span class="token punctuation">(</span><span class="token class-name">pagetable_t</span> pagetable<span class="token punctuation">,</span> uint64 va<span class="token punctuation">,</span> uint64 size<span class="token punctuation">,</span> uint64 pa<span class="token punctuation">,</span>                  <span class="token keyword">int</span> perm<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    uint64 a<span class="token punctuation">,</span> last<span class="token punctuation">;</span>    <span class="token class-name">pte_t</span> <span class="token operator">*</span>pte<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>va <span class="token operator">%</span> SUPERPGSIZE<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"mapsuperpages: va not aligned"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">%</span> SUPERPGSIZE<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"mapsuperpages: size not aligned"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"mapsuperpages: size"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    a <span class="token operator">=</span> va<span class="token punctuation">;</span>    last <span class="token operator">=</span> va <span class="token operator">+</span> size <span class="token operator">-</span> SUPERPGSIZE<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pte <span class="token operator">=</span> <span class="token function">l1walk</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> a<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"mapsuperpages: l1walk failed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>pte <span class="token operator">&amp;</span> PTE_V<span class="token punctuation">)</span>            <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"mapsuperpages: remap"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">*</span>pte <span class="token operator">=</span> <span class="token function">PA2PTE</span><span class="token punctuation">(</span>pa<span class="token punctuation">)</span> <span class="token operator">|</span> perm <span class="token operator">|</span> PTE_V <span class="token operator">|</span> PTE_R<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> last<span class="token punctuation">)</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        a <span class="token operator">+=</span> SUPERPGSIZE<span class="token punctuation">;</span>        pa <span class="token operator">+=</span> SUPERPGSIZE<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这基本是照抄 mappages，只是把普通页改成了超级页。</p><p>最后看看我们对 uvmalloc 的修改。uvmalloc 主要分为两部分，第一部分是用 kalloc/superalloc 请求物理内存，第二部分是用 mappages/mapsuperpages 把虚拟内存映射到物理内存上。</p><p>我们在注释里标出了修改的地方，修改 1 对应请求物理内存的第一部分，修改 2 对应做映射的第二部分：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">uint64 <span class="token function">uvmalloc</span><span class="token punctuation">(</span><span class="token class-name">pagetable_t</span> pagetable<span class="token punctuation">,</span> uint64 oldsz<span class="token punctuation">,</span> uint64 newsz<span class="token punctuation">,</span> <span class="token keyword">int</span> xperm<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>mem<span class="token punctuation">;</span>    uint64 a<span class="token punctuation">;</span>    <span class="token keyword">int</span> sz<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newsz <span class="token operator">&lt;</span> oldsz<span class="token punctuation">)</span>        <span class="token keyword">return</span> oldsz<span class="token punctuation">;</span>    oldsz <span class="token operator">=</span> <span class="token function">PGROUNDUP</span><span class="token punctuation">(</span>oldsz<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>a <span class="token operator">=</span> oldsz<span class="token punctuation">;</span> a <span class="token operator">&lt;</span> newsz<span class="token punctuation">;</span> a <span class="token operator">+=</span> sz<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 修改1从这里开始</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">%</span> SUPERPGSIZE <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> a <span class="token operator">+</span> SUPERPGSIZE <span class="token operator">&lt;=</span> newsz<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            sz <span class="token operator">=</span> SUPERPGSIZE<span class="token punctuation">;</span>            mem <span class="token operator">=</span> <span class="token function">superalloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// If no superpages, use regular pages</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>mem <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                sz <span class="token operator">=</span> PGSIZE<span class="token punctuation">;</span>                mem <span class="token operator">=</span> <span class="token function">kalloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            sz <span class="token operator">=</span> PGSIZE<span class="token punctuation">;</span>            mem <span class="token operator">=</span> <span class="token function">kalloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 修改1到这里结束</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mem <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">uvmdealloc</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> a<span class="token punctuation">,</span> oldsz<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">LAB_SYSCALL</span></span>        <span class="token function">memset</span><span class="token punctuation">(</span>mem<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> sz<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>        <span class="token comment">// 修改2从这里开始</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sz <span class="token operator">==</span> PGSIZE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">mappages</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> a<span class="token punctuation">,</span> sz<span class="token punctuation">,</span> <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>mem<span class="token punctuation">,</span>                         PTE_R <span class="token operator">|</span> PTE_U <span class="token operator">|</span> xperm<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">kfree</span><span class="token punctuation">(</span>mem<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">uvmdealloc</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> a<span class="token punctuation">,</span> oldsz<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">mapsuperpages</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> a<span class="token punctuation">,</span> sz<span class="token punctuation">,</span> <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>mem<span class="token punctuation">,</span>                              PTE_R <span class="token operator">|</span> PTE_U <span class="token operator">|</span> xperm<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">superfree</span><span class="token punctuation">(</span>mem<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">uvmdealloc</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> a<span class="token punctuation">,</span> oldsz<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 修改2到这里结束</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> newsz<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="释放内存"><a href="#释放内存" class="headerlink" title="释放内存"></a>释放内存</h2><p>在完成了分配内存的工作后，我们就能写释放内存相关的代码了。</p><p>回顾调用链：sys_sbrk -&gt; growproc -&gt; uvmdealloc -&gt; uvmunmap，我们要修改 uvmunmap. 这部分代码比较棘手。它原本只是在按部就班地删掉页表里从 va 出发的 npages 个物理页的映射，并选择性释放物理内存，但在加入超级页后它需要完成这些工作：</p><ol><li>让 <code>uint64 a</code> 从 <code>va</code> 出发，如果遇到了普通页，走普通页的 unmap 流程，然后 <code>a += PGSIZE</code></li><li>如果遇到了超级页，判断 <code>a</code> 是超级页的开头还是超级页的中间<ol><li>如果是超级页的开头，走超级页的 unmap 流程（和普通页 unmap 基本一致），然后 <code>a += SUPERPGSIZE</code></li><li>如果是超级页的中间，把超级页退化成若干个普通页，再走普通页释放流程，然后 <code>a += PGSIZE</code></li></ol></li></ol><p>这里主要是上面步骤中的 2b 的“退化”比较棘手，我是把页表里对应超级页的 L1 leaf 设置成了 invalid，然后把超级页视作多个普通页的合并，从超级页的开头出发做若干次 mappages 从而完成退化。思路可以参考下图：</p><p><img src="/images/learning/open-course/MIT-6.S081/labs/lab3-pagetable/super_demote.png" alt=""></p><p>这里是退化部分的代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> perm <span class="token operator">=</span> <span class="token function">PTE_FLAGS</span><span class="token punctuation">(</span><span class="token operator">*</span>pte<span class="token punctuation">)</span><span class="token punctuation">;</span>uint64 super_va_st <span class="token operator">=</span> <span class="token function">SUPERPGROUNDDOWN</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>uint64 super_pa_st <span class="token operator">=</span> <span class="token function">PTE2PA</span><span class="token punctuation">(</span><span class="token operator">*</span>pte<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">*</span>pte <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>pte <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// Make pte invalid to make `mappages` work</span><span class="token keyword">for</span> <span class="token punctuation">(</span>uint64 super_va <span class="token operator">=</span> super_va_st<span class="token punctuation">,</span> super_pa <span class="token operator">=</span> super_pa_st<span class="token punctuation">;</span>     super_va <span class="token operator">&lt;</span> super_va_st <span class="token operator">+</span> SUPERPGSIZE<span class="token punctuation">;</span>     super_va <span class="token operator">+=</span> PGSIZE<span class="token punctuation">,</span> super_pa <span class="token operator">+=</span> PGSIZE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">mappages</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> super_va<span class="token punctuation">,</span> PGSIZE<span class="token punctuation">,</span> super_pa<span class="token punctuation">,</span> perm<span class="token punctuation">)</span> <span class="token operator">!=</span>        <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"uvmunmap: mappages failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然这样的退化有一个潜在风险——每个进程的超级页上限在进程启动时就决定了，我们的退化会让本进程的超级页上限减一。如果有什么自动合并普通页为超级页的功能就好了…</p><p>另外，我的代码把之前步骤里描述的 1 和 2b 整合了一下（毕竟它们最后都走的是普通页释放流程），总之这里是完整代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">uvmunmap</span><span class="token punctuation">(</span><span class="token class-name">pagetable_t</span> pagetable<span class="token punctuation">,</span> uint64 va<span class="token punctuation">,</span> uint64 npages<span class="token punctuation">,</span> <span class="token keyword">int</span> do_free<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    uint64 a<span class="token punctuation">;</span>    <span class="token class-name">pte_t</span> <span class="token operator">*</span>pte<span class="token punctuation">;</span>    <span class="token keyword">int</span> sz<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>va <span class="token operator">%</span> PGSIZE<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"uvmunmap: not aligned"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>a <span class="token operator">=</span> va<span class="token punctuation">;</span> a <span class="token operator">&lt;</span> va <span class="token operator">+</span> npages <span class="token operator">*</span> PGSIZE<span class="token punctuation">;</span> a <span class="token operator">+=</span> sz<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// If `a` corresponds to a superpage and the superpage starts at `a`,</span>        <span class="token comment">// free the superpage</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pte <span class="token operator">=</span> <span class="token function">l1walk</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> a<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">PTE_LEAF</span><span class="token punctuation">(</span><span class="token operator">*</span>pte<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>            a <span class="token operator">%</span> SUPERPGSIZE <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            sz <span class="token operator">=</span> SUPERPGSIZE<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>pte <span class="token operator">&amp;</span> PTE_V<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"va=%ld pte=%ld\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> <span class="token operator">*</span>pte<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"uvmunmap: not mapped"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>do_free<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                uint64 pa <span class="token operator">=</span> <span class="token function">PTE2PA</span><span class="token punctuation">(</span><span class="token operator">*</span>pte<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">superfree</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>pa<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token operator">*</span>pte <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            sz <span class="token operator">=</span> PGSIZE<span class="token punctuation">;</span>            <span class="token comment">// If `a` corresponds to a superpage but the superpage doesn't</span>            <span class="token comment">// start at `a`, demote the superpage into regular pages</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>pte <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">PTE_LEAF</span><span class="token punctuation">(</span><span class="token operator">*</span>pte<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// Potential issue:</span>                <span class="token comment">// Each process has a max number of superpages defined as</span>                <span class="token comment">// `MAX_SUPER`. But whenever a superpage is demoted, the</span>                <span class="token comment">// process's max number of superpages permanently minus one,</span>                <span class="token comment">// since we view superpage as multiple regular pages.</span>                <span class="token comment">//</span>                <span class="token comment">// A possible solution is to kalloc multiple regular pages,</span>                <span class="token comment">// copy memory into them, and superfree the superpage.</span>                <span class="token keyword">int</span> perm <span class="token operator">=</span> <span class="token function">PTE_FLAGS</span><span class="token punctuation">(</span><span class="token operator">*</span>pte<span class="token punctuation">)</span><span class="token punctuation">;</span>                uint64 super_va_st <span class="token operator">=</span> <span class="token function">SUPERPGROUNDDOWN</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>                uint64 super_pa_st <span class="token operator">=</span> <span class="token function">PTE2PA</span><span class="token punctuation">(</span><span class="token operator">*</span>pte<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">*</span>pte <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>pte <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span>                       <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// Make pte invalid to make `mappages` work</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span>uint64 super_va <span class="token operator">=</span> super_va_st<span class="token punctuation">,</span> super_pa <span class="token operator">=</span> super_pa_st<span class="token punctuation">;</span>                     super_va <span class="token operator">&lt;</span> super_va_st <span class="token operator">+</span> SUPERPGSIZE<span class="token punctuation">;</span>                     super_va <span class="token operator">+=</span> PGSIZE<span class="token punctuation">,</span> super_pa <span class="token operator">+=</span> PGSIZE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">mappages</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> super_va<span class="token punctuation">,</span> PGSIZE<span class="token punctuation">,</span> super_pa<span class="token punctuation">,</span> perm<span class="token punctuation">)</span> <span class="token operator">!=</span>                        <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"uvmunmap: mappages failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// Free the regular page that begins at `a`</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pte <span class="token operator">=</span> <span class="token function">walk</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> a<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"uvmunmap: walk"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>pte <span class="token operator">&amp;</span> PTE_V<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"va=%ld pte=%ld\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> <span class="token operator">*</span>pte<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"uvmunmap: not mapped"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">PTE_FLAGS</span><span class="token punctuation">(</span><span class="token operator">*</span>pte<span class="token punctuation">)</span> <span class="token operator">==</span> PTE_V<span class="token punctuation">)</span>                <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"uvmunmap: not a leaf"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>do_free<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                uint64 pa <span class="token operator">=</span> <span class="token function">PTE2PA</span><span class="token punctuation">(</span><span class="token operator">*</span>pte<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">kfree</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>pa<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token operator">*</span>pte <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h2><p>最艰难的工作已经做完了，我们只要修改 uvmcopy 就能下班了！这里的修改只是加入一个简单的分类，在遇到普通页时走普通流程，遇到超级页时走超级流程。咱就直接放代码了：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">uvmcopy</span><span class="token punctuation">(</span><span class="token class-name">pagetable_t</span> old<span class="token punctuation">,</span> <span class="token class-name">pagetable_t</span> new<span class="token punctuation">,</span> uint64 sz<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">pte_t</span> <span class="token operator">*</span>pte<span class="token punctuation">;</span>    uint64 pa<span class="token punctuation">,</span> i<span class="token punctuation">;</span>    uint flags<span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>mem<span class="token punctuation">;</span>    <span class="token keyword">int</span> szinc<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> sz<span class="token punctuation">;</span> i <span class="token operator">+=</span> szinc<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// super page case</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pte <span class="token operator">=</span> <span class="token function">l1walk</span><span class="token punctuation">(</span>old<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">PTE_LEAF</span><span class="token punctuation">(</span><span class="token operator">*</span>pte<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            szinc <span class="token operator">=</span> SUPERPGSIZE<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>pte <span class="token operator">&amp;</span> PTE_V<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"uvmcopy: page not present"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            pa <span class="token operator">=</span> <span class="token function">PTE2PA</span><span class="token punctuation">(</span><span class="token operator">*</span>pte<span class="token punctuation">)</span><span class="token punctuation">;</span>            flags <span class="token operator">=</span> <span class="token function">PTE_FLAGS</span><span class="token punctuation">(</span><span class="token operator">*</span>pte<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>mem <span class="token operator">=</span> <span class="token function">superalloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token keyword">goto</span> err<span class="token punctuation">;</span>            <span class="token function">memmove</span><span class="token punctuation">(</span>mem<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>pa<span class="token punctuation">,</span> SUPERPGSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">mapsuperpages</span><span class="token punctuation">(</span>new<span class="token punctuation">,</span> i<span class="token punctuation">,</span> SUPERPGSIZE<span class="token punctuation">,</span> <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>mem<span class="token punctuation">,</span> flags<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">superfree</span><span class="token punctuation">(</span>mem<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">goto</span> err<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// regular page case</span>        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            szinc <span class="token operator">=</span> PGSIZE<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pte <span class="token operator">=</span> <span class="token function">walk</span><span class="token punctuation">(</span>old<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"uvmcopy: pte should exist"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>pte <span class="token operator">&amp;</span> PTE_V<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"uvmcopy: page not present"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            pa <span class="token operator">=</span> <span class="token function">PTE2PA</span><span class="token punctuation">(</span><span class="token operator">*</span>pte<span class="token punctuation">)</span><span class="token punctuation">;</span>            flags <span class="token operator">=</span> <span class="token function">PTE_FLAGS</span><span class="token punctuation">(</span><span class="token operator">*</span>pte<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>mem <span class="token operator">=</span> <span class="token function">kalloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token keyword">goto</span> err<span class="token punctuation">;</span>            <span class="token function">memmove</span><span class="token punctuation">(</span>mem<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>pa<span class="token punctuation">,</span> PGSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">mappages</span><span class="token punctuation">(</span>new<span class="token punctuation">,</span> i<span class="token punctuation">,</span> PGSIZE<span class="token punctuation">,</span> <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>mem<span class="token punctuation">,</span> flags<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">kfree</span><span class="token punctuation">(</span>mem<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">goto</span> err<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>err<span class="token operator">:</span>    <span class="token function">uvmunmap</span><span class="token punctuation">(</span>new<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> i <span class="token operator">/</span> PGSIZE<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Inspect-a-user-process-page-table&quot;&gt;&lt;a href=&quot;#Inspect-a-user-process-page-table&quot; class=&quot;headerlink&quot; title=&quot;Inspect a user-process pag</summary>
      
    
    
    
    <category term="公开课" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"/>
    
    <category term="MIT-6.S081" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/MIT-6-S081/"/>
    
    <category term="Labs" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/MIT-6-S081/Labs/"/>
    
    
  </entry>
  
  <entry>
    <title>探索日志[3]</title>
    <link href="http://rinevard.github.io/wiki/others/thoughts/%E6%8E%A2%E7%B4%A2%E6%97%A5%E5%BF%973/"/>
    <id>http://rinevard.github.io/wiki/others/thoughts/%E6%8E%A2%E7%B4%A2%E6%97%A5%E5%BF%973/</id>
    <published>2025-10-27T13:56:16.000Z</published>
    <updated>2025-10-28T02:14:10.603Z</updated>
    
    <content type="html"><![CDATA[<p>书接上上上回（探索日志[0]），今天和上上次参加 Ludum Dare Compo 结识的朋友一起吃饭了，难道说我就要失去社恐属性和宅属性了吗！</p><p>总之就是他这几天来北京玩，我就鼓起勇气问他要不要来找我玩（其实很大程度上是为了水一篇探索日志，探索日志驱动探索），然后今天就一起吃了披萨薯条炸鸡。</p><p><img src="/images/others/random_thoughts/explore3/rubatotree_food.jpg" alt="好吃的"></p><p>感觉自己宅的很大原因是互联网太有趣了。今天也没有和他一起到处玩（根据我的经验和想象，人们一般是会在相聚时去一些地点闲逛的），而是在饭店边吃饭边玩游戏顺便闲聊。咱还给他试了试最近做的新原型（探索日志[2]，感觉探索日志的相互引用都可以变成节点图了），感觉还不错。然后我们就在饭店待了两个多小时，直到他去赶高铁回学校。</p><p>我还蛮喜欢这样的交流的，果然还是要主动去和别人结交才行。好耶，这又是一个水探索日志的机会。等我下次 gamejam 看到喜欢的游戏就去找作者加好友，成功了就水一篇，失败了也能水一篇。当然，如果只是把范围局限在游戏领域也太狭窄了，不过等我水完再说吧。</p><p>为什么酒店叫酒店呢，它在字面上看起来很像饭店，却是居住的地方。我上网搜了一下（如我所言，互联网太有趣了），这是因为它是从 “Hotel” 翻译过来的。对清末的中国上层社会，”Hotel” 的第一功能是饮宴，而非住宿。传统中国贵人出行都带着仆人，所以 “Hotel” 的小间对他们并不是住宿的地方，而只是聚宴的地方，所以被翻译成了“酒店”。</p><p>有趣的生活太多了，一个人是体验不过来的，所以要认识更多的经历过有趣生活的人，才能看到更多有趣的体验。</p><p>又或许人们只是因为碰巧相遇，才碰巧认识了彼此吧。</p><p>当然还是要炫耀一下收到的小卡片的！</p><p><img src="/images/others/random_thoughts/explore3/rubatotree_shielded_card.jpg" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;书接上上上回（探索日志[0]），今天和上上次参加 Ludum Dare Compo 结识的朋友一起吃饭了，难道说我就要失去社恐属性和宅属性了吗！&lt;/p&gt;
&lt;p&gt;总之就是他这几天来北京玩，我就鼓起勇气问他要不要来找我玩（其实很大程度上是为了水一篇探索日志，探索日志驱动探索），</summary>
      
    
    
    
    <category term="杂谈" scheme="http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    <category term="碎碎念" scheme="http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
  </entry>
  
  <entry>
    <title>探索日志[2]</title>
    <link href="http://rinevard.github.io/wiki/others/thoughts/%E6%8E%A2%E7%B4%A2%E6%97%A5%E5%BF%972/"/>
    <id>http://rinevard.github.io/wiki/others/thoughts/%E6%8E%A2%E7%B4%A2%E6%97%A5%E5%BF%972/</id>
    <published>2025-10-27T13:56:15.000Z</published>
    <updated>2025-10-28T02:16:47.945Z</updated>
    
    <content type="html"><![CDATA[<p>陪跑了 Supercell 举办的 Global AI Game Hack. 虽然感觉自己做的游戏并不比获奖作品差，但无所谓了，我做出了自己满意的作品。</p><p><img src="/images/others/random_thoughts/explore2/wtf.png" alt=""></p><p>只是陪跑是称不上探索的（又不是第一次陪跑了）。这次主要是尝试做了以前构思过，但感觉“这根本做不到！”的作品，而且还做出来了。</p><p>我们该怎样做一个基于 LLM 的游戏？我的第一个答案是<a href="https://rinevard.itch.io/myriad-by-cards">牌生万物</a>，这是一个把卡牌放到一起让 AI 基于堆在一起的卡牌讲故事的游戏。一些试玩的玩家还挺喜欢这个游戏，不过介于 AI 很难写出有意义的故事，我简单改了改就没有继续做下去了（现在它叫做《西行牌录》）。</p><p>让我们回到之前的问题，我们该怎样做一个基于 LLM 的游戏？我们当然会想，如果让每个 NPC 都由 LLM 驱动，这个世界就会有无穷的可能性。这是我一开始就反对的答案。我认为 AI 回复的信息密度太低，还会胡编乱造，没有任何意义。更何况两个 AI 之间聊了几句就会开始相互复读了。不过后来玩到了一个 AI 会相互交互聊天的游戏，亲身进入一个 NPC 有自己的生活的游戏感觉超酷！当然我还是不认为这个东西有什么拓展空间，不过确实挺酷的。</p><p>那这次我的答案是什么呢？我想带来尽可能多的可能性，让玩家能做到他们能想到的大部分事情。以前我玩到过允许自定义规则的 LLM 游戏，但作者的实现方法是让 LLM 拼凑一堆预制的规则组件，于是经常出现“我想要这个规则但 AI 写不出来”的情况。因此我想，如果要真正做到尽可能多的可能性，就只能把整个游戏状态都交给 LLM 管理。</p><p>听上去就做不到不是吗？我想出这个想法时也感觉“这根本做不到！文字就算了，动画怎么办？还有更多更多的东西怎么办？”，因此没有去做。但如上文所言，我在这次 hackathon 试着做了这个想法（为什么它不叫 gamejam 而叫 hackathon 呢，明明是做游戏…）。</p><p>我见过的许多游戏设计资料都告诉我，“原型是很可能失败的，找到失败之处就是原型制作的目的。”但你我皆知我们都有对失败的恐惧。在面对一个看上去就做不到的概念时，我对“实现这个概念”的预期就是失败，即使是这样也要做下去吗…</p><p>即使是朝着失败也要做下去吗？几周前参加的 Ludum Dare 还提前一天出结果了，撞上了这个 hackathon 的开头，我也没拿到满意的成绩。即使是这样也要做下去吗？我是不是根本做不出有趣的游戏？</p><p>我看向了 Jeremy Ryan，Hope Falters 的作者（这是我最喜欢的游戏之一），想看看 ta 在最开始时做出的作品是怎样的。我看向了一些别的我喜欢的作者，想看看他们在最开始时做出的作品是怎样的。我看向了一些做了很久游戏但做的还是很糟糕，但还是在做游戏的作者。我看向了几个年龄小于我，排名也小于我的作者。即使是这样也要做下去吗？</p><p>无所谓了，即使是这样也要做下去。而如开头所言，陪跑了。</p><p>但至少我的朋友在玩了我的游戏以后发出了“这居然会陪跑吗”的声音，至少在试玩时几个玩家都挺喜欢的，这就好了。</p><p>嗯，即使要放弃，也要等到大家都不喜欢的那天吧。</p><p>给这个游戏剪辑的笨蛋小视频，可能不符合文章氛围，慎点：<a href="https://youtu.be/P-J1xkifbYA">https://youtu.be/P-J1xkifbYA</a></p><p>说完情绪上的挣扎了，不妨再来聊聊设计。你知道的，我一直都喜欢随便聊聊游戏设计上的东西。</p><p>在得到了“把整个游戏状态都交给 LLM 管理”这个概念后，我脑海中就呈现出了这个游戏现在的样子——让玩家组合词汇来创造魔法，LLM 解析魔法并改变场面。不过我感觉自己以前的设计都是除了概念一无是处的设计，所以这次想试试之前看到的“注重外围设计”的做法。</p><p>据我理解，外围设计就是在核心概念之外做一些设计来呈现这个概念的可能性。比如说俄罗斯方块的概念可能是“凑满一行就消除”，外围设计就是不同形状的积木。如果积木只有正方形和长条，游戏也能工作，但就没有现在这么丰富的可能性了。</p><p>这次我做的外围设计包括用于掩饰生成速度较慢的 TTS 旁白、一些手动设计的高概念词汇。</p><p>写到这里突然有些疑惑。既然在得到了这个“LLM 管理游戏状态”的概念后我就想出了这个游戏现在的样子，那我为什么会感觉“这根本做不到”呢？我不知道，可能只是恐惧失败吧。</p><p>《游戏设计艺术》向读者发出的最后一个问题是：“为什么我要做现在在做的事”。贯彻一个主题的作品会变得更加有力，我们每个人也都有自己的主题。那么我为什么要做游戏，我的主题又是什么？我会寻找答案。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;陪跑了 Supercell 举办的 Global AI Game Hack. 虽然感觉自己做的游戏并不比获奖作品差，但无所谓了，我做出了自己满意的作品。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/others/random_thoughts/explore2/wtf</summary>
      
    
    
    
    <category term="杂谈" scheme="http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    <category term="碎碎念" scheme="http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
  </entry>
  
  <entry>
    <title>如何在七天内制作游戏原型</title>
    <link href="http://rinevard.github.io/wiki/others/translation/%E4%B8%83%E5%A4%A9%E5%8E%9F%E5%9E%8B/"/>
    <id>http://rinevard.github.io/wiki/others/translation/%E4%B8%83%E5%A4%A9%E5%8E%9F%E5%9E%8B/</id>
    <published>2025-10-15T13:47:11.000Z</published>
    <updated>2025-10-15T14:10:39.846Z</updated>
    
    <content type="html"><![CDATA[<p>翻译自 <a href="http://miami.lgrace.com/documents/How%20to%20Prototype%20a%20Game%20in%20Under%207%20Days.pdf">How to Prototype a Game in Under 7 Days</a></p><p>来自四位在一个学期内做了超过 50 款游戏的研究生的心得</p><p>作者：Kyle Gabler, Kyle Gray, Matt Kucic 和 Shalin Shodhan</p><p><img src="/images/others/translation/how_to_prototype_seven_day/1_tower_of_goo.jpg" alt="&quot;黏黏世界&quot;在上线数月内下载量就超过了10万次。"></p><p>这里有一个疯狂的游戏点子：拖动那些会说垃圾话的粘液球，建造一座越来越高的巨塔。它们蠕动、咯咯笑，并爬上兄弟们的背向上攀爬。但要小心！这是一场与重力的持久战。如果你建造的塔太不稳定，它就会倒塌。</p><p>“黏黏世界”在上线数月内下载量超过了10万次，在一本杂志中被誉为“月度网络游戏”，在G4频道和GDC的实验性游戏工作坊上进行了演示，并且是我们在卡内基梅隆大学娱乐技术中心的实验性游戏项目中所制作的五十多款游戏之一。</p><p>和其余的游戏一样，它也是由一个人在一周之内完成的。</p><p>该项目始于2005年春季，目标是尽可能多地发现新的游戏玩法并给它们做原型。我们四名研究生组成了团队，把自己关在房间里，一个学期都遵守着下面三条规则：</p><ol><li>每个游戏必须在七天内完成，</li><li>每个游戏必须由一个人完成，</li><li>每个游戏必须基于一个共同的主题，例如“重力”、“植被”、“蜂群”等。</li></ol><p>随着项目进行，我们对蜂拥而至的流量、游戏杂志的关注以及行业专业人士和学者们都问着的同样的问题感到惊讶和激动：“你们是如何这么快地制作这些游戏的？”以及“我们该怎么做？”</p><p>我们在这里将一切全盘托出。结合以下的建议、技巧和例子，我们将讨论那些有用的和没用的方法。我们将向你展示如何进入快速原型制作的思维状态，如何组建一个高效的团队，以及如果你想过创造新东西但不知从何下手时应该从哪里开始。我们希望这些经过认真验证的指南对你的下一个项目，无论大小，能派上用场！</p><p>为了便于阅读，本文的建议和技巧会被分为四个部分：准备、设计、开发和通用的技巧。祝你阅读愉快！</p><h2 id="准备：快速是一种心态"><a href="#准备：快速是一种心态" class="headerlink" title="准备：快速是一种心态"></a>准备：快速是一种心态</h2><p>快速原型不仅是前期制作中的一个有用工具——它还可以成为一种生活方式！本节将展示如何准备并开始像一个快速原型制作者那样思考。</p><h3 id="拥抱失败的可能性——它鼓励创造性冒险"><a href="#拥抱失败的可能性——它鼓励创造性冒险" class="headerlink" title="拥抱失败的可能性——它鼓励创造性冒险"></a>拥抱失败的可能性——它鼓励创造性冒险</h3><p>“风险”对我们的影响太大了。据我们所知，对失败的恐惧是电影IP改编游戏和续作高达两位数的游戏不断被制作出来的原因。这就像总是选择去麦当劳，而不是一家未曾探索过的新餐厅——总是依赖于一个众所周知的、尚可的选项，而不是冒险尝试未知但可能美味的选择。</p><p>一个好的快速原型制作者会知道失败是可以接受的！找到失败之处就是原型制作的目的，所以尽情去做吧！即使你失败了，也还会有无数的机会，而且很可能你总能学到些东西。只有拥抱失败，才可能做出有价值的实验。</p><p>Mr. Gray：“《Mime After Mime》和《A Mime to Kill》是我做的两款只有声音没有画面的游戏。尽管它们是彻头彻尾的失败品，但整个团队都为能冒如此大的风险来证明纯音频游戏的失败而感到兴奋，我可以自豪地说它们是我做的。随着我在整个项目中积累经验，我逐渐能进行更有针对性的冒险，它们带来了成功的游戏。”</p><p><img src="/images/others/translation/how_to_prototype_seven_day/2_mine_after_mine_and_a_mime_to_kill.png" alt="&quot;Mime After Mime&quot;和&quot;A Mime to Kill&quot;——热情拥抱失败。"></p><h3 id="强制缩短开发周期（更多时间-更高质量）"><a href="#强制缩短开发周期（更多时间-更高质量）" class="headerlink" title="强制缩短开发周期（更多时间 != 更高质量）"></a>强制缩短开发周期（更多时间 != 更高质量）</h3><p>你只需要几天时间。有一种很自然的想法是：“我们一周做了一个很棒的游戏。所以如果我们花两周时间，它会好上两倍！”。当然，事实并非如此。我们发现，通常任何游戏点子都可以在不到一周的时间内有效地进行原型设计。多余的时间往往会产生递减的回报。例如，一些原型只用了一个晚上就完成了，而另一些则多花了一两周的时间。令人惊讶的是，我们发现开发时间与游戏最终的成功程度之间没有关联。</p><p><img src="/images/others/translation/how_to_prototype_seven_day/3_left_and_right.jpg" alt="&quot;Attack of the Killer Swarm&quot;（左）只用了一天时间就完成了，并出人意料地成为该项目中评价最高的游戏之一。&quot;Suburban Brawl&quot;（右）多花了一周的时间，但变得过于复杂。如果没有花时间添加那些巨型杀手机器人，它可能会更有趣。"></p><h3 id="对创造的约束让你更想创造"><a href="#对创造的约束让你更想创造" class="headerlink" title="对创造的约束让你更想创造"></a>对创造的约束让你更想创造</h3><p>我们最成功的游戏都源于特定的主题或“玩具”，比如“重力”、“蜂群”，或者“制作一款主要面向女性休闲玩家的游戏”。不知为什么，在有限制的情况下，创造变得更容易了。</p><p>此外，当一个团队的人都围绕一个特定主题同时做原型时，我们都倾向于避免使用那些显而易见的机制。这种挑战让我们去探索并挖掘主题中所有可能的游戏玩法。</p><p>在项目后期，我们逐渐偏离了这种模式，这最终对我们造成了损害。没有了主题约束，游戏制作时间更长，方向性更差，团队凝聚力也下降了。那种“我们都在一条船上”的感觉减少了，更糟糕的是，我们失去了那种曾激发额外创造力和技巧的友好竞争感。</p><p>我们探索过的一些主题有：“重力”、“弹簧”、“进化”、“声音”、“捕食者与猎物”、“令人上瘾的游戏”、“绘画”、“指数增长”、“植被”、“平衡”，以及其他一些个人主题。</p><p><img src="/images/others/translation/how_to_prototype_seven_day/4_gravity_head.jpg" alt="&quot;Gravity Head&quot;"></p><h3 id="组建一支优秀的团队和一位客观的顾问——心态与才华同等重要"><a href="#组建一支优秀的团队和一位客观的顾问——心态与才华同等重要" class="headerlink" title="组建一支优秀的团队和一位客观的顾问——心态与才华同等重要"></a>组建一支优秀的团队和一位客观的顾问——心态与才华同等重要</h3><p>团队中的每个成员都必须熟悉游戏开发的所有方面。每个人都负责自己的编程、美术、声音以及最终产品中的其他一切。但能力并非一切。理想情况下，每个人都必须以这样的理解来对待这种开发方式：设计是至高无上的——从美术到工程的一切都只是为最终设计服务。一个深谙此道的平庸工程师很可能比一个没有这种心态的优秀工程师更成功。</p><p>项目顾问 Jesse Schell 说：”我一直痴迷于产生新游戏创意的过程，所以当 Shalin、Matt 和两位 Kyle 提出这个项目时，我自然感到非常激动。我把它看作一个在创造力方面进行对照实验的机会，并希望能学到有用的游戏设计知识。作为指导老师，我努力确保团队尝试多种不同的技术、从错误中学习、不在行不通的想法上纠结太久，并努力保证每个人都在寻找最适合自己的创作过程。”</p><p>“我对如何改进游戏提出过一些建议，但大多数时候我尽量不干涉。我感觉自己有点像个园丁——我做了一些浇水和除草的工作，但开花结果全靠他们。正如这篇论文所示，团队能够得出一些非常有用的结论——并且最终做出了一些好游戏！关于创作过程的优化还有更多东西需要学习，卡内基梅隆大学娱乐技术中心计划继续进行这个项目。”</p><p><img src="/images/others/translation/how_to_prototype_seven_day/5.jpg" alt="&quot;我们的团队，永远的实验性朋友！&quot;"></p><h3 id="并行开发以最大化效果"><a href="#并行开发以最大化效果" class="headerlink" title="并行开发以最大化效果"></a>并行开发以最大化效果</h3><p>那么，一旦我们组建了团队，我们做了什么？我们各自独立工作！这听起来可能很奇怪，但独立工作的好处实在太大了，不容忽视：</p><ul><li>缓解风险：通过同时开发四个原型，我们可以在做出冒险的设计决策时感到安心，因为至少有一两个可能会成功。</li><li>友好竞争：每个人都因只专注于自己而受益。就像资本主义一样！</li><li>更广泛的主题探索：我们四个人都专注于同一个主题，这迫使我们深入思考主题。如果我们都做了一样的游戏，那该多尴尬啊！这迫使我们进入一些有益的创作领域，并让我们避免了显而易见的切入点。</li><li>分享与关怀：虽然我们没有共享代码（可以共享也可以不共享），但我们发现分享概念和理解很有帮助。例如，如果一个团队成员发现了一种表示弹簧系统的有效方法，每个人都会受益。</li></ul><p>随着几周过去，我们发现团队合作在每个周期的开始和结束时最有价值。在每个周期开始时，团队合作有助于提炼和比较想法。一旦进入开发阶段，我们发现合作更多是一种干扰——因为每个人都完全沉浸在自己的工作中。到每个周期结束时，我们会回到房间里一起工作到凌晨，体验竞赛快结束的感觉。这种合作价值随时间变化的图表可能像这样：</p><p><img src="/images/others/translation/how_to_prototype_seven_day/6_time_to_value.jpg" alt="&quot;合作价值&quot;随&quot;时间&quot;的变化。"></p><h2 id="设计：头脑风暴的神话和创造力"><a href="#设计：头脑风暴的神话和创造力" class="headerlink" title="设计：头脑风暴的神话和创造力"></a>设计：头脑风暴的神话和创造力</h2><p>一个好点子可能在瞬间产生，但等待点子可能是一种煎熬。没有办法强迫一个好点子迸发出来，但这一部分内容应该能帮助你培养你的创造力。</p><h3 id="正式头脑风暴的成功率为-0"><a href="#正式头脑风暴的成功率为-0" class="headerlink" title="正式头脑风暴的成功率为 0%"></a>正式头脑风暴的成功率为 0%</h3><p>我们真的很努力了——天呐，我们真的希望头脑风暴能奏效！我们安排了“头脑风暴会议”和“圆桌会议”，我们用不同颜色的记号笔在白板和超大便利贴上写画，我们甚至用了像“蓝天”这样的激励性短语来帮助我们摆脱思维定势。但最终，在我们创造的所有游戏中，没有一个是通过大家坐在一起进行头脑风暴会议得出的结果。</p><p>为什么会这样？我们也非常震惊。但经过一番调查，我们发现创造力确实是无法规划的。你不能说：“大家4:15开个会头脑风暴一下，到5:00我们就能拿出四个超棒的游戏点子！”</p><p>但头脑风暴并非无用。通过精心组织头脑风暴会议，我们仍然可以期待（至少）两件合理的事情。第一，当然是让所有人都开始思考。在开始思考后，过了一会儿，或许在回家的路上，或许在洗澡时，又或许在遛狗时，一个绝妙的点子会在你的脑海中迸发出来。当然，也或许不会。但据我们所知，神秘的大脑在我们最不经意间做了大量的思考。</p><p>第二，当有具体的东西可以讨论时，头脑风暴就有用了。比如，“我们如何改进这个？”比“让我们随便想点什么！”更好。又如，给出一个半成形的点子并让其他人来充实它是相当有用的。比起创作者，人们更适合当评论家，不是吗？</p><h3 id="收集概念艺术和音乐以创造情绪目标"><a href="#收集概念艺术和音乐以创造情绪目标" class="headerlink" title="收集概念艺术和音乐以创造情绪目标"></a>收集概念艺术和音乐以创造情绪目标</h3><p>作为头脑风暴的替代品，我们发现收集一些具有个人意义的艺术和音乐特别有用。人们评论说，许多游戏如“Gravity Head”和“On a Rainy Day”创造了引人入胜的氛围并具有强烈的情感吸引力。这不是偶然的。在许多情况下，配乐和初期美术共同创造了一种感受，推动了玩法、故事和最终美术的设定。</p><p>Mr. Gabler：“《黏黏世界》的想法是我在回家路上听 Astor Piazzolla 的《Tango Apasionado》开头时产生的，我脑海中浮现出一个日落时分小镇的朦胧景象，每个人都离开家，搬出椅子、桌子和任何他们能找到的东西，在市中心建造一座巨塔。我不知道确切原因，但他们想往上爬，再往上爬——但他们不是很好的土木工程师，所以你需要帮助他们。最终的原型变得更欢快一些，我把音乐换成了 Piazzolla 的更欢快的《Libertango》。这是一个初始情绪目标造就了整个游戏的例子。”</p><p><img src="/images/others/translation/how_to_prototype_seven_day/7_goo_prototype.jpg" alt="探戈音乐和爬得越来越高的小人……"></p><h3 id="在脑中模拟——做原型的原型"><a href="#在脑中模拟——做原型的原型" class="headerlink" title="在脑中模拟——做原型的原型"></a>在脑中模拟——做原型的原型</h3><p>这真的很简单！你要做的就是想象你的游戏玩家说：“哇！”然后倒推并填补空白。是什么让他们享受你的游戏？他们感受到了什么？游戏中是什么让他们有了这种体验？</p><p>对我们的那些最成功的游戏来说，我们并不对它们变得好玩感到意外——在最好的情况下，我们在接触任何一行代码之前就知道这个想法是靠谱的，因为我们已经在思维里模拟过了游戏。反之亦然，没有一个游戏是出乎意料地成功的，我们总是先知先觉。（可惜的是，这并没有阻止我们去追求那些半生不熟的想法。）</p><p>在你的脑海中模拟也使得最终原型的开发变得非常容易，因为你会确切地知道你将要做什么。你不会为了在设计上“试错”浪费时间修改代码。</p><p>一位团队成员承认：”我经常在一周的前3、4天里，只是为了’灵感’而闲逛看 O-Zone 音乐视频、倒挂在懒人沙发上听音乐、偶尔运行一些糟糕的大脑模拟。最后周四或周五来临时，我会感到恐慌，因为我仍然不知道周一要交什么，所以我就会采纳最强的那个想法，并根据本周自己喜欢上的东西进行调整，直到感觉像一个有趣的游戏，然后接下来几天熬夜写代码和画画。对我来说（我想对我们所有人来说），花在’前期制作’上的日子无疑比花在实际开发上的日子更有价值。”</p><p><img src="/images/others/translation/how_to_prototype_seven_day/8_rainy_day.jpg" alt="&quot;On a Rainy Day&quot;的早期纸上原型——在脑中模拟时很有帮助。"></p><h2 id="开发：没人知道你是怎么做的，也没人在乎"><a href="#开发：没人知道你是怎么做的，也没人在乎" class="headerlink" title="开发：没人知道你是怎么做的，也没人在乎"></a>开发：没人知道你是怎么做的，也没人在乎</h2><p>一旦你有了一个好点子，这里有一些技巧可以让你迅速做出一个 demo！</p><h3 id="先做玩具"><a href="#先做玩具" class="headerlink" title="先做玩具"></a>先做玩具</h3><p>从核心机制开始。无论是弹簧系统、群体行为、重力等等，花不了几个小时就能把游戏主题做出来。这个“玩具”应该是游戏的核心机制。它不需要任何目标或决策，没有输赢，只是一个好玩的东西。</p><p>Mr. Gabler：“对《Super Tummy Bubble》来说，‘玩具’只是一堆悬浮在小容器里的泡泡。我玩了一会儿这个玩具，把泡泡扔来扔去，然后调整了一下直到我感觉手指戳进泡泡里很有趣。之后，是时候加入一些游戏性了。在这个游戏里，游戏性包括寄生着不同虫子的泡泡、‘戳破’的概念、‘连锁’的概念、分数计数器等。”</p><p><img src="/images/others/translation/how_to_prototype_seven_day/9_left_and_right.jpg" alt="&quot;Super Tummy Bubble&quot;——玩具（左）vs. 最终原型（右）。"></p><h3 id="如果能偷懒，那就偷懒"><a href="#如果能偷懒，那就偷懒" class="headerlink" title="如果能偷懒，那就偷懒"></a>如果能偷懒，那就偷懒</h3><p>这可以说是这个项目最重要的教训之一。通常“正确”的解决方案并非最佳解决方案。有策略地偷懒会为你节省时间和金钱；它会让你的游戏更快，你的牙齿更白。大胆地、经常地偷懒！如果一个简单的阴影和烘焙纹理同样有效，就不要设置复杂的光照和阴影（《Darwin Hill》）。如果你可以用同样的效果蒙混过关，就不要为了分析用户的绘画而设置复杂的模式识别系统（《Suburban Brawl》）。当快速拉伸的位图能更快更容易地达到同样效果时，就不要绘制样条曲线或创建自己的矢量艺术库（《黏黏世界》）。我们发现，这条规则也是生活中一条极好的通用法则。懒人们，注意了。</p><p><img src="/images/others/translation/how_to_prototype_seven_day/10_left_mid_right.jpg" alt="&quot;Darwin Hill&quot;、&quot;Suburban Brawl&quot;、&quot;黏黏世界&quot;——都是假的，而且没人注意到。嘘！"></p><h3 id="及时止损，割舍心头之爱"><a href="#及时止损，割舍心头之爱" class="headerlink" title="及时止损，割舍心头之爱"></a>及时止损，割舍心头之爱</h3><p>在项目开始时，我们有一种想要挽救一切的愿望——再多花一点时间和精力，一个糟糕的游戏肯定会变成天才之作！我们有一个这样的注定失败的原型——它始于一个美丽的弹簧系统。它能挤压和拉伸，让你想抓住它并到处拉扯，但它就是没有变成一个引人入胜的游戏。最初的弹簧系统机制只花几个小时就创建好了，但随后它却耗费了整整一周的编码和重构时间。这是一次可悲的尝试，试图强行将这个机制变成一个游戏。</p><p>快速识别走不通的想法、及时止损并继续前进非常重要。我们发现，顺其自然比花时间试图挽救现有的东西更有价值。如果以后灵光一闪，你总可以再回来。</p><p>Mr. Kucic：“我的‘土豆’最终成为了一个在 Flash 中构建的完美的软体模拟系统，唯一的问题是它一点也不好玩。它给我带来的头痛比死亡金属还多。我浪费了一周时间，而它甚至都不能动。你得知道什么时候该继续，什么时候该放弃。”</p><p><img src="/images/others/translation/how_to_prototype_seven_day/11_circle.png" alt="&quot;马特的土豆&quot;——沐浴在它的荣耀中。"></p><h3 id="漂亮的包装无法挽救糟糕的设计（或者说，“烂泥扶不上墙”）"><a href="#漂亮的包装无法挽救糟糕的设计（或者说，“烂泥扶不上墙”）" class="headerlink" title="漂亮的包装无法挽救糟糕的设计（或者说，“烂泥扶不上墙”）"></a>漂亮的包装无法挽救糟糕的设计（或者说，“烂泥扶不上墙”）</h3><p>我们发现游戏玩家比你想象的要聪明，他们能看穿你是否在耍花招。如果游戏玩法很糟糕，那就没救了——世界上所有的美术、音乐和联动都无法让它成为一个好游戏。这就像是给一个无趣的游戏机制加入最新的3D动画电影角色，没人会被糊弄。</p><p>Mr. Gray：“《Spin to Win》的‘游戏玩法’是旋转你的鼠标来转动多个圆圈。为了掩盖它不好玩的事实，我用60年代《Bewitched》风格的艺术和音乐给游戏做了漂亮的包装。但无论我怎么打磨这个游戏，它都有趣不起来。尽管我付出了所有的爱，它还是很快就成了网站上最被讨厌的游戏之一。”</p><p><img src="/images/others/translation/how_to_prototype_seven_day/12_spin_to_win.jpg" alt="&quot;Spin to Win&quot;——盛装打扮却无处可去。"></p><h3 id="但整体美学很重要！合理运用美术、音效和音乐"><a href="#但整体美学很重要！合理运用美术、音效和音乐" class="headerlink" title="但整体美学很重要！合理运用美术、音效和音乐"></a>但整体美学很重要！合理运用美术、音效和音乐</h3><p>这实际上与我们最初的一个假设相反。我们当时认为美术和音效根本不会对原型有影响，但我们错了！玩一个精心打磨的游戏实际上比玩有着完全相同的代码，但艺术粗糙、音效差的游戏感觉更好。不过，重要的是要做出以下区分——单纯打磨美学无法挽救糟糕的设计，但它确实有能力让一个好游戏变得更好玩。这并不意味着你需要极其精美的图形或环绕声。这只是说你可以通过将所有东西紧密结合起来而受益。记住，即使是“蹩脚”也可以是一种紧密结合的美学，只要你以正确的方式呈现它。</p><p><img src="/images/others/translation/how_to_prototype_seven_day/13_unrealeased_tree.jpg" alt="一个未发布的原型——不复杂的美术也能在构图上感觉坚实。"></p><h3 id="没人关心你的代码质量"><a href="#没人关心你的代码质量" class="headerlink" title="没人关心你的代码质量"></a>没人关心你的代码质量</h3><p>再次强调，值得注意的是，一个伟大的工程师不一定能成为一个伟大的原型制作者。”正确”和”可复用”的方案通常不是我们在快速、一次性代码中所寻求的。对于每个问题，你应该能够想出一大堆解决方案，并选择那个能最快做完的方案。用户永远不会看到你伟大的代码，他们也不在乎。</p><p>Mr. Shodhan：“代码的过度设计很容易让我们做出一些通用工具或技术演示，但他们并不可玩。这就像是一个摇滚明星沉浸在自己的艺术中，而观众在打哈欠！对‘进化’那个主题，我用细分曲面和卡通渲染效果做了一个程序，通过杂交祖先树来进化3D模型。这里有很多很酷的技术，但完全没有游戏性！”</p><p><img src="/images/others/translation/how_to_prototype_seven_day/14_evolution_tree.png" alt="&quot;进化树&quot;——所有这些技术加起来并不等于乐趣。"></p><p><img src="/images/others/translation/how_to_prototype_seven_day/15_rubber_ball.jpg" alt="一个橡胶球。小心，3D技术！"></p><h2 id="通用的技巧：关于营造多汁乐趣的教程"><a href="#通用的技巧：关于营造多汁乐趣的教程" class="headerlink" title="通用的技巧：关于营造多汁乐趣的教程"></a>通用的技巧：关于营造多汁乐趣的教程</h2><p>除了在原型制作方面吸取了惨痛的教训外，我们还偶然发现了一些通用的准则。以下是一些显著增加“乐趣”的准则。</p><h3 id="复杂不一定有趣"><a href="#复杂不一定有趣" class="headerlink" title="复杂不一定有趣"></a>复杂不一定有趣</h3><p>如果人类以“球和平面”这个主题的变体来娱乐自己数千年，我们可能在这些新奇的视频游戏上做得太过头了。我们完全可能用基本的元素来获得乐趣。想想《俄罗斯方块》、《吃豆人》以及任何经典的街机游戏。就像罗密欧与朱丽叶的爱情故事原型一样，这些游戏的机制如此之好，以至于几十年后我们仍在使用它们。镜头光晕、凹凸贴图、泛光和其他惊人的新技术是不错，但它们不会让你的游戏更有趣。用一个简单的原型向自己证明你的核心机制值得一做，在你确信之后，把它变得漂亮。</p><h3 id="创造一种拥有感来让玩家不断重玩"><a href="#创造一种拥有感来让玩家不断重玩" class="headerlink" title="创造一种拥有感来让玩家不断重玩"></a>创造一种拥有感来让玩家不断重玩</h3><p>我们偶然发现，最具重玩价值的游戏是那些与创造或自定义相关的游戏。例如，“用手和雨伞制作一棵令人毛骨悚然的树”，或者“画你自己的房子”，或者“建造你自己的塔”，或者“进化你自己的突变生物种族”。显然我们能在许多地方中见到这种现象——游戏里的捏脸功能、自定义的手机铃声、乃至那些“与众不同，表达自我”的广告。所以，跳上这趟潮流吧！创造一种拥有感，让他们不断重玩。</p><p><img src="/images/others/translation/how_to_prototype_seven_day/16_darwin_hill.jpg" alt="&quot;Darwin Hill&quot;——每个人与众不同。"></p><h3 id="“实验性”不意味着”复杂”"><a href="#“实验性”不意味着”复杂”" class="headerlink" title="“实验性”不意味着”复杂”"></a>“实验性”不意味着”复杂”</h3><p>在项目早期，我们制作的许多游戏都太过复杂。它们的用户界面令人困惑，而且按键映射到的动作也不自然或不直观。除非我们能最小化玩家理解游戏之前的疑惑时间，否则玩家会感到沮丧，再也不玩这个游戏，甚至再也不来我们网站。幸运的是，我们发现既可以做到”实验性”，又可以保持易于理解。</p><p>Mr. Shodhan：“我的第一轮游戏‘Spaceball Munch’是老游戏‘Gorillas’的3D版本，在那个游戏里，你指定一个角度和速度，让一个猩猩向另一个猩猩扔香蕉。现在你不仅在3D环境中，更是用着弧形视角，还在一个球形场地上进行游戏。所以你要考虑两个角度和一个速度。另外，它现在也不再是一个离散的回合制游戏，而是需要控制一个连续的粒子流，同时必须击中所有这些移动的物体。这张截图展示了这种毫无意义的复杂度”</p><p><img src="/images/others/translation/how_to_prototype_seven_day/17_spaceball_munch.jpg" alt="&quot;Spaceball Munch&quot;——我们怎么能知道？！"></p><h3 id="朝着一个明确定义的目标前进"><a href="#朝着一个明确定义的目标前进" class="headerlink" title="朝着一个明确定义的目标前进"></a>朝着一个明确定义的目标前进</h3><p>人们很容易忘记设置一个明确定义的目标。没有游戏目标，一个原型就只是一个玩具，而不是一个游戏。出于某种原因，人们似乎喜欢有失败的机会。一个目标可以是任何事情——比如“在x时间内收集x个小部件”，或者“保持系统稳定”，或者“在不碰到任何坏东西的情况下穿越一个空间”。但找到一个不让人觉得牵强的目标还是很难的（比如时限一般就很牵强）。我们发现，最好的目标是游戏玩法中固有的部分，比如在《黏黏世界》中，隐含的目标就是简单地“向上建造”。</p><p><img src="/images/others/translation/how_to_prototype_seven_day/18_tower_of_goo.jpg" alt="&quot;黏黏世界&quot;——朝着一个目标……以及更远的地方建造！"></p><h3 id="让它多汁！"><a href="#让它多汁！" class="headerlink" title="让它多汁！"></a>让它多汁！</h3><p>多汁（Juicy）是我们用来形容持续且丰富的用户反馈的术语。一个多汁的游戏元素在你触摸它时会弹跳、扭动、喷射并发出一点声音。一个多汁的游戏很活泼，它对你做的每件事都有反应——一点点输入就会产生大量的回应和连锁反应，这让玩家感觉自己掌控着世界。它也在互动时不断让玩家知道自己正在做什么，引导他们了解游戏规则。</p><p>你可能经历过的一些多汁的例子可能包括：</p><ul><li>《Alien Hominid》：非常夸张的敌人爆炸和血液飞溅。</li><li>《马里奥兄弟》：在一个充满金币的房间里弹跳，叮当声很让人满足。</li><li>弹珠机：一股永无止境的球流全在你的控制之下。</li><li>《超级方块战士2 Turbo》：连击时，动画和特效层出不穷。</li></ul><p><img src="/images/others/translation/how_to_prototype_seven_day/19_left_mid_right.jpg" alt="多汁的感觉很棒！你简直停不下来。"></p><h2 id="最后的想法"><a href="#最后的想法" class="headerlink" title="最后的想法"></a>最后的想法</h2><p>这次关于实验性游戏项目的团队合作是一件非常愉快的事。我们希望下次当你尝试一些新的或有点疯狂的东西时，这些建议和技巧能对你有所帮助。谁知道呢，你今天早上有的那个小想法可能就是下一个神作。召集一些朋友或者单干，快去尝试并制作原型吧！你可能会给自己一个惊喜。</p><p>我们的顾问友好地指出，“快速原型可能很像怀一个孩子。没人指望每次都能赢，但你总是学到新东西，而且这通常很有趣！”</p><p>祝你原型制作愉快！</p><p><img src="/images/others/translation/how_to_prototype_seven_day/20_final.jpg" alt=""></p><p>此页面转载自 Gamasutra 网站：<br><a href="http://www.gamasutra.com/features/20051026/gabler_01.shtml">http://www.gamasutra.com/features/20051026/gabler_01.shtml</a></p><h2 id="便捷清单！"><a href="#便捷清单！" class="headerlink" title="便捷清单！"></a>便捷清单！</h2><ol><li><p>准备：快速是一种心态</p><ul><li>拥抱失败的可能性——它鼓励创造性冒险</li><li>强制缩短开发周期（更多时间 != 更高质量）</li><li>对创造的约束让你更想创造</li><li>组建一支优秀的团队和一位客观的顾问——心态与才华同等重要</li><li>并行开发以最大化效果</li></ul></li><li><p>设计：头脑风暴的神话和创造力</p><ul><li>正式头脑风暴的成功率为 0%</li><li>收集概念艺术和音乐以创造情绪目标</li><li>在脑中模拟——做原型的原型</li></ul></li><li><p>开发：没人知道你是怎么做的，也没人在乎</p><ul><li>先做玩具</li><li>如果能偷懒，那就偷懒</li><li>及时止损，割舍心头之爱</li><li>漂亮的包装无法挽救糟糕的设计（或者说，”烂泥扶不上墙”）</li><li>但整体美学很重要！合理运用美术、音效和音乐</li><li>没人关心你的代码质量</li></ul></li><li><p>通用的技巧：关于营造多汁乐趣的教程</p><ul><li>复杂不一定有趣</li><li>创造一种拥有感来让玩家不断重玩</li><li>“实验性”不意味着”复杂”</li><li>朝着一个明确定义的目标前进</li><li>让它多汁！</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;翻译自 &lt;a href=&quot;http://miami.lgrace.com/documents/How%20to%20Prototype%20a%20Game%20in%20Under%207%20Days.pdf&quot;&gt;How to Prototype a Game in Un</summary>
      
    
    
    
    <category term="杂谈" scheme="http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    <category term="翻译" scheme="http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/%E7%BF%BB%E8%AF%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Lab 2.1 系统调用流程——以sleep为例</title>
    <link href="http://rinevard.github.io/wiki/learning/open-course/MIT-6.S081/Labs/lab2_1-syscall_process/"/>
    <id>http://rinevard.github.io/wiki/learning/open-course/MIT-6.S081/Labs/lab2_1-syscall_process/</id>
    <published>2025-10-15T08:02:38.000Z</published>
    <updated>2025-10-19T03:44:03.330Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道应用程序在User mode下运行，而系统函数的执行需要Supervisor mode，那在系统调用时，User mode是怎么进入Supervisor mode的呢？我们以sleep的执行为例，看看都发生了什么。首先我们用 <code>git checkout util</code> 切换到 util 分支上。</p><p>在此之前，我们要先简介一下<strong>ECALL</strong>指令和<strong>stvec</strong>（Supervisor Trap Vector Base Address Register）寄存器。</p><p>ECALL 会触发一个异常，如果我们在用户态触发这个异常，程序计数器 pc 就会根据 stvec 进行跳转，到达异常处理处。</p><p>以下是 <a href="https://www.scs.stanford.edu/~zyedidia/docs/riscv/riscv-privileged.pdf">risc-v 手册</a> 对 ECALL 的解释：</p><blockquote><p>When executed in U-mode, S-mode, or M-mode, it generates an environment-call-from-U-mode exception, environment-call-from-S-mode exception, or environment-call-from-M-mode exception, respectively, and performs no other operation.</p><p>如果在 U-mode 执行，ECALL 指令会产生一个来自 U-mode 的环境调用异常；如果在 S-mode 执行，则产生来自 S-mode 的环境调用异常；如果在 M-mode 执行，则产生来自 M-mode 的环境调用异常。</p></blockquote><p>以下是 risc-v 手册对 stvec 寄存器的简介：</p><p><img src="/images/learning/open-course/MIT-6.S081/labs/lab2_1-syscall_process/stvec.png" alt=""></p><p>BASE是4字节对齐的（RISC-V 手册 P80），所以在MODE == 0时，我们跳转到的地址是 <code>(stvec &gt;&gt; 2) &lt;&lt; 2</code>，而由于 MODE == 0，这个值就是 stvec ；在MODE == 1时，我们转到的地址是 <code>(stvec &gt;&gt; 2) &lt;&lt; 2 + 4*cause</code></p><p>接下来我们就可以开始看看系统调用时究竟发生了什么！我们会以sleep为例。</p><p>首先我们打开gdb-multiarch（参考 Note 0 的”用终端调试“），然后用 <code>set prompt \\001\\033[1;33m\\002(gdb) \\001\\033[0m\\002</code> 来高亮 “(gdb)” 以方便观察自己的输入。</p><p>用 <code>file user/_sleep</code> 切换到用户符号表，接着用<code>c</code>运行到xv6的shell启动。</p><p>观察右边的终端可以看到shell已经成功启动了。</p><p><img src="/images/learning/open-course/MIT-6.S081/labs/lab2_1-syscall_process/debug_start.png" alt=""></p><p>然后我们在gdb里按下ctrl+c来中断，并用 <code>b main</code> 设置断点，再使用 <code>layout split</code> 让gdb显示出源码和汇编代码。接下来我们在gdb里输入 <code>c</code> 以让xv6继续执行，否则xv6的shell会处于暂停状态，不能处理输入。</p><p>然后在xv6的shell里执行 <code>sleep 1</code> ，它会在断点处停下。</p><p>观察左边的gdb，可以看到它停在了sleep.c的main函数。</p><p><img src="/images/learning/open-course/MIT-6.S081/labs/lab2_1-syscall_process/sleep_main.png" alt=""></p><p>随便执行一下直到到达sleep这行，<code>n</code> 表示执行一行c语言，<code>si</code>表示执行一个汇编语句。</p><p><img src="/images/learning/open-course/MIT-6.S081/labs/lab2_1-syscall_process/sleep_jal_atoi.png" alt=""></p><p>我们用<code>si</code>进入atoi，然后交替着用<code>n</code>和<code>si</code>，在快到return时用<code>si</code>，就能离开atoi回到sleep.c。</p><p>观察左边的gdb，和上图相比，虽然c语言的位置没有变化，但汇编代码的位置是有变化的。</p><p><img src="/images/learning/open-course/MIT-6.S081/labs/lab2_1-syscall_process/sleep_jal_sleep.png" alt=""></p><p>之后用<code>si</code>，会发现我们跳转到了 <code>usys.S</code>，它把sleep的系统调用号放到寄存器a7里，然后借助ecall来执行系统调用。</p><p>观察左边的gdb发现我们已经进入了<code>usys.S</code></p><p><img src="/images/learning/open-course/MIT-6.S081/labs/lab2_1-syscall_process/usys_enter.png" alt=""></p><p>如果我们直接用几个<code>si</code>，会发现<code>ecall</code>并没有像<code>jal</code>之类的跳转语句一样带我们到一些神奇的地方，而是直接到了下一行。这是因为<code>ecall</code>不是跳转，而是抛出了一个异常，内核自动处理了异常。</p><p>这样看来，我们要找到这个异常的开始处并设置断点才行。还记得我们之前说过<code>ecall</code>抛出异常时pc会跳转到哪里吗？答案是它会根据寄存器stvec的值进行跳转。让我们借助<code>p /x $stvec</code>看看stvec的值。</p><p>观察左边的gdb，发现stvec的值是 0x3ffffff000，至少在我这里是这样。</p><p><img src="/images/learning/open-course/MIT-6.S081/labs/lab2_1-syscall_process/print_stvec.png" alt=""></p><p>回顾一下stvec寄存器的结构和功能，会发现执行ecall后，pc会跳转到BASE所在的地址。我们之前说过，BASE是4字节对齐的（RISC-V 手册 P80），所以在MODE == 0时，我们跳转到的地址是 <code>(stvec &gt;&gt; 2) &lt;&lt; 2</code>，而由于 MODE == 0，这个值就是 stvec。</p><p><img src="/images/learning/open-course/MIT-6.S081/labs/lab2_1-syscall_process/stvec.png" alt=""></p><p>我们接下来把断点设置在这个值，然后用<code>si</code>到达<code>ecall</code>语句处</p><p>观察左边的gdb，我们现在已经在<code>ecall</code>这里了。</p><p><img src="/images/learning/open-course/MIT-6.S081/labs/lab2_1-syscall_process/break_ecall_target.png" alt=""></p><p>如果我们的操作正确，接下来的<code>si</code>会触发一个异常导致我们跳转到 0x3ffffff000 并触发断点，希望我们没有翻车~</p><p>观察左边的gdb，发现我们成功跳转到了一个未知的地方！</p><p>按我的理解，由于我们在U-mode下执行ecall以触发异常，所以我们现在已经进入了S-mode。不过我翻了很多资料还是没有找到能明确支持这一点的证据（也没有找到明确反对的证据），所以我保留我的观点。</p><p><img src="/images/learning/open-course/MIT-6.S081/labs/lab2_1-syscall_process/ecall.png" alt=""></p><p>总之一切顺利！让我们暂停一下，想想这个 0x3ffffff000 的地址代表什么。在内核启动时通过<code>file kernel/kernel</code> 加载内核符号表并在<code>usertrapret</code>设置断点，我们可以发现 0x3ffffff000 这个地址和 <code>kernel/trap.c</code> 里的<code>trampoline_uservec</code> 相等。</p><p>trampoline是什么？trampoline是在进程虚拟内存的顶部的一块空间，映射到的物理地址存放着跳转进和跳转出内核的代码。看起来在做系统调用时，我们通过ecall跳转进内核。这样一切都说得通了~</p><p>让我们打开trampoline.S，对比左边gdb显示的代码和右边的trampoline.S，会发现它们确实能对上！</p><p>好吧，也不是完全能对上，你会注意到右边的 <code>li a0,TRAPFRAME</code> 在左边似乎对应了三条语句，这是怎么回事呢？实际上，<code>li</code> 是RISC-V 汇编中的伪指令，实际执行时，<code>li</code> 会被汇编器翻译为一条或多条真正的 RISC-V 指令。</p><p>嗯，这样就能对上了！</p><p><img src="/images/learning/open-course/MIT-6.S081/labs/lab2_1-syscall_process/trapoline_enter.png" alt=""></p><p>读一读trampoline.S，我们发现它会把用户进程的寄存器等信息保存到trapframe里，然后跳转到内核的usertrap函数。</p><p>因此接下来我们要用<code>file kernel/kernel</code>把符号表切换到kernel，再用<code>si n</code> 来一次执行多条汇编语句，直到指令<code>jr</code>处：</p><p>比较左边和右边，发现它们的汇编代码确实能对上，接下来我们要准备跳转了。</p><p><img src="/images/learning/open-course/MIT-6.S081/labs/lab2_1-syscall_process/trapoline_jump.png" alt=""></p><p>陷阱，启动！</p><p><img src="/images/learning/open-course/MIT-6.S081/labs/lab2_1-syscall_process/usertrap_enter.png" alt=""></p><p>如果你发现你的gdb没有顺利显示出c语言代码，可能是你忘记切换符号表到内核了，用<code>file kernel/kernel</code>来切换，然后补一个<code>si</code>就能显示出来了。</p><p>由于一切正常，我们可以一路按<code>n</code>直到到达syscall这里。</p><p>比较左边和右边的代码，它们是能对应上的。接下来让我们准备进入<code>syscall</code></p><p><img src="/images/learning/open-course/MIT-6.S081/labs/lab2_1-syscall_process/usertrap_jump.png" alt=""></p><p>我们用<code>s</code>进入syscall函数。<code>n</code>和<code>s</code>都会执行当前行，不过如果当前行是函数，<code>n</code>不会进入函数，而<code>s</code>会。</p><p><img src="/images/learning/open-course/MIT-6.S081/labs/lab2_1-syscall_process/syscall_enter.png" alt=""></p><p>syscall函数从trapframe中取出系统调用号，然后调用它。还记得吗，我们调用系统函数时先进入了usys.S，然后把系统调用号保存到了a7。之后由于我们转入了内核，我们在trapoline.S里把所有的用户空间的寄存器都保存到了trapframe中。</p><p>总之我们在这里调用了sys_sleep，我们进入它看看。</p><p><img src="/images/learning/open-course/MIT-6.S081/labs/lab2_1-syscall_process/syssleep_enter.png" alt=""></p><p>可以发现它就是真正干活的地方！它非常忠实地执行了sleep的逻辑。</p><p>我们可以注意到 n 就是存放着我们最开始传入的参数的变量，内核通过argint来找到我们一开始传入的参数。argint的思路和我们之前找到系统调用号类似，也是从trapframe中找到存放着传入参数的寄存器。</p><p>让我们继续往后，看看在执行完逻辑以后发生了什么吧。</p><p><img src="/images/learning/open-course/MIT-6.S081/labs/lab2_1-syscall_process/syssleep_return.png" alt=""></p><p>回到<code>usertrap</code>，我们一路往下到达<code>usertrapret</code>，然后用<code>s</code>进入它。</p><p><img src="/images/learning/open-course/MIT-6.S081/labs/lab2_1-syscall_process/usertrapret_enter.png" alt=""></p><p>看函数名上面的注释就能发现它会带我们回到用户空间。</p><p>我们用<code>n</code>一路运行到底，再看看注释，发现注释说我们会跳转到trampoline.S。</p><p>观察左边的gdb，<code>p /x trampoline_userret</code> 没有打印值是因为trampoline_userret被编译器优化掉了，我们要手动把它的表达式写出来再打印，总之我们打印出了 0x3ffffff09c。</p><p>在那里设个断点，然后准备继续。</p><p><img src="/images/learning/open-course/MIT-6.S081/labs/lab2_1-syscall_process/usertrapret_break.png" alt=""></p><p>多按几个<code>si</code> 到达跳转语句处，不出意外的话再用一次<code>si</code> 就会带我们进入trapoline.S的userret部分了。</p><p><img src="/images/learning/open-course/MIT-6.S081/labs/lab2_1-syscall_process/usertrapret_jump.png" alt=""></p><p>一切的一切都符合预期，我们成功进入了trampoline.S。</p><p>对比左右的汇编代码可以发现它们是对应的。与之前相同，<code>li</code>被展开了。</p><p><img src="/images/learning/open-course/MIT-6.S081/labs/lab2_1-syscall_process/trapoline_enter_again.png" alt=""></p><p>然后我们一路按<code>si</code>到达<code>sret</code>语句处。<code>sret</code>会做什么呢？让我们看看riscv手册：</p><blockquote><p>The SRET instruction is used to return from a trap taken into S-mode. […] When executing SRET, the privilege level is set to the value in the SPP field of the sstatus register; […] the pc is set to the value stored in the sepc register.</p><p><code>SRET</code> 指令用于从进入 S-mode 的陷阱中返回。[…] 当执行 <code>SRET</code> 时，特权级别被设置为<code>sstatus</code> 寄存器中 <code>SPP</code> 字段的值；[…] 程序计数器 pc 被设置为存储在 <code>sepc</code> 寄存器中的值。</p></blockquote><p>我们借助 <code>p /x sepc</code> 打印这个寄存器的值看看~（请忽视左图里我之前写成spec的手误）</p><p><img src="/images/learning/open-course/MIT-6.S081/labs/lab2_1-syscall_process/trapoline_ret_user.png" alt=""></p><p>0x342是什么？如果你记忆力很好的话，会发现它恰好就是usys.S里的<code>ret</code>那行！</p><p>（这鬼才记得住啊喂）</p><p>总之我们看看之前的截图吧，我们可以发现0x342确实是ret那行，就是下面的截图中高亮的汇编代码下面那行。</p><p><img src="/images/learning/open-course/MIT-6.S081/labs/lab2_1-syscall_process/hello_world_again.png" alt=""></p><p>我们用<code>b *0x342</code>设个断点在那里，然后执行<code>si</code> ，我们回到了用户空间！同时，<code>sret</code>也让我们回到了U-mode。</p><p><img src="/images/learning/open-course/MIT-6.S081/labs/lab2_1-syscall_process/return_to_user.png" alt=""></p><p>用<code>file user/_sleep</code>切换符号表，再执行<code>si</code>，我们回来了。</p><p><img src="/images/learning/open-course/MIT-6.S081/labs/lab2_1-syscall_process/im_back.png" alt=""></p><p>至此，我们就完成了一个完整的系统调用。</p><p>总结一下，当我们进行系统调用时，我们先进入usys.S，然后ecall触发异常并跳转到trapoline.S的uservec处，之后到达trap.c的usertrap函数，它会调用syscall函数以执行系统函数的逻辑，执行完后进入usertrapret函数，再跳转到trapoline.S的userret处，最后回到usys.S，再回到用户的代码里。</p><p>第一次跳转到trapoline.S主要是保存了用户的各个寄存器到trapframe，第二次跳转是从trapframe中恢复了这些寄存器。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们知道应用程序在User mode下运行，而系统函数的执行需要Supervisor mode，那在系统调用时，User mode是怎么进入Supervisor mode的呢？我们以sleep的执行为例，看看都发生了什么。首先我们用 &lt;code&gt;git checkout u</summary>
      
    
    
    
    <category term="公开课" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"/>
    
    <category term="MIT-6.S081" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/MIT-6-S081/"/>
    
    <category term="Labs" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/MIT-6-S081/Labs/"/>
    
    
  </entry>
  
  <entry>
    <title>Lab 2 System calls</title>
    <link href="http://rinevard.github.io/wiki/learning/open-course/MIT-6.S081/Labs/lab2-syscall/"/>
    <id>http://rinevard.github.io/wiki/learning/open-course/MIT-6.S081/Labs/lab2-syscall/</id>
    <published>2025-10-15T07:54:38.000Z</published>
    <updated>2025-10-15T08:10:39.024Z</updated>
    
    <content type="html"><![CDATA[<p>在开始之前，我们回顾一下怎么启动调试模式：</p><p>在一个终端里执行 <code>make qemu-gdb</code> ，<code>make qemu-gdb CPUS=1</code> 可以只使用一个核心，比起多线程更便于调试。</p><p>在另一个终端里执行 <code>gdb-multiarch kernel/kernel</code> ，进入 gdb 后执行 <code>target remote localhost:26001</code>，这里的端口号不一定是 26001，看 <code>make qemu-gdb CPUS=1</code> 的打印结果就行。</p><p>这样就进入调试模式了。另外，我习惯用 <code>set prompt \001\033[1;33m\002(gdb) \001\033[0m\002</code> 来高亮 “(gdb)” 这几个字。</p><h1 id="Using-gdb"><a href="#Using-gdb" class="headerlink" title="Using gdb"></a>Using gdb</h1><p>lab 开头让我们熟悉一下 gdb 的使用。启动调试模式以后按部就班就能完成，我们这里记录一下常用的一些 gdb 指令：</p><pre class="line-numbers language-none"><code class="language-none">c 或 continue - 继续执行直到遇到下一个断点n 或 next - 单步执行,会跳过函数调用s 或 step - 单步执行,会进入函数内部si - 执行一条汇编指令finish - 运行到当前函数返回为止p &#x2F;x $mstatus - 以十六进制打印CPU当前模式backtrace（缩写bt） - 显示函数调用栈set prompt \\001\\033[1;33m\\002(gdb) \\001\\033[0m\\002 - 高亮(gdb)until - 运行到指定行号为止<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="System-call-tracing"><a href="#System-call-tracing" class="headerlink" title="System call tracing"></a>System call tracing</h1><p>这道题让我们实现一个系统调用，按着 hints 按部就班就能做掉。唯一要注意的是在 syscall 里打印 trace 相关的内容时要把系统调用的返回值 ret 从原本的 <code>uint64</code> 转换为 <code>long long</code>，否则对那些可能返回 -1 的系统调用，我们无法正确打印 -1.</p><p>在照着 hints 实现之后，看看系统调用是如何进行的也是更有趣的事情。我在 <a href="/wiki/learning/open-course/MIT-6.S081/Labs/lab2_1-syscall_process/" title="Lab 2.1 系统调用流程——以sleep为例">Lab 2.1 系统调用流程——以sleep为例</a> 中写得还挺详细的，这里不多赘述细节。</p><p>简而言之，当我们进行系统调用时：</p><ol><li>进入由 <code>usys.pl</code> 生成的 <code>usys.S</code> </li><li>ecall 触发异常并跳转到 <code>trapoline.S</code> 的 uservec 处</li><li>到达 <code>trap.c</code> 的 usertrap 函数，它会调用 syscall 函数以执行系统函数的逻辑</li><li>系统函数执行完成后进入usertrapret函数</li><li>跳转到 <code>trapoline.S</code> 的userret处</li><li>最后回到 <code>usys.S</code></li><li>回到用户的代码里。</li></ol><p>让我们根据这个流程来看看 hints 的每一步的原因：</p><ol><li>把 <code>$U/_trace</code> 加入到 Makefile 中是为了编译时识别到 <code>trace</code>。</li><li>在 <code>user.h</code> 里加入 <code>trace</code> 是为了让用户的 <code>trace.c</code> 识别到 <code>trace</code> 这个函数。</li><li>在 <code>usys.pl</code> 里加入 <code>trace</code> 是为了让 <code>usys.pl</code> 在生成的 <code>usys.S</code> 里加入 <code>trace</code> 相关的内容，它是我们进行系统调用时的第一站。</li><li>在 <code>syscall.h</code> 里加入 <code>trace</code> 是因为我们通过寄存器里存储的整数确定调用的系统函数，很多地方都使用了这个文件里定义的常量。</li><li>在 <code>syscall.c</code> 和 <code>sysproc.c</code> 里加入的函数则是实际的逻辑部分，由 syscall 函数调用。</li></ol><h1 id="Attack-xv6"><a href="#Attack-xv6" class="headerlink" title="Attack xv6"></a>Attack xv6</h1><p>在 xv6 的 syscall 分支上有一个漏洞——进程被回收后，它曾经使用的物理内存不会被重置为垃圾数据，而是保持之前的状态。所以我们可以打破内存隔离，访问别的已经被回收的进程的内存。</p><p>我们看向 <code>secret.c</code>，会发现它请求了 32 个物理页大小的物理内存，然后把一串字符放在了某个物理页的开头。所以我们只要在 <code>attck.c</code> 里也请求一些物理页，然后找到这串字符串就行。</p><p>我们先请求 32 个物理页然后依次打印出每个物理页开头的一串字符，结果如下：</p><pre class="line-numbers language-none"><code class="language-none">第 1 页: ��第 2 页: �              第 3 页:  �第 4 页: ��             第 5 页: �第 6 页: 0�             第 7 页:  �第 8 页: �              第 9 页: ��&#x2F;cea.ae第 10 页: @�7�G�������f���13��fv␦3              第 11 页: P�#4��&quot;�����&#96;Bdaa��q�&quot;�                                                                                 ��第 12 页: ��� attackte              第 13 页: p�第 14 页: &#96;�            第 15 页:  ���第 16 页: ��7�G�������f���13��fv␦3              第 17 页: ��very very secret pw is: &#x2F;cea.ae第 18 页: ��            第 19 页: p�第 20 页: 0�            第 21 页: 0��第 22 页: @��           第 23 页: P��第 24 页: ��            第 25 页: ���第 26 页: P�            第 27 页: @�第 28 页: 0�            第 29 页: ��&amp;�J����lE�&#96;*&amp;�J�               第 31 页: ������?���第 32 页: ���          <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以注意到大多数都是乱码，这是因为内存里有非文本的二进制数据，它们不能被当作文本输出。</p><p>当然，我们会注意到第 17 页有 “very very secret pw is: /cea.ae”，它与 <code>secret.c</code> 写入的内容唯一的区别是少了 “my very ” 这八个字符。为什么会有八个字符的差异呢？</p><p>看向 <code>kallc.c</code> 的 <code>kfree</code>：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">kfree</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>pa<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">run</span> <span class="token operator">*</span>r<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>pa <span class="token operator">%</span> PGSIZE<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>pa <span class="token operator">&lt;</span> end <span class="token operator">||</span> <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>pa <span class="token operator">>=</span> PHYSTOP<span class="token punctuation">)</span>        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"kfree"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">LAB_SYSCALL</span></span>    <span class="token comment">// Fill with junk to catch dangling refs.</span>    <span class="token function">memset</span><span class="token punctuation">(</span>pa<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> PGSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>    r <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">run</span> <span class="token operator">*</span><span class="token punctuation">)</span>pa<span class="token punctuation">;</span>    <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kmem<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    r<span class="token operator">-></span>next <span class="token operator">=</span> kmem<span class="token punctuation">.</span>freelist<span class="token punctuation">;</span>    kmem<span class="token punctuation">.</span>freelist <span class="token operator">=</span> r<span class="token punctuation">;</span>    <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kmem<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结合 <code>struct run</code> 的定义，就能知道 <code>r-&gt;next = kmem.freelist</code> 这句语句是把一个指针放在了输入的物理地址的前八个 bytes 中。这正是之前八个字符的差异的由来。</p><p>总结一下，在运行 <code>secret.c</code> 的进程被回收后，其中包含 “my very very very secret pw is: /cea.ae” 的物理页的开头八个 bytes 被指针覆盖，所以只剩下了 “[8 bytes 指针]very very secret pw is: /cea.ae”. 所以我们多请求几个新的物理页然后遍历它们，用前缀 “very very secret pw is: ” 来匹配就行。</p><p>我们在文末会更具体地讲讲进程被回收的过程，但先让我们来看看代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">strncmp</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>str1<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>str2<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// kalloc.c 的 kfree 函数里把物理页的开头换成了一个指针.</span><span class="token comment">// 所以我们丢失了开头的 sizeof(指针) 个字符.</span><span class="token keyword">const</span> <span class="token keyword">int</span> overwrite_len <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>end<span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>prefix <span class="token operator">=</span> <span class="token string">"my very very very secret pw is: "</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> cmplen <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>prefix<span class="token punctuation">)</span> <span class="token operator">-</span> overwrite_len<span class="token punctuation">;</span>    <span class="token comment">// 遍历新插入的32个物理页</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">32</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        end <span class="token operator">=</span> <span class="token function">sbrk</span><span class="token punctuation">(</span>PGSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strncmp</span><span class="token punctuation">(</span>end <span class="token operator">+</span> overwrite_len<span class="token punctuation">,</span> prefix <span class="token operator">+</span> overwrite_len<span class="token punctuation">,</span> cmplen<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">write</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> end <span class="token operator">+</span> <span class="token number">32</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里把内容写进文件描述符 2 是因为 <code>attacktest.c</code> 里开了一个管道，运行 <code>attack.c</code> 的进程的文件描述符 2 连接着管道写端，运行 <code>attacktest.c</code> 的进程则在读取管道读端。下面的代码就是把 <code>attack.c</code> 的文件描述符 2 连接到管道写端的代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">close</span><span class="token punctuation">(</span>fds<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">close</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">dup</span><span class="token punctuation">(</span>fds<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>newargv<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">"attack"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token function">exec</span><span class="token punctuation">(</span>newargv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> newargv<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"exec %s failed\n"</span><span class="token punctuation">,</span> newargv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="进程被回收的过程"><a href="#进程被回收的过程" class="headerlink" title="进程被回收的过程"></a>进程被回收的过程</h1><p>一个进程调用 exit(int) 后会进入 ZOMBIE 状态，但并不立即释放物理内存，而是会唤醒其父进程：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">exit</span><span class="token punctuation">(</span><span class="token keyword">int</span> status<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 我们在这里省略了很多代码，有兴趣可以自己看 proc.c</span>    <span class="token function">wakeup</span><span class="token punctuation">(</span>p<span class="token operator">-></span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>    p<span class="token operator">-></span>state <span class="token operator">=</span> ZOMBIE<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>父进程调用 wait(uint64) 会找到 ZOMBIE 子进程并调用 <code>freeproc</code> 来回收它：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">wait</span><span class="token punctuation">(</span>uint64 addr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 我们在这里省略了很多代码，有兴趣可以自己看 proc.c</span>    <span class="token keyword">struct</span> <span class="token class-name">proc</span> <span class="token operator">*</span>pp<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">proc</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token function">myproc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>pp <span class="token operator">=</span> proc<span class="token punctuation">;</span> pp <span class="token operator">&lt;</span> <span class="token operator">&amp;</span>proc<span class="token punctuation">[</span>NPROC<span class="token punctuation">]</span><span class="token punctuation">;</span> pp<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>pp<span class="token operator">-></span>parent <span class="token operator">==</span> p <span class="token operator">&amp;&amp;</span> pp<span class="token operator">-></span>state <span class="token operator">==</span> ZOMBIE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// Found one.</span>                pid <span class="token operator">=</span> pp<span class="token operator">-></span>pid<span class="token punctuation">;</span>                <span class="token function">freeproc</span><span class="token punctuation">(</span>pp<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> pid<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// Wait for a child to exit.</span>        <span class="token function">sleep</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token operator">&amp;</span>wait_lock<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// DOC: wait-sleep</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>freeproc 则又调用 <code>proc_freepagetable</code> 来回收物理内存：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// Free a process's page table, and free the</span><span class="token comment">// physical memory it refers to.</span><span class="token keyword">void</span> <span class="token function">proc_freepagetable</span><span class="token punctuation">(</span><span class="token class-name">pagetable_t</span> pagetable<span class="token punctuation">,</span> uint64 sz<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">uvmunmap</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> TRAMPOLINE<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">uvmunmap</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> TRAPFRAME<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">uvmfree</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> sz<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中的 <code>uvmfree(pagetable, sz)</code> 就在释放物理内存了：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// Free user memory pages,</span><span class="token comment">// then free page-table pages.</span><span class="token keyword">void</span> <span class="token function">uvmfree</span><span class="token punctuation">(</span><span class="token class-name">pagetable_t</span> pagetable<span class="token punctuation">,</span> uint64 sz<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>sz <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">uvmunmap</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token function">PGROUNDUP</span><span class="token punctuation">(</span>sz<span class="token punctuation">)</span> <span class="token operator">/</span> PGSIZE<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">freewalk</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>让我们看向 <code>uvmunmap</code>，它获取每一页的物理地址然后调用 <code>kfree</code>：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// Remove npages of mappings starting from va. va must be</span><span class="token comment">// page-aligned. The mappings must exist.</span><span class="token comment">// Optionally free the physical memory.</span><span class="token keyword">void</span> <span class="token function">uvmunmap</span><span class="token punctuation">(</span><span class="token class-name">pagetable_t</span> pagetable<span class="token punctuation">,</span> uint64 va<span class="token punctuation">,</span> uint64 npages<span class="token punctuation">,</span> <span class="token keyword">int</span> do_free<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    uint64 a<span class="token punctuation">;</span>    <span class="token class-name">pte_t</span> <span class="token operator">*</span>pte<span class="token punctuation">;</span>    <span class="token keyword">int</span> sz<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>va <span class="token operator">%</span> PGSIZE<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"uvmunmap: not aligned"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>a <span class="token operator">=</span> va<span class="token punctuation">;</span> a <span class="token operator">&lt;</span> va <span class="token operator">+</span> npages <span class="token operator">*</span> PGSIZE<span class="token punctuation">;</span> a <span class="token operator">+=</span> sz<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        sz <span class="token operator">=</span> PGSIZE<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pte <span class="token operator">=</span> <span class="token function">walk</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> a<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"uvmunmap: walk"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>pte <span class="token operator">&amp;</span> PTE_V<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"va=%ld pte=%ld\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> <span class="token operator">*</span>pte<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"uvmunmap: not mapped"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">PTE_FLAGS</span><span class="token punctuation">(</span><span class="token operator">*</span>pte<span class="token punctuation">)</span> <span class="token operator">==</span> PTE_V<span class="token punctuation">)</span>            <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"uvmunmap: not a leaf"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>do_free<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            uint64 pa <span class="token operator">=</span> <span class="token function">PTE2PA</span><span class="token punctuation">(</span><span class="token operator">*</span>pte<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">kfree</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>pa<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token operator">*</span>pte <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>更细节的释放 trapframe、释放页表我们就不在这里多说了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在开始之前，我们回顾一下怎么启动调试模式：&lt;/p&gt;
&lt;p&gt;在一个终端里执行 &lt;code&gt;make qemu-gdb&lt;/code&gt; ，&lt;code&gt;make qemu-gdb CPUS=1&lt;/code&gt; 可以只使用一个核心，比起多线程更便于调试。&lt;/p&gt;
&lt;p&gt;在另一个终端里执</summary>
      
    
    
    
    <category term="公开课" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"/>
    
    <category term="MIT-6.S081" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/MIT-6-S081/"/>
    
    <category term="Labs" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/MIT-6-S081/Labs/"/>
    
    
  </entry>
  
  <entry>
    <title>探索日志[1]</title>
    <link href="http://rinevard.github.io/wiki/others/thoughts/%E6%8E%A2%E7%B4%A2%E6%97%A5%E5%BF%971/"/>
    <id>http://rinevard.github.io/wiki/others/thoughts/%E6%8E%A2%E7%B4%A2%E6%97%A5%E5%BF%971/</id>
    <published>2025-10-13T12:11:11.000Z</published>
    <updated>2025-10-27T13:34:23.367Z</updated>
    
    <content type="html"><![CDATA[<p>不知道人们平常是怎样与他人相识的。许久以前我就在想，自己的社交方式是否有点不太像一般人类🫠🫠咱更偏好那种“大家一起做一件都感兴趣的事情然后渐渐就认识了”的社交方式，但似乎这种做法相对少见，而且我以前也没怎么因此认识到新朋友。</p><p>在不短的质疑期后，渐渐地也发现自己也是能用这种方法交到朋友的，至少是能结识人类的。比如说这次的探索日志就和 GMTK Jam 在小红书拉到的美术同学有关（赞美小红书喵</p><p>“我对普通的人类没有兴趣。你们之中如果有画画人、音乐人、音效人或者异世界人就来找我吧！”虽然我不是这么拉人的（没人会这么拉人吧！），但总之就是拉到了这位中传的美术同学一起来gamejam，这是八月的事了。</p><p>今天鹰角在中传开了个宣讲会，咱作为资深粥粥人当然想去听听看。访客进中传需要找校内同学或老师预约，于是咱就找了这位美术同学然后成功进入中传了。</p><p><img src="/images/others/random_thoughts/explore1/cuc_arknights.jpg" alt=""></p><p>一般来说故事应该跌宕起伏，比方说我们起码要写写在中传遇到的趣事，然后写写有什么糟糕的地方，然后再华丽收场，不过事情就是很平平淡淡。鹰角的宣讲会很普通，虽然发了点周边但我并没有抽中有趣的奖品，中传的饭比北理的好吃，但好吃得不多。</p><p><img src="/images/others/random_thoughts/explore1/cuc_food.jpg" alt=""></p><p>可我确实从来没有去外校玩的经历，更别说要找外校同学预约才能进的学校了🫠🫠咱能从社恐进化成现在这样能主动拉人组队还能联系别人已经很好了不是吗（）</p><p>探索也不是次次有趣，倒不如说探索的结果普普通通才是理所应当的吧。现在是晚上十点五十分，我在良乡大学城北的地铁站没有摆渡车，要骑车回学校了。</p><p><img src="/images/others/random_thoughts/explore1/cuc_tree.jpg" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;不知道人们平常是怎样与他人相识的。许久以前我就在想，自己的社交方式是否有点不太像一般人类🫠🫠咱更偏好那种“大家一起做一件都感兴趣的事情然后渐渐就认识了”的社交方式，但似乎这种做法相对少见，而且我以前也没怎么因此认识到新朋友。&lt;/p&gt;
&lt;p&gt;在不短的质疑期后，渐渐地也发现</summary>
      
    
    
    
    <category term="杂谈" scheme="http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    <category term="碎碎念" scheme="http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
  </entry>
  
  <entry>
    <title>Assignment 7 Path Tracing</title>
    <link href="http://rinevard.github.io/wiki/learning/open-course/GAMES101/Hw/Hw7-path-tracing/"/>
    <id>http://rinevard.github.io/wiki/learning/open-course/GAMES101/Hw/Hw7-path-tracing/</id>
    <published>2025-10-10T14:10:44.000Z</published>
    <updated>2025-10-10T15:04:14.905Z</updated>
    
    <content type="html"><![CDATA[<h1 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h1><p>这次的作业挺难的。首先我们来对照公式解释一下大致的代码流程：</p><script type="math/tex; mode=display">\begin{align*}L_o(p, \vec{\omega_o}) = &L_e(p, \vec{\omega_o}) + \int_{\Omega} f_r(p, \vec{\omega_i}, \vec{\omega_o}) L_i(p, \vec{\omega_i}) (\vec{\omega_i} \cdot n) d\omega_i \\= &L_e(p, \vec{\omega_o}) + \int_{\Omega_{光源方向}} f_r(p, \vec{\omega_i}, \vec{\omega_o}) L_i(p, \vec{\omega_i}) (\vec{\omega_i} \cdot n) d\omega_i \\&+ \int_{\Omega_{非光源方向}} f_r(p, \vec{\omega_i}, \vec{\omega_o}) L_i(p, \vec{\omega_i}) (\vec{\omega_i} \cdot n) d\omega_i\end{align*}</script><ol><li>如果点 $p$ 是光源，直接返回其自发光项 $L_e$.</li><li>随机采样一个光源方向 $w_s$，根据公式计算 $L_\text{direct}$.</li><li><p>随机采样一个方向 $w_i$，按轮盘赌决定是否结束弹射。</p><p> 如果不结束且 $w_i$ 没打到光源，根据公式计算 $L_\text{indirect}$.</p></li><li><p>返回 $L_\text{direct}+L_\text{indirect}$</p></li></ol><p>然后放代码：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Vector3f <span class="token class-name">Scene</span><span class="token double-colon punctuation">::</span><span class="token function">castRay</span><span class="token punctuation">(</span><span class="token keyword">const</span> Ray <span class="token operator">&amp;</span>ray<span class="token punctuation">,</span> <span class="token keyword">int</span> depth<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">&#123;</span>    Intersection shade_point_inter <span class="token operator">=</span> <span class="token function">intersect</span><span class="token punctuation">(</span>ray<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>shade_point_inter<span class="token punctuation">.</span>happened<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token function">Vector3f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// ----------------Contribution from emission----------------</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>shade_point_inter<span class="token punctuation">.</span>m<span class="token operator">-></span><span class="token function">hasEmission</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// Light source doesn't reflect light, so we return here</span>        <span class="token keyword">return</span> shade_point_inter<span class="token punctuation">.</span>m<span class="token operator">-></span><span class="token function">getEmission</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// ----------------Contribution from the light source----------------</span>    Vector3f wo <span class="token operator">=</span> <span class="token operator">-</span><span class="token function">normalize</span><span class="token punctuation">(</span>ray<span class="token punctuation">.</span>direction<span class="token punctuation">)</span><span class="token punctuation">;</span>    Vector3f normal <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>shade_point_inter<span class="token punctuation">.</span>normal<span class="token punctuation">)</span><span class="token punctuation">;</span>    Vector3f l_direct <span class="token operator">=</span> <span class="token function">Vector3f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Intersection light_sample<span class="token punctuation">;</span>    <span class="token keyword">float</span> pdf_light<span class="token punctuation">;</span>    <span class="token function">sampleLight</span><span class="token punctuation">(</span>light_sample<span class="token punctuation">,</span> pdf_light<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// If the ray is not blocked in the middle, compute its contribution</span>    Vector3f light_normal <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>light_sample<span class="token punctuation">.</span>normal<span class="token punctuation">)</span><span class="token punctuation">;</span>    Vector3f shade_point <span class="token operator">=</span> shade_point_inter<span class="token punctuation">.</span>coords<span class="token punctuation">;</span>    Vector3f ws <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>light_sample<span class="token punctuation">.</span>coords <span class="token operator">-</span> shade_point<span class="token punctuation">)</span><span class="token punctuation">;</span>    Vector3f direct_ray_origin <span class="token operator">=</span> shade_point <span class="token operator">+</span> ws <span class="token operator">*</span> EPSILON<span class="token punctuation">;</span>    Ray <span class="token function">ray_to_light</span><span class="token punctuation">(</span>direct_ray_origin<span class="token punctuation">,</span> ws<span class="token punctuation">)</span><span class="token punctuation">;</span>    Intersection inter_between_light <span class="token operator">=</span> <span class="token function">intersect</span><span class="token punctuation">(</span>ray_to_light<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">!</span>inter_between_light<span class="token punctuation">.</span>happened<span class="token punctuation">)</span> <span class="token operator">||</span> inter_between_light<span class="token punctuation">.</span>distance <span class="token operator">></span> <span class="token punctuation">(</span>light_sample<span class="token punctuation">.</span>coords <span class="token operator">-</span> direct_ray_origin<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">norm</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> EPSILON<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        l_direct <span class="token operator">=</span> light_sample<span class="token punctuation">.</span>emit <span class="token operator">*</span> shade_point_inter<span class="token punctuation">.</span>m<span class="token operator">-></span><span class="token function">eval</span><span class="token punctuation">(</span>ws<span class="token punctuation">,</span> wo<span class="token punctuation">,</span> normal<span class="token punctuation">)</span> \        <span class="token operator">*</span> std<span class="token double-colon punctuation">::</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token function">dotProduct</span><span class="token punctuation">(</span>ws<span class="token punctuation">,</span> normal<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">)</span> <span class="token operator">*</span> std<span class="token double-colon punctuation">::</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token function">dotProduct</span><span class="token punctuation">(</span><span class="token operator">-</span>ws<span class="token punctuation">,</span> light_normal<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">)</span> \        <span class="token operator">/</span> std<span class="token double-colon punctuation">::</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token punctuation">(</span>light_sample<span class="token punctuation">.</span>coords <span class="token operator">-</span> direct_ray_origin<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">norm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">/</span> pdf_light<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// ----------------Contribution from other reflectors----------------</span>    Vector3f l_indirect <span class="token operator">=</span> <span class="token function">Vector3f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Russian Roulette test</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">get_random_float</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> RussianRoulette<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        Vector3f wi <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>shade_point_inter<span class="token punctuation">.</span>m<span class="token operator">-></span><span class="token function">sample</span><span class="token punctuation">(</span>wo<span class="token punctuation">,</span> normal<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Vector3f indirect_ray_origin <span class="token operator">=</span> shade_point <span class="token operator">+</span> wi <span class="token operator">*</span> EPSILON<span class="token punctuation">;</span>        Ray <span class="token function">reflected_ray</span><span class="token punctuation">(</span>indirect_ray_origin<span class="token punctuation">,</span> wi<span class="token punctuation">)</span><span class="token punctuation">;</span>        Intersection reflected_inter <span class="token operator">=</span> <span class="token function">intersect</span><span class="token punctuation">(</span>reflected_ray<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// If reflected_ray hitting a non-emitting object, compute its contribution </span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>reflected_inter<span class="token punctuation">.</span>happened <span class="token operator">&amp;&amp;</span> reflected_inter<span class="token punctuation">.</span>m<span class="token operator">-></span><span class="token function">hasEmission</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            l_indirect <span class="token operator">=</span> <span class="token function">Vector3f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            l_indirect <span class="token operator">=</span> <span class="token function">castRay</span><span class="token punctuation">(</span>reflected_ray<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> shade_point_inter<span class="token punctuation">.</span>m<span class="token operator">-></span><span class="token function">eval</span><span class="token punctuation">(</span>wi<span class="token punctuation">,</span> wo<span class="token punctuation">,</span> normal<span class="token punctuation">)</span> \            <span class="token operator">*</span> std<span class="token double-colon punctuation">::</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token function">dotProduct</span><span class="token punctuation">(</span>wi<span class="token punctuation">,</span> normal<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">)</span> \            <span class="token operator">/</span> <span class="token punctuation">(</span>shade_point_inter<span class="token punctuation">.</span>m<span class="token operator">-></span><span class="token function">pdf</span><span class="token punctuation">(</span>wi<span class="token punctuation">,</span> wo<span class="token punctuation">,</span> normal<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> RussianRoulette<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> l_direct <span class="token operator">+</span> l_indirect<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再来看看图</p><p><img src="/images/learning/open-course/GAMES101/Assignments/hw7/screenshot.png" alt=""></p><h1 id="代码细节"><a href="#代码细节" class="headerlink" title="代码细节"></a>代码细节</h1><p>接下来我们再聊聊具体的代码细节。自发光项比较简单，我们略过。</p><h2 id="L-text-direct"><a href="#L-text-direct" class="headerlink" title="$L_\text{direct}$"></a>$L_\text{direct}$</h2><p>直接光部分。首先要注意的是，各个射线 $w_i, w_o, w_s$ 都是从着色点指向外的单位方向向量。这是一个图形学里常用的约定，所以不要问为什么不是指向内了（）</p><p><img src="/images/learning/open-course/GAMES101/Assignments/hw7/wiwodir.png" alt=""></p><p>然后在发出射线时，最好做一个微小的偏移以避免发出的射线和着色点平面相交。这就是我们 <code>direct_ray_origin = shade_point + ws * EPSILON</code> 做了加法的原因。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Vector3f wo <span class="token operator">=</span> <span class="token operator">-</span><span class="token function">normalize</span><span class="token punctuation">(</span>ray<span class="token punctuation">.</span>direction<span class="token punctuation">)</span><span class="token punctuation">;</span>Vector3f normal <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>shade_point_inter<span class="token punctuation">.</span>normal<span class="token punctuation">)</span><span class="token punctuation">;</span>Vector3f l_direct <span class="token operator">=</span> <span class="token function">Vector3f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Intersection light_sample<span class="token punctuation">;</span><span class="token keyword">float</span> pdf_light<span class="token punctuation">;</span><span class="token function">sampleLight</span><span class="token punctuation">(</span>light_sample<span class="token punctuation">,</span> pdf_light<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// If the ray is not blocked in the middle, compute its contribution</span>Vector3f light_normal <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>light_sample<span class="token punctuation">.</span>normal<span class="token punctuation">)</span><span class="token punctuation">;</span>Vector3f shade_point <span class="token operator">=</span> shade_point_inter<span class="token punctuation">.</span>coords<span class="token punctuation">;</span>Vector3f ws <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>light_sample<span class="token punctuation">.</span>coords <span class="token operator">-</span> shade_point<span class="token punctuation">)</span><span class="token punctuation">;</span>Vector3f direct_ray_origin <span class="token operator">=</span> shade_point <span class="token operator">+</span> ws <span class="token operator">*</span> EPSILON<span class="token punctuation">;</span>Ray <span class="token function">ray_to_light</span><span class="token punctuation">(</span>direct_ray_origin<span class="token punctuation">,</span> ws<span class="token punctuation">)</span><span class="token punctuation">;</span>Intersection inter_between_light <span class="token operator">=</span> <span class="token function">intersect</span><span class="token punctuation">(</span>ray_to_light<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">!</span>inter_between_light<span class="token punctuation">.</span>happened<span class="token punctuation">)</span> <span class="token operator">||</span> inter_between_light<span class="token punctuation">.</span>distance <span class="token operator">></span> <span class="token punctuation">(</span>light_sample<span class="token punctuation">.</span>coords <span class="token operator">-</span> direct_ray_origin<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">norm</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> EPSILON<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    l_direct <span class="token operator">=</span> light_sample<span class="token punctuation">.</span>emit <span class="token operator">*</span> shade_point_inter<span class="token punctuation">.</span>m<span class="token operator">-></span><span class="token function">eval</span><span class="token punctuation">(</span>ws<span class="token punctuation">,</span> wo<span class="token punctuation">,</span> normal<span class="token punctuation">)</span> \    <span class="token operator">*</span> std<span class="token double-colon punctuation">::</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token function">dotProduct</span><span class="token punctuation">(</span>ws<span class="token punctuation">,</span> normal<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">)</span> <span class="token operator">*</span> std<span class="token double-colon punctuation">::</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token function">dotProduct</span><span class="token punctuation">(</span><span class="token operator">-</span>ws<span class="token punctuation">,</span> light_normal<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">)</span> \    <span class="token operator">/</span> std<span class="token double-colon punctuation">::</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token punctuation">(</span>light_sample<span class="token punctuation">.</span>coords <span class="token operator">-</span> direct_ray_origin<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">norm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">/</span> pdf_light<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另外，我们有从光源采样计算直接光的公式：</p><script type="math/tex; mode=display">\begin{align*}&\int_{\Omega_{光源方向}} f_r(p, \vec{\omega_i}, \vec{\omega_o}) L_i(p, \vec{\omega_i}) (\vec{\omega_i} \cdot n) d\omega_i \\=&\int_{A} f_r(p, \vec{\omega_i}, \vec{\omega_o}) L_i(p, \vec{\omega_i}) \frac{\cos\theta\cos\theta_i}{\lVert p'-p \rVert^2} dA \end{align*}</script><p>用蒙特卡罗近似就是代码里写的东西了。</p><p><img src="/images/learning/open-course/GAMES101/Assignments/hw7/nee.png" alt=""></p><h2 id="L-text-indirect"><a href="#L-text-indirect" class="headerlink" title="$L_\text{indirect}$"></a>$L_\text{indirect}$</h2><p>间接部分。首先要做俄罗斯轮盘赌，然后要检查打到的是否是光源。</p><p>如果通过了轮盘赌，而且打到的不是光源，就要计算间接光。</p><p>与直接光一样，我们要做微小偏移，这就是 <code>indirect_ray_origin = shade_point + wi * EPSILON</code> .</p><p>然后套公式就行。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Vector3f l_indirect <span class="token operator">=</span> <span class="token function">Vector3f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Russian Roulette test</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">get_random_float</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> RussianRoulette<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    Vector3f wi <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>shade_point_inter<span class="token punctuation">.</span>m<span class="token operator">-></span><span class="token function">sample</span><span class="token punctuation">(</span>wo<span class="token punctuation">,</span> normal<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Vector3f indirect_ray_origin <span class="token operator">=</span> shade_point <span class="token operator">+</span> wi <span class="token operator">*</span> EPSILON<span class="token punctuation">;</span>    Ray <span class="token function">reflected_ray</span><span class="token punctuation">(</span>indirect_ray_origin<span class="token punctuation">,</span> wi<span class="token punctuation">)</span><span class="token punctuation">;</span>    Intersection reflected_inter <span class="token operator">=</span> <span class="token function">intersect</span><span class="token punctuation">(</span>reflected_ray<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// If reflected_ray hitting a non-emitting object, compute its contribution </span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>reflected_inter<span class="token punctuation">.</span>happened <span class="token operator">&amp;&amp;</span> reflected_inter<span class="token punctuation">.</span>m<span class="token operator">-></span><span class="token function">hasEmission</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        l_indirect <span class="token operator">=</span> <span class="token function">Vector3f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        l_indirect <span class="token operator">=</span> <span class="token function">castRay</span><span class="token punctuation">(</span>reflected_ray<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> shade_point_inter<span class="token punctuation">.</span>m<span class="token operator">-></span><span class="token function">eval</span><span class="token punctuation">(</span>wi<span class="token punctuation">,</span> wo<span class="token punctuation">,</span> normal<span class="token punctuation">)</span> \        <span class="token operator">*</span> std<span class="token double-colon punctuation">::</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token function">dotProduct</span><span class="token punctuation">(</span>wi<span class="token punctuation">,</span> normal<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">)</span> \        <span class="token operator">/</span> <span class="token punctuation">(</span>shade_point_inter<span class="token punctuation">.</span>m<span class="token operator">-></span><span class="token function">pdf</span><span class="token punctuation">(</span>wi<span class="token punctuation">,</span> wo<span class="token punctuation">,</span> normal<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> RussianRoulette<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果对 EPSILON 挺敏感的，可以把 EPSILON 适当调大点，我用的是 <code>0.00020</code> .</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;大致流程&quot;&gt;&lt;a href=&quot;#大致流程&quot; class=&quot;headerlink&quot; title=&quot;大致流程&quot;&gt;&lt;/a&gt;大致流程&lt;/h1&gt;&lt;p&gt;这次的作业挺难的。首先我们来对照公式解释一下大致的代码流程：&lt;/p&gt;
&lt;script type=&quot;math/tex; mod</summary>
      
    
    
    
    <category term="公开课" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"/>
    
    <category term="GAMES101" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/"/>
    
    <category term="Assignments" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/Assignments/"/>
    
    
  </entry>
  
  <entry>
    <title>Note 6 BRDF and Rendering Eequation</title>
    <link href="http://rinevard.github.io/wiki/learning/open-course/GAMES101/Notes/Note6-BRDF-and-renderingequation/"/>
    <id>http://rinevard.github.io/wiki/learning/open-course/GAMES101/Notes/Note6-BRDF-and-renderingequation/</id>
    <published>2025-10-10T13:45:28.000Z</published>
    <updated>2025-10-10T14:49:51.245Z</updated>
    
    <content type="html"><![CDATA[<p>我们之前已经学过了 Blinn-Phong 光照模型，但它只是一个启发式模型，在物理上是不正确的。接下来我们看看物理上正确的光照是怎样的，以及如何用计算机近似求解接近正确的光照。</p><h1 id="辐射度量学"><a href="#辐射度量学" class="headerlink" title="辐射度量学"></a>辐射度量学</h1><p>在了解光照的物理模型之前，我们先来看看一些物理量。最关键的物理量有四个，分别是</p><ol><li>Radiant flux/power $\Phi$，单位 $W$.</li><li>Radiant intensity $I$，单位 $\frac{W}{\text{sr}}$.</li><li>Irradiance $E$，单位 $\frac{W}{m^2}$.</li><li>Radiance $L$，单位 $\frac{W}{\text{sr}\cdot m^2}$.</li></ol><p>接下来让我们看看它们的具体定义。</p><h2 id="Radiant-flux-power-Phi"><a href="#Radiant-flux-power-Phi" class="headerlink" title="Radiant flux/power $\Phi$"></a>Radiant flux/power $\Phi$</h2><p>Radiant flux/power 符号 $\Phi$，单位 $W$.</p><p>定义为</p><script type="math/tex; mode=display">\Phi = \frac{dQ}{dt}</script><h2 id="Radiant-intensity-I"><a href="#Radiant-intensity-I" class="headerlink" title="Radiant intensity $I$"></a>Radiant intensity $I$</h2><p>Radiant Intensity 符号 $I$，单位 $\frac{W}{\text{sr}}$，表示某个定点接收/穿过/发出的，在指定方向 $\vec{\omega}$ 上的，单位立体角的 Power.</p><p>定义为</p><script type="math/tex; mode=display">I(\vec{\omega})=\frac{d\Phi}{d\omega}</script><p>这里的符号略显混乱。左边的参数 $\vec{\omega}$ 是一个方向向量，右边的 $d\omega$ 则是这个方向上立体角的微分。</p><p>我们知道方向向量 $\vec{\omega}$ 也能在球坐标下被表示为 $(\theta,\varphi)$。对给定的 $(\theta,\varphi)$，我们可以算出其在球面上的面积微分，也能进一步求出立体角微分 $d\omega$，如下所示</p><script type="math/tex; mode=display">\begin{align*}&dA=r^2 \sin \theta \space d\theta \space d\varphi\\&d\omega=\frac{dA}{r^2}=\sin \theta \space d\theta \space d\varphi\end{align*}</script><p>下图是对  Solid angle 和 Radiant Intensity 两个概念的图解</p><p><img src="/images/learning/open-course/GAMES101/Notes/note6/solid_angle_and_intensity.png" alt=""></p><h2 id="Irradiance-E"><a href="#Irradiance-E" class="headerlink" title="Irradiance $E$"></a>Irradiance $E$</h2><p>Irradiance 符号 $E$，单位 $\frac{W}{m^2}$.</p><p>表示点 $x$ 周围单位面积接收/穿过/发出的 Power，定义为</p><script type="math/tex; mode=display">E(x)=\frac{d\Phi}{dA}</script><p>下图计算并对比了平行光穿过两个不同截面时的 irradiance：垂直截面 $A$，以及与垂直方向成 $\theta$ 角的倾斜截面 $A’$。</p><p>其中 $\Phi=\Phi’$ 是因为能量守恒，光束穿过任何一个完整截面的功率是固定的。</p><p><img src="/images/learning/open-course/GAMES101/Notes/note6/irradiance.png" alt=""></p><h2 id="Radiance-L"><a href="#Radiance-L" class="headerlink" title="Radiance $L$"></a>Radiance $L$</h2><p>Radiance $L$ 的单位是 $\frac{W}{\text{sr}\cdot \space m^2}$，表示表面某点 $x$ 周围单位投影面积接收/穿过/发出的，在指定方向 $\vec{w}$ 上的，单位立体角的 radiant flux.</p><p>定义为</p><script type="math/tex; mode=display">L(x,\vec{\omega})=\frac{d^2\Phi}{d\omega ds}=\frac{d^2\Phi}{d\omega ds_{0}\cos\theta}</script><p>这里的 $ds$ 是投影前面积，$ds_0 \cos\theta$ 是投影面积。</p><p>下图是对 Irradiance 和 Radiance的图解</p><p><img src="/images/learning/open-course/GAMES101/Notes/note6/irradiance_and_radiance.png" alt=""></p><h1 id="BRDF和材质"><a href="#BRDF和材质" class="headerlink" title="BRDF和材质"></a>BRDF和材质</h1><p>现在我们可以看看光照的物理模型了，其中最关键的是 BRDF，即双向反射分布函数。它定义了从方向 $\vec{\omega_i}$ 射入的光线打到某个表面上反射到 $\vec{\omega_r}$ 方向的强度：</p><script type="math/tex; mode=display">f_r(p,\vec{\omega_i}, \vec{\omega_r}) = \frac{dL_r(p,\vec{\omega_r})}{dE_i(p,\vec{\omega_i})}</script><p>你可能会疑惑为什么之前我们说 $E$ 是关于 $x$ 的函数，现在却除了坐标 $p$ 外还多了一个方向参数 $\omega_i$，这是因为 BRDF 里的 $E$ 是微分。具体可以看看下面这个式子：</p><script type="math/tex; mode=display">E(x) = \int_{\Omega} L_i(x,\vec{\omega_i}) \cos\theta_i d\omega_i\\dE_i(x, \vec{\omega_i}) = L_i(x, \vec{\omega_i}) \cos\theta_i d\omega_i</script><p>你可能还会疑惑，为什么分母用 $E$ 呢？和分母一样统一用 $L$ 不是更优雅吗？</p><p>据 <a href="https://www.zhihu.com/question/28476602/answer/41003204">https://www.zhihu.com/question/28476602/answer/41003204</a> 这个答案所说，测量出射的 Radiance $L$ 很方便，但测量入射的 Irradiance $L$ 很困难，而测量入射的 $dE$ 挺方便，因此我们就使用了 $\frac{dL}{dE}$.</p><p>我们把上面的 $dE_i(x,\vec{\omega_i})$ 代入 BRDF，就得到了</p><script type="math/tex; mode=display">f_r(p,\vec{\omega_i}, \vec{\omega_r}) = \frac{dL_r(p,\vec{\omega_r})}{L_i(x,\vec{w_i})\cos\theta_i dw_i}</script><p>物体的材质就用 BSDF（反射的BRDF+折射的BTDF）表示。我们这里只聊 BRDF，因为 BTDF 和 BRDF 接近。BRDF 的获取包括但不限于这两种方式：</p><ol><li>现实测量。我们可以找到许多包含大量 BRDF 测量数据的数据集，比如 MERL 数据集。</li><li>微表面模型。用粗糙度、金属度等参数来构建启发式的 BRDF 函数。</li></ol><p>还值得一提的是，由 Helmholtz Reciprocity Principle，有</p><script type="math/tex; mode=display">f_r(p,\vec{\omega_i}, \vec{\omega_o}) = f_r(p,\vec{\omega_o}, \vec{\omega_i})</script><p>也就是说交换入射出射方向，BRDF 函数 $f_r$ 不变。</p><h1 id="渲染方程"><a href="#渲染方程" class="headerlink" title="渲染方程"></a>渲染方程</h1><p>现在我们先看看反射方程，再看看渲染方程。</p><p>反射方程是通过 BRDF 求出 $L_r$ 的方程，对 BRDF 的公式积分一下就行：</p><script type="math/tex; mode=display">L_r(p, \vec{\omega_r}) = \int_{\Omega} f_r(p, \vec{\omega_i}, \vec{\omega_r}) L_i(p, \vec{\omega_i}) (\vec{\omega_i} \cdot \vec{n}) d\omega_i</script><p>其中 $\vec{n}$ 是点 $p$ 处的法线方向，$\vec{\omega_i} \cdot \vec{n}$ 是 BRDF 定义里的 $\cos\theta_i$.</p><p>而渲染方程，不考虑折射，只是比反射方程多了一个自发光项：</p><script type="math/tex; mode=display">L_o(p, \vec{\omega_o}) = L_e(p, \vec{\omega_o}) + \int_{\Omega} f_r(p, \vec{\omega_i}, \vec{\omega_o}) L_i(p, \vec{\omega_i}) (\vec{\omega_i} \cdot n) d\omega_i</script><p>你可能会好奇右侧的 $L_i(p,\vec{\omega_i}<br>)$ 怎么求出来。由能量守恒，我们可以从 $p$ 出发顺着 $-\vec{\omega_i}$ 找到第一个交点 $q$，然后就有</p><script type="math/tex; mode=display">L_i(p,\vec{\omega_i})=L_o(q,-\vec{\omega_i})</script><h1 id="实际算法"><a href="#实际算法" class="headerlink" title="实际算法"></a>实际算法</h1><p>由上可知，我们要求解下面的方程：</p><script type="math/tex; mode=display">L_o(p, \vec{\omega_o}) = L_e(p, \vec{\omega_o}) + \int_{\Omega} f_r(p, \vec{\omega_i}, \vec{\omega_o}) L_o(\text{raycast}(p, -\vec{\omega_i}), -\vec{\omega_i}) (\vec{\omega_i} \cdot n) d\vec{\omega_i}</script><p>这是一个积分，还是一个递归，我们先用蒙特卡罗算法近似积分，得到</p><script type="math/tex; mode=display">L_o(p, \vec{\omega_o}) \approx L_e(p, \vec{\omega_o}) + \frac{1}{N}\sum_{k=1}^{N}\frac{f_r(p, \vec{\omega_i}^{(k)}, \vec{\omega_o}) L_o(\text{raycast}(p, -\vec{\omega_i}^{(k)}), -\vec{\omega_i}^{(k)}) (\vec{\omega_i} ^{(k)}\cdot n) }{p(\vec{\omega_i}^{(k)})}</script><p>其中 $\vec{\omega_i}^{(k)}$ 是随机采样的方向向量，$p(\vec{\omega_i}^{(k)})$ 是采样到它的概率。</p><p>有了这个求和，我们就可以开始递归了，大致算法如下：</p><ol><li>从 $p$ 射出朝随机方向 $\vec{\omega_i}<br>^{(k)}$ 的射线，打到 $q^{(k)}$.</li><li>计算 $L_o(q,-w_i^{(k)})$，然后代入式子，求得 $L_o(p,\vec{\omega_o})$。</li></ol><p>等等，这不是无限递归吗？确实如此。所以我们会假设如果射线打到了光源就只返回自发光项 $L_e$.</p><p>但这不还是很复杂吗，假设我们对每个点发射 $10$ 条射线，弹射以后就要发射 $10^2$ 个，再弹射就要 $10^3$ 个！</p><p>没错，所以我们只对每个点发出 $1$ 条射线并计算其弹射后的完整路径，然后对每个点追踪多条路径并取平均。虽然这不完全符合上面的公式，但很有效。</p><p>让我们来看看新的算法吧：</p><ol><li>如果点 $p$ 是光源，直接返回其自发光项。</li><li>随机采样一个方向 $w_i$，从 $p$ 发出一条朝向 $w_i$ 的射线，打到点 $q$.</li><li>计算点 $q$ 的 $L_o(q,-w_i)$，代入公式，求得 $L_o(p,w_o)$.</li><li>对求得的多个 $L_o(p,w_o)$ 取平均。</li></ol><p>这个算法当然可以进一步优化，比如说上面还是有潜在的无限弹射风险，所以要用俄罗斯轮盘赌来在每次弹射时都有随机概率停止弹射（这被称作RR）；又比如上面打到光源的概率太低，所以可以从光源采样射线（这被称作NEE）。不过这些东西就留到作业 7 的解析里再说吧。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>Stanford CS348B, Spring 2022：<a href="https://gfxcourses.stanford.edu/cs348b/spring22">https://gfxcourses.stanford.edu/cs348b/spring22</a></p><p>多伦多大学图形学讲义：<a href="https://www.dgp.toronto.edu/public_user/elf/2522/light.pdf">https://www.dgp.toronto.edu/public_user/elf/2522/light.pdf</a></p><p>Introduction to Radiometry and Photometry</p><p>UE4 的 BRDF 实现：<a href="https://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf">https://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们之前已经学过了 Blinn-Phong 光照模型，但它只是一个启发式模型，在物理上是不正确的。接下来我们看看物理上正确的光照是怎样的，以及如何用计算机近似求解接近正确的光照。&lt;/p&gt;
&lt;h1 id=&quot;辐射度量学&quot;&gt;&lt;a href=&quot;#辐射度量学&quot; class=&quot;head</summary>
      
    
    
    
    <category term="公开课" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"/>
    
    <category term="GAMES101" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/"/>
    
    <category term="Notes" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/Notes/"/>
    
    
  </entry>
  
  <entry>
    <title>探索日志[0]</title>
    <link href="http://rinevard.github.io/wiki/others/thoughts/%E6%8E%A2%E7%B4%A2%E6%97%A5%E5%BF%970/"/>
    <id>http://rinevard.github.io/wiki/others/thoughts/%E6%8E%A2%E7%B4%A2%E6%97%A5%E5%BF%970/</id>
    <published>2025-10-10T12:10:11.000Z</published>
    <updated>2025-10-27T13:33:04.965Z</updated>
    
    <content type="html"><![CDATA[<p>第二次参加了 Ludum Dare，第二次参加了 Compo 赛道。Compo 要求单人从零开始在 48 小时内做出一个能玩的东西。不觉得这很酷吗，作为一个玩家我觉得这太酷了，很符合我对极客的想象。</p><p>上一次参加 Compo 结识了一位很有趣的朋友，所以这次又参加了 Compo 而不是组队的 Jam。不过这次似乎至少到现在为止还没结识到很有趣的朋友（）</p><p>从上学期就开始想，大学的每天都太相似，日复一日。因此想每周都做一些没做过的事情。虽然没坚持很久，但我想这确实是值得做的。所以从现在开始简单写写探索日志吧，时不时探索一下。</p><p>这次除了自己参加之外，还和墨鱼游研社的同学们一起组织了一个活动，和社团的大家一起参加了这场 gamejam，咱们社团最后一共做了四个游戏。我做了 <a href="https://ldjam.com/events/ludum-dare/58/swarm-surge">SwarmSurge</a>.</p><p><img src="/images/others/random_thoughts/explore0/swarm_surge.jpg" alt="Swarm Surge"></p><p>怎样的生活值得我过，我该过怎样的生活？我确实还没想明白。Jam 是生活里为数不多的一抹奇幻色彩，惊艳又短暂。在有趣的故事结束之后，我们又该做什么，又该去往何方？</p><p>也难怪会喜欢凉宫春日。虽然她性格恶劣想一出是一出，但她是让世界变得更热闹的凉宫春日团团长！阿虚曾问自己：“对这种超乎常识的学园生活，你就不觉得快乐吗？”他的回答是：“当然快乐了，别问我这种明摆着的事情。”</p><p>对这些奇幻色彩，我难道不感觉快乐吗？当然快乐了。我会一直探索下去，即使每天都是某个雨日。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;第二次参加了 Ludum Dare，第二次参加了 Compo 赛道。Compo 要求单人从零开始在 48 小时内做出一个能玩的东西。不觉得这很酷吗，作为一个玩家我觉得这太酷了，很符合我对极客的想象。&lt;/p&gt;
&lt;p&gt;上一次参加 Compo 结识了一位很有趣的朋友，所以这次又参</summary>
      
    
    
    
    <category term="杂谈" scheme="http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    <category term="碎碎念" scheme="http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
  </entry>
  
  <entry>
    <title>Note 5 RayTracing</title>
    <link href="http://rinevard.github.io/wiki/learning/open-course/GAMES101/Notes/Note5-RayTracing/"/>
    <id>http://rinevard.github.io/wiki/learning/open-course/GAMES101/Notes/Note5-RayTracing/</id>
    <published>2025-09-25T13:48:28.000Z</published>
    <updated>2025-09-25T13:51:26.850Z</updated>
    
    <content type="html"><![CDATA[<p>渲染可以分为两个大类：object-order rendering 和 Image-order rendering. 前者以场景中的物体（通常是如三角形）为基本单位进行迭代，遍历场景中的每一个物体，然后确定该物体会影响屏幕上的哪些像素；后者以屏幕上的像素为基本单位进行迭代，遍历输出图像中的每一个像素，然后对于每个像素，它会找出场景中的哪个物体或物体的哪个部分决定了该像素的颜色。</p><p>我们之前学的光栅化是前者，而我们接下来要介绍的光线追踪就是后者。</p><h1 id="光线追踪"><a href="#光线追踪" class="headerlink" title="光线追踪"></a>光线追踪</h1><h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>光线追踪的思想基于光路可逆——既然光路可逆，那么打到摄像机里的光就可以看作从摄像机发出的射线，我们只要打出射线然后计算射线打到的点的颜色就好了。</p><p>其实基本思路真的就是这么简单！如下图所示，我们从眼睛里发出经过每个像素的射线，然后射线打到物体上就得到了物体的基本颜色。而射线还会反射、折射，我们计算反射、折射后的射线打到的颜色，再加到基本颜色上，就得到了这个像素的颜色。</p><p><img src="/images/learning/open-course/GAMES101/Notes/note5/ray_tracing.png" alt=""></p><p>光线追踪也自然地生成了阴影——如果射线打中的点和光源的连线间有物体遮挡，这点就是阴影，否则就不是阴影。</p><h2 id="碰撞检测"><a href="#碰撞检测" class="headerlink" title="碰撞检测"></a>碰撞检测</h2><p>既然如此，我们只要检测射线和三角形的碰撞就好了。我们可以用下面的 Möller Trumbore Algorithm 来做检测，其思路是解 “直线上的点 = 三角形重心坐标表示” 这个方程：</p><p>考虑射线 $\vec{O} + t\vec{D}$ 和三角形 $P_0, P_1, P_2$，我们要解方程</p><script type="math/tex; mode=display">\vec{O} + t\vec{D} = (1-b_1-b_2)\vec{P_0} + b_1\vec{P_1} + b_2\vec{P_2}</script><p>这是一个线性方程组，解为</p><script type="math/tex; mode=display">\begin{bmatrix} t \\ b_1 \\ b_2 \end{bmatrix} = \frac{1}{\vec{S_1} \cdot \vec{E_1}} \begin{bmatrix} \vec{S_2} \cdot \vec{E_2} \\ \vec{S_1} \cdot \vec{S} \\ \vec{S_2} \cdot \vec{D} \end{bmatrix}</script><p>其中</p><script type="math/tex; mode=display">\begin{aligned}\vec{E_1} &= \vec{P_1} - \vec{P_0} \\\vec{E_2} &= \vec{P_2} - \vec{P_0} \\\vec{S} &= \vec{O} - \vec{P_0} \\\vec{S_1} &= \vec{D} \times \vec{E_2} \\\vec{S_2} &= \vec{S} \times \vec{E_1}\end{aligned}</script><h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><p>在做射线和三角形的碰撞检测时，简单地遍历场景里的每个三角形显然太慢了，所以我们用包围盒来优化。如果一个射线没有碰到包围盒，自然就不会碰到盒子里的物体；如果碰到了，再和盒子里的物体做碰撞检测。</p><h2 id="常见包围盒"><a href="#常见包围盒" class="headerlink" title="常见包围盒"></a>常见包围盒</h2><p>包围盒有两种思路，一种是基于空间的划分，另一种是基于物体的划分。前者的代表包括四叉树、八叉树；后者的代表是 BVH.</p><p>四叉树、八叉树把空间进行平分，当一个区域里还剩较多物体时就再在这个区域里平分一次。</p><p><img src="/images/learning/open-course/GAMES101/Notes/note5/octree.png" alt=""></p><p>BVH 为每组物体建立包围盒，然后再把父包围盒划分成子包围盒。</p><p><img src="/images/learning/open-course/GAMES101/Notes/note5/bvh.png" alt=""></p><h2 id="射线和包围盒的碰撞检测"><a href="#射线和包围盒的碰撞检测" class="headerlink" title="射线和包围盒的碰撞检测"></a>射线和包围盒的碰撞检测</h2><p>包围盒有六个面，我们可以把相对的面划分成一组从而得到三组面。计算射线 $\vec{O} + t\vec{D}$ 与这三组面的交点后，我们会得到 $[t<em>{x, \text{enter}}, t</em>{x, \text{exit}}],[t<em>{y, \text{enter}}, t</em>{y, \text{exit}}],[t<em>{z, \text{enter}}, t</em>{z, \text{exit}}]$，之后计算下面的交集：</p><script type="math/tex; mode=display">[t_\text{raymin},t_\text{raymax}]\cap[t_{x, \text{enter}}, t_{x, \text{exit}}]\cap[t_{y, \text{enter}}, t_{y, \text{exit}}]\cap[t_{z, \text{enter}}, t_{z, \text{exit}}]</script><p>如果交集为空则无交点，否则有交点。</p><p>为了方便计算，包围盒一般是与坐标轴平行的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;渲染可以分为两个大类：object-order rendering 和 Image-order rendering. 前者以场景中的物体（通常是如三角形）为基本单位进行迭代，遍历场景中的每一个物体，然后确定该物体会影响屏幕上的哪些像素；后者以屏幕上的像素为基本单位进行迭代，</summary>
      
    
    
    
    <category term="公开课" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"/>
    
    <category term="GAMES101" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/"/>
    
    <category term="Notes" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/Notes/"/>
    
    
  </entry>
  
  <entry>
    <title>Assignment 6 Bounding Box</title>
    <link href="http://rinevard.github.io/wiki/learning/open-course/GAMES101/Hw/Hw6-bounding-box/"/>
    <id>http://rinevard.github.io/wiki/learning/open-course/GAMES101/Hw/Hw6-bounding-box/</id>
    <published>2025-09-24T09:46:44.000Z</published>
    <updated>2025-09-24T12:56:28.461Z</updated>
    
    <content type="html"><![CDATA[<p>这次的作业要求实现用包围盒来加快光线追踪，再用 BVH 优化。</p><p>首先我们要把 hw5 里的代码复制过来，让我不解的是代码里明明已经提供了 <code>rayTriangleIntersect</code> 函数，PDF 里却还说“将你的光线-三角形相交函数粘贴到此处”，明明直接调用它就好了，如下所示：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">inline</span> Intersection <span class="token class-name">Triangle</span><span class="token double-colon punctuation">::</span><span class="token function">getIntersection</span><span class="token punctuation">(</span>Ray ray<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    Intersection inter<span class="token punctuation">;</span>    <span class="token keyword">float</span> u<span class="token punctuation">,</span> v<span class="token punctuation">,</span> t<span class="token punctuation">;</span>    inter<span class="token punctuation">.</span>happened <span class="token operator">=</span> <span class="token function">rayTriangleIntersect</span><span class="token punctuation">(</span>v0<span class="token punctuation">,</span> v1<span class="token punctuation">,</span> v2<span class="token punctuation">,</span> ray<span class="token punctuation">.</span>origin<span class="token punctuation">,</span> ray<span class="token punctuation">.</span>direction<span class="token punctuation">,</span> t<span class="token punctuation">,</span> u<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>inter<span class="token punctuation">.</span>happened<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        inter<span class="token punctuation">.</span>coords <span class="token operator">=</span> ray<span class="token punctuation">.</span>origin <span class="token operator">+</span> t <span class="token operator">*</span> ray<span class="token punctuation">.</span>direction<span class="token punctuation">;</span>        inter<span class="token punctuation">.</span>normal <span class="token operator">=</span> normal<span class="token punctuation">;</span>        inter<span class="token punctuation">.</span>distance <span class="token operator">=</span> t<span class="token punctuation">;</span>        inter<span class="token punctuation">.</span>obj <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        inter<span class="token punctuation">.</span>m <span class="token operator">=</span> m<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> inter<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后我也不太喜欢代码框架对 <code>IntersectP</code> 的定义，在我看来既然另外两个参数能通过 <code>ray</code> 算出来，就完全没有理由作为参数传入。</p><p>于是我就改成了这个只保留 <code>ray</code> 参数的样子：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">inline</span> <span class="token keyword">bool</span> <span class="token class-name">Bounds3</span><span class="token double-colon punctuation">::</span><span class="token function">IntersectP</span><span class="token punctuation">(</span><span class="token keyword">const</span> Ray<span class="token operator">&amp;</span> ray<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">&#123;</span>    <span class="token comment">// invDir: ray direction(x,y,z), invDir=(1.0/x,1.0/y,1.0/z), use this because Multiply is faster that Division</span>    <span class="token keyword">auto</span> tMinVec <span class="token operator">=</span> <span class="token punctuation">(</span>pMin <span class="token operator">-</span> ray<span class="token punctuation">.</span>origin<span class="token punctuation">)</span> <span class="token operator">*</span> ray<span class="token punctuation">.</span>direction_inv<span class="token punctuation">;</span>    <span class="token keyword">auto</span> tMaxVec <span class="token operator">=</span> <span class="token punctuation">(</span>pMax <span class="token operator">-</span> ray<span class="token punctuation">.</span>origin<span class="token punctuation">)</span> <span class="token operator">*</span> ray<span class="token punctuation">.</span>direction_inv<span class="token punctuation">;</span>    <span class="token keyword">float</span> tMinx <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>std<span class="token double-colon punctuation">::</span><span class="token function">min</span><span class="token punctuation">(</span>tMinVec<span class="token punctuation">.</span>x<span class="token punctuation">,</span> tMaxVec<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>ray<span class="token punctuation">.</span>t_min<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">float</span> tMiny <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>std<span class="token double-colon punctuation">::</span><span class="token function">min</span><span class="token punctuation">(</span>tMinVec<span class="token punctuation">.</span>y<span class="token punctuation">,</span> tMaxVec<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>ray<span class="token punctuation">.</span>t_min<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">float</span> tMinz <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>std<span class="token double-colon punctuation">::</span><span class="token function">min</span><span class="token punctuation">(</span>tMinVec<span class="token punctuation">.</span>z<span class="token punctuation">,</span> tMaxVec<span class="token punctuation">.</span>z<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>ray<span class="token punctuation">.</span>t_min<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">float</span> tMaxx <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>std<span class="token double-colon punctuation">::</span><span class="token function">max</span><span class="token punctuation">(</span>tMinVec<span class="token punctuation">.</span>x<span class="token punctuation">,</span> tMaxVec<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>ray<span class="token punctuation">.</span>t_max<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">float</span> tMaxy <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>std<span class="token double-colon punctuation">::</span><span class="token function">max</span><span class="token punctuation">(</span>tMinVec<span class="token punctuation">.</span>y<span class="token punctuation">,</span> tMaxVec<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>ray<span class="token punctuation">.</span>t_max<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">float</span> tMaxz <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>std<span class="token double-colon punctuation">::</span><span class="token function">max</span><span class="token punctuation">(</span>tMinVec<span class="token punctuation">.</span>z<span class="token punctuation">,</span> tMaxVec<span class="token punctuation">.</span>z<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>ray<span class="token punctuation">.</span>t_max<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">float</span> tMin <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>tMinx<span class="token punctuation">,</span> tMiny<span class="token punctuation">,</span> tMinz<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">float</span> tMax <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>tMaxx<span class="token punctuation">,</span> tMaxy<span class="token punctuation">,</span> tMaxz<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>tMin <span class="token operator">&lt;=</span> tMax<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>思路就是计算这个交集：</p><script type="math/tex; mode=display">[t_\text{raymin},t_\text{raymax}]\cap[t_{x, \text{enter}}, t_{x, \text{exit}}]\cap[t_{y, \text{enter}}, t_{y, \text{exit}}]\cap[t_{z, \text{enter}}, t_{z, \text{exit}}]</script><p>对于最后的 <code>getIntersection</code>，小 AI 说可以在发生相交时更新 <code>ray</code> 的 <code>t_max</code>，然后在射线和盒子的交点大于 <code>t_max</code> 时不再检测盒子内部的相交，这可以优化性能。我认为他说得非常有道理，但改起来有点麻烦，就不改了。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Intersection <span class="token class-name">BVHAccel</span><span class="token double-colon punctuation">::</span><span class="token function">getIntersection</span><span class="token punctuation">(</span>BVHBuildNode<span class="token operator">*</span> node<span class="token punctuation">,</span> <span class="token keyword">const</span> Ray<span class="token operator">&amp;</span> ray<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token operator">-></span>bounds<span class="token punctuation">.</span><span class="token function">IntersectP</span><span class="token punctuation">(</span>ray<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token function">Intersection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// leaf node checks ray's intersection with obj  </span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-></span>left <span class="token operator">==</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> node<span class="token operator">-></span>right <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-></span>object <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token function">Intersection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> node<span class="token operator">-></span>object<span class="token operator">-></span><span class="token function">getIntersection</span><span class="token punctuation">(</span>ray<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>     <span class="token comment">// parent with only one child returns child's intersection</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-></span>left <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token function">getIntersection</span><span class="token punctuation">(</span>node<span class="token operator">-></span>right<span class="token punctuation">,</span> ray<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-></span>right <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token function">getIntersection</span><span class="token punctuation">(</span>node<span class="token operator">-></span>left<span class="token punctuation">,</span> ray<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>     <span class="token comment">// parent with two children returns the closer intersection</span>    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        Intersection inter1 <span class="token operator">=</span> <span class="token function">getIntersection</span><span class="token punctuation">(</span>node<span class="token operator">-></span>left<span class="token punctuation">,</span> ray<span class="token punctuation">)</span><span class="token punctuation">;</span>        Intersection inter2 <span class="token operator">=</span> <span class="token function">getIntersection</span><span class="token punctuation">(</span>node<span class="token operator">-></span>right<span class="token punctuation">,</span> ray<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>inter1<span class="token punctuation">.</span>happened <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>inter2<span class="token punctuation">.</span>happened<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token function">Intersection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>inter1<span class="token punctuation">.</span>happened<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> inter2<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>inter2<span class="token punctuation">.</span>happened<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> inter1<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>inter1<span class="token punctuation">.</span>distance <span class="token operator">&lt;</span> inter2<span class="token punctuation">.</span>distance<span class="token punctuation">)</span> <span class="token operator">?</span> inter1 <span class="token operator">:</span> inter2<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>咱还是在最后放放图图</p><p><img src="/images/learning/open-course/GAMES101/Assignments/hw6/bvh.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这次的作业要求实现用包围盒来加快光线追踪，再用 BVH 优化。&lt;/p&gt;
&lt;p&gt;首先我们要把 hw5 里的代码复制过来，让我不解的是代码里明明已经提供了 &lt;code&gt;rayTriangleIntersect&lt;/code&gt; 函数，PDF 里却还说“将你的光线-三角形相交函数粘贴</summary>
      
    
    
    
    <category term="公开课" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"/>
    
    <category term="GAMES101" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/"/>
    
    <category term="Assignments" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/Assignments/"/>
    
    
  </entry>
  
  <entry>
    <title>Assignment 5 Raytracing</title>
    <link href="http://rinevard.github.io/wiki/learning/open-course/GAMES101/Hw/Hw5-raytracing/"/>
    <id>http://rinevard.github.io/wiki/learning/open-course/GAMES101/Hw/Hw5-raytracing/</id>
    <published>2025-09-22T11:46:16.000Z</published>
    <updated>2025-09-26T04:09:50.574Z</updated>
    
    <content type="html"><![CDATA[<p>如果只是实现要求的话，感觉这会是很无聊的一次作业。为了让事情有趣一点，我们来看看 <code>castRay</code> 函数的实现吧。我们会把作业代码放在文末。</p><h1 id="castRay-函数的分析"><a href="#castRay-函数的分析" class="headerlink" title="castRay 函数的分析"></a>castRay 函数的分析</h1><p>castRay 函数实现了课上讲的光线追踪，它从 <code>orig</code> 打出朝着 <code>dir</code> 方向的射线，并返回颜色。其工作流程如下：</p><ol><li><p>首先，检查当前的递归深度<code>depth</code>。当<code>depth</code>超过场景设定的最大深度<code>scene.maxDepth</code>时，函数返回黑色。这就是开头的代码：</p> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span>depth <span class="token operator">></span> scene<span class="token punctuation">.</span>maxDepth<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">Vector3f</span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">,</span><span class="token number">0.0</span><span class="token punctuation">,</span><span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>然后，计算射线是否与场景中的任何物体相交。如果没有发生相交，说明射线射向了场景的背景，函数将返回背景颜色。</p></li><li><p>如果射线击中了某个物体，函数将根据该物体的材质类型，进入不同的处理分支计算颜色。接下来我们会分析这些分支。</p></li></ol><p>我们可以看到物体被分为了三种材质，分别是既有镜面反射又有折射的 <code>REFLECTION_AND_REFRACTION</code>、只有反射的 <code>REFLECTION</code>、只有漫反射的 <code>DIFFUSE_AND_GLOSSY</code>。<code>REFLECTION_AND_REFRACTION</code> 和 <code>REFLECTION</code> 部分的代码比较相似，我们就先讨论 <code>REFLECTION_AND_REFRACTION</code> 的代码，再讨论 <code>DIFFUSE_AND_GLOSSY</code> 的代码。</p><h2 id="REFLECTION-AND-REFRACTION"><a href="#REFLECTION-AND-REFRACTION" class="headerlink" title="REFLECTION_AND_REFRACTION"></a>REFLECTION_AND_REFRACTION</h2><p>这里的反射/折射材质自身是没有颜色的，也就是说它们只显示反射/折射后射线打到的点的颜色。所以代码思路比较简单，如果射线打到了这种材质的物体上，它会反射/折射，我们需要计算出反射/折射后的射线打到的颜色，这就对应着下面的代码：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Vector3f reflectionColor <span class="token operator">=</span> <span class="token function">castRay</span><span class="token punctuation">(</span>reflectionRayOrig<span class="token punctuation">,</span> reflectionDirection<span class="token punctuation">,</span> scene<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Vector3f refractionColor <span class="token operator">=</span> <span class="token function">castRay</span><span class="token punctuation">(</span>refractionRayOrig<span class="token punctuation">,</span> refractionDirection<span class="token punctuation">,</span> scene<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>代码里还考虑了菲涅尔效应来计算反射和折射的比例。菲涅尔效应的公式有点复杂，我们就不讲解了。这里的 <code>kr</code> 就是菲涅尔方程算出的反射系数，而由能量守恒，折射系数就是 $1-\text{kr}$。</p><p><code>hitColor</code> 就是这个点的最终颜色：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">float</span> kr <span class="token operator">=</span> <span class="token function">fresnel</span><span class="token punctuation">(</span>dir<span class="token punctuation">,</span> N<span class="token punctuation">,</span> payload<span class="token operator">-></span>hit_obj<span class="token operator">-></span>ior<span class="token punctuation">)</span><span class="token punctuation">;</span>hitColor <span class="token operator">=</span> reflectionColor <span class="token operator">*</span> kr <span class="token operator">+</span> refractionColor <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> kr<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>我们也会注意到，代码在开头对反射/折射点做了一个小小的偏移，这似乎是为了避免反射/折射时立即打到自己（咱也不确定，这是猜测）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Vector3f reflectionRayOrig <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token function">dotProduct</span><span class="token punctuation">(</span>reflectionDirection<span class="token punctuation">,</span> N<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span>                              hitPoint <span class="token operator">-</span> N <span class="token operator">*</span> scene<span class="token punctuation">.</span>epsilon <span class="token operator">:</span>                              hitPoint <span class="token operator">+</span> N <span class="token operator">*</span> scene<span class="token punctuation">.</span>epsilon<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>我们都看到菲涅尔效应的代码了，不如再看看纯反射/纯折射的球是怎样的。注意靠近我们观察者的球，我们可以先把 <code>kr</code> 设为 1 来看看纯反射的结果：</p><p><img src="/images/learning/open-course/GAMES101/Assignments/hw5/reflection_only.png" alt=""></p><p>再来看看纯折射的结果：</p><p><img src="/images/learning/open-course/GAMES101/Assignments/hw5/refraction_only.png" alt=""></p><p>与文末的图比较一下，就会发现菲涅尔效应确实就是反射和折射的叠加。</p><h2 id="DIFFUSE-AND-GLOSSY"><a href="#DIFFUSE-AND-GLOSSY" class="headerlink" title="DIFFUSE_AND_GLOSSY"></a>DIFFUSE_AND_GLOSSY</h2><p>再来看看 <code>DIFFUSE_AND_GLOSSY</code> 部分，这里是正常的 Phong 模型着色。唯一要注意的是，要判断射线打到的点和光源之间有没有物体遮挡，如果有遮挡这里就是阴影。</p><p>我认为这一部分的代码有问题，它只考虑了漫反射分量在不在阴影里，而没考虑镜面反射分量。这里是原本的代码：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 漫反射</span>lightAmt <span class="token operator">+=</span> inShadow <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> light<span class="token operator">-></span>intensity <span class="token operator">*</span> LdotN<span class="token punctuation">;</span><span class="token comment">// 镜面反射</span>Vector3f reflectionDirection <span class="token operator">=</span> <span class="token function">reflect</span><span class="token punctuation">(</span><span class="token operator">-</span>lightDir<span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span>specularColor <span class="token operator">+=</span> <span class="token function">powf</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">0.f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token function">dotProduct</span><span class="token punctuation">(</span>reflectionDirection<span class="token punctuation">,</span> dir<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    payload<span class="token operator">-></span>hit_obj<span class="token operator">-></span>specularExponent<span class="token punctuation">)</span> <span class="token operator">*</span> light<span class="token operator">-></span>intensity<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我想我们应该做这样的修改：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>inShadow<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 漫反射</span>    lightAmt <span class="token operator">+=</span> light<span class="token operator">-></span>intensity <span class="token operator">*</span> LdotN<span class="token punctuation">;</span>        <span class="token comment">// 镜面反射</span>    Vector3f reflectionDirection <span class="token operator">=</span> <span class="token function">reflect</span><span class="token punctuation">(</span><span class="token operator">-</span>lightDir<span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span>    specularColor <span class="token operator">+=</span> <span class="token function">powf</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">0.f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token function">dotProduct</span><span class="token punctuation">(</span>reflectionDirection<span class="token punctuation">,</span> dir<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        payload<span class="token operator">-></span>hit_obj<span class="token operator">-></span>specularExponent<span class="token punctuation">)</span> <span class="token operator">*</span> light<span class="token operator">-></span>intensity<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="作业代码"><a href="#作业代码" class="headerlink" title="作业代码"></a>作业代码</h1><p>接下来咱就直接放作业代码了。</p><p>首先是 <code>rayTriangleIntersect</code>：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">rayTriangleIntersect</span><span class="token punctuation">(</span><span class="token keyword">const</span> Vector3f<span class="token operator">&amp;</span> v0<span class="token punctuation">,</span> <span class="token keyword">const</span> Vector3f<span class="token operator">&amp;</span> v1<span class="token punctuation">,</span> <span class="token keyword">const</span> Vector3f<span class="token operator">&amp;</span> v2<span class="token punctuation">,</span> <span class="token keyword">const</span> Vector3f<span class="token operator">&amp;</span> orig<span class="token punctuation">,</span>                          <span class="token keyword">const</span> Vector3f<span class="token operator">&amp;</span> dir<span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token operator">&amp;</span> tNear<span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token operator">&amp;</span> u<span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token operator">&amp;</span> v<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">auto</span> e1 <span class="token operator">=</span> v1 <span class="token operator">-</span> v0<span class="token punctuation">;</span>    <span class="token keyword">auto</span> e2 <span class="token operator">=</span> v2 <span class="token operator">-</span> v0<span class="token punctuation">;</span>    <span class="token keyword">auto</span> s <span class="token operator">=</span> orig <span class="token operator">-</span> v0<span class="token punctuation">;</span>    <span class="token keyword">auto</span> s1 <span class="token operator">=</span> <span class="token function">crossProduct</span><span class="token punctuation">(</span>dir<span class="token punctuation">,</span> e2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> s2 <span class="token operator">=</span> <span class="token function">crossProduct</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> e1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> coefficient <span class="token operator">=</span> <span class="token number">1.0</span> <span class="token operator">/</span> <span class="token function">dotProduct</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> e1<span class="token punctuation">)</span><span class="token punctuation">;</span>    tNear <span class="token operator">=</span> coefficient <span class="token operator">*</span> <span class="token function">dotProduct</span><span class="token punctuation">(</span>s2<span class="token punctuation">,</span> e2<span class="token punctuation">)</span><span class="token punctuation">;</span>    u <span class="token operator">=</span> coefficient <span class="token operator">*</span> <span class="token function">dotProduct</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>    v <span class="token operator">=</span> coefficient <span class="token operator">*</span> <span class="token function">dotProduct</span><span class="token punctuation">(</span>s2<span class="token punctuation">,</span> dir<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>tNear <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>u <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>v <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> u <span class="token operator">-</span> v<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后是 <code>Render</code> 的部分：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> scene<span class="token punctuation">.</span>width<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// generate primary ray direction</span>    <span class="token keyword">float</span> x<span class="token punctuation">;</span>    <span class="token keyword">float</span> y<span class="token punctuation">;</span>    <span class="token comment">// I don't understand what are the guiding comments talking about.</span>    <span class="token comment">// Anyway, the code is assuming the distance between eye and screen is one, since abs(dir.z) == 1</span>    <span class="token comment">// With this assumption we can compute screen's width and height</span>    <span class="token comment">// Then we map x from [0, scene.width - 1] to [-screen_width / 2, screenwidth / 2]</span>    <span class="token comment">// and map y from [0, scene.height - 1] to [screen_height / 2, -screen_height / 2]</span>    <span class="token keyword">float</span> screen_height <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> scale<span class="token punctuation">;</span>    <span class="token keyword">float</span> screen_width <span class="token operator">=</span> imageAspectRatio <span class="token operator">*</span> screen_height<span class="token punctuation">;</span>        x <span class="token operator">=</span> <span class="token punctuation">(</span>screen_width <span class="token operator">/</span> <span class="token punctuation">(</span>scene<span class="token punctuation">.</span>width <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">0.5</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token punctuation">(</span>screen_width <span class="token operator">/</span> <span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    y <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">-</span>screen_height <span class="token operator">/</span> <span class="token punctuation">(</span>scene<span class="token punctuation">.</span>height <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>j <span class="token operator">+</span> <span class="token number">0.5</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>screen_height <span class="token operator">/</span> <span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Vector3f dir <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span><span class="token function">Vector3f</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Don't forget to normalize this direction!</span>    framebuffer<span class="token punctuation">[</span>m<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">castRay</span><span class="token punctuation">(</span>eye_pos<span class="token punctuation">,</span> dir<span class="token punctuation">,</span> scene<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看看结果吧！如果和前面的纯反射/纯折射对照，会发现前面的球确实就是反射和折射的叠加（反射很淡，不过仔细看也是能看出来的！）</p><p><img src="/images/learning/open-course/GAMES101/Assignments/hw5/binary.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;如果只是实现要求的话，感觉这会是很无聊的一次作业。为了让事情有趣一点，我们来看看 &lt;code&gt;castRay&lt;/code&gt; 函数的实现吧。我们会把作业代码放在文末。&lt;/p&gt;
&lt;h1 id=&quot;castRay-函数的分析&quot;&gt;&lt;a href=&quot;#castRay-函数的分析&quot; cl</summary>
      
    
    
    
    <category term="公开课" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"/>
    
    <category term="GAMES101" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/"/>
    
    <category term="Assignments" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/Assignments/"/>
    
    
  </entry>
  
  <entry>
    <title>Assignment 4 Geometry</title>
    <link href="http://rinevard.github.io/wiki/learning/open-course/GAMES101/Hw/Hw4-geometry/"/>
    <id>http://rinevard.github.io/wiki/learning/open-course/GAMES101/Hw/Hw4-geometry/</id>
    <published>2025-09-22T11:44:16.000Z</published>
    <updated>2025-09-22T11:44:41.718Z</updated>
    
    <content type="html"><![CDATA[<p>这次作业过于简单，我们直接放代码。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cv<span class="token double-colon punctuation">::</span>Point2f <span class="token function">recursive_bezier</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>cv<span class="token double-colon punctuation">::</span>Point2f<span class="token operator">></span> <span class="token operator">&amp;</span>control_points<span class="token punctuation">,</span> <span class="token keyword">float</span> t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// TODO: Implement de Casteljau's algorithm</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>control_points<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> t<span class="token punctuation">)</span> <span class="token operator">*</span> control_points<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> t <span class="token operator">*</span> control_points<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>cv<span class="token double-colon punctuation">::</span>Point2f<span class="token operator">></span> new_control_points <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> control_points<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        new_control_points<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> t<span class="token punctuation">)</span> <span class="token operator">*</span> control_points<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> t <span class="token operator">*</span> control_points<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token function">recursive_bezier</span><span class="token punctuation">(</span>new_control_points<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">bezier</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>cv<span class="token double-colon punctuation">::</span>Point2f<span class="token operator">></span> <span class="token operator">&amp;</span>control_points<span class="token punctuation">,</span> cv<span class="token double-colon punctuation">::</span>Mat <span class="token operator">&amp;</span>window<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// TODO: Iterate through all t = 0 to t = 1 with small steps, and call de Casteljau's </span>    <span class="token comment">// recursive Bezier algorithm.</span>    <span class="token keyword">float</span> step <span class="token operator">=</span> <span class="token number">0.001</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">float</span> t <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> t <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span> t <span class="token operator">+=</span> step <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">auto</span> point <span class="token operator">=</span> <span class="token function">recursive_bezier</span><span class="token punctuation">(</span>control_points<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>        window<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">at</span><span class="token generic class-name"><span class="token operator">&lt;</span>cv<span class="token double-colon punctuation">::</span>Vec3b<span class="token operator">></span></span></span><span class="token punctuation">(</span>point<span class="token punctuation">.</span>y<span class="token punctuation">,</span> point<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">255</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另外，由于咱以前在 Godot 里导入字体时见过多通道符号距离场的设置，而且发现开启多通道符号距离场的字体显示清晰了一大截，所以我找了找一些关于 SDF 的资料，感觉这个不错：<a href="https://www.xianlongok.site/post/4625ed6a/#SDF-font">动态 SDF 字体渲染方法 | 十三</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这次作业过于简单，我们直接放代码。&lt;/p&gt;
&lt;pre class=&quot;line-numbers language-cpp&quot; data-language=&quot;cpp&quot;&gt;&lt;code class=&quot;language-cpp&quot;&gt;cv&lt;span class=&quot;token double-c</summary>
      
    
    
    
    <category term="公开课" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"/>
    
    <category term="GAMES101" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/"/>
    
    <category term="Assignments" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/Assignments/"/>
    
    
  </entry>
  
  <entry>
    <title>Note 4 Geometry</title>
    <link href="http://rinevard.github.io/wiki/learning/open-course/GAMES101/Notes/Note4-Geometry/"/>
    <id>http://rinevard.github.io/wiki/learning/open-course/GAMES101/Notes/Note4-Geometry/</id>
    <published>2025-09-19T12:10:28.000Z</published>
    <updated>2025-09-19T12:13:54.595Z</updated>
    
    <content type="html"><![CDATA[<p>课上只是简单提了下几何专题，我也认为这个专题相较于别的几个没那么重要，所以只是记一下隐式表示和参数表示的相关内容，再简单提一句网格处理。</p><h1 id="隐式表示和参数表示"><a href="#隐式表示和参数表示" class="headerlink" title="隐式表示和参数表示"></a>隐式表示和参数表示</h1><p>对一个几何图形，我们一般有两种表示方法，一种是用普通方程 $f(x,y,z)=0$ 来表示，另一种是用参数方程 $g(u,v)=(x,y,z)$ 来表示。前者是隐式表示，因为不能方便地求出这个方程表示的所有点；后者是参数表示，通过参数 $(u,v)$ 的变化可以轻易求出这个方程表示的所有点。</p><p>不过隐式表示也有优点，它能很方便地判断一个点 $(x,y,z)$ 是否在曲线上 / 曲线内 / 曲线外。接下来我们看看隐式表示和参数表示的代表应用。</p><h2 id="隐式表示：符号距离场"><a href="#隐式表示：符号距离场" class="headerlink" title="隐式表示：符号距离场"></a>隐式表示：符号距离场</h2><p>符号距离场（Signed Distance Filed, SDF）是隐式表示的代表应用之一，自 2007 年 Valve 的论文以来，它一直被用于游戏内的文本渲染。虽然现在用的更多是多通道符号距离场（MSDF），但我们这里只简单介绍下符号距离场，因为后者更加复杂。</p><p>符号距离场就是带符号的距离场，对给定的点 $(u,v)$，我们记录它到图形的最近距离——如果它在图形内部（图形的线条是有宽度的，这个内部指在线条内而非几何闭环内），距离为正值，否则为负值。</p><p>在 V 社的论文中，他们先对矢量文字做了光栅化得到了 $4096\times 4096$ 的图像，然后基于这张图得到了 $64\times 64$ 的符号距离场。</p><p>下图展示了原图和符号距离场。图像不透明度是在 $[0,1]$ 间的非负数，为了可视化符号距离场，我们把距离为正的内部映射到 $(0.5, 1]$，距离为 $0$ 的边缘被映射到 $0.5$，距离为负的外部映射到 $[0, 0.5)$.</p><p><img src="/images/learning/open-course/GAMES101/Notes/note4/sdf.png" alt=""></p><p>得到了符号距离场之后，我们就能对任何一个点插值出它与图形的距离，然后根据这个距离决定它是否显示出来。我们之前已经提过了距离到不透明度的映射，我们可以简单设置一个阈值来决定是否显示某个像素：</p><pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl">baseColor<span class="token punctuation">.</span>a <span class="token operator">=</span> distAlphaMask <span class="token operator">>=</span> <span class="token number">0.5</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我个人的思考是，不要因为我们可视化了符号距离场就把它当作图像。它本质上是一个距离函数 $d(u,v)$，我们的 $64\times 64$ 的 SDF 图像的每个像素表示的不是“平均颜色”，而是“像素中心点到图形的距离”。要把它看作点，而非方块。</p><h2 id="参数表示：贝塞尔曲线和曲面"><a href="#参数表示：贝塞尔曲线和曲面" class="headerlink" title="参数表示：贝塞尔曲线和曲面"></a>参数表示：贝塞尔曲线和曲面</h2><p>贝塞尔曲线和曲面是参数表示的很好例子，我们先来看看计算贝塞尔曲线的常用算法和一般公式。</p><h3 id="贝塞尔曲线"><a href="#贝塞尔曲线" class="headerlink" title="贝塞尔曲线"></a>贝塞尔曲线</h3><p>常用的生成贝塞尔曲线的 Casteljau Algorithm 如下，我们以四个点求三阶贝塞尔曲线为例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">bezier</span><span class="token punctuation">(</span>t<span class="token punctuation">:</span> <span class="token builtin">float</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 第一层线性插值</span>    p0_1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> t<span class="token punctuation">)</span> <span class="token operator">*</span> p0 <span class="token operator">+</span> t <span class="token operator">*</span> p1    p1_1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> t<span class="token punctuation">)</span> <span class="token operator">*</span> p1 <span class="token operator">+</span> t <span class="token operator">*</span> p2    p2_1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> t<span class="token punctuation">)</span> <span class="token operator">*</span> p2 <span class="token operator">+</span> t <span class="token operator">*</span> p3    <span class="token comment"># 第二层线性插值</span>    p0_2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> t<span class="token punctuation">)</span> <span class="token operator">*</span> p0_1 <span class="token operator">+</span> t <span class="token operator">*</span> p1_1    p1_2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> t<span class="token punctuation">)</span> <span class="token operator">*</span> p1_1 <span class="token operator">+</span> t <span class="token operator">*</span> p2_1    <span class="token comment"># 第三层（最后一层）线性插值</span>    p_final <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> t<span class="token punctuation">)</span> <span class="token operator">*</span> p0_2 <span class="token operator">+</span> t <span class="token operator">*</span> p1_2    <span class="token keyword">return</span> p_final<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看看这个算法也就知道贝塞尔曲线是怎么来的了。</p><p>三阶公式是</p><script type="math/tex; mode=display">\mathbf{B}(t) = (1-t)^3 \mathbf{P}_0 + 3(1-t)^2 t \mathbf{P}_1 + 3(1-t) t^2 \mathbf{P}_2 + t^3 \mathbf{P}_3</script><p>一般的 $n$ 阶公式是</p><script type="math/tex; mode=display">\mathbf{B}(t) = \sum_{i=0}^{m} \binom{m}{i} (1-t)^{m-i} t^i \mathbf{P}_i</script><p>下图中，左图是 Godot 里的 Curve，它就用到了贝塞尔曲线；右图贝塞尔曲线的生成方法，和上面提到的 Casteljau Algorithm 一致。</p><p><img src="/images/learning/open-course/GAMES101/Notes/note4/bezier.png" alt=""></p><p>再看看左图，我们会发现它是由三个贝塞尔曲线拼接而成的，而且看起来很平滑，这就是所谓的“分段贝塞尔曲线”。高阶贝塞尔曲线不容易控制，所以我们更倾向于把几个低阶贝塞尔曲线拼接起来形成复杂曲线。</p><h3 id="贝塞尔曲面"><a href="#贝塞尔曲面" class="headerlink" title="贝塞尔曲面"></a>贝塞尔曲面</h3><p>我们同样用 Casteljau Algorithm 生成贝塞尔曲面：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">_de_casteljau_1d</span><span class="token punctuation">(</span>points<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""对一维点序列执行 Casteljau 算法。"""</span>    <span class="token keyword">while</span> <span class="token builtin">len</span><span class="token punctuation">(</span>points<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">:</span>        points <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> t<span class="token punctuation">)</span> <span class="token operator">*</span> p1 <span class="token operator">+</span> t <span class="token operator">*</span> p2 <span class="token keyword">for</span> p1<span class="token punctuation">,</span> p2 <span class="token keyword">in</span> <span class="token builtin">zip</span><span class="token punctuation">(</span>points<span class="token punctuation">,</span> points<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token keyword">return</span> points<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token keyword">def</span> <span class="token function">bezier_surface</span><span class="token punctuation">(</span>control_points<span class="token punctuation">,</span> u<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""计算贝塞尔曲面上的一点。"""</span>    intermediate_points <span class="token operator">=</span> <span class="token punctuation">[</span>_de_casteljau_1d<span class="token punctuation">(</span>row<span class="token punctuation">,</span> u<span class="token punctuation">)</span> <span class="token keyword">for</span> row <span class="token keyword">in</span> control_points<span class="token punctuation">]</span>    final_point <span class="token operator">=</span> _de_casteljau_1d<span class="token punctuation">(</span>intermediate_points<span class="token punctuation">,</span> v<span class="token punctuation">)</span>    <span class="token keyword">return</span> final_point<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如下图中的右图所示，我们本质上是先沿着一个轴向生成一组贝塞尔曲线，再在曲线上取值生成一组新的控制点，然后用这组新控制点定义一条新的曲线，最后在新的曲线上取值得到曲面上的最终点。</p><p><img src="/images/learning/open-course/GAMES101/Notes/note4/bezier_surface.png" alt=""></p><h1 id="网格处理"><a href="#网格处理" class="headerlink" title="网格处理"></a>网格处理</h1><p>生成三角形网格后，我们经常还希望做一些处理，比如细分来让模型更光滑；减少三角形数量来简化网格。下面简单提一下网格细分和网格简化的常用算法。</p><p><img src="/images/learning/open-course/GAMES101/Notes/note4/mesh_operation.png" alt=""></p><h2 id="网格细分"><a href="#网格细分" class="headerlink" title="网格细分"></a>网格细分</h2><p>网格细分算法的绝对主流是 Catmull-Clark 细分，Blender 的表面细分修改器的默认算法就是这个。它可以细分任意形状的多边形，但在细分四边形时效果最好。</p><p>课上还提到了用于细分三角形的 Loop 细分，不过两个细分都只是简单提了提概念，我们这里不多记笔记。</p><h2 id="网格简化"><a href="#网格简化" class="headerlink" title="网格简化"></a>网格简化</h2><p>网格简化的基本思路是每次把一条边坍缩成一个点。我们用二次误差衡量每条边坍缩后引入的误差，然后选择最小的边来坍缩，之后重新计算二次误差（因为坍缩后形状会改变），然后再次选择最小的边，如此重复。这是个贪婪算法，但能拿到不错的结果。</p><p>具体公式我们也不写，因为课上没详细讲，我也不感兴趣，用到的时候去查查就好了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;课上只是简单提了下几何专题，我也认为这个专题相较于别的几个没那么重要，所以只是记一下隐式表示和参数表示的相关内容，再简单提一句网格处理。&lt;/p&gt;
&lt;h1 id=&quot;隐式表示和参数表示&quot;&gt;&lt;a href=&quot;#隐式表示和参数表示&quot; class=&quot;headerlink&quot; title</summary>
      
    
    
    
    <category term="公开课" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"/>
    
    <category term="GAMES101" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/"/>
    
    <category term="Notes" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/Notes/"/>
    
    
  </entry>
  
</feed>
