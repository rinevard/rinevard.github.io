<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Rinevard</title>
  
  
  <link href="http://rinevard.github.io/atom.xml" rel="self"/>
  
  <link href="http://rinevard.github.io/"/>
  <updated>2025-06-16T14:03:15.522Z</updated>
  <id>http://rinevard.github.io/</id>
  
  <author>
    <name>Rinevard</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>我也想做出优秀的作品，可是好难</title>
    <link href="http://rinevard.github.io/wiki/others/thoughts/%E6%88%91%E4%B9%9F%E6%83%B3%E5%81%9A%E5%87%BA%E4%BC%98%E7%A7%80%E7%9A%84%E4%BD%9C%E5%93%81/"/>
    <id>http://rinevard.github.io/wiki/others/thoughts/%E6%88%91%E4%B9%9F%E6%83%B3%E5%81%9A%E5%87%BA%E4%BC%98%E7%A7%80%E7%9A%84%E4%BD%9C%E5%93%81/</id>
    <published>2025-06-16T14:03:30.000Z</published>
    <updated>2025-06-16T14:03:15.522Z</updated>
    
    <content type="html"><![CDATA[<p>最近做了<a href="https://rinevard.itch.io/myriad-by-cards">牌生万物</a>，感觉挺难受的。一直以来我都希望每一部作品都做得比上一部更好，这一部看起来比<a href="https://rinevard.itch.io/undertetris">undertetris</a>好一点吗？或许吧，但我就是感觉不开心。</p><p>想来可能是因为这不是我喜欢的体验吧。我想做出能打动玩家的作品，能让玩家记住一辈子，至少是一年的作品，而不是这样的莫名其妙的“融合卡牌”。玩着这个游戏时，比起对作品的满意，更多的是烦躁。也可能是因为现在是考试周压力大吧，我也不清楚。</p><p>我想和LLM一起创造一个世界啊，一个栩栩如生的世界。每个事件都让人思考，每个角色都给人深刻印象，而不是现在的名词堆砌、数值膨胀。LLM不会写故事从来都不是借口，我们是不是本可以做得更好？</p><p>我该怎么做才好？我该前往何方？</p><p>我知道，让LLM生成的世界像《苏丹的游戏》一样本身就是一件不现实的事情。但起码它要像是一个世界吧，整个冒险是有故事性的吧，现在是个什么玩意？？？更可气的是这玩意还真有可玩性，做了一个靠强化程序和数值膨胀堆砌起来的东西真像是对自己的侮辱！</p><p>至少，它的体验不该是数值膨胀。至少，让玩家玩下去的动力不该是强化程序。如果我们拿走了玩家的时间，我们起码应当补偿一些什么才对，而不该徒留悔恨感。</p><p>可能也有点偏激了，可能只是我自己不喜欢这种类型而已……甚至我自己也觉得还算可以，至少确实有让我印象深刻的时刻。但我还是感觉不开心，毕竟，“我们是不是本可以做得更好？”</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近做了&lt;a href=&quot;https://rinevard.itch.io/myriad-by-cards&quot;&gt;牌生万物&lt;/a&gt;，感觉挺难受的。一直以来我都希望每一部作品都做得比上一部更好，这一部看起来比&lt;a href=&quot;https://rinevard.itch.io/un</summary>
      
    
    
    
    <category term="杂谈" scheme="http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    <category term="碎碎念" scheme="http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
  </entry>
  
  <entry>
    <title>Lab2 System calls</title>
    <link href="http://rinevard.github.io/wiki/learning/open-course/MIT-6.S081/Labs/lab2-syscall/"/>
    <id>http://rinevard.github.io/wiki/learning/open-course/MIT-6.S081/Labs/lab2-syscall/</id>
    <published>2025-06-04T07:10:38.000Z</published>
    <updated>2025-06-04T06:37:13.135Z</updated>
    
    
    
    
    <category term="学习" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="公开课" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/"/>
    
    <category term="MIT-6.S081" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/MIT-6-S081/"/>
    
    <category term="Labs" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/MIT-6-S081/Labs/"/>
    
    
  </entry>
  
  <entry>
    <title>第二章——操作系统概述</title>
    <link href="http://rinevard.github.io/wiki/learning/open-course/MIT-6.S081/Notes/note2-organization-overview/"/>
    <id>http://rinevard.github.io/wiki/learning/open-course/MIT-6.S081/Notes/note2-organization-overview/</id>
    <published>2025-06-04T06:26:38.000Z</published>
    <updated>2025-06-04T06:43:40.608Z</updated>
    
    
    
    
    <category term="学习" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="公开课" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/"/>
    
    <category term="MIT-6.S081" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/MIT-6-S081/"/>
    
    <category term="Notes" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/MIT-6-S081/Notes/"/>
    
    
  </entry>
  
  <entry>
    <title>第一章——系统接口</title>
    <link href="http://rinevard.github.io/wiki/learning/open-course/MIT-6.S081/Notes/note1-sys-interface/"/>
    <id>http://rinevard.github.io/wiki/learning/open-course/MIT-6.S081/Notes/note1-sys-interface/</id>
    <published>2025-06-01T03:18:38.000Z</published>
    <updated>2025-06-04T06:36:39.184Z</updated>
    
    <content type="html"><![CDATA[<style>img{    width: 70%;}</style><h1 id="常用的系统接口"><a href="#常用的系统接口" class="headerlink" title="常用的系统接口"></a>常用的系统接口</h1><table><thead><tr><th><strong>系统调用</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>fork()</td><td>创建进程</td></tr><tr><td>exit()</td><td>结束当前进程</td></tr><tr><td>wait()</td><td>等待子进程结束</td></tr><tr><td>kill(pid)</td><td>结束 pid 所指进程</td></tr><tr><td>getpid()</td><td>获得当前进程 pid</td></tr><tr><td>sleep(n)</td><td>睡眠 n 秒</td></tr><tr><td>exec(filename, *argv)</td><td>加载并执行一个文件</td></tr><tr><td>sbrk(n)</td><td>为进程内存空间增加 n 字节</td></tr><tr><td>open(filename, flags)</td><td>打开文件，flags 指定读&#x2F;写模式</td></tr><tr><td>read(fd, buf, n)</td><td>从文件中读 n 个字节到 buf</td></tr><tr><td>write(fd, buf, n)</td><td>从 buf 中写 n 个字节到文件</td></tr><tr><td>close(fd)</td><td>关闭打开的 fd</td></tr><tr><td>dup(fd)</td><td>复制 fd</td></tr><tr><td>pipe( p)</td><td>创建管道， 并把读和写的 fd 返回到p</td></tr><tr><td>chdir(dirname)</td><td>改变当前目录</td></tr><tr><td>mkdir(dirname)</td><td>创建新的目录</td></tr><tr><td>mknod(name, major, minor)</td><td>创建设备文件</td></tr><tr><td>fstat(fd)</td><td>返回文件信息</td></tr><tr><td>link(f1, f2)</td><td>给 f1 创建一个新名字(f2)</td></tr><tr><td>unlink(filename)</td><td>删除文件</td></tr></tbody></table><h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><table><thead><tr><th><strong>系统调用</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>fork()</td><td>创建进程</td></tr><tr><td>exit()</td><td>结束当前进程</td></tr><tr><td>wait()</td><td>等待子进程结束</td></tr><tr><td>kill(pid)</td><td>结束 pid 所指进程</td></tr><tr><td>getpid()</td><td>获得当前进程 pid</td></tr><tr><td>exec(filename, *argv)</td><td>加载并执行一个文件</td></tr><tr><td>sbrk(n)</td><td>为进程内存空间增加 n 字节</td></tr></tbody></table><h1 id="I-O"><a href="#I-O" class="headerlink" title="I&#x2F;O"></a>I&#x2F;O</h1><table><thead><tr><th><strong>系统调用</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>open(filename, flags)</td><td>打开文件，flags 指定读&#x2F;写模式</td></tr><tr><td>read(fd, buf, n)</td><td>从文件中读 n 个字节到 buf</td></tr><tr><td>write(fd, buf, n)</td><td>从 buf 中写 n 个字节到文件</td></tr><tr><td>close(fd)</td><td>关闭打开的 fd</td></tr><tr><td>dup(fd)</td><td>复制 fd</td></tr></tbody></table><p>代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">512</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cat</span><span class="params">(<span class="type">int</span> fd)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((n = read(fd, buf, <span class="keyword">sizeof</span>(buf))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 写入标准输出</span></span><br><span class="line">        <span class="keyword">if</span> (write(<span class="number">1</span>, buf, n) != n) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;cat: write error\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;cat: read error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd, i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        cat(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((fd = open(argv[i], O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;cat: cannot open %s\n&quot;</span>, argv[i]);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        cat(fd);</span><br><span class="line">        close(fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不妨再来看看CSAPP的两张图</p><h3 id="open两次："><a href="#open两次：" class="headerlink" title="open两次："></a><strong>open两次：</strong></h3><p><img src="/images/learning/open-course/MIT-6.S081/notes/note1-syscall/opentwice.png"></p><h3 id="fork："><a href="#fork：" class="headerlink" title="fork："></a><strong>fork：</strong></h3><p><img src="/images/learning/open-course/MIT-6.S081/notes/note1-syscall/fork.png"></p><h1 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h1><table><thead><tr><th><strong>系统调用</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>pipe( p)</td><td>创建管道， 并把读和写的 fd 返回到p，其中p是 int p[2]</td></tr></tbody></table><ul><li>p[0]: 读端(read end)的文件描述符</li><li>p[1]: 写端(write end)的文件描述符</li></ul><p>样例： <code>grep fork sh.c | wc -l</code> 命令将第一个命令(grep)的输出作为第二个命令(wc)的输入，<code>|</code> 就是管道符号。</p><p>下面的代码是 <code>|</code> 的实现示例，大体思路是把 <code>|</code> 左边的标准输出重定向到pipe的写端，把 <code>|</code> 右边的标准输入重定向到pipe的读端。</p><p>注意要关闭管道的所有写入端来让 <code>read</code> 返回，因为当 pipe 中没有数据时，<code>read</code> 会阻塞等待新数据写入，或是写入端都关闭，如果有新数据写入就读取，如果所有写入端都关闭就返回 0（对应EOF）.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设我们的命令是 grep fork sh.c | wc -l</span></span><br><span class="line"><span class="keyword">case</span> PIPE:</span><br><span class="line">    pcmd = (<span class="keyword">struct</span> pipecmd *)cmd;</span><br><span class="line">    <span class="keyword">if</span> (pipe(p) &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fork1() == <span class="number">0</span>) &#123;</span><br><span class="line">        close(<span class="number">1</span>);   <span class="comment">// 释放文件描述符1，从而让dup把文件描述符1绑定到p[1]指向的东西</span></span><br><span class="line">        dup(p[<span class="number">1</span>]);  <span class="comment">//换句话说，我们在重定向标准输出到pipe的写端</span></span><br><span class="line">        close(p[<span class="number">0</span>]);</span><br><span class="line">        close(p[<span class="number">1</span>]);</span><br><span class="line">        runcmd(pcmd-&gt;left); <span class="comment">// 对应 grep fork sh.c</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fork1() == <span class="number">0</span>) &#123;</span><br><span class="line">        close(<span class="number">0</span>);  <span class="comment">// 与上面类似，重定向标准输入到pipe的读端</span></span><br><span class="line">        dup(p[<span class="number">0</span>]);</span><br><span class="line">        close(p[<span class="number">0</span>]);</span><br><span class="line">        close(p[<span class="number">1</span>]);</span><br><span class="line">        runcmd(pcmd-&gt;right); <span class="comment">// 对应 wc -l</span></span><br><span class="line">    &#125;</span><br><span class="line">    close(p[<span class="number">0</span>]);</span><br><span class="line">    close(p[<span class="number">1</span>]);</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><table><thead><tr><th><strong>系统调用</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>chdir(dirname)</td><td>改变当前目录</td></tr><tr><td>mkdir(dirname)</td><td>创建新的目录</td></tr><tr><td>mknod(name, major, minor)</td><td>创建设备文件</td></tr><tr><td>fstat(fd)</td><td>返回文件信息</td></tr><tr><td>link(f1, f2)</td><td>给 f1 创建一个新名字(f2)</td></tr><tr><td>unlink(filename)</td><td>删除文件</td></tr></tbody></table><p>我们通常认为文件名就是文件本身，但实际上名称是一个硬链接(hard link)。一个文件可以有多个硬链接——例如，一个目录至少有两个硬链接：目录名和 <code>.</code> （在目录内时）。它还有来自每个子目录的一个硬链接（每个子目录中的 <code>..</code> 文件）。</p><p>那文件是什么呢？一个文件和一个 inode 一一对应，inode存放着这个文件的相关信息</p><p>xv6系统的inode结构包括下面这些内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> &#123;</span></span><br><span class="line">    <span class="type">short</span> type;              <span class="comment">// File type</span></span><br><span class="line">    <span class="type">short</span> major;             <span class="comment">// Major device number (T_DEVICE only)</span></span><br><span class="line">    <span class="type">short</span> minor;             <span class="comment">// Minor device number (T_DEVICE only)</span></span><br><span class="line">    <span class="type">short</span> nlink;             <span class="comment">// Number of links to inode in file system</span></span><br><span class="line">    uint size;               <span class="comment">// Size of file (bytes)</span></span><br><span class="line">    uint addrs[NDIRECT + <span class="number">1</span>]; <span class="comment">// Data block addresses</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以通过 <code>fstat</code> 获取文件描述符指向的文件的信息。dinode是磁盘上存储的详细信息，stat是暴露给用户的文件信息接口</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> dev;     <span class="comment">// File system&#x27;s disk device</span></span><br><span class="line">    uint ino;    <span class="comment">// Inode number</span></span><br><span class="line">    <span class="type">short</span> type;  <span class="comment">// Type of file</span></span><br><span class="line">    <span class="type">short</span> nlink; <span class="comment">// Number of links to file</span></span><br><span class="line">    uint64 size; <span class="comment">// Size of file in bytes</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>仅当我们把所有指向某个inode的链接都删除，这个inode才会被删除。</p><p>在下面的示例中，我们用 <code>ln</code> 创建了两个连接 file2 和 file3，它们都和 file1 指向的 inode 相同。可以看到，如果用 <code>echo</code> 修改 file2，那么 file1 也会被修改，因为我们修改的实际上是 inode，而它们指向同一个inode。<code>ls -l</code> 列出目录中的文件和目录的详细信息，第二个值是inode的link数。我们可以把链接视作文件的“别名”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;What&#x27;s in a name? That which we call a rose, by any other word would smell as sweet.&quot; &gt; file1.txt</span><br><span class="line"></span><br><span class="line">$ ls</span><br><span class="line">file1.txt  open-course  programs</span><br><span class="line"></span><br><span class="line">$ cat file1.txt</span><br><span class="line">What&#x27;s in a name? That which we call a rose, by any other word would smell as sweet.</span><br><span class="line"></span><br><span class="line">$ ln file1.txt file2.txt</span><br><span class="line"></span><br><span class="line">$ ln file1.txt file3.txt</span><br><span class="line"></span><br><span class="line">$ ls -l</span><br><span class="line">total 20</span><br><span class="line">-rw-r--r-- 3 rinevard rinevard   85 May 29 11:37 file1.txt</span><br><span class="line">-rw-r--r-- 3 rinevard rinevard   85 May 29 11:37 file2.txt</span><br><span class="line">-rw-r--r-- 3 rinevard rinevard   85 May 29 11:37 file3.txt</span><br><span class="line">drwxr-xr-x 3 rinevard rinevard 4096 May 28 11:00 open-course</span><br><span class="line">drwxr-xr-x 2 rinevard rinevard 4096 May 28 10:19 programs</span><br><span class="line"></span><br><span class="line">$ echo &quot;-- William Shakespeare&quot; &gt;&gt; file2.txt</span><br><span class="line"></span><br><span class="line">$ cat file1.txt</span><br><span class="line">What&#x27;s in a name? That which we call a rose, by any other word would smell as sweet.</span><br><span class="line">-- William Shakespeare</span><br></pre></td></tr></table></figure><p>你可能会好奇目录的链接数怎么计算，是这样的：</p><ol><li>每个目录默认有2个链接，一个是目录自身的”.”，另一个是父目录中指向该目录的链接</li><li>目录中每包含一个子目录，链接数就会+1，因为每个子目录都会创建”..”链接指向父目录</li></ol><p>在下面的例子中，rootdir 的链接数是 4，因为父目录有一个指向它的链接”rootdir”，它自己有一个指向自己的链接”.”，它的两个子目录dir1和dir2分别有指向它的链接”..”</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">~/open-course/rootdir$ <span class="built_in">ls</span></span><br><span class="line">dir1  dir2  file1.md  file2.md  file3.md</span><br><span class="line"></span><br><span class="line">~/open-course/rootdir$ <span class="built_in">ls</span> ../ -l</span><br><span class="line">total 8</span><br><span class="line">drwxr-xr-x 11 rinevard rinevard 4096 May 31 16:40 mit-6.828</span><br><span class="line">drwxr-xr-x  4 rinevard rinevard 4096 Jun  1 10:58 rootdir</span><br></pre></td></tr></table></figure><p>文件路径格式：以 “&#x2F;” 开头的是从根目录出发的路径，否则是从当前文件夹出发的路径</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">~/open-course$ <span class="built_in">ls</span></span><br><span class="line">mit-6.828</span><br><span class="line">~/open-course$ <span class="built_in">ls</span> mit-6.828/</span><br><span class="line">LICENSE  Makefile  README  conf  grade-lab-util  gradelib.py  kernel  mkfs  user</span><br><span class="line">~/open-course$ <span class="built_in">ls</span> /home/rinevard/</span><br><span class="line">open-course  programs</span><br></pre></td></tr></table></figure><p>unix shell的许多命令都是用户级别的，而非内置的。shell通过fork子进程并调用exec来执行它们。但cd是内置的，因为cd改变了shell自身的工作目录。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read and run input commands.</span></span><br><span class="line"><span class="keyword">while</span> (getcmd(buf, <span class="keyword">sizeof</span>(buf)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (buf[<span class="number">0</span>] == <span class="string">&#x27;c&#x27;</span> &amp;&amp; buf[<span class="number">1</span>] == <span class="string">&#x27;d&#x27;</span> &amp;&amp; buf[<span class="number">2</span>] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// Chdir must be called by the parent, not the child.</span></span><br><span class="line">        buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// chop \n</span></span><br><span class="line">        <span class="keyword">if</span> (chdir(buf + <span class="number">3</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;cannot cd %s\n&quot;</span>, buf + <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fork1() == <span class="number">0</span>)</span><br><span class="line">        runcmd(parsecmd(buf));</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;style&gt;
img{
    width: 70%;
}
&lt;/style&gt;

&lt;h1 id=&quot;常用的系统接口&quot;&gt;&lt;a href=&quot;#常用的系统接口&quot; class=&quot;headerlink&quot; title=&quot;常用的系统接口&quot;&gt;&lt;/a&gt;常用的系统接口&lt;/h1&gt;&lt;table&gt;
&lt;the</summary>
      
    
    
    
    <category term="学习" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="公开课" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/"/>
    
    <category term="MIT-6.S081" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/MIT-6-S081/"/>
    
    <category term="Notes" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/MIT-6-S081/Notes/"/>
    
    
  </entry>
  
  <entry>
    <title>Lab1 Xv6 and Unix utilities</title>
    <link href="http://rinevard.github.io/wiki/learning/open-course/MIT-6.S081/Labs/lab1-util/"/>
    <id>http://rinevard.github.io/wiki/learning/open-course/MIT-6.S081/Labs/lab1-util/</id>
    <published>2025-05-31T03:18:38.000Z</published>
    <updated>2025-06-01T03:19:59.012Z</updated>
    
    <content type="html"><![CDATA[<style>img{    width: 80%;}</style><p>在开始 lab 之前，我们先来解释一下为什么我们写的代码能直接在 xv6 的 shell 里执行。我们来看看 <code>sh.c</code> 的部分代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read and run input commands.</span></span><br><span class="line"><span class="keyword">while</span> (getcmd(buf, <span class="keyword">sizeof</span>(buf)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (buf[<span class="number">0</span>] == <span class="string">&#x27;c&#x27;</span> &amp;&amp; buf[<span class="number">1</span>] == <span class="string">&#x27;d&#x27;</span> &amp;&amp; buf[<span class="number">2</span>] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// Chdir must be called by the parent, not the child.</span></span><br><span class="line">        buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// chop \n</span></span><br><span class="line">        <span class="keyword">if</span> (chdir(buf + <span class="number">3</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;cannot cd %s\n&quot;</span>, buf + <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fork1() == <span class="number">0</span>)</span><br><span class="line">        runcmd(parsecmd(buf));</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里我们看出，shell通过fork子进程来执行命令。如果进一步看看 <code>runcmd</code> 函数，就会发现它调用了 <code>exec</code>，因此 shell 能执行用户写的代码。</p><p>有趣的是，从这段代码里我们也能看出 <code>cd</code> 是内置在 shell 里的命令，这是因为 cd 改变了shell自身的工作目录。</p><h1 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h1><p>这题让我们简单熟悉下接口。其实这里用 <code>printf</code> 更易读，不过我当时做的时候没发现有 <code>printf</code> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fcntl.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">char</span> *errmsg = <span class="string">&quot;sleep: missing operand\n&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        write(<span class="number">1</span>, errmsg, <span class="built_in">strlen</span>(errmsg));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(atoi(argv[<span class="number">1</span>]));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="pingpong"><a href="#pingpong" class="headerlink" title="pingpong"></a><strong>pingpong</strong></h1><p>这题让我们接触一下管道的使用，难者不会，会者不难</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fcntl.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">512</span>];</span><br><span class="line">    <span class="type">int</span> p_parent_sender[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> p_child_sender[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    pipe(p_parent_sender);</span><br><span class="line">    pipe(p_child_sender);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程先读</span></span><br><span class="line">        read(p_parent_sender[<span class="number">0</span>], buf, <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: received ping\n&quot;</span>, getpid());</span><br><span class="line">        write(p_child_sender[<span class="number">1</span>], buf, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        close(p_parent_sender[<span class="number">0</span>]);</span><br><span class="line">        close(p_parent_sender[<span class="number">1</span>]);</span><br><span class="line">        close(p_child_sender[<span class="number">0</span>]);</span><br><span class="line">        close(p_child_sender[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父进程先写</span></span><br><span class="line">    write(p_parent_sender[<span class="number">1</span>], buf, <span class="number">2</span>);</span><br><span class="line">    read(p_child_sender[<span class="number">0</span>], buf, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d: received pong\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">    close(p_parent_sender[<span class="number">0</span>]);</span><br><span class="line">    close(p_parent_sender[<span class="number">1</span>]);</span><br><span class="line">    close(p_child_sender[<span class="number">0</span>]);</span><br><span class="line">    close(p_child_sender[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="primes"><a href="#primes" class="headerlink" title="primes"></a>primes</h1><p>这题很有趣，是一个并发素数筛法。这个算法理论上是可以提高效率的，毕竟在运行了一段时间后，各个进程里都有一些数等待筛选，这时各个进程在同时用自己的素数筛选输入的数。</p><p><img src="/images/learning/open-course/MIT-6.S081/labs/lab1-util/prime-concurrent.png"></p><p>网上很多代码都是2020版的，当时的要求是找出 2-35 间的素数。这些代码能过老版本的要求，但过不了2024版要求的 2-280。我认真看了一两份代码，发现它们在用 fork 创建子进程的子进程后，忘了关闭子子进程的连接到父进程的描述符。可以看下面示意图的第三个框，这些代码忘了关闭 child child process 的 fd_read.</p><p>我画了示意图来解释我的代码~</p><p><img src="/images/learning/open-course/MIT-6.S081/labs/lab1-util/prime-code.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NUM = <span class="number">280</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">connected_fork</span><span class="params">(<span class="type">int</span> *)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">do_child</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    <span class="type">int</span> fd = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> ((pid = connected_fork(&amp;fd)) == <span class="number">0</span>) &#123;</span><br><span class="line">        do_child(fd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">for</span> (n = <span class="number">2</span>; n &lt;= NUM; n++) &#123;</span><br><span class="line">        write(fd, (<span class="type">void</span> *)&amp;n, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 创建子进程. 父进程的 fd 和子进程的 fd 会被分别设置为一个 pipe 的两端.</span></span><br><span class="line"><span class="comment"> * 对父进程, fd 被设置为写端.</span></span><br><span class="line"><span class="comment"> * 对子进程, fd 被设置为读端.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * return 0 if is child else child&#x27;s pid</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">connected_fork</span><span class="params">(<span class="type">int</span> *fd)</span> &#123;</span><br><span class="line">    <span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line">    pipe(p);</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// child</span></span><br><span class="line">        close(p[<span class="number">1</span>]);</span><br><span class="line">        *fd = p[<span class="number">0</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// parent</span></span><br><span class="line">        close(p[<span class="number">0</span>]);</span><br><span class="line">        *fd = p[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 从 fd_read 中读取数字, 打印第一个数,</span></span><br><span class="line"><span class="comment"> * 筛选其他数并新建子进程把被筛选后的数写入子进程. 在运行完成后关闭 fd_read.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_child</span><span class="params">(<span class="type">int</span> fd_read)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> prime = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> fd = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (read(fd_read, (<span class="type">void</span> *)&amp;n, <span class="keyword">sizeof</span>(<span class="type">int</span>)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prime == <span class="number">-1</span>) &#123;</span><br><span class="line">            prime = n;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;prime %d\n&quot;</span>, prime);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((n % prime) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fd == <span class="number">-1</span> &amp;&amp; connected_fork(&amp;fd) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// fd == -1 等价于没有子进程</span></span><br><span class="line">                <span class="comment">// 如果没有子进程就创建子进程并让它开始工作</span></span><br><span class="line">                close(fd_read);</span><br><span class="line">                do_child(fd);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            write(fd, (<span class="type">void</span> *)&amp;n, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd_read);</span><br><span class="line">    <span class="comment">// fd == -1 等价于没有子进程, 说明它是最后一个进程</span></span><br><span class="line">    <span class="comment">// 最后一个进程不需要关闭描述符, 也不需要等待</span></span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 个人认为关闭 fd_read 不应该是 do_child 的工作, 我觉得&quot;谁创建,</span></span><br><span class="line"><span class="comment"> * 谁关闭&quot;会更合适. 也就是说, 我觉得让调用 do_child 的函数关闭 fd_read</span></span><br><span class="line"><span class="comment"> * 更合适.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 但如果 do_child 不关闭 fd_read, 子孙进程就会保留父进程未关闭的描述符,</span></span><br><span class="line"><span class="comment"> * 从而耗尽 xv6 的资源.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h1 id="find"><a href="#find" class="headerlink" title="find"></a>find</h1><p>在 <code>ls.c</code> 的基础上稍微改改就好了，要注意的是递归时不要递归进 “.” 和 “..” 两个文件夹</p><p>我们实现的 <code>find &lt;path&gt; &lt;name&gt;</code> 的功能和 Linux 里的 <code>find &lt;path&gt; -name &lt;name&gt;</code> 一致</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fcntl.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">find</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">basename</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: find &lt;path&gt; &lt;filename&gt;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    find(argv[<span class="number">1</span>], argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 在以 path 为根节点的文件树下搜索名为 name 的文件,</span></span><br><span class="line"><span class="comment"> * 如果找到则打印其路径.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">find</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *name)</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="keyword">if</span> ((fd = open(path, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot open %s\n&quot;</span>, path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (fstat(fd, &amp;st) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot stat %s\n&quot;</span>, path);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(basename(path), name) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只有文件夹有递归的必要</span></span><br><span class="line">    <span class="keyword">if</span> (st.type != T_DIR) &#123;</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">512</span>], *p;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line">    <span class="comment">// 第一个 +1 对应 &#x27;/&#x27;, 第二个 +1 对应结尾的 &#x27;\0&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(path) + <span class="number">1</span> + DIRSIZ + <span class="number">1</span> &gt; <span class="keyword">sizeof</span>(buf)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ls: path too long\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(buf, path);</span><br><span class="line">    p = buf + <span class="built_in">strlen</span>(buf);</span><br><span class="line">    *p++ = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span> (read(fd, &amp;de, <span class="keyword">sizeof</span>(de)) == <span class="keyword">sizeof</span>(de)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (de.inum == <span class="number">0</span> || <span class="built_in">strcmp</span>(de.name, <span class="string">&quot;.&quot;</span>) == <span class="number">0</span> ||</span><br><span class="line">            <span class="built_in">strcmp</span>(de.name, <span class="string">&quot;..&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        memmove(p, de.name, DIRSIZ);</span><br><span class="line">        p[DIRSIZ] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (stat(buf, &amp;st) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ls: cannot stat %s\n&quot;</span>, buf);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        find(buf, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 获取路径 path 的最后一部分</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">basename</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *p;</span><br><span class="line">    <span class="keyword">for</span> (p = path + <span class="built_in">strlen</span>(path); p &gt;= path &amp;&amp; *p != <span class="string">&#x27;/&#x27;</span>; --p)</span><br><span class="line">        ;</span><br><span class="line">    ++p;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a><strong>xargs</strong></h1><p>xargs 将标准输入（stdin）数据转换成命令行参数，一般和管道一起使用。在 linux 中，xargs 默认的命令是 echo.</p><p>上面的解释可能不太清晰，通过两个例子就能看出来它在做什么了：</p><p>第一个例子是直接使用 xargs</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ xargs -n 1 <span class="built_in">echo</span> Im prefix</span><br><span class="line">111</span><br><span class="line">Im prefix 111</span><br><span class="line">222</span><br><span class="line">Im prefix 222</span><br><span class="line">（按 ctrl+D 终止输入)</span><br></pre></td></tr></table></figure><p>第二个例子是和管道联用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ (<span class="built_in">echo</span> 1 ; <span class="built_in">echo</span> 2) | xargs -n 1 <span class="built_in">echo</span></span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>我们实现的 <code>xargs &lt;command&gt;</code> 的功能和 Linux 里的 <code>xargs -n 1 &lt;command&gt;</code> 一致</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;usage: xargs command\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *cmd = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">char</span> *cmdargs[MAXARG];</span><br><span class="line">    <span class="type">int</span> cmdargc = <span class="number">0</span>; <span class="comment">// 在更改 cmdargc 前, 最好检查 cmdargc &lt; MAXARG,</span></span><br><span class="line">                     <span class="comment">// 不过为了简化代码, 我们就不检查了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// argv[0] 是 &#x27;xargs&#x27;, argv[1] 是 command, 之后是参数</span></span><br><span class="line">    <span class="comment">// cmdargs 应当形如 [command, arg1, arg2, ..., addition_arg1, ...]</span></span><br><span class="line">    cmdargc = argc - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cmdargc; i++) &#123;</span><br><span class="line">        cmdargs[i] = argv[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">512</span>]; <span class="comment">// 输入行</span></span><br><span class="line">    <span class="type">char</span> *p = buf; <span class="comment">// 输入行的末尾</span></span><br><span class="line">    <span class="keyword">while</span> (read(<span class="number">0</span>, p, <span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[<span class="number">0</span>] == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">            p[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            cmdargs[cmdargc] = buf;</span><br><span class="line">            ++cmdargc;</span><br><span class="line">            cmdargs[cmdargc] = <span class="number">0</span>;</span><br><span class="line">            ++cmdargc;</span><br><span class="line">            <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">                exec(cmd, cmdargs);</span><br><span class="line">            &#125;</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 重置</span></span><br><span class="line">            p = buf;</span><br><span class="line">            cmdargc = argc - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ++p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;style&gt;
img{
    width: 80%;
}
&lt;/style&gt;

&lt;p&gt;在开始 lab 之前，我们先来解释一下为什么我们写的代码能直接在 xv6 的 shell 里执行。我们来看看 &lt;code&gt;sh.c&lt;/code&gt; 的部分代码：&lt;/p&gt;
&lt;figure clas</summary>
      
    
    
    
    <category term="学习" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="公开课" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/"/>
    
    <category term="MIT-6.S081" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/MIT-6-S081/"/>
    
    <category term="Labs" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/MIT-6-S081/Labs/"/>
    
    
  </entry>
  
  <entry>
    <title>慢慢地冲浪</title>
    <link href="http://rinevard.github.io/wiki/others/thoughts/%E7%BD%91%E4%B8%8A%E5%86%B2%E6%B5%AA/"/>
    <id>http://rinevard.github.io/wiki/others/thoughts/%E7%BD%91%E4%B8%8A%E5%86%B2%E6%B5%AA/</id>
    <published>2025-05-28T03:50:11.000Z</published>
    <updated>2025-05-28T03:50:24.770Z</updated>
    
    <content type="html"><![CDATA[<p>在互联网上冲浪时，偶尔会看到一些博客，若是它们帮到了我，我经常也会点进主页看看作者都写了怎样的文章，都有怎样的故事。</p><p>很多人的网站里全是技术文章，我对这样的网站确实没什么兴致。我更喜欢杂谈类的文章，那种像是在夜深人静时，独自一人在电脑前慢慢写下的文章。读这样独处时写下的文章，总让我觉得自己和作者的灵魂更近了一点。</p><p>在互联网上随机漫游，对着完全不认识自己的人产生单箭头，如果运气好得话说不定会是双箭头，真的非常有趣。我可能还是喜欢慢一点的故事，喜欢有着很长很长回复的贴子，喜欢把自己遇见的趣事分享到网上的视频，喜欢随意的、真诚的文章。它们只是被放在那里，等着十年后被另一个人偶然发现，那是痕迹。</p><style>/* 隐藏草书 */.hidden-text {    font-size: 18px;    text-align: center;    margin: 20px 0;    /* padding: 20px; */    line-height: 1.5;    color: transparent;    cursor: default}.hidden-fancy-text::selection {    color: black;    background: white;}</style><div class="hidden-text">就像这里的痕迹。</div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在互联网上冲浪时，偶尔会看到一些博客，若是它们帮到了我，我经常也会点进主页看看作者都写了怎样的文章，都有怎样的故事。&lt;/p&gt;
&lt;p&gt;很多人的网站里全是技术文章，我对这样的网站确实没什么兴致。我更喜欢杂谈类的文章，那种像是在夜深人静时，独自一人在电脑前慢慢写下的文章。读这样独</summary>
      
    
    
    
    <category term="杂谈" scheme="http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    <category term="碎碎念" scheme="http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
  </entry>
  
  <entry>
    <title>在开始之前</title>
    <link href="http://rinevard.github.io/wiki/learning/open-course/MIT-6.S081/BeforeStory/"/>
    <id>http://rinevard.github.io/wiki/learning/open-course/MIT-6.S081/BeforeStory/</id>
    <published>2025-05-27T07:20:38.000Z</published>
    <updated>2025-06-01T03:11:14.619Z</updated>
    
    <content type="html"><![CDATA[<p>最近发现了 <a href="https://arthals.ink/">Arthal</a> 的笔记，感觉学长写得非常精美！回头看看自己对 15213 labs 的笔记，感觉写得确实太粗糙了，希望我的 6.S081 的笔记也能写得详细一些。</p><p>咳咳，我知道我还没写 15213 的 proxylab，不过我感觉csapp网络那一章写得有点含糊，所以晚点再做吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近发现了 &lt;a href=&quot;https://arthals.ink/&quot;&gt;Arthal&lt;/a&gt; 的笔记，感觉学长写得非常精美！回头看看自己对 15213 labs 的笔记，感觉写得确实太粗糙了，希望我的 6.S081 的笔记也能写得详细一些。&lt;/p&gt;
&lt;p&gt;咳咳，我知道我还</summary>
      
    
    
    
    <category term="学习" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="公开课" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/"/>
    
    <category term="MIT-6.S081" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/MIT-6-S081/"/>
    
    
  </entry>
  
  <entry>
    <title>第九章——虚拟内存</title>
    <link href="http://rinevard.github.io/wiki/learning/open-course/CMU-15-213/Notes/Chapter9-virtual-memory/"/>
    <id>http://rinevard.github.io/wiki/learning/open-course/CMU-15-213/Notes/Chapter9-virtual-memory/</id>
    <published>2025-05-13T14:10:28.000Z</published>
    <updated>2025-05-13T14:13:32.709Z</updated>
    
    <content type="html"><![CDATA[<style>img{    width: 80%;}</style><h1 id="重走虚拟路"><a href="#重走虚拟路" class="headerlink" title="重走虚拟路"></a>重走虚拟路</h1><p>让我们尝试重新发明一遍虚拟内存。</p><h2 id="使用虚拟地址的原因"><a href="#使用虚拟地址的原因" class="headerlink" title="使用虚拟地址的原因"></a>使用虚拟地址的原因</h2><p>想象一下我们只能用物理地址来写程序，我们写出了下面的东西：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">; 假设目标机器是Intel 8080，内存地址为物理地址</span><br><span class="line">ORG 0x0100      ; 程序起始地址，直接指定物理地址0x0100</span><br><span class="line">MVI A, 0x05     ; 将立即数0x05加载到寄存器A</span><br><span class="line">STA 0x0200      ; 将寄存器A的值存储到物理内存地址0x0200</span><br><span class="line">HLT             ; 停止程序</span><br></pre></td></tr></table></figure><p>这东西的可移植性显然很差！所以我们发明了“虚拟地址”。这样程序就能直接使用虚拟地址，而在程序执行时，虚拟地址被操作系统的<strong>MMU</strong>（Memory Management Unit）实时翻译成物理地址。</p><h2 id="虚拟地址到物理地址的映射"><a href="#虚拟地址到物理地址的映射" class="headerlink" title="虚拟地址到物理地址的映射"></a>虚拟地址到物理地址的映射</h2><p>这么看来，我们可以把 MMU 当作一个从虚拟地址空间到物理地址空间的映射，那我们自然要用一个数据结构来存储映射。</p><p>但怎么组织这个数据结构呢？用一个数组，然后每个虚拟地址对应一个物理地址？假设我们有 $M$ 个虚拟地址，我们就存一个长度为 $M$ 的数组？这样的话，这个数组就太大了。假设我们有 $k$ 个进程，按这个想法，我们就需要至少 $k\times M \times \text{sizeof(char *)}$ 大小的内存来存储这个数据结构。</p><p>我们选择把 $N$ 个连续的虚拟地址当作一个虚拟页，同时把 $N$ 个连续的物理地址当作一个物理页，这样对每个进程，我们就只要做物理页之间的映射，存储 $\frac{M}{N}$ 个项就好了。考虑到程序的局部性， 我们的这种选择是合理的。这样的一个数据结构就叫做一个<strong>页表</strong>。</p><p>在下图的<strong>单级页表</strong>中，每一项都带有一个有效位（用于标记这个虚拟页对应的物理页是否在 DRAM 中）和对应物理页的开头物理地址（如果没有对应物理页，为 null）。</p><p>把虚拟地址翻译成物理地址的大致思路是根据虚拟地址找到页表中对应的项，从而找到对应的物理页，然后根据虚拟地址的最后几位确定具体的物理地址。（还记得吗，一个页由很多地址组成）</p><p><img src="/images/learning/open-course/CMU-15213/Notes/Chapter9/singlelvelpagetable.png"></p><p>但这样的页表还是很大吧。我们总在进程被创建时就为他们分配了一个超大的页表，而实际上绝大多数程序都根本用不到那么多虚拟地址。所以，我们能不能动态地改变页表的大小，比如说，在程序请求某个虚拟地址，但它不在页表中时，再去增大页表？</p><p>所以我们进一步把页表分成多级，在需要的时候再去新增 level 较高的页表。</p><p>在这样的<strong>多级页表</strong>中，只有 level 最高的页表存储对应页的开头物理地址，而其他 level 的页表存储下一个级别的页表的开始地址。我们会在下一节详细讲解它的翻译过程。</p><p><img src="/images/learning/open-course/CMU-15213/Notes/Chapter9/twolevelpagetable.png"></p><p>让我们总结一下，每个进程有自己的页表，在切换到某个进程时，操作系统会更新存储着页表地址的寄存器（在 RISC-Ⅴ 中是 satp 寄存器）。当进程需要访问某个虚拟地址时，MMU 会把虚拟地址翻译成物理地址，然后访问物理地址。</p><p>要特别强调的是，每个 level 可以有多个页表，我们可以把多级页表看作树状结构！</p><h2 id="虚拟地址的翻译"><a href="#虚拟地址的翻译" class="headerlink" title="虚拟地址的翻译"></a>虚拟地址的翻译</h2><p>我们已经知道了虚拟内存大致是怎样的了。那么 MMU 具体是怎么把虚拟地址翻译成物理地址的呢？我们这里讨论多级页表。</p><p>在多级页表中，只有 level 最高的页表存储对应页的开头物理地址，而其他 level 的页表存储下一个级别的页表的开始地址。</p><p>虚拟地址的前几位在翻译过程中会起到“页表索引”的作用，当我们到达了某个 level 的页表，我们会用它来确定我们具体需要这个页表的哪个项。而虚拟地址的最后几位是一个 offset，还记得吗，一个虚拟页和一个物理页对应，所以在找到了对应的物理页的开头地址后，我们要根据 offset 得到真正对应的物理地址。</p><p>VPN 是 virtual page number，VPO 是 virtual page offset，PTE 是 page table entry</p><p><img src="/images/learning/open-course/CMU-15213/Notes/Chapter9/translation.png"></p><p>我魔改了一下上图，希望这能让“每个 level 有多个页表”这件事显得更清晰。</p><p><img src="/images/learning/open-course/CMU-15213/Notes/Chapter9/virtual2physic.png"></p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>看起来多级页表在存储方面优化得不错，但速度呢？既然每个页表都放在不同的地址，那它不是要求多次访问不同地址吗？正是如此，所以我们用 TLB（Translation Lookaside Buffer）来缓存最近使用的页表项，来加快地址翻译。</p><h1 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h1><p>当我们调用 malloc 和 free 时究竟发生了什么？在做完 malloclab 以后，我们对此已经有了比较清晰的理解。</p><h2 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h2><p>调用 malloc 时，我们在寻找足够大的空闲内存块来提供给用户，如果不够大就扩容。在“寻找”的过程中，我们有很多种策略可以选，这就是 placement policy，包括但不限于 first fit、next fit、best fit.</p><p>而在找到空闲块以后，有时空闲块可能比用户的需求大很多，这时就要想想要不要切割空闲块，这就是 splitting policy。</p><h2 id="free"><a href="#free" class="headerlink" title="free"></a>free</h2><p>调用 free 时，我们简单地把一个已分配内存块标记为空闲。但空闲之后又要决定是否把它和相邻的空闲块合并，这就是 coalescing policy。</p><h2 id="块的结构"><a href="#块的结构" class="headerlink" title="块的结构"></a>块的结构</h2><p>之前提到，malloc 是在找空闲块，但什么是“块”呢？块的数据结构也有很多种可以选，不过一般来说，每个块都至少会有 size 和 is_alloc 标记。</p><p>举个例子，使用显式链表策略时，我们的堆大概长这样：</p><p><img src="/images/learning/open-course/CMU-15213/Notes/Chapter9/heap.svg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;style&gt;
img{
    width: 80%;
}
&lt;/style&gt;

&lt;h1 id=&quot;重走虚拟路&quot;&gt;&lt;a href=&quot;#重走虚拟路&quot; class=&quot;headerlink&quot; title=&quot;重走虚拟路&quot;&gt;&lt;/a&gt;重走虚拟路&lt;/h1&gt;&lt;p&gt;让我们尝试重新发明一遍虚拟内存。&lt;</summary>
      
    
    
    
    <category term="学习" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="公开课" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/"/>
    
    <category term="CMU-15-213" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/"/>
    
    <category term="Notes" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/Notes/"/>
    
    
  </entry>
  
  <entry>
    <title>Malloclab和我不得不说的那些事</title>
    <link href="http://rinevard.github.io/wiki/learning/open-course/CMU-15-213/Labs/Malloclab/"/>
    <id>http://rinevard.github.io/wiki/learning/open-course/CMU-15-213/Labs/Malloclab/</id>
    <published>2025-05-12T11:28:38.000Z</published>
    <updated>2025-05-27T07:14:34.317Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>malloclab 的难度很大，我实现了书上的基础的隐式空闲链表和显式空闲链表，用时约 16 小时，得分如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Perf index = 47 (util) + 40 (thru) = 87/100</span><br></pre></td></tr></table></figure><p>实现的逻辑本身是简单的，难度最大的地方在于调试，所以我并没有进一步实现分离的空闲链表，因为调试起来实在是太麻烦了。算是体验了一下系统级编程的复杂性。</p><p>有趣的是，由于 fail fast 的编程习惯，我喜欢在代码里到处放 assert 和 print 语句，这帮我节省了不少调试时间，我甚至一次 gdb 都没用就把所有的 bug 都修完了。（话说回来我也不知道这种东西怎么用 gdb 调试）</p><p>本文会谈谈做这个 lab 时学到的一些编程技巧，不会太多谈 lab 本身，因为照着书上实现出来就好了。</p><h1 id="宏编程"><a href="#宏编程" class="headerlink" title="宏编程"></a>宏编程</h1><p>宏编程最需要关注的地方就是到处都要加括号。让我们以下面这行代码为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GET(p) (*((unsigned int * )p))</span></span><br></pre></td></tr></table></figure><p>像这种就是有问题的，因为没给 p 加括号！比如说，GET((char _)bp - WSIZE) 的原本意图是让 bp 减去 WSIZE，但放到 GET 里就导致 bp 先被转换成 unsigned int 指针，再减去 WSIZE，从而让 bp 减去了 WSIZE _ sizeof(unsigned int)！</p><h1 id="validation-check"><a href="#validation-check" class="headerlink" title="validation_check"></a>validation_check</h1><p>这个 lab 可以看作在创建一个神奇的类，我们总会对类有一些 validation 要求（比如说在这个 lab 中，我们要求内存里不能有连续的空闲块），这时我们就可以写一个 validation_check 函数，它会检查这个类是否满足我们的 validation 要求。</p><p>那这个 validation_check 有什么用呢？在调试的时候，我们可以把它插入到各种地方，然后看它在哪里 fail，这能帮助我们更快定位 bug。一个小技巧是用二分的思路来插入 validation_check。</p><h1 id="其他小技巧"><a href="#其他小技巧" class="headerlink" title="其他小技巧"></a>其他小技巧</h1><p>写这个 lab 的时候用到了很多 6.102 的知识，果然软工知识超有用~比如说，写一个简练清晰的 specification 很有帮助，fail fast 特别有用。</p><p>还注意到了一个有趣的地方，<code>size_t</code> 在我的系统上是这样显示的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">size_t</span></span><br></pre></td></tr></table></figure><p>据 claude 说，<code>size_t</code> 的具体定义取决于系统架构，这可能是为了可移植性考虑？</p><p>除此之外，我觉得还有一个重要的作用，就是给类型提供“别名”。有时我们希望类型有一个更具描述性的名称，而不只是“int”。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;malloclab 的难度很大，我实现了书上的基础的隐式空闲链表和显式空闲链表，用时约 16 小时，得分如下：&lt;/p&gt;
&lt;f</summary>
      
    
    
    
    <category term="学习" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="公开课" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/"/>
    
    <category term="CMU-15-213" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/"/>
    
    <category term="Labs" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/Labs/"/>
    
    
  </entry>
  
  <entry>
    <title>Ludum Dare参加指南</title>
    <link href="http://rinevard.github.io/wiki/game-design/ldjam%E5%8F%82%E8%B5%9B%E6%8C%87%E5%8D%97/"/>
    <id>http://rinevard.github.io/wiki/game-design/ldjam%E5%8F%82%E8%B5%9B%E6%8C%87%E5%8D%97/</id>
    <published>2025-04-13T01:36:38.000Z</published>
    <updated>2025-06-04T06:38:41.513Z</updated>
    
    <content type="html"><![CDATA[<h1 id="零、在文章开始之前"><a href="#零、在文章开始之前" class="headerlink" title="零、在文章开始之前"></a>零、在文章开始之前</h1><p>本文包含了对 Ludum Dare 的介绍、参与流程及个人看法。写作的契机是参与 Ludum Dare 后体验很好，但在中文互联网上没有找到很全面的介绍资料，只找到了 <a href="https://zhuanlan.zhihu.com/p/20337558">规则介绍</a>。在规则介绍之外，我希望聊聊 Ludum Dare 的体验为什么好（比起我参加过的其他 gamejam），并按时间线介绍一下参与流程。</p><h1 id="一、什么是-Ludum-Dare"><a href="#一、什么是-Ludum-Dare" class="headerlink" title="一、什么是 Ludum Dare"></a>一、什么是 Ludum Dare</h1><p>官网写到，”Ludum Dare is an event where you create a game from scratch in a weekend based on a theme.”（出自 <a href="https://ludumdare.com/resources/archive/rules-2017/">rules</a>），即“Ludum Dare 是一个围绕某个主题在一个周末从零开始做出一个游戏的活动。”更具体一点，Ludum Dare 主要分为两个赛道，分别是单人 48 小时做一个游戏和组队 72 小时做一个游戏。</p><p>这时候有经验的读者就会问了，这不就是 gamejam 吗？正是如此！Ludum Dare 是非常早期的 gamejam，它自 2002 年开始举办，每年举办两次，到今天已经办了 57 届。每届 Ludum Dare 都会吸引全球数以万计的开发者，如 2021 年的 49 届收到了近 3000 款游戏提交， 2023 年的第 52 届收到了 1632 款游戏提交（<a href="https://github.blog/open-source/gaming/a-peek-inside-some-of-the-top-games-from-ludum-dare-49/">数据来源</a>）。在这大量的提交游戏中，也有许多精品作品从此发源，比如邪恶铭刻（inscryption）的原型 <a href="https://ldjam.com/events/ludum-dare/43/sacrifices-must-be-made-2">Sacrifices Must Be Made</a> 就于 Ludum Dare 43 制作。</p><h1 id="二、为什么参加-Ludum-Dare"><a href="#二、为什么参加-Ludum-Dare" class="headerlink" title="二、为什么参加 Ludum Dare"></a>二、为什么参加 Ludum Dare</h1><p>中国有那么多本土的 gamejam，那为什么要顶着语言障碍参加 Ludum Dare 呢？我认为最重要的两点是游戏质量高、收获反馈多。</p><p>先说前者，gamejam 总是有竞赛性质的，在 Ludum Dare 里我们要和全世界的优秀开发者竞争，单是看着这些开发者围绕主题的奇思妙想就已经让人觉得值回票价了（并没有票价，这是免费活动），而如果取得了好排名则更是会给人相当的成就感。</p><p>再说后者，介于 Ludum Dare 的算法，每个游戏基本都会获得 20 个以上的评分，而且你玩的游戏越多，Ludum Dare 就会把你的游戏放在推荐榜越靠前的位置，从而就会有越多人玩你的游戏。以我的经验来看，玩的游戏数量和收获的评分数量基本接近，而且很多玩了我们游戏的开发者会在游戏下给出评论来反馈，非常利于我们了解自己游戏的优秀之处（可惜的是评论一般不说缺点，以夸夸居多）。</p><p>下面再举几个 Ludum Dare 的其他优势：</p><ul><li>足不出户：与线下 gamejam 不同，参加 Ludum Dare 无需报名，只要注册账号并在提交时间截止前提交游戏即可。</li><li>玩游戏方便：大部分开发者都会提供游戏的 web 版本，即使不提供 web 版本也可以直接在对应的游戏页面下载游戏。</li><li>交流机会：我们可以给别的游戏提供反馈，也可以在别的游戏评论区里询问开发者的设计思路，一般都会收到积极的回复。</li><li>和大神合影：每届的 Ludum Dare 都会有一些大神来参加，如果恰巧碰上了自己感兴趣的大神，就有了在他们的游戏评论区夸夸的合影机会！</li></ul><h1 id="三、参与流程"><a href="#三、参与流程" class="headerlink" title="三、参与流程"></a>三、参与流程</h1><p>Ludum Dare 的流程大概是主题投票、制作、评分与反馈、结果公布。为了顺利参赛，首先我们要在 Ludum Dare 上注册一个账号。注册账号需要邀请码，我们可以在 Google 上用 ludum dare invitation code 之类的关键词或者在<a href="https://ldjam.com/users/pov/feed">举办者的主页</a>上找到邀请码。我找到的第 57 届的邀请码有 Time4LD57 和 BirdSiteLD57。</p><p>在注册成功之后，我们要想想这次是单人参赛还是组队参赛。Ludum Dare 有三条赛道，Compo、Jam 和 Extra.</p><p>Compo 是经典模式，要求单人 48 小时内做游戏，所有内容包括美术、音效等都需要在 48 小时内从零开始做出，而且必须开源源代码。我们可以使用任何已经写过的基础代码和任何工具。如果你的游戏收到了 20 个以上的评分，会得到最终评分。</p><p>Jam 相对宽松，只要求组队 72 小时内做游戏，可以使用任何已经写过的基础代码，也允许使用部分预制素材。若美术或音效非原创，需要在提交时关闭对应类别的打分。比如如果我们用了第三方美术，就要在提交时关闭 Graphics 的打分。如果你的游戏收到了 20 个以上的评分，会得到最终评分。</p><p>Extra 则是轻松组，时间宽裕至 3 周，单人或团队均可，内容以原创为主但允许预制素材，美术或音效非原创可退出对应评分类别，源代码提交可选，但无最终排名。</p><p>赛道在提交时才需要确定，所以如果你原本打算参加 Compo，但没来得及赶上 Compo 的截止提交时间，也可以转去 Jam 的提交。</p><p>想好了赛道后，就能进入之后的环节了。</p><h2 id="主题投票"><a href="#主题投票" class="headerlink" title="主题投票"></a>主题投票</h2><p>官方会提供大量的主题（第 57 届有 1000 多个），经过初选轮、复选轮、决赛轮，最终得出一个结果主题。我们当然不必给每个主题都投票，我的个人建议是在决赛轮投一下就行。而且即使不投票也是能参赛的！参赛的唯一要求就是在提交时间截止前提交作品。</p><p>是否围绕主题做游戏也是可选的，主题只是最终评分中的一部分，Ludum Dare 的宗旨是鼓励开发者把游戏做出来。</p><h2 id="制作阶段"><a href="#制作阶段" class="headerlink" title="制作阶段"></a>制作阶段</h2><p>进入制作阶段后，我们就可以开始做游戏了！点击右上角的 join event，就能创建游戏草稿页。我们会在上传阶段填充这个草稿页。</p><p><img src="/images/game-design/gamejam/ldjam%E5%8F%82%E8%B5%9B%E6%8C%87%E5%8D%97/ldjam-joinevent.png"></p><p>制作游戏需要大家各显神通，我简单谈谈个人建议吧。</p><ul><li>设计<br>一般来说，我们要快速地找到多个想法，然后选择自己觉得最有前途的想法做下去。由于制作时间很紧，我们注定不能做大做全。比起大而全，小而美是更好的选择。一个只有三关的认真打磨过的作品比一个有十关的每关都很粗糙的作品要好得多。</li><li>程序<br>尽管 Ludum Dare 允许设计桌游乃至更不被定义的游戏（我见过一个翻文件夹的游戏），但我们这里只讨论电子游戏。程序方面，选用自己最熟悉的工具即可。有熟练的游戏引擎就选游戏引擎，喜欢不用引擎开发就不用引擎开发。</li><li>音乐<br>我是音乐萌新，虽然听说过 FL studio 之类的工作站，但我现在还没学会。所以我这里推荐一个简单的音乐制作网站——<a href="https://musiclab.chromeexperiments.com/">Musiclab</a>，我使用里面的<a href="https://musiclab.chromeexperiments.com/Song-Maker">SongMaker</a>做出了能听的东西。</li><li>音效<br><a href="https://sfxr.me/">sfxr</a>是很简单的音效制作网站，我看不懂参数，所以我的工作流是把我想要的效果告诉 AI，AI 告诉我怎么调参，效果出乎意料地还算不错。</li><li>美术<br>我用<a href="https://www.piskelapp.com/">Piskel</a>画简单的像素画，偶尔也用<a href="https://krita.org/">Krita</a>来画别的东西。</li></ul><p>抛开 Extra 赛道不谈，这个阶段持续 48 小时或 72 小时，我最后的建议是在参与的同时保持充足的睡眠，好好睡觉好好吃饭很重要！</p><h2 id="上传阶段"><a href="#上传阶段" class="headerlink" title="上传阶段"></a>上传阶段</h2><p>在制作阶段结束后，会给<strong>额外的一小时</strong>来上传。尽管官网给了额外一小时的上传时间，我还是建议大家在制作阶段的末尾就开始研究怎么上传游戏，以防万一嘛。</p><p>我们可以在这段时间里填充右上角 My Game 的草稿页，按着页面要求填写即可。</p><p><img src="/images/game-design/gamejam/ldjam%E5%8F%82%E8%B5%9B%E6%8C%87%E5%8D%97/mygame.png"></p><p>我们可以把游戏压缩包上传到页面上，同时 Ludum Dare 支持 Embed HTML5，也就是说我们可以根据<a href="https://ludumdare.com/resources/guides/embedding/">Embedding Guide</a>直接把游戏的网页版上传到官网的游戏页面上。建议大家同时把网页版上传到 itch 上，毕竟官网的网页版游戏支持做得不算很完美。</p><p>记得退出自己不符合&#x2F;不想要的打分选项。</p><p><img src="/images/game-design/gamejam/ldjam%E5%8F%82%E8%B5%9B%E6%8C%87%E5%8D%97/opt.png"></p><h2 id="评分阶段"><a href="#评分阶段" class="headerlink" title="评分阶段"></a>评分阶段</h2><p>至此，恭喜你做出了自己的游戏！</p><p>评分阶段持续三周，在评分阶段，我们可以试玩别人的游戏并打分，你打分的游戏越多，推荐算法给你的游戏的推荐优先级就越高。同时高质量评论也能提高你游戏的推荐优先级。</p><p>评分阶段允许继续编辑页面，比如如果你发现游戏页面的描述有问题，随时可以进行修改。修游戏内的 bug 也是被允许的，但要求在修 bug 以后显式地在游戏页面标出自己做的修改（写一个简要的 devlog），而且不能增加新功能。</p><p><img src="/images/game-design/gamejam/ldjam%E5%8F%82%E8%B5%9B%E6%8C%87%E5%8D%97/scores.png"></p><h2 id="结果公布"><a href="#结果公布" class="headerlink" title="结果公布"></a>结果公布</h2><p>游戏会根据打分来排名。没有奖品，你的游戏就是最好的奖品！</p><h1 id="四、其他资料"><a href="#四、其他资料" class="headerlink" title="四、其他资料"></a>四、其他资料</h1><p>可以在<a href="https://ludumdare.com/resources/archive/rules-2017/">rules</a>页面找到详细的参加规则，<strong>强烈建议在参加前阅读</strong>。</p><p>可以在这篇<a href="https://zhuanlan.zhihu.com/p/20337558">规则介绍</a>找到中文的规则介绍，但不如上面那个全面。</p><p>本文的结构参考了 <a href="https://zhuanlan.zhihu.com/p/27330699">Google 编程之夏(GSoC)：海量优质项目，丰厚报酬，你竟然还不知道？</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;零、在文章开始之前&quot;&gt;&lt;a href=&quot;#零、在文章开始之前&quot; class=&quot;headerlink&quot; title=&quot;零、在文章开始之前&quot;&gt;&lt;/a&gt;零、在文章开始之前&lt;/h1&gt;&lt;p&gt;本文包含了对 Ludum Dare 的介绍、参与流程及个人看法。写作的契机是参与 L</summary>
      
    
    
    
    <category term="gamejam" scheme="http://rinevard.github.io/categories/gamejam/"/>
    
    
  </entry>
  
  <entry>
    <title>第十章——系统级I/O</title>
    <link href="http://rinevard.github.io/wiki/learning/open-course/CMU-15-213/Notes/Chapter10-system-io/"/>
    <id>http://rinevard.github.io/wiki/learning/open-course/CMU-15-213/Notes/Chapter10-system-io/</id>
    <published>2025-04-11T02:00:00.000Z</published>
    <updated>2025-04-13T02:02:21.876Z</updated>
    
    <content type="html"><![CDATA[<style>img{    width: 75%;}</style><h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><p>所有的 I&#x2F;O 设备都被视为文件，因此我们能用一致的方式处理各种输入输出。</p><p>文件类型分为以下几类</p><ul><li>普通文件：包含用户数据，可以是文本文件（如.txt）或二进制文件（如.jpg、.exe）</li><li>目录：包含一系列链接，每个连接将一个文件名映射到一个文件</li><li>套接字（socket）：跨网络通信用的文件</li></ul><h1 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h1><h2 id="文件描述符（file-descriptor）"><a href="#文件描述符（file-descriptor）" class="headerlink" title="文件描述符（file descriptor）"></a>文件描述符（file descriptor）</h2><p>文件描述符是一个非负整数，代表进程打开的文件的标识符。在进程中，每当打开一个文件时，操作系统会分配一个文件描述符给它。</p><p>默认情况下，0 表示标准输入（stdin），1 表示标准输出（stdout），2 表示标准错误（stderr）。通过系统调用（如 open）打开文件后，会返回一个新的文件描述符（如 3、4 等），具体值取决于当前进程中已使用的描述符情况。</p><p>以下是一个使用 <code>open</code> 系统调用的示例，展示如何打开一个文件并获取文件描述符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 打开文件 &quot;example.txt&quot;，以只读模式</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;example.txt&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;文件描述符: %d\\n&quot;</span>, fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用文件描述符进行操作（如读取）</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line">    <span class="type">ssize_t</span> bytes_read = read(fd, buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">    <span class="keyword">if</span> (bytes_read == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;read failed&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件描述符</span></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不足值（short-count）"><a href="#不足值（short-count）" class="headerlink" title="不足值（short count）"></a>不足值（short count）</h2><p>“不足值”是指在读写操作中，实际读取或写入的字节数少于请求的字节数。原因有遇到 EOF、从终端读文本行（如果读终端，read 一次只传输一个文本行）、读写网络套接字。</p><p>比如调用 read(fd, buffer, 100)请求读取 100 字节，但文件只剩 50 字节可用，则返回 50（不足值）。</p><p>我们需要检查返回值，确认实际读写字节数，并根据需要调整逻辑（如循环读取剩余数据）。</p><h2 id="描述符表、文件表、v-node-表"><a href="#描述符表、文件表、v-node-表" class="headerlink" title="描述符表、文件表、v-node 表"></a>描述符表、文件表、v-node 表</h2><p>操作系统在内核中维护了三层数据结构来管理文件：</p><ul><li><strong>描述符表</strong>：每个进程独有，记录该进程打开的所有文件描述符及其对应的文件表项。</li><li><strong>文件表</strong>：所有进程共享，表项包括偏移值、引用计数（即当前指向该表的描述符表项数）、指向 v-node 表中对应项的指针。关闭一个描述符会减少相应的文件表表项的引用计数，减到零会删除。</li><li><strong>v-node 表</strong>（或 inode 表）：与具体文件系统相关，记录文件的元数据（如文件大小、权限、存储位置）。每个文件在 v-node 表中有一个唯一条目。</li></ul><h3 id="调用-open-打开文件的具体过程"><a href="#调用-open-打开文件的具体过程" class="headerlink" title="调用 open 打开文件的具体过程"></a>调用 open 打开文件的具体过程</h3><p>当调用 <code>open</code> 系统调用打开一个文件时，操作系统会执行以下步骤：</p><ol><li><strong>验证和查找文件</strong>：<ul><li>内核检查文件路径、权限等，确定文件是否存在且进程有权访问。</li><li>找到文件对应的 v-node（或 inode），如果文件已在 v-node 表中，则复用，否则创建新条目。</li></ul></li><li><strong>分配文件表项</strong>：<ul><li>内核在文件表（file table）中创建一个新表项，记录文件的偏移量（初始为 0）、访问模式（如只读、读写）、引用计数（初始为 1）以及指向对应 v-node 的指针。</li></ul></li><li><strong>更新描述符表</strong>：<ul><li>内核在调用进程的描述符表（file descriptor table）中分配一个未使用的最小描述符编号（如 3，若 0、1、2 已占用）。</li><li>将该描述符指向新创建的文件表项。</li></ul></li><li><strong>返回文件描述符</strong>：<ul><li><code>open</code> 调用返回分配的文件描述符给进程，供后续操作（如 <code>read</code>、<code>write</code>）使用。</li></ul></li></ol><h3 id="open-两次："><a href="#open-两次：" class="headerlink" title="open 两次："></a><strong>open 两次：</strong></h3><p><img src="/images/learning/open-course/CMU-15213/Notes/Chapter10/opentwice.png"></p><h3 id="fork："><a href="#fork：" class="headerlink" title="fork："></a><strong>fork：</strong></h3><p><img src="/images/learning/open-course/CMU-15213/Notes/Chapter10/fork.png"></p><h1 id="基于缓冲区的读写"><a href="#基于缓冲区的读写" class="headerlink" title="基于缓冲区的读写"></a>基于缓冲区的读写</h1><p>基于缓冲区的读写将数据先写入内存缓冲区，等缓冲区满或显式刷新（如 fflush）时再一次性与底层设备做数据交换，降低了 I&#x2F;O 开销。</p><p>在使用读写时，我们应尽可能使用 stdio 标准库。stdio（标准输入输出库）提供了基于缓冲区的 I&#x2F;O 操作（如 fopen、fread、fwrite、printf 等），相比直接使用低级系统调用（如 read、write），它的<strong>效率更高</strong>而且更不易出错。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;style&gt;
img{
    width: 75%;
}
&lt;/style&gt;

&lt;h1 id=&quot;文件&quot;&gt;&lt;a href=&quot;#文件&quot; class=&quot;headerlink&quot; title=&quot;文件&quot;&gt;&lt;/a&gt;文件&lt;/h1&gt;&lt;p&gt;所有的 I&amp;#x2F;O 设备都被视为文件，因此我们能用一</summary>
      
    
    
    
    <category term="学习" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="公开课" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/"/>
    
    <category term="CMU-15-213" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/"/>
    
    <category term="Notes" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/Notes/"/>
    
    
  </entry>
  
  <entry>
    <title>Shlab调试记录和一键测试脚本</title>
    <link href="http://rinevard.github.io/wiki/learning/open-course/CMU-15-213/Labs/Shlab/"/>
    <id>http://rinevard.github.io/wiki/learning/open-course/CMU-15-213/Labs/Shlab/</id>
    <published>2025-04-03T09:04:28.000Z</published>
    <updated>2025-04-03T09:15:49.780Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>用时 10h30min, 通过所有测试。这个 lab 还是比较直接的, 按着 trace 的顺序逐步实现即可, 难点主要在调试和不熟悉系统调用语法上。我在写代码的过程中遇到了两个调了蛮久的 bug, 分别在 trace13 和 trace16 上, 下面简要复盘一下。</p><h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><h2 id="trace16"><a href="#trace16" class="headerlink" title="trace16"></a>trace16</h2><p>先说 trace16 的 bug, 这个调了半小时。trace16 测试的是 shell 能否处理子进程被外部信号中断或停止的情况。我遇到的问题是 trace16 在 <code>./mystop</code> 那里卡住了, 于是猜测原因是 jobs 没能正确更新子进程的暂停状态。后面加了点调试语句发现果然如此。那么修复思路就是在子进程暂停后把它对应的 job 状态进行更新。但怎么知道子进程什么时候暂停呢？答案是 sigchld_handler.</p><p>我一开始以为 sigchld_handler 只会在某个子进程终止后被调用, 所以只在 sigchld_handler 里写了回收已经终止的子进程的逻辑。后来发现<strong>子进程只要状态发生变化就会发 SIGCHLD 信号给父进程, 子进程终止只是一种情况, 暂停、恢复也会发送这个信号</strong>。所以让 sigchld_handler 检查已经停止的子进程, 并更新它们对应的 jobs 状态就修复了这个 bug.</p><h2 id="trace13"><a href="#trace13" class="headerlink" title="trace13"></a>trace13</h2><p>然后是 trace13 的 bug, 这个调了两小时半。这里的问题是在 <code>fg %1</code> 卡住。第一个猜测自然是进程没能被正确移到前台, 但加了调试语句后发现它确实被移到前台了。之后的猜测就是 waitfg 的实现有误, 这个猜测看起来很合理, 毕竟 handout 里写 waitfg 大概需要 20 行, 而我只用了 4 行。但测了半天发现 waitfg 也没问题。</p><p>进一步加入各种调试语句, 发现在 fg %1 之后, 进程确实被顺利移到了前台, jobs 也正确更新了, waitfg 只是因为它没结束, 所以一直循环着等着它。好吧, 那我猜是 sigchld_handler 没能正确回收它。我检查了一下, 发现终止的进程也都被正确回收了。那还能是什么原因呢？难道它被暂停了, 但没有被正确启动, 导致我们的 shell 误以为这个暂停着的进程是前台进程, 从而卡住了？这听起来就像是一个并行导致的问题, 于是我又调试了好久, 最后发现它确实被正确启动了, 这个进程只是单纯地还没有终止而已。</p><p>那这怎么可能呢？凭什么它在 tshref 里几秒钟就执行完了, 在我的实现里五分钟了都没执行完？原来是我的“启动”写错了。我使用的是 <code>kill(job-&gt;pid, SIGCONT)</code>, <strong>这个代码只把启动信号发给了这一个子进程, 而不是发给它所在的进程组</strong>, 从而让这个子进程所在组的别的进程没有被正确启动。而看看 <code>mysplit.c</code> 的代码, 会发现它等待它的子进程执行完才会终止, 所以我们把代码改成 <code>kill(-job-&gt;pid, SIGCONT)</code> 就解决了这个 bug.</p><p>就因为这一个负号, 我调试了两个半小时, 而且我感觉我一路下来的各种猜想也都很合理, 只能感叹系统级代码真难调试啊。</p><h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>也算是学到了几招吧：</p><ol><li>在调用系统函数时一定要检查返回值, 不然会报一些很难调试的错误</li><li>在修改全局变量时一定要用 sigprocmask 拦截别的信号, 避免冲突</li><li>子进程只要状态发生变化就会发 SIGCHLD 信号给父进程, 终止、暂停、恢复都会发送这个信号</li><li>可以用 waitpid 来检查子进程的变化状态, 它会回收终止的子进程</li><li>只在信号处理程序中调用异步安全的函数</li><li>调试时大胆猜想, 小心求证</li></ol><h1 id="一键测试脚本"><a href="#一键测试脚本" class="headerlink" title="一键测试脚本"></a>一键测试脚本</h1><p>我让 AI 写了一份一键测试脚本, 比官方的形如 <code>make test13</code> 的测试方便不少。脚本的功能是在 traceA 到 traceB（要求 A &lt; B）上分别运行 tsh 和 tshref, 并把输出结果放到两个文件中。比如说, 如果我们输入 <code>./test_traces.sh 1 5</code>, 就能测试 <code>trace01.txt</code> 到 <code>trace05.txt</code>, 并将结果分别保存到 <code>_tshref_output.txt</code> 和 <code>_tsh_output.txt</code>。之后用各种编辑器自带的比较文件功能就能很方便的比较输出异同。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 脚本名称：test_traces.sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示用法</span></span><br><span class="line"><span class="function"><span class="title">usage</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;用法: <span class="variable">$0</span> lower upper&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;  lower: 开始的 trace 文件编号 (1-16)&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;  upper: 结束的 trace 文件编号 (1-16)&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;示例: <span class="variable">$0</span> 1 5&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;  这将测试 trace01.txt 到 trace05.txt，并将输出分别保存到 _tshref_output.txt 和 _tsh_output.txt&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查是否提供了两个参数</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$#</span>&quot;</span> -ne 2 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;错误: 请提供 lower 和 upper 两个参数&quot;</span></span><br><span class="line">    usage</span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">lower=<span class="variable">$1</span></span><br><span class="line">upper=<span class="variable">$2</span></span><br><span class="line">ref_output_file=<span class="string">&quot;_tshref_output.txt&quot;</span></span><br><span class="line">tsh_output_file=<span class="string">&quot;_tsh_output.txt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 清空输出文件（如果已存在）</span></span><br><span class="line">&gt; <span class="string">&quot;<span class="variable">$ref_output_file</span>&quot;</span></span><br><span class="line">&gt; <span class="string">&quot;<span class="variable">$tsh_output_file</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取当前工作目录（模仿 make 的 Entering directory 格式）</span></span><br><span class="line">directory=$(<span class="built_in">pwd</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环运行指定范围的 trace 文件</span></span><br><span class="line"><span class="keyword">for</span> ((i=lower; i&lt;=upper; i++)); <span class="keyword">do</span></span><br><span class="line">    <span class="comment"># 补齐两位数格式（例如 01, 02, ..., 16）</span></span><br><span class="line">    trace_num=$(<span class="built_in">printf</span> <span class="string">&quot;%02d&quot;</span> <span class="variable">$i</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 输出 make 样式的进入目录信息（仅第一次循环时）</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$i</span> -eq <span class="variable">$lower</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;make[1]: Entering directory \`<span class="variable">$directory</span>&#x27;&quot;</span> &gt;&gt; <span class="string">&quot;<span class="variable">$ref_output_file</span>&quot;</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;make[1]: Entering directory \`<span class="variable">$directory</span>&#x27;&quot;</span> &gt;&gt; <span class="string">&quot;<span class="variable">$tsh_output_file</span>&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 为 tshref 输出添加分隔符和内容</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;===== Trace <span class="variable">$trace_num</span> =====&quot;</span> &gt;&gt; <span class="string">&quot;<span class="variable">$ref_output_file</span>&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;./sdriver.pl -t trace<span class="variable">$trace_num</span>.txt -s ./tshref -a \&quot;-p\&quot;&quot;</span> &gt;&gt; <span class="string">&quot;<span class="variable">$ref_output_file</span>&quot;</span></span><br><span class="line">    <span class="built_in">head</span> -n 1 <span class="string">&quot;trace<span class="variable">$trace_num</span>.txt&quot;</span> &gt;&gt; <span class="string">&quot;<span class="variable">$ref_output_file</span>&quot;</span></span><br><span class="line">    ./sdriver.pl -t <span class="string">&quot;trace<span class="variable">$trace_num</span>.txt&quot;</span> -s ./tshref -a <span class="string">&quot;-p&quot;</span> &gt;&gt; <span class="string">&quot;<span class="variable">$ref_output_file</span>&quot;</span> 2&gt;&amp;1</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;&quot;</span> &gt;&gt; <span class="string">&quot;<span class="variable">$ref_output_file</span>&quot;</span>  <span class="comment"># 添加空行作为间隔</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 为 tsh 输出添加分隔符和内容</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;===== Trace <span class="variable">$trace_num</span> =====&quot;</span> &gt;&gt; <span class="string">&quot;<span class="variable">$tsh_output_file</span>&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;./sdriver.pl -t trace<span class="variable">$trace_num</span>.txt -s ./tsh -a \&quot;-p\&quot;&quot;</span> &gt;&gt; <span class="string">&quot;<span class="variable">$tsh_output_file</span>&quot;</span></span><br><span class="line">    <span class="built_in">head</span> -n 1 <span class="string">&quot;trace<span class="variable">$trace_num</span>.txt&quot;</span> &gt;&gt; <span class="string">&quot;<span class="variable">$tsh_output_file</span>&quot;</span></span><br><span class="line">    ./sdriver.pl -t <span class="string">&quot;trace<span class="variable">$trace_num</span>.txt&quot;</span> -s ./tsh -a <span class="string">&quot;-p&quot;</span> &gt;&gt; <span class="string">&quot;<span class="variable">$tsh_output_file</span>&quot;</span> 2&gt;&amp;1</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;&quot;</span> &gt;&gt; <span class="string">&quot;<span class="variable">$tsh_output_file</span>&quot;</span>  <span class="comment"># 添加空行作为间隔</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;测试完成。参考实现结果已保存到 <span class="variable">$ref_output_file</span>，学生实现结果已保存到 <span class="variable">$tsh_output_file</span>&quot;</span></span><br></pre></td></tr></table></figure><h2 id="用法简述"><a href="#用法简述" class="headerlink" title="用法简述"></a>用法简述</h2><ol><li>保存脚本：<ul><li>将上述代码保存到一个文件，例如 <code>test_traces.sh</code>。</li></ul></li><li>赋予执行权限：<ul><li>在终端中运行以下命令，为脚本添加执行权限：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x test_traces.sh</span><br></pre></td></tr></table></figure></li><li>这一步是必须的，因为在 Linux&#x2F;Unix 系统中，脚本默认没有执行权限，需要手动赋予。</li></ul></li><li>运行脚本：<ul><li>使用以下格式运行脚本：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./test_traces.sh lower upper</span><br></pre></td></tr></table></figure><ul><li><code>lower</code>：起始的 trace 文件编号（1-16）。</li><li><code>upper</code>：结束的 trace 文件编号（1-16）。</li></ul></li><li>示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./test_traces.sh 1 5</span><br></pre></td></tr></table></figure><ul><li>这将测试 <code>trace01.txt</code> 到 <code>trace05.txt</code>，并将结果分别保存到 <code>_tshref_output.txt</code> 和 <code>_tsh_output.txt</code>。</li></ul></li></ul></li><li>检查输出：<ul><li>测试完成后，比较 <code>_tshref_output.txt</code>（参考实现结果）和 <code>_tsh_output.txt</code>（学生实现结果）。</li><li>用各种编辑器自带的比较文件功能就能很方便的比较输出异同。</li></ul></li></ol><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>环境要求：确保当前目录下有 <code>sdriver.pl</code>、<code>tshref</code>、<code>tsh</code> 以及对应的 <code>traceXX.txt</code> 文件，否则脚本会报错。</li><li>覆盖输出：每次运行脚本时，输出文件（<code>_tshref_output.txt</code> 和 <code>_tsh_output.txt</code>）会被清空并重新生成。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;用时 10h30min, 通过所有测试。这个 lab 还是比较直接的, 按着 trace 的顺序逐步实现即可, 难点主要在调</summary>
      
    
    
    
    <category term="学习" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="公开课" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/"/>
    
    <category term="CMU-15-213" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/"/>
    
    <category term="Labs" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/Labs/"/>
    
    
  </entry>
  
  <entry>
    <title>第八章——异常控制流</title>
    <link href="http://rinevard.github.io/wiki/learning/open-course/CMU-15-213/Notes/Chapter8-exception-control-flow/"/>
    <id>http://rinevard.github.io/wiki/learning/open-course/CMU-15-213/Notes/Chapter8-exception-control-flow/</id>
    <published>2025-03-31T03:26:01.000Z</published>
    <updated>2025-04-13T02:02:37.529Z</updated>
    
    <content type="html"><![CDATA[<style>img{    width: 70%;}</style><p>当我们在程序执行时按下 ctrl+c ，究竟发生了什么？为解答这个问题，我们引入<strong>异常控制流</strong>（exceptional control flow，ECF）的概念。异常控制流允许我们将控制转移到其他程序，从而实现一些神奇的效果，比如中断程序、上下文切换、调用系统函数。</p><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a><strong>异常</strong></h1><p>异常是异常控制流的一种形式，分为四类：</p><table><thead><tr><th>类别</th><th>异步&#x2F;同步</th><th>产生原因</th><th>例子</th></tr></thead><tbody><tr><td>中断（interrupt）</td><td>异步</td><td>外部事件</td><td>外部时钟（timer interrupt）</td></tr><tr><td>陷阱（trap）</td><td>同步</td><td>执行内部指令</td><td>系统调用（system calls）</td></tr><tr><td>故障（fault）</td><td>同步</td><td>执行内部指令</td><td>除以零</td></tr><tr><td>终止（abort）</td><td>同步</td><td>执行内部指令</td><td>硬件错误</td></tr></tbody></table><p><strong>注意：一定要检查系统调用的返回值，不然会出现一些很难调试的错误！</strong></p><p>异常发生后，控制会转移给异常处理程序。在处理完成后，根据异常的具体内容可能会返回到原程序的下一条指令，也可能返回到原程序的当前指令，也可能不返回。：</p><p><img src="/images/learning/open-course/CMU-15213/Notes/Chapter8/exception-control-shift.png"></p><h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a><strong>进程</strong></h1><h2 id="并发和上下文切换"><a href="#并发和上下文切换" class="headerlink" title="并发和上下文切换"></a>并发和上下文切换</h2><p>我们可以并发地执行多个进程，如下图所示：</p><p><img src="/images/learning/open-course/CMU-15213/Notes/Chapter8/concurrency.png"></p><p>但我们是怎么实现这种并发的呢？答案是上下文切换。下图展现了单核 CPU 的上下文切换，每个进程都有自己的上下文。</p><p>上下文切换的原因多种多样，举两个常见例子：用户可能执行系统调用而等待某个事件（比如用 waitpid 等待子进程终止），这时内核就可以让当前进程休眠并切换到另一个进程；系统每隔若干毫秒也会产生一次定时器中断的异常，并切换到新的进程。</p><p><img src="/images/learning/open-course/CMU-15213/Notes/Chapter8/content-change.png"></p><h2 id="进程的创建、终止和回收"><a href="#进程的创建、终止和回收" class="headerlink" title="进程的创建、终止和回收"></a>进程的创建、终止和回收</h2><p>我们可以用 fork 来创建一个当前进程的复制——它执行一次，返回两次，分别返回到父进程和父进程的子进程中。对父进程，它返回子进程的 pid；对子进程，它返回 0.</p><p>子进程在终止后不会自动被清楚，而是进入“僵死进程”状态，直到被父进程回收。如果父进程终止了，init 进程会成为它的孤儿进程的养父。很明显，这里有潜在的内存泄漏。那么，怎么回收子进程呢？</p><p>我们可以用 waitpid 来等待子进程终止，在 waitpid 返回后，这个终止的子进程会被回收。</p><p>我们可以用 execve 来加载并运行程序。execve 函数在当前进程的上下文中加载并运行一个新程序，只有在出现错误时，它才会返回到调用程序。注意，它并没有创建一个新进程，而是在当前进程的上下文中加载并运行新程序。</p><p>来看一个综合运用上面的东西的例子吧：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fork failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child process (PID: %d) running...\n&quot;</span>, <span class="built_in">getpid</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 execve 加载并运行 &quot;ls&quot; 程序</span></span><br><span class="line">        <span class="type">char</span> *argv[] = &#123;<span class="string">&quot;/bin/ls&quot;</span>, <span class="literal">NULL</span>&#125;; <span class="comment">// 参数列表</span></span><br><span class="line">        <span class="type">char</span> *envp[] = &#123;<span class="literal">NULL</span>&#125;;            <span class="comment">// 环境变量列表</span></span><br><span class="line">        <span class="built_in">execve</span>(<span class="string">&quot;/bin/ls&quot;</span>, argv, envp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 execve 返回，说明执行失败</span></span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;execve failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Parent process (PID: %d), waiting for child (PID: %d)...\n&quot;</span>, <span class="built_in">getpid</span>(), pid);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 waitpid 等待子进程终止并回收</span></span><br><span class="line">        <span class="type">int</span> status;</span><br><span class="line">        <span class="built_in">waitpid</span>(pid, &amp;status, <span class="number">0</span>); <span class="comment">// 阻塞等待子进程 pid 结束</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">WIFEXITED</span>(status)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Child exited with status %d\n&quot;</span>, <span class="built_in">WEXITSTATUS</span>(status));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="信号"><a href="#信号" class="headerlink" title="信号"></a><strong>信号</strong></h1><p>信号允许内核异步通知目标进程发生了特定事件。</p><h2 id="发送和接收信号"><a href="#发送和接收信号" class="headerlink" title="发送和接收信号"></a>发送和接收信号</h2><p><strong>发送信号</strong><br>信号可以由内核自动生成，例如：</p><ul><li>当某个子进程的状态发生变化时（比如终止、暂停、恢复），内核会发送一个 <code>SIGCHLD</code> 信号给父进程；</li><li>当某个进程尝试除以 0 时，内核会发送一个 <code>SIGFPE</code> 信号给该进程。<br>此外，进程也可以通过 <code>kill</code> 函数手动请求内核向其他进程发送信号。</li></ul><p><strong>接收信号</strong><br>当内核将信号传递给目标进程，并迫使进程对此信号采取行动（例如执行信号处理程序或默认行为）时，进程就接收了该信号。需要注意的是，如果信号被阻塞或暂时未处理，它不会被视为“已接收”，而是进入待处理状态。</p><p>我们能用 <code>signal</code> 函数修改接收信号后的行为。</p><p><strong>未接收的信号会怎样？</strong><br>如果信号发出后未被立即接收，它会变成一个待处理信号。内核为每个进程维护一个表示待处理信号的位向量（pending signal bit vector），用以追踪有哪些信号尚未处理。由于信号不排队，同一时刻同一类型的待处理信号最多只有一个（即位向量中该位被置为 1）。如果某个类型已经有了待处理信号，被发送过来的同类信号会被简单地丢弃。此外，内核还为每个进程维护一个表示被阻塞信号的位向量（blocked signal bit vector），用来记录当前被屏蔽、不允许传递的信号。</p><h2 id="异步的风险"><a href="#异步的风险" class="headerlink" title="异步的风险"></a>异步的风险</h2><p>下面的例子很好地说明了异步的风险</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">sig_atomic_t</span> pid;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sigchld_handler</span><span class="params">(<span class="type">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> olderrno = errno;</span><br><span class="line">    pid = <span class="built_in">waitpid</span>(<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>); <span class="comment">// 在子进程终止后更新pid</span></span><br><span class="line">    errno = olderrno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sigint_handler</span><span class="params">(<span class="type">int</span> s)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="type">sigset_t</span> mask, prev;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Signal</span>(SIGCHLD, sigchld_handler); <span class="comment">// 在子进程终止后更新pid</span></span><br><span class="line">    <span class="built_in">Signal</span>(SIGINT, sigint_handler);</span><br><span class="line">    <span class="built_in">Sigemptyset</span>(&amp;mask);</span><br><span class="line">    <span class="built_in">Sigaddset</span>(&amp;mask, SIGCHLD);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">Sigprocmask</span>(SIG_BLOCK, &amp;mask, &amp;prev); <span class="comment">/* Block SIGCHLD */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Fork</span>() == <span class="number">0</span>) &#123; <span class="comment">/* Child */</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Parent */</span></span><br><span class="line">        pid = <span class="number">0</span>; <span class="comment">// 我们 block 信号，这样即使子进程在这条语句前终止，pid也能正确更新</span></span><br><span class="line">        <span class="built_in">Sigprocmask</span>(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>); <span class="comment">/* Unblock SIGCHLD */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Wait for SIGCHLD to be received (wasteful) */</span></span><br><span class="line">        <span class="keyword">while</span> (!pid) &#123;</span><br><span class="line">            <span class="built_in">pause</span>(); <span class="comment">// 潜在的竞争！</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Do some work after receiving SIGCHLD */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先来看看下面的局部代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Sigprocmask</span>(SIG_BLOCK, &amp;mask, &amp;prev); <span class="comment">/* Block SIGCHLD */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Fork</span>() == <span class="number">0</span>) &#123; <span class="comment">/* Child */</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Parent */</span></span><br><span class="line">pid = <span class="number">0</span>; <span class="comment">// 我们 block 信号，这样即使子进程在这条语句前终止，pid也能正确更新</span></span><br><span class="line"><span class="built_in">Sigprocmask</span>(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>); <span class="comment">/* Unblock SIGCHLD */</span></span><br></pre></td></tr></table></figure><p>如果不使用 block，而子进程在 pid&#x3D;0 这条语句前终止，那么信号处理程序会先把 pid 设置为子进程 pid，然后 pid 被重置为 0，导致我们没能正确记录 pid。这就是<strong>阻塞信号</strong>的重要性。</p><p>再来看看这里：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!pid) &#123;</span><br><span class="line">    <span class="built_in">pause</span>(); <span class="comment">// 潜在的竞争！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的原意是在没有接收到信号时暂停，以避免空循环浪费处理器资源。具体来说，在收到子进程终止的信号后 pause 状态会结束，然后执行信号处理代码，然后进入下一个循环。</p><p>但这个 pause 带来了潜在的竞争。比如说，如果在 while 测试后和 pause 前收到信号，之后又没有别的信号，pause 就会进入永久睡眠。这就是<strong>竞争的风险</strong>。</p><p>对这个例子，解决办法是用 sigsuspend 替换 pause，我们不多说了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;style&gt;
img{
    width: 70%;
}
&lt;/style&gt;

&lt;p&gt;当我们在程序执行时按下 ctrl+c ，究竟发生了什么？为解答这个问题，我们引入&lt;strong&gt;异常控制流&lt;/strong&gt;（exceptional control flow，ECF）的概念。</summary>
      
    
    
    
    <category term="学习" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="公开课" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/"/>
    
    <category term="CMU-15-213" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/"/>
    
    <category term="Notes" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/Notes/"/>
    
    
  </entry>
  
  <entry>
    <title>Cachelab理论分析</title>
    <link href="http://rinevard.github.io/wiki/learning/open-course/CMU-15-213/Labs/Cachelab/"/>
    <id>http://rinevard.github.io/wiki/learning/open-course/CMU-15-213/Labs/Cachelab/</id>
    <published>2025-03-26T10:37:28.000Z</published>
    <updated>2025-03-26T10:38:34.242Z</updated>
    
    <content type="html"><![CDATA[<style>img{    width: 60%;}</style><p>先放一个最终结果在这里</p><p><img src="/images/learning/open-course/CMU-15213/Labs/Cachelab/result.png"></p><h1 id="Part-A-模拟-cache"><a href="#Part-A-模拟-cache" class="headerlink" title="Part A 模拟 cache"></a>Part A 模拟 cache</h1><p>用时 3h.</p><p>一开始因为 16 进制踩了坑。我第一个看的 trace 文件是 yi.trace，我把里面的地址当成了十进制，分析了半天总感觉不对，后来惊醒这是十六进制。</p><p>part A 不难，正常模拟一遍就好。由于 handout 里说，“you should assume that memory accesses are aligned properly, such that a single memory access never crosses block boundaries”，所以对每行记录，我们只要考虑其指令类型和地址即可，不必考虑操作大小。我使用了这样的数据结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span> valid;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> lineTag;</span><br><span class="line">    <span class="type">int</span> lruCount; <span class="comment">// 记录上一次访问到现在的时间</span></span><br><span class="line">&#125; CacheLine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    CacheLine *lines;</span><br><span class="line">&#125; CacheSet;</span><br><span class="line"></span><br><span class="line">CacheSet *sets = <span class="built_in">malloc</span>((<span class="number">1</span> &lt;&lt; s)* <span class="built_in">sizeof</span>(CacheSet));</span><br></pre></td></tr></table></figure><p>在核心循环里，对某个给定的 set，我们在遍历过程中从前往后填充每个 set 的 line，思路如下：</p><p>对每个地址，用位运算得到其 setIdx 和 tag，然后找到对应的 set，遍历里面的所有 line. 如果找到了空 line，直接填充进去；如果找到了对应的 tag，就 hit 了；如果没找到对应 tag，说明需要驱逐某个 line，找到 lru 最大的 line（即最久没有访问过的 line）并把它换掉即可。</p><p>注意正确更新遍历的 set 里的每个 line 的 lruCount.</p><p>用下面的位运算就能得到 setIdx 和 tag：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> mask = <span class="number">-1</span>;</span><br><span class="line">mask = ~(mask &lt;&lt; s); <span class="comment">// 000...11 (s 个 1)</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> setIdx = (address &gt;&gt; b) &amp; mask;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> tag = address &gt;&gt; (b + s);</span><br></pre></td></tr></table></figure><p>还有一个小 trick 是可以用这样的写法来简化代码，毕竟我们并不关心操作在类型上的差异，只关心操作的地址：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (operation) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>:</span><br><span class="line">        <span class="comment">// M = L + S, 其 &#x27;S&#x27; 总会命中</span></span><br><span class="line">        hits++;</span><br><span class="line">        <span class="comment">// fall through</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>:</span><br><span class="line">        <span class="comment">// fall through</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>:</span><br><span class="line">        <span class="comment">// 真正的工作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Part-B"><a href="#Part-B" class="headerlink" title="Part B"></a>Part B</h1><p>用时 7 h，拼尽全力也只能把 64x64 拿到 1411 miss，上网找了找别人的思路，最后得到了 1179 miss. 最后结果如下：</p><p>Points Max pts Misses<br>Trans perf 32x32 8.0 8 287<br>Trans perf 64x64 8.0 8 1179<br>Trans perf 61x67 10.0 10 1997</p><p>我参考的文章是这篇： <a href="https://zhuanlan.zhihu.com/p/387662272">CSAPP - Cache Lab 的更(最)优秀的解法 - 知乎</a>，作者直接拿到了 64x64 的理论最优解，非常强大。不过我没有在对角线上做微调，而是只参考了作者对一般块的读写顺序。</p><p>我的三个转置都没有特别考虑对角线的情况。一方面是因为嫌麻烦，另一方面是因为我觉得这种“两个内存块位置恰好差 2 的幂次导致缓存抖动”的事情太特殊，所以没额外处理。</p><h2 id="分块大小的确定"><a href="#分块大小的确定" class="headerlink" title="分块大小的确定"></a>分块大小的确定</h2><p>首先，分块优化是一定要做的。但分成多大的块呢？最朴素的想法是，我们希望块尽可能大来装满 cache，但不要太大以至于 cache 装不下。</p><p>我们有 $2^5 &#x3D; 32$ 个 sets，每个 set 一个 line，每个 line 存 8 个 int，也就是说，我们最多能存 $32*8 &#x3D; 256 &#x3D; 2^8$ 个 int. 我们希望同时把 A 的块和 B 的块放到 cache 中，两个块大小应当相同，所以每个块可以放 $256&#x2F;2 &#x3D; 128$ 个 int. 128 不是完全平方数，所以我们可以分块成 8x8.</p><h2 id="初版代码"><a href="#初版代码" class="headerlink" title="初版代码"></a>初版代码</h2><p>回到之前的 8x8 分块的讨论上来。总之，我写出了我的初版代码。思路就是分块，然后把 A 的块存到 tmp 数组里，然后复制到 B 里。为什么要用 tmp 做中转呢？答案是为了避免缓存冲突：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">transpose_submit</span><span class="params">(<span class="type">int</span> M, <span class="type">int</span> N, <span class="type">int</span> A[N][M], <span class="type">int</span> B[M][N])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> blockSize = <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> rowBlock, colBlock, i, j;</span><br><span class="line">    <span class="comment">// 向上取整, 计算出总 block 数.</span></span><br><span class="line">    <span class="comment">// 可能会含有不是正方形的 block</span></span><br><span class="line">    <span class="type">int</span> rowBlocks = (N + blockSize - <span class="number">1</span>) / blockSize;</span><br><span class="line">    <span class="type">int</span> colBlocks = (M + blockSize - <span class="number">1</span>) / blockSize;</span><br><span class="line">    <span class="type">int</span> tmp[blockSize][blockSize]; <span class="comment">// cachelab不允许开数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (rowBlock = <span class="number">0</span>; rowBlock &lt; rowBlocks; rowBlock++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (colBlock = <span class="number">0</span>; colBlock &lt; colBlocks; colBlock++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (i = rowBlock * blockSize; i &lt; (rowBlock + <span class="number">1</span>) * blockSize &amp;&amp; i &lt; N; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (j = colBlock * blockSize; j &lt; (colBlock + <span class="number">1</span>) * blockSize &amp;&amp; j &lt; M; j++) &#123;</span><br><span class="line">                    tmp[j - colBlock * blockSize][i - rowBlock * blockSize] = A[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (j = colBlock * blockSize; j &lt; (colBlock + <span class="number">1</span>) * blockSize &amp;&amp; j &lt; M; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (i = rowBlock * blockSize; i &lt; (rowBlock + <span class="number">1</span>) * blockSize &amp;&amp; i &lt; N; i++) &#123;</span><br><span class="line">                    B[j][i] = tmp[j - colBlock * blockSize][i - rowBlock * blockSize];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果很不错：</p><p>Cache Lab summary:<br>Points Max pts Misses<br>Trans perf 32x32 8.0 8 261<br>Trans perf 64x64 8.0 8 1029<br>Trans perf 61x67 10.0 10 1725</p><p>正当我觉得 cachelab 不过如此的时候，忽然发现 handout 里写了不允许开数组（哈哈，你想得到的 cmu 老师想不到吗），于是被迫手动展开了 j 循环，使用 8 个变量来读取每行的值。这就得到了下面的结果：</p><p>Cache Lab summary:<br>Points Max pts Misses<br>Trans perf 32x32 8.0 8 287<br>Trans perf 64x64 0.0 8 4611<br>Trans perf 61x67 10.0 10 1997</p><p>也还算不错吧，毕竟 32x32 和 61x67 都满分了。唯一的问题是 64x64 的性能奇差无比。</p><h2 id="分析-64x64-矩阵的-miss-次数"><a href="#分析-64x64-矩阵的-miss-次数" class="headerlink" title="分析 64x64 矩阵的 miss 次数"></a>分析 64x64 矩阵的 miss 次数</h2><p>这时候就要理论分析了。对 64x64 的矩阵，按我们之前的做法，每个 8x8 的块大约发生了多少次 miss 呢？</p><p>答案是 72 次。A 提供了 8 次 miss，B 提供了 64 次 miss</p><p>验证一下结果对不对：64x64 的矩阵共有 64 个 8x8 的块，64 个块每个块 72 次 miss，总计约 $64*72&#x3D;4608$ 次 miss，和结果 4611 次 miss 相差无几。</p><p>这个 miss 是怎么算出来的呢？让我们看看下图：</p><p><img src="/images/learning/open-course/CMU-15213/Labs/Cachelab/64x64bad.png"></p><p>对 64x64 的矩阵来说，B[x][y] 和 B[x+4][y] 的 setIdx 相同，这就导致我们之前的方法不断驱逐旧 line. 定量地说，每读 A 的块的一行，大约是 1 个 miss，A 的块共有 8 行，所以 A 的每个块提供 8 次 miss；每对 B 的块写入一个值，都驱逐了一次旧 line（因为 B[x+4][y] 会驱逐 B[x][y]），所以 B 的每个块提供 64 次 miss.</p><p>之后的工作就是找到方法来避免这种驱逐了。</p><h2 id="对-64x64-矩阵的第一次优化——1699"><a href="#对-64x64-矩阵的第一次优化——1699" class="headerlink" title="对 64x64 矩阵的第一次优化——1699"></a>对 64x64 矩阵的第一次优化——1699</h2><p>一开始我的思路是直接用 4x4 的块，这确实有不小优化，但离满分还很远。读者可以试着做一个理论分析看看 4x4 的结果大概是多少 miss。我分析出来会得到 1536 个 miss，实际结果是 1699 个 miss，也差不多吧。</p><p>好吧，这个理论分析看起来值得详细讲解一下。不过在写之前，希望读者自己分析一下，看看得到的结果是不是 2048，并想想哪里出错了：</p><p>如果块的大小是 4x4，每个块发生 4 次 miss，每个矩阵 256 个块，一共 2048 次 miss，看起来很合理。但这是理论最优解，为什么理论最优（2048）比实际结果（1699）还差呢？难道说数学的大厦崩塌了？</p><p>并非如此。事实上，在我们把某个 4x4 的块放入 cache 时，我们也同时把它的右边的那个 4x4 的块放入了 cache。这是因为 cache 的每个 line 能装 8 个 int.</p><p>也就是说，我们可以认为我们实际上是在处理 4x8 的块。对每个 4x8 的块，A 提供了 4 次 miss，B 提供了 8 次 miss，总计 $64 * 4 + 64 * 8 &#x3D; 1536$ 次 miss.</p><h2 id="对-64x64-矩阵的第二次优化——1411"><a href="#对-64x64-矩阵的第二次优化——1411" class="headerlink" title="对 64x64 矩阵的第二次优化——1411"></a>对 64x64 矩阵的第二次优化——1411</h2><p>分析了那么多，还是没拿到满分。我的后续思路是把 8x8 的块再分成四个小块，并按下面的顺序来写入 B：</p><p><img src="/images/learning/open-course/CMU-15213/Labs/Cachelab/64x64normal.png"></p><p>理论分析一下，把 A1 写入 B1 时，A miss 4 次，B miss 4 次；</p><p>把 A2 写入 B2 时，A miss 4 次，B 没有 miss（因为写入 B1 时把 B2 放进了 cache）；</p><p>把 A3 写入 B3 时，A 没有 miss，B miss 4 次；（因为读 A2 时把 A3 放入了 cache）；</p><p>把 A4 写入 B4 时，A miss 4 次，B 没有 miss（因为写入 B3 时把 B4 放进了 cache）</p><p>总计 20 次 miss，理论最优解 1280，实际结果 1411，我猜问题出在对角线上，我也懒得在这个基础上继续优化了。优化对角线这种事情看起来就很麻烦，而且感觉现实里几乎不会遇见这种情况。</p><h2 id="对-64x64-矩阵的第二次优化——1179"><a href="#对-64x64-矩阵的第二次优化——1179" class="headerlink" title="对 64x64 矩阵的第二次优化——1179"></a>对 64x64 矩阵的第二次优化——1179</h2><p>没什么好说的，直接看 <a href="https://zhuanlan.zhihu.com/p/387662272">CSAPP - Cache Lab 的更(最)优秀的解法 - 知乎</a> 和代码吧。这篇文章的作者拿到了 64x64 的理论最优解，非常强大。不过我没有在对角线上做微调，而是只参考了作者对一般块的读写顺序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">transpose_submit_64x64</span><span class="params">(<span class="type">int</span> M, <span class="type">int</span> N, <span class="type">int</span> A[N][M], <span class="type">int</span> B[M][N])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> blockSize = <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> rowBlock, colBlock, i, j;</span><br><span class="line">    <span class="type">int</span> rowBlocks = (N + blockSize - <span class="number">1</span>) / blockSize;</span><br><span class="line">    <span class="type">int</span> colBlocks = (M + blockSize - <span class="number">1</span>) / blockSize;</span><br><span class="line">    <span class="type">int</span> tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (rowBlock = <span class="number">0</span>; rowBlock &lt; rowBlocks; rowBlock++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (colBlock = <span class="number">0</span>; colBlock &lt; colBlocks; colBlock++) &#123;</span><br><span class="line">            <span class="comment">// A上</span></span><br><span class="line">            <span class="keyword">for</span> (i = rowBlock * blockSize; i &lt; rowBlock * blockSize + blockSize / <span class="number">2</span> &amp;&amp; i &lt; N; i++) &#123;</span><br><span class="line">                <span class="comment">// 读取A的一行</span></span><br><span class="line">                tmp0 = A[i][colBlock * blockSize];</span><br><span class="line">                tmp1 = A[i][colBlock * blockSize + <span class="number">1</span>];</span><br><span class="line">                tmp2 = A[i][colBlock * blockSize + <span class="number">2</span>];</span><br><span class="line">                tmp3 = A[i][colBlock * blockSize + <span class="number">3</span>];</span><br><span class="line">                tmp4 = A[i][colBlock * blockSize + <span class="number">4</span>];</span><br><span class="line">                tmp5 = A[i][colBlock * blockSize + <span class="number">5</span>];</span><br><span class="line">                tmp6 = A[i][colBlock * blockSize + <span class="number">6</span>];</span><br><span class="line">                tmp7 = A[i][colBlock * blockSize + <span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 填充B左上</span></span><br><span class="line">                B[colBlock * blockSize][i] = tmp0;</span><br><span class="line">                B[colBlock * blockSize + <span class="number">1</span>][i] = tmp1;</span><br><span class="line">                B[colBlock * blockSize + <span class="number">2</span>][i] = tmp2;</span><br><span class="line">                B[colBlock * blockSize + <span class="number">3</span>][i] = tmp3;</span><br><span class="line">                <span class="comment">// 填充B右上, 这一部分未来会被放到B左下</span></span><br><span class="line">                B[colBlock * blockSize][i + blockSize / <span class="number">2</span>] = tmp4;</span><br><span class="line">                B[colBlock * blockSize + <span class="number">1</span>][i + blockSize / <span class="number">2</span>] = tmp5;</span><br><span class="line">                B[colBlock * blockSize + <span class="number">2</span>][i + blockSize / <span class="number">2</span>] = tmp6;</span><br><span class="line">                B[colBlock * blockSize + <span class="number">3</span>][i + blockSize / <span class="number">2</span>] = tmp7;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// A左下, 注意这里按列遍历</span></span><br><span class="line">            <span class="keyword">for</span> (j = colBlock * blockSize; j &lt; colBlock * blockSize + blockSize / <span class="number">2</span> &amp;&amp; j &lt; M; j++) &#123;</span><br><span class="line">                <span class="comment">// 读取 A 的左下小块的一列</span></span><br><span class="line">                tmp0 = A[rowBlock * blockSize + blockSize / <span class="number">2</span>][j];</span><br><span class="line">                tmp1 = A[rowBlock * blockSize + blockSize / <span class="number">2</span> + <span class="number">1</span>][j];</span><br><span class="line">                tmp2 = A[rowBlock * blockSize + blockSize / <span class="number">2</span> + <span class="number">2</span>][j];</span><br><span class="line">                tmp3 = A[rowBlock * blockSize + blockSize / <span class="number">2</span> + <span class="number">3</span>][j];</span><br><span class="line">                <span class="comment">// 读取 B 的右上小块的一行</span></span><br><span class="line">                tmp4 = B[j][rowBlock * blockSize + blockSize / <span class="number">2</span>];</span><br><span class="line">                tmp5 = B[j][rowBlock * blockSize + blockSize / <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">                tmp6 = B[j][rowBlock * blockSize + blockSize / <span class="number">2</span> + <span class="number">2</span>];</span><br><span class="line">                tmp7 = B[j][rowBlock * blockSize + blockSize / <span class="number">2</span> + <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 把从 A 左下读到的内容写到 B 右上</span></span><br><span class="line">                B[j][rowBlock * blockSize + blockSize / <span class="number">2</span>] = tmp0;</span><br><span class="line">                B[j][rowBlock * blockSize + blockSize / <span class="number">2</span> + <span class="number">1</span>] = tmp1;</span><br><span class="line">                B[j][rowBlock * blockSize + blockSize / <span class="number">2</span> + <span class="number">2</span>] = tmp2;</span><br><span class="line">                B[j][rowBlock * blockSize + blockSize / <span class="number">2</span> + <span class="number">3</span>] = tmp3;</span><br><span class="line">                <span class="comment">// 把 B 右上的内容写到 B 左下</span></span><br><span class="line">                B[j + blockSize / <span class="number">2</span>][rowBlock * blockSize] = tmp4;</span><br><span class="line">                B[j + blockSize / <span class="number">2</span>][rowBlock * blockSize + <span class="number">1</span>] = tmp5;</span><br><span class="line">                B[j + blockSize / <span class="number">2</span>][rowBlock * blockSize + <span class="number">2</span>] = tmp6;</span><br><span class="line">                B[j + blockSize / <span class="number">2</span>][rowBlock * blockSize + <span class="number">3</span>] = tmp7;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// A右下</span></span><br><span class="line">            <span class="keyword">for</span> (i = rowBlock * blockSize + blockSize / <span class="number">2</span>; i &lt; (rowBlock + <span class="number">1</span>) * blockSize &amp;&amp; i &lt; N; i++) &#123;</span><br><span class="line">                <span class="comment">// 读取A的一行</span></span><br><span class="line">                tmp0 = A[i][colBlock * blockSize + blockSize / <span class="number">2</span>];</span><br><span class="line">                tmp1 = A[i][colBlock * blockSize + blockSize / <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">                tmp2 = A[i][colBlock * blockSize + blockSize / <span class="number">2</span> + <span class="number">2</span>];</span><br><span class="line">                tmp3 = A[i][colBlock * blockSize + blockSize / <span class="number">2</span> + <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 填充B</span></span><br><span class="line">                B[colBlock * blockSize + blockSize / <span class="number">2</span>][i] = tmp0;</span><br><span class="line">                B[colBlock * blockSize + blockSize / <span class="number">2</span> + <span class="number">1</span>][i] = tmp1;</span><br><span class="line">                B[colBlock * blockSize + blockSize / <span class="number">2</span> + <span class="number">2</span>][i] = tmp2;</span><br><span class="line">                B[colBlock * blockSize + blockSize / <span class="number">2</span> + <span class="number">3</span>][i] = tmp3;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Future-work"><a href="#Future-work" class="headerlink" title="Future work"></a>Future work</h1><p>写文章的时候突然想到我们似乎可以分长方形的 16x8 的块，因为 $16<em>8</em>2 &#x3D; 256$ 可以完全填满 cache. 简单写了下代码得到了下面的结果：</p><p>[16x8]<br>Points Max pts Misses<br>Trans perf 32x32 8.0 8 287<br>Trans perf 61x67 10.0 10 1811<br>看起来效果出乎意料地不错？甚至比我的 8x8 分块效果更好。这里没有放进来 64x64 转置的结果，因为我没有做分小块的优化。所以说，这种方法说不定还有不小探索空间？</p><p>下面是我的 8x8 分块的结果，可以用来和上面的结果做比较。两个代码都只用了简单的分块和 8 个 tmp 变量，没有额外优化。</p><p>[8x8]</p><p>Points Max pts Misses<br>Trans perf 32x32 8.0 8 287<br>Trans perf 61x67 10.0 10 1997</p><p>这里是我使用的 16x8 的分块代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">transpose_submit</span><span class="params">(<span class="type">int</span> M, <span class="type">int</span> N, <span class="type">int</span> A[N][M], <span class="type">int</span> B[M][N])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> blockRow = <span class="number">16</span>;    <span class="comment">// 块的行数</span></span><br><span class="line">    <span class="type">int</span> blockCol = <span class="number">8</span>;   <span class="comment">// 块的列数</span></span><br><span class="line">    <span class="type">int</span> rowBlock, colBlock, i, j;</span><br><span class="line">    <span class="comment">// 向上取整, 计算出总 block 数</span></span><br><span class="line">    <span class="type">int</span> rowBlocks = (N + blockRow - <span class="number">1</span>) / blockRow;</span><br><span class="line">    <span class="type">int</span> colBlocks = (M + blockCol - <span class="number">1</span>) / blockCol;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (rowBlock = <span class="number">0</span>; rowBlock &lt; rowBlocks; rowBlock++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (colBlock = <span class="number">0</span>; colBlock &lt; colBlocks; colBlock++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (i = rowBlock * blockRow; i &lt; (rowBlock + <span class="number">1</span>) * blockRow &amp;&amp; i &lt; N; i++) &#123;</span><br><span class="line">                <span class="comment">// 展开j循环，每次处理8个元素</span></span><br><span class="line">                j = colBlock * blockCol;</span><br><span class="line">                <span class="keyword">if</span> (j &lt; M) tmp0 = A[i][j];</span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">1</span> &lt; M) tmp1 = A[i][j + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">2</span> &lt; M) tmp2 = A[i][j + <span class="number">2</span>];</span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">3</span> &lt; M) tmp3 = A[i][j + <span class="number">3</span>];</span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">4</span> &lt; M) tmp4 = A[i][j + <span class="number">4</span>];</span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">5</span> &lt; M) tmp5 = A[i][j + <span class="number">5</span>];</span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">6</span> &lt; M) tmp6 = A[i][j + <span class="number">6</span>];</span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">7</span> &lt; M) tmp7 = A[i][j + <span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 写入B矩阵</span></span><br><span class="line">                <span class="keyword">if</span> (j &lt; M) B[j][i] = tmp0;</span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">1</span> &lt; M) B[j + <span class="number">1</span>][i] = tmp1;</span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">2</span> &lt; M) B[j + <span class="number">2</span>][i] = tmp2;</span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">3</span> &lt; M) B[j + <span class="number">3</span>][i] = tmp3;</span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">4</span> &lt; M) B[j + <span class="number">4</span>][i] = tmp4;</span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">5</span> &lt; M) B[j + <span class="number">5</span>][i] = tmp5;</span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">6</span> &lt; M) B[j + <span class="number">6</span>][i] = tmp6;</span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">7</span> &lt; M) B[j + <span class="number">7</span>][i] = tmp7;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;style&gt;
img{
    width: 60%;
}
&lt;/style&gt;

&lt;p&gt;先放一个最终结果在这里&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/learning/open-course/CMU-15213/Labs/Cachelab/result.png&quot;&gt;&lt;/</summary>
      
    
    
    
    <category term="学习" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="公开课" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/"/>
    
    <category term="CMU-15-213" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/"/>
    
    <category term="Labs" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/Labs/"/>
    
    
  </entry>
  
  <entry>
    <title>玩乐的人</title>
    <link href="http://rinevard.github.io/wiki/others/thoughts/%E7%8E%A9%E4%B9%90%E7%9A%84%E4%BA%BA/"/>
    <id>http://rinevard.github.io/wiki/others/thoughts/%E7%8E%A9%E4%B9%90%E7%9A%84%E4%BA%BA/</id>
    <published>2025-03-24T11:09:30.000Z</published>
    <updated>2025-03-24T11:08:37.615Z</updated>
    
    <content type="html"><![CDATA[<h1 id="故事之前"><a href="#故事之前" class="headerlink" title="故事之前"></a>故事之前</h1><p>最近在学<a href="https://www.bilibili.com/video/BV1eE411F73t">查理老师的编剧课</a>，课很有趣，不过信息密度似乎有点低，我就当单口相声听了。这篇文章记录了第五课老师布置的作业，故事的八要素、支点和大纲是我自己写的，具体内容是 AI 填充的，我把 AI 生成的多个版本拼拼凑凑得到了下面的故事（什么拼好文）。</p><p>最近的思绪挺乱的。前两天做了个游戏原型，感觉大体上还算值得做，暂命名叫《翻命师》。这样的话，想做的事情实在是有点多了。想参加 GSoC 来接触下开发，顺便提升下 cpp 水平；想继续学公开课，了解下底层知识；还想花 100 天完整地做一个能放到 itch 甚至 steam 上的小游戏，跑一遍流程。</p><p>说来有些凡尔赛，但上学期的成绩好得有点莫名其妙，以至于我真的开始考虑外保之类的事情。这就导致我们真的陷入了一个奇怪的“保研开发两手抓”的境地，但我的水平却不足以支持我把它们全部抓牢，于是便深感时间紧张。全抓牢真的不可能吗？如果是我的话说不定也能做到呢，但这样的生活是否缺乏了一抹奇幻色彩呢？比起把绝大多数时间都花在自我实现和提升自己的水平上，我还是想抽出时间来学学新东西，看看番剧，打打游戏。再说了，现在的社交水平仍然是负的，是不是该去提升一下？原本想着靠找人来试玩来和人们交流，但这又回到了开发上。虽然这看起来是条可行的路，但感觉有点点奇怪。</p><p>人生短则二十年，长则一百年，我们究竟想做什么，想去往何方，想成为什么样的人？</p><p>前路未定却仍试图看向未来，自会焦虑。不过我喜欢的一个虚拟角色在这种情况下想必会说：“焦虑也是一种不可多得的体验呢”。喜悦和平静自然是大家都喜欢的体验，但焦虑、悲伤这些负面情绪似乎也是奇妙的体验。人类，很神奇吧。</p><p>话说回来，翻命师这个名字听起来就很有趣吧。听说为自己摆个”过路牌阵”，一行三牌，便能解一时之困。我回去摆一下试试。</p><p>在 101 发了个没那么凡尔赛的版本。我在认真思考，BIT101 对我来说究竟意味着什么。我从未想过立一个很厉害的人设，但我在发帖时总会不自觉地只展示看起来不错的一面，于是渐渐地就只写出了一些“局部的真实”。</p><p>那我是怎么发现这个版本有点凡尔赛的呢？答案是让 AI 写了一个翻版。我要求 AI 把和游戏、编程相关的内容换成别的领域的内容，就得到了本文中“故事之后——AI 的凡尔赛”那一节的内容。看了看，感觉真的好凡尔赛啊&#x3D;) 于是就改了改。如果我真的很厉害就好了，可惜我并不。但我会变强的。</p><h1 id="故事——玩乐的人"><a href="#故事——玩乐的人" class="headerlink" title="故事——玩乐的人"></a>故事——玩乐的人</h1><p>“姓名？”</p><p>“李明。”</p><p>“年龄？”</p><p>“呃……十七岁？”</p><p>检票员扫了他一眼，最后只是叹了口气，挥手放行。</p><p>李明现年 32 岁，身高 169 厘米，体重 61.5 公斤，没有女朋友，没有宠物，没有不良嗜好。在李明居住的城市里，所有 20 岁以上的成年人都按照同样的程序生活：起床、工作、吃饭、睡觉，偶尔参加培训、会议和团建活动。政府颁布的《成年人行为准则》明确规定，成年人的首要任务是工作，次要任务是为国家培养合格公民，第三任务是照顾老人，第四任务是自我提升。第十七条特别强调：成年人严禁进入游乐设施。</p><p>现在他站在游乐园入口处，身上裹着一件印着卡通恐龙的 T 恤，下半身穿着一条明显短了一截的背带裤，脚上是一双带灯的运动鞋。他的脸上贴着两块大号创可贴，试图掩盖胡茬的痕迹。</p><p>李明小心翼翼地走进游乐园，手里握着一根棒棒糖，时不时紧张地舔一口，假装自己对糖果很感兴趣。实际上，他上一次吃棒棒糖还是在十三岁那年。</p><p>“嘿！你在这里干嘛呀？你家大人呢？”一个游乐园工作人员走过来问道。</p><p>“我爸爸去买饮料了，让我在这里等他。”李明背了五遍的标准答案脱口而出。</p><p>工作人员上下打量了他几眼：”你多大了？看起来挺高的。”</p><p>“我发育得早，十七岁。”李明掏出事先准备好的学生证，那是他从网上特意定制的。</p><p>工作人员勉强相信了他的说法，转身离开。李明松了一口气，迅速往旋转木马方向走去。</p><p>旋转木马上，李明紧紧抓住金色的扶手，感受着上下起伏的节奏。音乐响起，木马开始旋转，李明的心跳加速，一种奇怪的快感从脚底蔓延到全身。他已经记不清上一次有这种感觉是什么时候了。</p><p>“你也是一个人来的吗？”旁边的木马上，一个大约九岁的小女孩问道。</p><p>李明僵硬地点点头。</p><p>“我也是！我妈妈在那边，”小女孩指着远处一个看手机的女人，”她说自己太忙了，没时间陪我玩。大人们总是很忙。”</p><p>李明想起自己的父母。他们在李明八岁时就告诉他：”玩是没有出息的表现。”十二岁时，他们卖掉了他所有的玩具，换成了各种学习资料。十八岁时，他们为他制定了”成功人生规划表”，上面没有一项与娱乐有关。三十岁时，他们送给他一套”友爱公寓”的首付款，条件是他必须在十年内获得三次职位晋升。</p><p>木马停下来后，李明迫不及待地跑向过山车。排队时，他故意弯着腰，装作比实际身高矮一些。轮到他时，检查身高的工作人员狐疑地看了他一眼：”你确定要玩吗？看起来有点紧张。”</p><p>“我当然要玩！”李明用他练习过的童声说，声音因为紧张而有些发抖。</p><p>过山车启动了，缓缓爬升。李明死死抓住安全杆，心脏几乎要跳出胸膛。风呼啸着掠过耳边，李明感到一种前所未有的自由。当车厢俯冲而下时，他放声尖叫，那是他 32 年人生中第一次如此肆无忌惮地尖叫。</p><p>下了过山车，李明头晕目眩，但脸上挂着难以抑制的笑容。他感觉脖子有点僵硬，下意识地左右轻轻晃动了一下，缓解那股熟悉的酸痛。这是他工作十年养成的习惯——每天盯着电脑十小时，颈椎早已不堪重负。</p><p>李明决定接着去玩碰碰车。坐进小车里，他像个真正的十七岁少年一样兴奋地抓紧方向盘。电流接通，车子启动，李明猛踩油门冲向前方。左冲右撞间，他又感到脖子一阵刺痛。他条件反射地做起了办公室保健操第三式：双手托住后脑勺，缓慢向后拉伸。</p><p>一位游乐园的医护人员恰好路过，看到了李明标准的颈椎操动作。她驻足观察了几秒，然后走到碰碰车场地边缘。</p><p>“这套颈椎病保健操做得不错啊，先生。”医护人员在李明经过时大声说道，”是职业医师教的吧？”</p><p>李明一惊，猛地回头，车子失控撞上了场地边缘。</p><p>“什么？不不不，我只是……”李明慌乱地摆手，”我……”他张了张嘴，最终还是像泄了气的气球一样瘫在碰碰车里，放弃了辩解。</p><p>医护人员按下对讲机：”安保部，A 区有一位违规进入的成年人。”</p><p>两名保安赶到，架起李明就往外走。路过旋转木马时，李明忍不住回头看了一眼，那些五颜六色的小马依然在音乐声中旋转，仿佛在向他告别。他的真实身份被确认：”李明，32 岁，工程师，违反《成年人行为准则》第十七条。”</p><p>两个小时后，他被直接送往了”成年人再教育中心”。</p><p>在那里，他被迫学习如何做一个”成熟的大人”：每天工作十小时，严肃阅读财经新闻，周末必须去公园遛狗或者喝咖啡，以塑造”符合社会期待的成年形象”。</p><h1 id="故事之后——AI-的凡尔赛"><a href="#故事之后——AI-的凡尔赛" class="headerlink" title="故事之后——AI 的凡尔赛"></a>故事之后——AI 的凡尔赛</h1><p>最近在学<a href="https://www.bilibili.com/video/BV1eE411F73t">余老师的诗歌创作课</a>，课很有趣，不过信息密度似乎有点低，我就当单口相声听了。这篇文章记录了第五课老师布置的作业，诗歌的意象、结构和情感是我自己构思的，具体内容是借助写作软件润色的，我把几个版本拼拼凑凑得到了下面的作品（什么拼好诗）。</p><p>最近的思绪挺乱的。前两天构思了个摄影专辑创意，感觉大体上还算值得做，暂命名叫《时光师》。这样的话，想做的事情实在是有点多了。想投稿一些文学期刊来接触文坛，顺便提升下文笔水平；想继续研读一些经典著作，了解下文学理论；还想花 100 天完整地做一个能放到豆瓣甚至出版社投稿的诗集，跑一遍流程。</p><p>说来有些凡尔赛，但上学期的文学竞赛成绩意外地好，以至于我真的开始考虑考研中文系或者去杂志社实习之类的事情。这就导致我们真的陷入了一个奇怪的”学术与创作两手抓”的境地，但我的水平却不足以支持我把它们全部抓牢，于是便深感时间紧张。全抓牢真的不可能吗？如果是我的话说不定也能做到呢，但这样的生活是否缺乏了一抹奇幻色彩呢？比起把绝大多数时间都花在自我实现和提升自己的水平上，我还是想抽出时间来阅读新书，看看番剧，去咖啡馆发呆。再说了，现在的社交水平仍然是负的，是不是该去提升一下？原本想着靠办读书会来和人们交流，但这又回到了文学上。虽然这看起来是条可行的路，但感觉有点点奇怪。</p><p>人生短则二十年，长则一百年，我们究竟想做什么，想去往何方，想成为什么样的人？</p><p>前路未定却仍试图看向未来，自会焦虑。不过我喜欢的一个虚拟角色在这种情况下想必会说：”焦虑也是一种不可多得的体验呢”。喜悦和平静自然是大家都喜欢的体验，但焦虑、悲伤这些负面情绪似乎也是奇妙的体验。人类，很神奇吧。</p><p>话说回来，时光师这个名字听起来就很有诗意吧。听说为自己摆个”诗意三行”，记录三个瞬间，便能解一时之困。我回去试试。</p><h1 id="翻命师"><a href="#翻命师" class="headerlink" title="翻命师"></a>翻命师</h1><p>这江湖之上，有一门玄门奇术，叫做”翻命一术”，修习此术之人，世人唤作”翻命师”。</p><p>这翻命师不比寻常江湖术士，既不是掐指一算的算命先生，也不是敲盆问卦的游方道人。他们修的，乃是上古传下来的翻命秘术。但凡有人求问命途，这翻命师便能施展异术，将那人前程化作一张张命运符牌，一一摆在案上。</p><p>这牌阵大小不一，全看机缘深浅。小则一行三牌，称为”过路牌阵”，多解一时之困；中则三行五牌，名唤”三星照命”，为那命途多舛之人寻觅转机；若遇命格复杂之人，或是牵连多人的大事，定要摆下五行七列的”天罗地网阵”，方能窥得命运全貌。</p><p>却说这符牌玄妙非常。翻开一张，或显凶险，或现吉祥。翻命师观之，便知那人命中该有何等机缘。其技高者，还能将那不利的命数重新封回牌中，暂时封住那眼看就要降临的灾祸！</p><p>江湖传闻，翻命师之术，非是逆天改命，乃是巧借天机。如同棋盘残局，看似已无生路，翻命师却能寻那缝隙间微妙一着，引得命运暗流转向。明是命中注定，实则皆由人心一念之差。高明的翻命师，不过是将那本就存在的可能，向明处轻推罢了。</p><p>无论如何在做原型之前都不应该写剧情。不过我做了原型！所以我可以写一点点剧情了吧，虽然这段背景故事也大多是 AI 写的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;故事之前&quot;&gt;&lt;a href=&quot;#故事之前&quot; class=&quot;headerlink&quot; title=&quot;故事之前&quot;&gt;&lt;/a&gt;故事之前&lt;/h1&gt;&lt;p&gt;最近在学&lt;a href=&quot;https://www.bilibili.com/video/BV1eE411F73t&quot;&gt;查理老师</summary>
      
    
    
    
    <category term="杂谈" scheme="http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    <category term="碎碎念" scheme="http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
  </entry>
  
  <entry>
    <title>第六章——存储器层次结构</title>
    <link href="http://rinevard.github.io/wiki/learning/open-course/CMU-15-213/Notes/Chapter6-memory-and-cache/"/>
    <id>http://rinevard.github.io/wiki/learning/open-course/CMU-15-213/Notes/Chapter6-memory-and-cache/</id>
    <published>2025-03-20T03:26:01.000Z</published>
    <updated>2025-03-20T03:32:19.785Z</updated>
    
    <content type="html"><![CDATA[<h1 id="存储器层次结构"><a href="#存储器层次结构" class="headerlink" title="存储器层次结构"></a>存储器层次结构</h1><p>存储器有多种类型，我们可以根据访问速度把他们排成金字塔结构。靠近上面的访问速度快，靠近下面的访问速度慢。每一层都作为下面一层的缓存（cache），即从下面一层读取数据来加快访问速度：</p><p><img src="/images/learning/open-course/CMU-15213/Notes/Chapter6/memory-hierarchy.png"></p><p>下图比较了不同存储器的访问速度</p><p><img src="/images/learning/open-course/CMU-15213/Notes/Chapter6/memory-mountain.png"></p><h1 id="局部性"><a href="#局部性" class="headerlink" title="局部性"></a>局部性</h1><p>局部性分为空间局部性和时间局部性。前者指如果一个内存位置被引用，程序可能在将来引用附近的一个内存位置；后者指如果一个内存位置被引用，程序可能在将来再次引用它。</p><p>为什么我们希望程序有较好的局部性呢？这是因为访问 cache 比访问 cache 下面一层要快，而 cache 的大小有限，因此我们希望尽可能访问 cache 里的数据。而 cache 存储的数据在空间上和时间上都有一定连续性（参考下面的“高速缓存”一节），所以我们希望程序的局部性好。</p><p>如果我们引用了不在 cache 中的数据，这就被称作“缓存不命中”（命中为 “hit”，不命中为“miss”），从而要把 cache 下面一层的数据复制到 cache 中，这是很慢的。</p><p>举个例子，一般来说，数组的局部性比链表好，因为链表的地址往往是碎片化的。</p><p><img src="/images/learning/open-course/CMU-15213/Notes/Chapter6/cache-data-memory.png"></p><h1 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h1><p>高速缓存的结构如图所示：</p><p><img src="/images/learning/open-course/CMU-15213/Notes/Chapter6/cache.png"></p><p>让我们推测一下 line 和 set 是怎么设计出来的。</p><p>我们的核心思路是尽量减少高速缓存和主存间交换数据的次数。如果我们能预知未来，我们只要根据未来<strong>尽可能把高速缓存填满未来会读的值</strong>，然后在需要新值时再读一次就好了。</p><p>显然我们不能预知未来，所以我们希望每次的数据交换都尽可能多带来一些“未来可能用到的数据”。所以我们把高速缓存划分成若干个 line，<strong>每个 line 都存储一组连续的地址的数据</strong>。毕竟如果读到了一个地址，有理由认为它附近的地址在将来会被读到。</p><p><img src="/images/learning/open-course/CMU-15213/Notes/Chapter6/cache-line.png"></p><p>上图给出了 line 的可视化，我们把数据存储在 data 段中，共存储 B 个 bytes.</p><p>但只是读取连续的一段是不够的。在下图中，我们把主存中需要用到的地址标红。这两种情况中，我们认为右边那种情况更可能在运行时发生，所以我们希望实现多个 set. 如果每个 set 只有一个 line，就实现了<strong>直接映射高速缓存</strong>。如果每个 set 有多个 line，就实现了<strong>组相联高速缓存</strong>。</p><p><img src="/images/learning/open-course/CMU-15213/Notes/Chapter6/cache-set.png"></p><h2 id="读"><a href="#读" class="headerlink" title="读"></a>读</h2><p>接下来我们讲讲如何读取数据，我们以组相联高速缓存为例，毕竟直接映射是组相联的特殊情况。</p><p>这里的思路是根据地址找到高速缓冲中对应的 set，然后检查 set 的 line 中是否有当前地址。</p><p><img src="/images/learning/open-course/CMU-15213/Notes/Chapter6/cache-read.png"></p><p>我们把每个地址划分为三个部分，tag 部分、组索引部分、偏移部分。<strong>组索引部分</strong>在中间，耗费 $\log_2 S$ 个位，用于<strong>定位对应的组</strong>；<strong>tag 部分</strong>在最前，占据地址剩下的位置，用于和每个 line 的 tag 作比较从而<strong>确定是否有与地址对应的 line</strong>；<strong>偏移部分</strong>在最后，耗费 $\log_2 B$ 个位，用于在找到对应的 line 以后<strong>找到对应的数据位置</strong>。</p><p>所以，对给定的地址，我们先找到它的组索引部分，从而定位对应的组，然后把组里的所有 line 的 tag 和地址的 tag 比较，找到相同的 tag 以后就算是成功命中，然后根据偏移获取对应的值。</p><p>如果没找到相同的 tag 呢？这就是不命中了，这时就要让主存和 cache 间交换数据，选一个 line（一般是一组间最久没有被使用的那个）把它替换掉。</p><h2 id="写"><a href="#写" class="headerlink" title="写"></a>写</h2><p>写比读复杂很多，书上没详细讲，所以我们只是简要提一下。</p><p>一个比较靠谱的思路是检查要写的地址是否在 cache 中，如果在就直接写 cache，并标记那个位置为“已修改”。如果不在 cache 中，就像读一样，把那个地址拿到 cache 里来，然后覆写。在 cache 的任何一个地址被覆盖掉时，检查那个地址的值是否已修改，如果修改则覆写主存上的值。</p><p>这种做法叫做写回（write-back），尽可能地推迟更新。</p><p>要注意的是，由于写是可以推迟的，所以写一般比读要快。</p><h1 id="性能例子"><a href="#性能例子" class="headerlink" title="性能例子"></a>性能例子</h1><h2 id="Memory-Mountain——数组大小和访问步长影响性能"><a href="#Memory-Mountain——数组大小和访问步长影响性能" class="headerlink" title="Memory Mountain——数组大小和访问步长影响性能"></a>Memory Mountain——数组大小和访问步长影响性能</h2><p><img src="/images/learning/open-course/CMU-15213/Notes/Chapter6/memory-mountain.png"></p><p>这张图是对一个大小为 size 的数组以 stride 为步长求和的性能比较。</p><p>注意到随着 size 增大，我们愈发往存储器层次结构下面走（比如说，L1 不足以装下所有数据了，我们就不得不走到 L2），同时每走一层时间都有一个猛增。</p><p>随着 stride 增大，缓存命中率越来越低，耗时越来越大，直到某个临界点，每次都不命中。</p><h2 id="缓存命中影响性能——以矩阵乘法为例"><a href="#缓存命中影响性能——以矩阵乘法为例" class="headerlink" title="缓存命中影响性能——以矩阵乘法为例"></a>缓存命中影响性能——以矩阵乘法为例</h2><p>假设我们在做矩阵乘法，我们的高速缓存的每个 line 的 block 能装下 $K$ 个值。</p><h3 id="循环顺序对性能的影响"><a href="#循环顺序对性能的影响" class="headerlink" title="循环顺序对性能的影响"></a>循环顺序对性能的影响</h3><p>版本 1 是 ijk 循环，a 是行遍历，b 是列遍历，c 不在最内存循环内所以不计性能损耗。对 a 来说，每经过 K 个值，就有一次不命中；对 b 来说，每次都不命中。我们可以认为有这样的缓存<strong>不命中率</strong>：</p><table><thead><tr><th>a</th><th>b</th><th>c</th></tr></thead><tbody><tr><td>1 &#x2F; K</td><td>1</td><td>0</td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 版本1</span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;n; j++) &#123;</span><br><span class="line">        sum = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (k=<span class="number">0</span>; k&lt;n; k++)</span><br><span class="line">            sum += a[i][k] * b[k][j];</span><br><span class="line">        c[i][j] = sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果把循环顺序改成 ikj，就能得到更好的性能。</p><p>这时 a 不在最内层循环，不计性能损耗，b 是行遍历，c 也是行遍历，我们可以认为有这样的缓存不命中率：</p><table><thead><tr><th>a</th><th>b</th><th>c</th></tr></thead><tbody><tr><td>0</td><td>1 &#x2F; K</td><td>1 &#x2F; K</td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (k=<span class="number">0</span>; k&lt;n; k++) &#123;</span><br><span class="line">        r = a[i][k];</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">            c[i][j] += r * b[k][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下图展示了六种循环顺序带来的不同效率：</p><p><img src="/images/learning/open-course/CMU-15213/Notes/Chapter6/matrix-order.png"></p><p>最好的是 ikj 循环，我们可以简单地算出它的大概的总不命中次数。共有 $n^2$ 个值要算，没算一个值大概会不命中 $\frac{n}{K}</p><ul><li>\frac{n}{K}$<br>次，因此总不命中次数大约为：</li></ul><p>$$<br>n^2 \times (\frac{n}{K} + \frac{n}{K})&#x3D;\frac{2n^3}{K}<br>$$</p><h3 id="blocking-对性能的影响"><a href="#blocking-对性能的影响" class="headerlink" title="blocking 对性能的影响"></a>blocking 对性能的影响</h3><p>其实我们还有更好的优化手段——矩阵分块乘法：</p><p><img src="/images/learning/open-course/CMU-15213/Notes/Chapter6/matrix-blocking.png"></p><p>结果里的每个 block 的计算需要访问 $\frac{2n}{B}$ 个小 blck，每个小 block 大概会不命中 $\frac{B^2<br>}{K}$ 次，因此总不命中次数大约为：</p><p>$$<br>(\frac{n}{B}<br>)^2 \times \frac{B^2}{K}\times \frac{2n}{B}&#x3D;\frac{2n^3}{BK}<br>$$</p><p>当然，我们不能无限地增大 $B$. 对于矩阵乘法 C&#x3D;A×B，我们要同时在缓存中保存 A 的一个块、B 的一个块和 C 的一个块，从而希望有类似 $3B^2 &lt; C$ 的限制（这里的 $C$ 是 cache 的 capacity）。所以尽可能选大的 block，但保证不过大就好。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;存储器层次结构&quot;&gt;&lt;a href=&quot;#存储器层次结构&quot; class=&quot;headerlink&quot; title=&quot;存储器层次结构&quot;&gt;&lt;/a&gt;存储器层次结构&lt;/h1&gt;&lt;p&gt;存储器有多种类型，我们可以根据访问速度把他们排成金字塔结构。靠近上面的访问速度快，靠近下面的访问速度</summary>
      
    
    
    
    <category term="学习" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="公开课" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/"/>
    
    <category term="CMU-15-213" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/"/>
    
    <category term="Notes" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/Notes/"/>
    
    
  </entry>
  
  <entry>
    <title>第五章——性能优化</title>
    <link href="http://rinevard.github.io/wiki/learning/open-course/CMU-15-213/Notes/Chapter5-optimization/"/>
    <id>http://rinevard.github.io/wiki/learning/open-course/CMU-15-213/Notes/Chapter5-optimization/</id>
    <published>2025-03-18T07:30:28.000Z</published>
    <updated>2025-03-18T07:37:40.194Z</updated>
    
    <content type="html"><![CDATA[<p>15213 里没讲第四章，我看了下感觉太硬件了于是就跳过了。我们从第五章继续——</p><p>一些常见的优化手段我们就不详细说了，简单提一下有这些：</p><ul><li>用代码剖析程序找到性能瓶颈</li><li>选好的算法</li><li>外提循环不变式</li><li>减少不必要的内存读写</li></ul><p>循环展开技巧性太强，牺牲了可读性，而且说实话性能也没好太多，所以也不详谈。而且大多数编译器在把优化等级设得比较高时会自动做循环展开。</p><p>我们主要聊聊——编译器的局限；用 CPE 表示程序性能；指令级并行。</p><h1 id="编译器的局限性"><a href="#编译器的局限性" class="headerlink" title="编译器的局限性"></a>编译器的局限性</h1><p>编译器对程序只使用安全的优化，因此有些我们脑补编译器会优化的东西实际上不会被优化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add1</span><span class="params">(<span class="type">long</span> *x1, <span class="type">long</span> *x2)</span> </span>&#123;</span><br><span class="line">*x1 += *x2;</span><br><span class="line">*x1 += *x2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add2</span><span class="params">(<span class="type">long</span> *x1, <span class="type">long</span> *x2)</span> </span>&#123;</span><br><span class="line">*x1 += *x2 * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>乍一看这两个函数功能相同，且下面那种读写内存次数更少，或许我们会期望编译器把上面的版本优化成下面的版本。</p><p>可其实两者功能并不完全相同。考虑两个指针指向同一个对象的情况。</p><p>因此，要很仔细才能写出编译器能顺利优化的代码。</p><h1 id="用-CPE-表示程序性能"><a href="#用-CPE-表示程序性能" class="headerlink" title="用 CPE 表示程序性能"></a>用 CPE 表示程序性能</h1><p>CPE 即 Cycles Per Element，计算方法如下：</p><p>CPE &#x3D; Total Cycles &#x2F; Number of Elements，即总周期数 &#x2F; 元素数量。</p><p>实际的 CPE 值很难仅通过代码分析准确预测，需要在特定硬件、编译器配置下通过实际测试获得准确值。一般来说，我们通过性能分析工具来得到总周期数，然后根据任务得出其元素数量，从而算出 CPE。</p><h1 id="指令级并行"><a href="#指令级并行" class="headerlink" title="指令级并行"></a>指令级并行</h1><p>现代处理器并不是顺序执行指令的，顺序执行只是一种抽象。指令执行的顺序不一定要与它们在机器级程序中的顺序一致。这让我们实现了<strong>指令级并行</strong>。</p><p>这里的内容太多太硬核了，我也没理解，就只讲讲指令级并行的大体概念和流水线吧。</p><p>大体来说，处理器会分析程序里每条指令的依赖关系，从而并行执行没有依赖关系的指令。</p><p>例子：</p><p>假设我们有指令序列:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. mov eax, [mem1]    # 从内存加载数据到eax</span><br><span class="line">2. add ebx, ecx       # 将ebx和ecx相加，结果存入ebx</span><br><span class="line">3. mul eax, 4         # 将eax乘以4</span><br><span class="line">4. add edx, ebx       # 将ebx和edx相加，结果存入edx</span><br><span class="line">5. mov [mem2], eax    # 将eax存入内存</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>依赖关系图:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">     指令1           指令2</span><br><span class="line"> (mov eax, [mem1])  (add ebx, ecx)</span><br><span class="line">       |                 |</span><br><span class="line">       v                 v</span><br><span class="line">    指令3              指令4</span><br><span class="line"> (mul eax, 4)       (add edx, ebx)</span><br><span class="line">       |</span><br><span class="line">       v</span><br><span class="line">     指令5</span><br><span class="line">(mov [mem2], eax)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这时我们可能就会并行执行指令 1 和指令 2.</p><h2 id="流水线-Pipeline"><a href="#流水线-Pipeline" class="headerlink" title="流水线(Pipeline)"></a>流水线(Pipeline)</h2><p>流水线将单条指令的执行阶段（取指、解码、执行、访存、写回）拆分成多个步骤，每个步骤由不同的硬件单元处理，从而可以同时处理多条处于不同步骤的指令。例如，一个典型的浮点加法器包含三个阶段：一个阶段处理指数值，一个阶段将小数相加，另一个阶段对结果进行舍人。这种技术<strong>增加了吞吐量（Throughput）</strong>，但单个指令的执行延迟并不会减少。</p><p><img src="/images/learning/open-course/CMU-15213/Notes/Chapter5/pipeline.png"></p><h2 id="数据流图"><a href="#数据流图" class="headerlink" title="数据流图"></a>数据流图</h2><p>我们可以通过程序的数据流图来粗糙地分析程序的指令级并行程度。这里举一个例子应该就足够了。假设我们想算 $\sum_{k&#x3D;0}^{n}a_kx^k$，下面有两种算法：</p><p>在 poly 中，我们共做了 n 次加法，2n 次乘法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">poly</span><span class="params">(<span class="type">double</span> a[], <span class="type">double</span> x, <span class="type">long</span> degree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">double</span> result = a[<span class="number">0</span>];</span><br><span class="line">    <span class="type">double</span> xpwr = x;  <span class="comment">/* Equals x^i at start of loop */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= degree; i++) &#123;</span><br><span class="line">        result += a[i] * xpwr;</span><br><span class="line">        xpwr = x * xpwr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 polyh 中，我们共做了 n 次加法，n 次乘法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Apply Horner&#x27;s method */</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">polyh</span><span class="params">(<span class="type">double</span> a[], <span class="type">double</span> x, <span class="type">long</span> degree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">double</span> result = a[degree];</span><br><span class="line">    <span class="keyword">for</span> (i = degree<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        result = a[i] + x*result;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而实际上 poly 速度更快，为什么呢？因为 poly 有更好的指令级并行度。</p><p><img src="/images/learning/open-course/CMU-15213/Notes/Chapter5/dataflow.png"></p><p>poly 的关键路径是 mul，polyh 的关键路径则是 mul → add.</p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>之前做 leetcode 还遇到了一则趣事（3356. Zero Array TransformationⅡ）</p><p>那题的解法里需要构造这样的函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">iskZeroArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;queries, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ops</span><span class="params">(nums.size() + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="type">int</span> l = queries[i][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> r = queries[i][<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> val = queries[i][<span class="number">2</span>];</span><br><span class="line">        ops[l] += val;</span><br><span class="line">        ops[r + <span class="number">1</span>] -= val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> op = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        op += ops[i];</span><br><span class="line">        <span class="keyword">if</span> (op &lt; nums[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 iskZeroArray 的第一个 for 循环中, 我写的原本是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; query = queries[i];</span><br><span class="line"><span class="type">int</span> l = query[<span class="number">0</span>];</span><br><span class="line"><span class="type">int</span> r = query[<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> val = query[<span class="number">2</span>];</span><br></pre></td></tr></table></figure><p>但是这样的程序耗时 1000 ms. 换成</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> l = queries[i][<span class="number">0</span>];</span><br><span class="line"><span class="type">int</span> r = queries[i][<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> val = queries[i][<span class="number">2</span>];</span><br></pre></td></tr></table></figure><p>后，50ms. 两者甚至都是 O(N)的，前者之所以如此慢应该是因为不断分配内存给 query 吧.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;15213 里没讲第四章，我看了下感觉太硬件了于是就跳过了。我们从第五章继续——&lt;/p&gt;
&lt;p&gt;一些常见的优化手段我们就不详细说了，简单提一下有这些：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用代码剖析程序找到性能瓶颈&lt;/li&gt;
&lt;li&gt;选好的算法&lt;/li&gt;
&lt;li&gt;外提循环不变式&lt;/l</summary>
      
    
    
    
    <category term="学习" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="公开课" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/"/>
    
    <category term="CMU-15-213" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/"/>
    
    <category term="Notes" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/Notes/"/>
    
    
  </entry>
  
  <entry>
    <title>第三章——程序的机器级别表示</title>
    <link href="http://rinevard.github.io/wiki/learning/open-course/CMU-15-213/Notes/Chapter3-machine-level-program/"/>
    <id>http://rinevard.github.io/wiki/learning/open-course/CMU-15-213/Notes/Chapter3-machine-level-program/</id>
    <published>2025-03-14T08:41:28.000Z</published>
    <updated>2025-03-14T08:47:55.347Z</updated>
    
    <content type="html"><![CDATA[<style>img{    width: 75%;}</style><p><img src="/images/learning/open-course/CMU-15213/Notes/Chapter3/st.png"></p><h1 id="汇编简介"><a href="#汇编简介" class="headerlink" title="汇编简介"></a>汇编简介</h1><p>CSAPP 教的是 x86-64 汇编语言，使用的是 AT&amp;T 语法风格。</p><p>下图概述了程序的工作方式，即从内存中读取指令，CPU 根据指令在寄存器上执行操作来修改内存里的数据：</p><p><img src="/images/learning/open-course/CMU-15213/Notes/Chapter3/cpu-memory.png"></p><p>下图描述了借助 gcc 进行编译的过程，其中 .s 就是汇编文件：</p><p><img src="/images/learning/open-course/CMU-15213/Notes/Chapter3/compile.png"></p><p>一些汇编指令示例：</p><p><code>movq 7(%rdx, %rsi, 2), %rax</code> 表示把 2 * %rsi + %rdx + 7 指向的地址的值复制到 %rax 中</p><p><code>leaq 7(%rdx, %rsi, 2), %rax</code> 表示把 2 * %rsi + %rdx + 7 复制到 %rax 中，leaq 常被编译器用来做一些聪明的快速计算，不过 leaq 的第三个项只能是 1, 2, 4, 8.</p><p><code>salq $n, %rax</code> 表示把 %rax 中的值左移 n 位 (sal 是 shift arithmetic left 的缩写)</p><p><code>imulq %rdx, %rax</code> 表示把 %rdx 中的值与 %rax 中的值相乘，结果存入 %rax (有符号整数乘法)</p><p>操作很多，我们不再列举更多，随便找个书查一查就好。</p><p>我们可以注意到这些操作都以 ‘q’ 结尾，那如果我不喜欢 ‘q’，我可以用 ‘r’ 结尾吗？不行，因为这里的 ‘q’ 实际上是在指定操作的大小。还记得寄存器长什么样吗：</p><p><img src="/images/learning/open-course/CMU-15213/Notes/Chapter3/register-rax.png"></p><table><thead><tr><th>后缀</th><th>全称</th><th>大小(字节)</th><th>位数</th><th>指令示例</th><th>描述</th></tr></thead><tbody><tr><td><code>b</code></td><td>byte</td><td>1</td><td>8 位</td><td><code>movb</code></td><td>移动单字节(8 位)数据</td></tr><tr><td><code>w</code></td><td>word</td><td>2</td><td>16 位</td><td><code>movw</code></td><td>移动字(16 位)数据</td></tr><tr><td><code>l</code></td><td>long</td><td>4</td><td>32 位</td><td><code>movl</code></td><td>移动双字(32 位)数据</td></tr><tr><td><code>q</code></td><td>quadword</td><td>8</td><td>64 位</td><td><code>movq</code></td><td>移动四字(64 位)数据</td></tr></tbody></table><p>我们也有 pushq 和 popq 之类的和栈相关的操作。栈是什么？请看下集——函数和栈。（在“控制”这一节后面）</p><h1 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h1><p>我已经会加减乘除了，那你能教教我怎么写条件（if）和循环（for, while）吗？</p><p>乐意效劳。😎</p><h2 id="if，while，do-while"><a href="#if，while，do-while" class="headerlink" title="if，while，do-while"></a>if，while，do-while</h2><p>无论是条件还是循环，我们都在做两件事——判断条件是否满足和根据条件跳到某个地方执行语句。</p><p>让我们先来看看汇编里的一个典型的 do-while 循环：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">long fact_do(long n)</span><br><span class="line">n in %rdi</span><br><span class="line">1 fact_do:</span><br><span class="line">2   movl $1, %eax     Set result = 1</span><br><span class="line">3 .L2: loop:</span><br><span class="line">4   imulq %rdi, %rax  Compute result *= n</span><br><span class="line">5   subq $1, %rdi     Decrement n</span><br><span class="line">6   cmpq $1, %rdi     Compare n:1</span><br><span class="line">7   jg .L2            If &gt;, goto loop</span><br><span class="line">8   rep ; ret         Return</span><br></pre></td></tr></table></figure><p>在这里，我们通过“cmpq”和“jg”来判断条件是否满足，通过“jg”来跳转以执行循环。那么，cmpq 实际上是在做什么呢？</p><p>在汇编中，我们有几个特殊的标志寄存器 CF、ZF、SF、OF 来记录最近的操作是否产生了 unsigned 的溢出、产生 0、产生负数、产生了补码溢出。cmp 和 test 两个指令假装执行减法和按位与并修改这些标志寄存器。</p><p>在上面的代码中，cmpq $1, %rdi 就是在假装做 %rdi - 1，并根据计算结果修改标志寄存器。而 jg 则根据标志寄存器的值来进行跳转。jg 的效果是，如果 ~(SF ^ OF) &amp; ~ZF 为真，就进行跳转。</p><p>jg 的跳转条件看起来很复杂，但它和 cmpq x, y 联动的效果是——如果 y &gt; x，跳转，因此它叫做 jg.</p><p>下表是 CMP 和 TEST 的概述：</p><table><thead><tr><th>Instruction</th><th>Based on</th><th>Description</th></tr></thead><tbody><tr><td>CMP S₁, S₂</td><td>S₂ - S₁</td><td>Compare</td></tr><tr><td>TEST S₁, S₂</td><td>S₁ &amp; S₂</td><td>Test</td></tr></tbody></table><p>这里是一些跳转语句示例：</p><table><thead><tr><th>Instruction</th><th>Synonym</th><th>Jump condition</th><th>Description</th></tr></thead><tbody><tr><td>jmp Label</td><td></td><td>1</td><td>Direct jump<br>例：jmp 0x400123<br>直接跳转到具体地址</td></tr><tr><td>jmp *Operand</td><td></td><td>1</td><td>Indirect jump<br>例：jmp *%rax<br>跳转目标在运行时才能确定</td></tr><tr><td>je Label</td><td>jz</td><td>ZF</td><td>Equal &#x2F; zero</td></tr><tr><td>js Label</td><td></td><td>SF</td><td>Negative</td></tr><tr><td>jg Label</td><td>jnle</td><td>~(SF ^ OF) &amp; ~ZF</td><td>Greater (signed &gt;)</td></tr><tr><td>jge Label</td><td>jnl</td><td>~(SF ^ OF)</td><td>Greater or equal (signed &gt;&#x3D;)</td></tr></tbody></table><h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p>要注意的是，switch 和 if 的汇编有本质区别。switch 基于跳转表（类似哈希表），它先把 case 同时增减一个值来让最小的 case 变为 0，然后建立跳转表，并根据 case 的值来计算合适的跳转地址。</p><p>以这个 C 代码为例，它可能被编译成下面的汇编代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(n) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> <span class="string">&quot;one&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>: <span class="keyword">return</span> <span class="string">&quot;three&quot;</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">return</span> <span class="string">&quot;other&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cmpl    $2, %eax                        # 检查是否超出范围(&gt;2), 这里%eax = x-1,</span><br><span class="line">                                        # 因为最小case是1</span><br><span class="line">        ja      .L_default              # 如果超出范围则跳转到default</span><br><span class="line">        jmp     *.L_table(,%rax,4)      # 使用跳转表: base + index*4</span><br><span class="line"></span><br><span class="line">.section .rodata</span><br><span class="line">.align 4</span><br><span class="line">.L_table:</span><br><span class="line">        .long   .L_case1                # case 1, %eax = 0</span><br><span class="line">        .long   .L_default              # case 2, %eax = 1</span><br><span class="line">        .long   .L_case2                # case 3, %eax = 2</span><br></pre></td></tr></table></figure><h1 id="函数和栈"><a href="#函数和栈" class="headerlink" title="函数和栈"></a>函数和栈</h1><p>啊哈哈，我们又要讨论寄存器了。还记得 %rsp 吗？它就是存储栈指针的寄存器。下图左边是栈的结构，右边是寄存器：</p><p><img src="/images/learning/open-course/CMU-15213/Notes/Chapter3/st.png"></p><p>那么，栈和函数有什么关系呢？</p><h2 id="借助栈来控制转移"><a href="#借助栈来控制转移" class="headerlink" title="借助栈来控制转移"></a>借助栈来控制转移</h2><p>栈的第一个作用是“passing control“，即控制转移。</p><p>调用函数（callq）本质上就是让程序计数器跳转（jmp）到了函数所在的汇编地址，并把调用完成后应该执行的指令地址压入栈中（pushq）。而函数返回（retq）本质上就是把调用完成后应该执行的指令地址 pop 出来（popq），并跳转回去（jmp）。</p><h2 id="借助栈来存储数据"><a href="#借助栈来存储数据" class="headerlink" title="借助栈来存储数据"></a>借助栈来存储数据</h2><p>栈的另一个作用是存储数据。</p><p>在函数被调用时，栈指针会移动并为这个函数分配一些栈空间用于存储寄存器的值、存储本地变量、传入的参数之类的东西。我们一个一个解释。</p><p>寄存器：在上图的右边可以看到有 caller saved 和 callee saved 的寄存器，标注 caller saved 的寄存器由调用者负责保存，标注 callee saved 的寄存器由被调用者负责保存。比如说，在被调用的函数返回时，被调用者要确保 callee saved 的寄存器和调用前没有区别。</p><p>本地变量：有时候寄存器不足以保存所有本地变量，就要放到栈中。</p><p>传入的参数：参数确实可以存在寄存器中，但有时候寄存器不够存，也就只能放到栈中了。我们可以用类似 movl -4(%rsp), %edx 的指令来获取传入的参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">高地址</span><br><span class="line">            |  参数7                |</span><br><span class="line">            |  参数8                |</span><br><span class="line">            |  ...                 |  ← 调用前push</span><br><span class="line">            |  返回地址             |  ← call指令自动push</span><br><span class="line">            |  保存的寄存器值        |  ← 刚进入函数时push</span><br><span class="line">            |  本地变量1            |</span><br><span class="line">            |  本地变量2            |</span><br><span class="line">            |  ...                 |   ← 当前rsp指向这里</span><br><span class="line">低地址</span><br></pre></td></tr></table></figure><p>对了，根据上面的描述，递归就成了自然涌现出的结果，真神奇！</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>我们来聊聊 array、struct、union 都是怎么表示在内存中的。</p><h2 id="array-和寻址"><a href="#array-和寻址" class="headerlink" title="array 和寻址"></a>array 和寻址</h2><p>先说 Array，二维 array 如下图：</p><p><img src="/images/learning/open-course/CMU-15213/Notes/Chapter3/array.png"></p><p>简单易懂。假设我们有 T A[R][C]，那么&amp;D[i][j] &#x3D; x0 + L(C * i + j). 其中 x0 为数组的起始地址，L 是 sizeof(T). 编译器在寻址时也就是这么做的。不过编译器会做一些聪明的优化来避免乘法，比如用 leaq 来加快计算：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># A in %rdi, i in %rsi, and j in %rdx</span><br><span class="line"></span><br><span class="line">1 leaq (%rsi,%rsi,2), %rax       # Compute 3i</span><br><span class="line">2 leaq (%rdi,%rax,4), %rax       # Compute xA + 12i</span><br><span class="line">3 movl (%rax,%rdx,4), %eax       # Read from M[xA + 12i + 4]</span><br></pre></td></tr></table></figure><h2 id="struct-和对齐"><a href="#struct-和对齐" class="headerlink" title="struct 和对齐"></a>struct 和对齐</h2><p>再来聊聊 struct，看看这张图就差不多了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct rec &#123;</span><br><span class="line">    int i;</span><br><span class="line">    int a[2];</span><br><span class="line">    int *p;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/images/learning/open-course/CMU-15213/Notes/Chapter3/struct.png"></p><p>上图中，12 到 16 的“填充”是出于数据对齐的需要，对齐原则是——任何 K 字节的基本对象的地址必须是 K 的倍数。</p><table><thead><tr><th>K</th><th>type</th></tr></thead><tbody><tr><td>1</td><td>char</td></tr><tr><td>2</td><td>short</td></tr><tr><td>4</td><td>int, float</td></tr><tr><td>8</td><td>long, double, char *</td></tr></tbody></table><h2 id="union"><a href="#union" class="headerlink" title="union"></a>union</h2><p>union 允许我们用不同方式解释同一段位表示，常用于节省内存。</p><p><img src="/images/learning/open-course/CMU-15213/Notes/Chapter3/union.png"></p><p>最常见的应用是，union 中的东西互斥，比如实现比较基础的动态类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DynamicValue</span> &#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Type</span> &#123; INT, DOUBLE, STRING &#125; type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span> <span class="title class_">Data</span> &#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line">        <span class="type">char</span>* s;</span><br><span class="line">    &#125; data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="变长栈帧和-rbp"><a href="#变长栈帧和-rbp" class="headerlink" title="变长栈帧和%rbp"></a>变长栈帧和%rbp</h2><p>有时我们会用到长度不定的数组，比如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">coolArr</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="type">int</span> A[n];</span><br><span class="line"><span class="comment">// 做一些cool things</span></span><br><span class="line"><span class="keyword">return</span> A[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时我们在调用函数前是无法确定要为函数分配多少栈空间的，编译出来的函数会形如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">collArr:</span><br><span class="line">pushq %rbp</span><br><span class="line">movq  %rsp, %rbp</span><br><span class="line">...            # 做一些cool things</span><br><span class="line">leave          # 等价于  movq %rbp, %rsp; popq %rbp</span><br><span class="line">retq</span><br></pre></td></tr></table></figure><p>编译器会用 %rbp 作为基指针（base pointer）来记录进入函数前的栈指针位置，并在返回时复位 %rsp 和 %rbp 的状态。</p><h1 id="攻击与防御"><a href="#攻击与防御" class="headerlink" title="攻击与防御"></a>攻击与防御</h1><h2 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h2><p>最常见的攻击是缓冲区溢出攻击，CSAPP 里讲了栈溢出攻击，具体可以看看 attacklab. 这可以分为植入恶意代码和 ROP 攻击。</p><h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><p>对栈溢出的防御手段主要有栈破坏检测、栈随机化、限制可执行代码区域。</p><p>最有效的手段是栈破坏检测，只要你破坏不了栈，自然就没办法攻击了。常用的手段是金丝雀值，即在调用允许用户修改栈的函数时，在栈里放一个随机值，然后在函数返回时判断这个值是否被改变。</p><p>栈随机化是指每次运行代码时，栈的地址都不一样。</p><p>限制可执行代码区域可以防御植入恶意代码到栈里，只要不允许执行栈里的代码就行了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;style&gt;
img{
    width: 75%;
}
&lt;/style&gt;

&lt;p&gt;&lt;img src=&quot;/images/learning/open-course/CMU-15213/Notes/Chapter3/st.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;汇编简介&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="学习" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="公开课" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/"/>
    
    <category term="CMU-15-213" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/"/>
    
    <category term="Notes" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/Notes/"/>
    
    
  </entry>
  
  <entry>
    <title>Attackblab记录</title>
    <link href="http://rinevard.github.io/wiki/learning/open-course/CMU-15-213/Labs/Attacklab/"/>
    <id>http://rinevard.github.io/wiki/learning/open-course/CMU-15-213/Labs/Attacklab/</id>
    <published>2025-03-13T03:18:38.000Z</published>
    <updated>2025-03-13T03:24:56.863Z</updated>
    
    <content type="html"><![CDATA[<style>img{    width: 40%;}</style><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>非常有趣的 lab！做了一大半以后感觉自己已经是 super 嗨客了。我不打算做最后一个，毕竟读汇编来做 ROP 攻击挺麻烦的，我感觉这对我的水平提升也不大（而且拿到 95&#x2F;100 我已经很满足了）</p><p>“Why good people can only do good things and bad people can only do bad things? We bad people can do <strong>whatever we want</strong>.——Evil Neuro”</p><h1 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h1><p>attacklab 的攻击主要分为植入攻击代码和 ROP 攻击。</p><h2 id="植入攻击代码"><a href="#植入攻击代码" class="headerlink" title="植入攻击代码"></a>植入攻击代码</h2><h3 id="攻击-1"><a href="#攻击-1" class="headerlink" title="攻击 1"></a>攻击 1</h3><p>攻击 1 只是简单地让我们熟悉一下工作流程，我们只要覆写掉返回地址就好了。</p><p>大致的攻击流程是——跑一下 ctarget 看看我们写入的内容会被放在栈的哪个位置，熟悉位置以后把十六进制的攻击内容写到某个 txt 文件里，再用 hex2raw 转换为输入值，最后把输入值传到 ctarget 就实现了攻击。</p><p>下面给一些小 hints。</p><p>用 <code>./hex2raw &lt; rinevinput.txt &gt; evil</code> 来把内容从十六进制转换为输入值, 并把输入值写入 evil（我把攻击文件叫做 evil）</p><p>注意, 不要把内容写入形如 <code>evil.txt</code> 这样的<strong>有格式的文件</strong>里! 这可能修改一些特殊字符。我之前就踩了这个坑。</p><p>使用 <code>./ctarget -q &lt; evil</code> 来运行，因为我们不能连接到 CMU 服务器（唉，CMU）.</p><p><img src="/images/learning/open-course/CMU-15213/Labs/Attacklab/evil.jpg"></p><h3 id="攻击-2"><a href="#攻击-2" class="headerlink" title="攻击 2"></a>攻击 2</h3><p>攻击 2 就是典型的“植入攻击代码”了。一开始我的思路如下图：</p><p><img src="/images/learning/open-course/CMU-15213/Labs/Attacklab/attack2.png"></p><p>这确实能跑，也确实顺利执行了 touch2，但执行完之后发生了<strong>segmentation fault</strong>！这是为什么？<strong>我至今没有搞清楚</strong>，如果有朋友知道可以跟我说一下。但我可以排除一些疑点。</p><p>首先，segmentation fault 不是因为栈指针跑到了预期位置之外。因为在 phase-2-level2 中，我们的栈指针跑得老远了。</p><p>segmentation fault 的发生<strong>大概率是因为栈指针没有对齐</strong>。给能通过的 phase2-level2 再加一句 ret，就造成了 segmentation fault。再在造成了 segmentation fault 的基础上多 ret 一次就又没有 segmentation fault 了。</p><p>所以我觉得大概率是栈指针的对齐问题。那栈指针，你究竟该在哪里呢？</p><p>回到攻击 2，既然我们猜测是栈指针对齐问题，只要让它对齐就行了。我们微调一下，通过 push 让栈指针的位置偏移 8，然后就通过了。</p><p><img src="/images/learning/open-course/CMU-15213/Labs/Attacklab/attack2_2.png"></p><h3 id="攻击-3"><a href="#攻击-3" class="headerlink" title="攻击 3"></a>攻击 3</h3><p>攻击 3 和攻击 2 差不多，唯一要注意的是 hexmatch 和 strncmp 会覆写栈，所以我们要把字符串藏在更下面的位置（即栈地址比较大的位置）。造成了 segmentation fault 怎么办？我们已经有了攻击 2 的经验，所以借助 pop，push，ret 来微调一下栈指针位置就行。</p><p>作业 PDF 里还提到，”Make position of check string unpredictable”。这有什么意义？我猜是为了防止我们把 sval 指向 cbuf 来实现攻击，这或许不符合 attacklab 的世界观，因为连字符串都不用注入了。</p><p><img src="/images/learning/open-course/CMU-15213/Labs/Attacklab/attack3.png"></p><h2 id="ROP-攻击"><a href="#ROP-攻击" class="headerlink" title="ROP 攻击"></a>ROP 攻击</h2><h3 id="攻击-4"><a href="#攻击-4" class="headerlink" title="攻击 4"></a>攻击 4</h3><p>我是笨蛋，又踩了一个坑。考虑指令<br>4017fc: 3b 3d e2 3c 20 00 cmp 0x203ce2(%rip),%edi # 6054e4 <cookie><br>401802: 75 20 jne 401824 &lt;touch2+0x38&gt;<br>在执行 cmp 指令时：RIP 的值是 0x401802，而不是 0x4017fc。我之前还想了半天为什么我们能指向 cookie。</p><p>回到题目上来，根据提示，我们要用 mov，pop，ret，那么思路是写入 cookie 到栈中，pop 它到某个地方（addval_219 有 pop %rax），最后移动到 rdi 中（addval_273 有 movl %eax %edi）</p><p><img src="/images/learning/open-course/CMU-15213/Labs/Attacklab/attack4.png"></p><p>我们在攻击 2 里已经讨论过 segmentation fault 的发生原因，最合理的猜测是栈指针的对齐问题。所以如果发生了 segmentation fault，找个 ret 再用一下就行了。</p><h3 id="攻击-5"><a href="#攻击-5" class="headerlink" title="攻击 5"></a>攻击 5</h3><p>没做，we bad people can do whatever we want！</p><p><img src="/images/learning/open-course/CMU-15213/Labs/Attacklab/neuro.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;style&gt;
img{
    width: 40%;
}
&lt;/style&gt;

&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;非常有趣的 lab！做了一大半以后感觉自己</summary>
      
    
    
    
    <category term="学习" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="公开课" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/"/>
    
    <category term="CMU-15-213" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/"/>
    
    <category term="Labs" scheme="http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/Labs/"/>
    
    
  </entry>
  
  <entry>
    <title>技巧的分类，冰山之下的深度</title>
    <link href="http://rinevard.github.io/wiki/game-design/%E5%86%B0%E5%B1%B1%E4%B9%8B%E4%B8%8B%E7%9A%84%E6%B7%B1%E5%BA%A6/"/>
    <id>http://rinevard.github.io/wiki/game-design/%E5%86%B0%E5%B1%B1%E4%B9%8B%E4%B8%8B%E7%9A%84%E6%B7%B1%E5%BA%A6/</id>
    <published>2025-03-08T04:22:38.000Z</published>
    <updated>2025-03-13T03:25:48.212Z</updated>
    
    <content type="html"><![CDATA[<style>img{    width: 70%;}</style><p><img src="/images/game-design/%E5%86%B0%E5%B1%B1%E4%B9%8B%E4%B8%8B%E7%9A%84%E6%B7%B1%E5%BA%A6/the-iceberg-theory.png"></p><p>《体验引擎》里提到，“深度游戏能够通过高水平的技巧创造有意义的玩法。深度（depth）这个概念用于描述游戏中需要学习的内容有多少。”在这里，我们将探讨一下如何对技巧的类型进行区分，以及如何创造这些技巧来提高游戏深度，同时不让游戏门槛过高。</p><p>既然要求有深度，那游戏里必然有很多技巧。我们有必要对技巧做一个区分——技巧可以被分为“<strong>规则涌现的技巧</strong>”和“<strong>预设的技巧</strong>”。围棋的各种技巧就是前者的一个很好的例子（uh actually☝️🤓 数学是更好的例子），而“炸弹能炸开有裂缝的墙”就是后者的一个例子。</p><h1 id="基于规则的技巧"><a href="#基于规则的技巧" class="headerlink" title="基于规则的技巧"></a>基于规则的技巧</h1><p>创造“基于规则的技巧”是相对困难的，因为这要求我们创造能涌现出许多技巧的规则。这种纯粹的创造性活动恐怕没有什么经验可以写，我能说的也只是<strong>多去学学不同领域的知识</strong>。如果要做出有灵性的规则，当然不能只是玩各个游戏并尝试“学习经验”（你学的都是别人做过的规则！），而是要更多去看看自己从未见过的领域。比如说，比起盯着《baba is you》学，不如去学学编程。编程的“赋值”被 baba 做掉了，但编程的“语句执行顺序”是不是就可以做成 noita 的魔杖？编程的“抽象”思想会不会也可以做成另一个有趣的规则？</p><p>虽然说“这种创造性活动恐怕没什么经验可写”，但还是写了一堆东西。我确实对基于规则的技巧更感兴趣，这完美实现了“冰山之下的深度”（我在这里点题了！）。不过接下来我们还是聊聊没有灵感时也能做的东西吧。</p><h1 id="预设的技巧"><a href="#预设的技巧" class="headerlink" title="预设的技巧"></a>预设的技巧</h1><p>比起创造基于规则的技巧，创造预设的技巧则简单很多。我们可以随便口胡一些预设的技巧，比如“土狼跳”、“攻击过程中按冲刺能取消攻击”、“在开启技能的前摇时移动来消除前摇而直接开启技能”（唉，取消），实际上为了保证手感，几乎所有游戏都用了大量的预设的技巧。对预设的技巧来说，实际难点在于如何把深度藏在冰山之下，不让玩家因直面大量技巧而感到无所适从。</p><p>把深度藏在冰山之下听着很高大上，实际上最好用的藏深度的做法就是<strong>把预设的技巧逐渐呈现给玩家</strong>。每过几关给玩家一个新能力就是这种做法。更巧妙的做法是<strong>把多个预设的技巧融入到同一个操作之中</strong>，用恰当的关卡设计让技巧逐渐呈现出来。典型的例子是《闰跃之年》，开局跳一下就死了，那怎样跳才能活下来呢？这就是被藏在冰山下的预设的技巧了。</p><p>有的游戏还会<strong>把预设的技巧伪装成规则涌现的技巧</strong>，这让技巧显得更优雅，但实际上不是很本质的改进。围绕一个摸棱两可的主题设计一些预设的技巧，就能做到这一点。我能想到的最好的例子就是《蔚蓝》。蔚蓝把蹭墙跳、凌波微步这些预设的技巧藏在了“惯性”的后面，让各个技巧看起来都是涌现的。虽然这些技巧看起来都和惯性有联系，但实际上玩家并不能根据规则本身推理出这些技巧的存在，因此这是”把预设的技巧伪装成规则涌现的技巧“。</p><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>基于规则的技巧和预设的技巧并非截然对立。大多数情况下，我们都逐渐学到所有的预设的技巧，再把预设的技巧作为规则组合起来形成基于规则的技巧。</p><p>还要注意的是，这种技巧的区分是在呈现给玩家的层面上，而非在实现层面上。如果你硬编码出 noita 的所有可能的法术搭配并写出对应效果，这在实现层面上显然是“预设”的，但对玩家来说，这仍然是“基于规则”的，毕竟玩家可以基于规则推理出可能的技巧。相较而言，如果我们设计一个和法术相关的游戏，每个法术在代码层面上都是几个小法术的组合，但玩家看到的只是组合好的各个法术而不能自己去组合法术，这在实现层面上是“基于规则”的，但对玩家来说是“预设”的。</p><p>多说一句，“在实现层面上基于规则，但呈现出来的效果是预设的”实际上是很适合做成探索类游戏的。核心思路是，首先把大量的预设的现象呈现给玩家，再让玩家逐步探索现象背后的规则。这种思路在别的游戏里也有，不过全是解谜游戏，我们完全可以做一个更有趣的探索类游戏。比如说玩家看到了火球术，之后我们逐渐引导玩家发现火球术本质上是火焰魔法+移动魔法，玩家就能进而基于规则构建出新魔法了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;style&gt;
img{
    width: 70%;
}
&lt;/style&gt;

&lt;p&gt;&lt;img src=&quot;/images/game-design/%E5%86%B0%E5%B1%B1%E4%B9%8B%E4%B8%8B%E7%9A%84%E6%B7%B1%E5%BA%A6/th</summary>
      
    
    
    
    <category term="游戏设计" scheme="http://rinevard.github.io/categories/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="技巧" scheme="http://rinevard.github.io/categories/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E6%8A%80%E5%B7%A7/"/>
    
    
  </entry>
  
</feed>
