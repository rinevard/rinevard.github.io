<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Rinevard</title>
  
  
  <link href="http://rinevard.github.io/atom.xml" rel="self"/>
  
  <link href="http://rinevard.github.io/"/>
  <updated>2025-10-28T08:29:01.912Z</updated>
  <id>http://rinevard.github.io/</id>
  
  <author>
    <name>Rinevard</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Lab 3 Page Tables</title>
    <link href="http://rinevard.github.io/wiki/learning/open-course/MIT-6.S081/Labs/lab3-pagetable/"/>
    <id>http://rinevard.github.io/wiki/learning/open-course/MIT-6.S081/Labs/lab3-pagetable/</id>
    <published>2025-10-28T08:28:22.000Z</published>
    <updated>2025-10-28T08:29:01.912Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Inspect-a-user-process-page-table"><a href="#Inspect-a-user-process-page-table" class="headerlink" title="Inspect a user-process page table"></a><strong>Inspect a user-process page table</strong></h1><p>这道题让我们解释一下 <code>print_pgtbl</code> 的打印结果，首先让我们来看看它打印了什么：</p><pre class="line-numbers language-none"><code class="language-none">print_pgtbl startingva 0x0 pte 0x21FCD85B pa 0x87F36000 perm 0x5Bva 0x1000 pte 0x21FD141B pa 0x87F45000 perm 0x1Bva 0x2000 pte 0x21FD1017 pa 0x87F44000 perm 0x17va 0x3000 pte 0x21FD4007 pa 0x87F50000 perm 0x7va 0x4000 pte 0x21FC70D7 pa 0x87F1C000 perm 0xD7va 0x5000 pte 0x0 pa 0x0 perm 0x0va 0x6000 pte 0x0 pa 0x0 perm 0x0va 0x7000 pte 0x0 pa 0x0 perm 0x0va 0x8000 pte 0x0 pa 0x0 perm 0x0va 0x9000 pte 0x0 pa 0x0 perm 0x0va 0xFFFF6000 pte 0x0 pa 0x0 perm 0x0va 0xFFFF7000 pte 0x0 pa 0x0 perm 0x0va 0xFFFF8000 pte 0x0 pa 0x0 perm 0x0va 0xFFFF9000 pte 0x0 pa 0x0 perm 0x0va 0xFFFFA000 pte 0x0 pa 0x0 perm 0x0va 0xFFFFB000 pte 0x0 pa 0x0 perm 0x0va 0xFFFFC000 pte 0x0 pa 0x0 perm 0x0va 0xFFFFD000 pte 0x0 pa 0x0 perm 0x0va 0xFFFFE000 pte 0x21FC94C7 pa 0x87F25000 perm 0xC7va 0xFFFFF000 pte 0x2000184B pa 0x80006000 perm 0x4Bprint_pgtbl: OK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结合 <code>print_pgtbl</code> 的实现，我们可以知道 <code>pgtbltest</code> 遍历了用户进程虚拟地址空间开头和末尾的一些地址，并打印出它们对应的 PTE、物理地址、权限位。让我们先来看看 PTE 的结构：</p><p><img src="/images/learning/open-course/MIT-6.S081/labs/lab3-pagetable/pte.png" alt=""></p><p>然后我们以 <code>va 0x4000 pte 0x21FC70D7 pa 0x87F1C000 perm 0xD7</code> 为例，解析一下其打印的内容。首先我们从 PTE 中提取出 Physical Page Number（PPN）和权限位：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 打印 PPN&#x2F;&#x2F; 虚拟地址的末尾 12 位是 0, 所以物理地址偏移量为 0&#x2F;&#x2F; 物理地址为 ((pte &gt;&gt; 10) &lt;&lt; 12) + 0 即 0x87f1c000(gdb) p &#x2F;x (0x21FC70D7 &gt;&gt; 10)$17 &#x3D; 0x87f1c&#x2F;&#x2F; 构造一个末尾 10 位为 1 的量, 方便后续取出权限位(gdb) set $mask &#x3D; ((1 &lt;&lt; 10) - 1)(gdb) p &#x2F;t $mask$18 &#x3D; 1111111111&#x2F;&#x2F; 分别用二进制和十六进制打印权限位(gdb) p &#x2F;t (0x21FC70D7 &amp; $mask)$19 &#x3D; 11010111(gdb) p &#x2F;x (0x21FC70D7 &amp; $mask)$20 &#x3D; 0xd7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>检验可知和 <code>print_pgtbl</code> 的打印结果一致。对照权限位的末五位 10111 和 PTE 的末尾五位 UXWRV，可知这里是用户内存、不可执行、可写、可读、合法。</p><p>我们可以再检查一下 <code>va 0xFFFFF000 pte 0x2000184B pa 0x80006000 perm 0x4B</code>，会发现它的权限位末五位是 01011，说明这里是非用户内存、可以执行、不可写、可读、合法。</p><p>对照下面的用户进程虚拟内存空间图可知我们分析的第一段虚拟地址 <code>0x4000</code> 大约在开头位置，确实是用户的东西；而分析的第二段 <code>0xFFFFF000</code> 则在接近末尾的位置，用于存储系统调用相关的陷阱代码。</p><p><img src="/images/learning/open-course/MIT-6.S081/labs/lab3-pagetable/user_addr_space.png" alt=""></p><p>我们还可以进一步打印一下内存里的值。启动 gdb，用 <code>file user/_pgtbltest</code> 加载符号表，然后在 <code>main</code> 设置断点，这样我们就能在加载用户页表时打印各个虚拟地址的值：</p><pre class="line-numbers language-none"><code class="language-none">(gdb) p *0x0$7 &#x3D; -335146751(gdb) p *0x1000$8 &#x3D; 72(gdb) p *0x5000Cannot access memory at address 0x5000(gdb) p *0xFFFFE000Cannot access memory at address 0xffffe000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对照最开始的 <code>print_pgtbl</code> 的打印结果（关注其权限位），可以看到我们能正确打印 <code>0x0</code> 和 <code>0x1000</code> ，它们是用户内存、可读、合法的虚拟地址的内容。而 <code>0x5000</code> 是不合法的地址所以无法打印，<code>0xFFFFE000</code> 是非用户内存（内核内存）所以无法打印。</p><h1 id="Speed-up-system-calls"><a href="#Speed-up-system-calls" class="headerlink" title="Speed up system calls"></a>Speed up system calls</h1><p>这道题让我们创建一个特殊的内存页并把进程 pid 存储在里面，这样我们在获取 pid 时就不必做系统调用 <code>getpid</code>，而是可以直接调用 <code>ugetpid</code>，从而无需陷入内核以提高效率。</p><p>提示里说我们创建的这个页面会和 <code>trapframe</code> 有很多相似之处——它们都在进程初始化时自动创建，在进程退出时自动释放。所以我们可以分为以下几步完成任务：</p><ol><li>定义 <code>usyscall</code>：在 <code>struct proc</code> 里添加 <code>struct usyscall *usyscall</code></li><li><p>进程初始化时创建页面：阅读 <code>fork</code> 的代码可以知道我们调用 <code>allocproc</code> 以创建进程。</p><p> 在 <code>allocproc</code> 里，我们用 <code>kalloc</code> 给 <code>trapframe</code> 分配了一个物理页，然后调用 <code>proc_pagetable</code> 来做页表映射。</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">proc</span> <span class="token operator">*</span><span class="token function">allocproc</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// ...</span>    <span class="token comment">// Allocate a trapframe page.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p<span class="token operator">-></span>trapframe <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">trapframe</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">kalloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">freeproc</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// An empty user page table.</span>    p<span class="token operator">-></span>pagetable <span class="token operator">=</span> <span class="token function">proc_pagetable</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// ...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 所以照葫芦画瓢就行，先在 <code>allocproc</code> 里加入给 <code>usyscall</code> 分配物理页的代码（记得把 <code>pid</code> 存进去）：</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// Allocate a usyscall page</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p<span class="token operator">-></span>usyscall <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">usyscall</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">kalloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">freeproc</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>p<span class="token operator">-></span>usyscall<span class="token operator">-></span>pid <span class="token operator">=</span> p<span class="token operator">-></span>pid<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 然后在 <code>proc_pagetable</code> 加入页表映射的代码：</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// map the usyscall page just below the trapframe page, for</span><span class="token comment">// data sharing between userspace and the kernel</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">mappages</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> USYSCALL<span class="token punctuation">,</span> PGSIZE<span class="token punctuation">,</span> <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span><span class="token punctuation">(</span>p<span class="token operator">-></span>usyscall<span class="token punctuation">)</span><span class="token punctuation">,</span>             PTE_R <span class="token operator">|</span> PTE_U<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">uvmunmap</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> TRAPFRAME<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">uvmunmap</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> TRAMPOLINE<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">uvmfree</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>退出时释放：我们知道进程调用 <code>exit</code> 来下班，但其实调用 <code>exit</code> 后进程并没有立即销毁自身，而是进入 ZOMBIE 态等待父进程的 <code>wait</code> 来回收。具体可以看看 <code>proc.c</code>，这里不多赘述。</p><p> 总之看向 <code>wait</code> 函数，可以发现我们调用 <code>freeproc</code> 来释放进程。</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">freeproc</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">proc</span> <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">-></span>trapframe<span class="token punctuation">)</span>        <span class="token function">kfree</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>p<span class="token operator">-></span>trapframe<span class="token punctuation">)</span><span class="token punctuation">;</span>    p<span class="token operator">-></span>trapframe <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">-></span>pagetable<span class="token punctuation">)</span>        <span class="token function">proc_freepagetable</span><span class="token punctuation">(</span>p<span class="token operator">-></span>pagetable<span class="token punctuation">,</span> p<span class="token operator">-></span>sz<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// ...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 对照代码对 <code>trapframe</code> 的处理，我们要在 <code>freeproc</code> 里加入释放物理页的代码：</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">-></span>usyscall<span class="token punctuation">)</span>    <span class="token function">kfree</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>p<span class="token operator">-></span>usyscall<span class="token punctuation">)</span><span class="token punctuation">;</span>p<span class="token operator">-></span>usyscall <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p> 然后修改 <code>proc_freepagetable</code> 以删除页表映射：</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">uvmunmap</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> USYSCALL<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><p>闲着也是闲着，不如和我一起看看 <code>uvmfree</code> 为什么没有自动释放 <code>trapframe</code> 和 <code>usyscall</code>：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">uvmfree</span><span class="token punctuation">(</span><span class="token class-name">pagetable_t</span> pagetable<span class="token punctuation">,</span> uint64 sz<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>sz <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">uvmunmap</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token function">PGROUNDUP</span><span class="token punctuation">(</span>sz<span class="token punctuation">)</span> <span class="token operator">/</span> PGSIZE<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">freewalk</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码调用 <code>uvmunmap</code> 来释放所有在页表里有记录的物理页，然后调用 <code>freewalk</code> 来释放页表自身。</p><p>这里的 <code>uvmunmap(pagetable, 0, PGROUNDUP(sz) / PGSIZE, 1)</code> 表示释放虚拟地址从 <code>0</code> 到 <code>0 + PGROUNDUP(sz) / PGSIZE</code> 的内容，即释放用户内存的内容。</p><p>但 <code>trapframe</code> 和 <code>usyscall</code> 不是用户内存的内容，它们被存放在虚拟地址的顶部（分别在 TRAPFRAME 和 USYSCALL），所以它们没有被释放。</p><h1 id="Print-a-page-table"><a href="#Print-a-page-table" class="headerlink" title="Print a page table"></a>Print a page table</h1><p>先来看看打印结果吧：</p><pre class="line-numbers language-none"><code class="language-none">page table 0x0000000087f22000 ..0x0000000000000000: pte 0x0000000021fc7801 pa 0x0000000087f1e000 .. ..0x0000000000000000: pte 0x0000000021fc7401 pa 0x0000000087f1d000 .. .. ..0x0000000000000000: pte 0x0000000021fc7c5b pa 0x0000000087f1f000 .. .. ..0x0000000000001000: pte 0x0000000021fc701b pa 0x0000000087f1c000 .. .. ..0x0000000000002000: pte 0x0000000021fc6cd7 pa 0x0000000087f1b000 .. .. ..0x0000000000003000: pte 0x0000000021fc6807 pa 0x0000000087f1a000 .. .. ..0x0000000000004000: pte 0x0000000021fc64d7 pa 0x0000000087f19000 ..0xffffffffc0000000: pte 0x0000000021fc8401 pa 0x0000000087f21000 .. ..0xffffffffffe00000: pte 0x0000000021fc8001 pa 0x0000000087f20000 .. .. ..0xffffffffffffd000: pte 0x0000000021fd4c13 pa 0x0000000087f53000 .. .. ..0xffffffffffffe000: pte 0x0000000021fd00c7 pa 0x0000000087f40000 .. .. ..0xfffffffffffff000: pte 0x000000002000184b pa 0x0000000080006000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果比 2024 的作业文档多了一行</p><pre class="line-numbers language-none"><code class="language-none">.. .. ..0x0000000000000000: pte 0x0000000021fc7c5b pa 0x0000000087f1f000<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这是正确表现。2024 的作业文档这里写错了，2025 的版本就加入了这行。</p><p>如提示所言，这个函数和 <code>freewalk</code> 很像，我们先来看看 <code>freewalk</code>：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">freewalk</span><span class="token punctuation">(</span><span class="token class-name">pagetable_t</span> pagetable<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// there are 2^9 = 512 PTEs in a page table.</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">512</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">pte_t</span> pte <span class="token operator">=</span> pagetable<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pte <span class="token operator">&amp;</span> PTE_V<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>pte <span class="token operator">&amp;</span> <span class="token punctuation">(</span>PTE_R <span class="token operator">|</span> PTE_W <span class="token operator">|</span> PTE_X<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// this PTE points to a lower-level page table.</span>            uint64 child <span class="token operator">=</span> <span class="token function">PTE2PA</span><span class="token punctuation">(</span>pte<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">freewalk</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">pagetable_t</span><span class="token punctuation">)</span>child<span class="token punctuation">)</span><span class="token punctuation">;</span>            pagetable<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pte <span class="token operator">&amp;</span> PTE_V<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"freewalk: leaf"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">kfree</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>pagetable<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>它遍历 L0 级页表的 512 个 PTE，对每个 PTE，用 <code>PTE2PA(pte)</code> 找到它指向的次级页表的物理地址，然后递归。它忽略了叶子 PTE，在打印时我们不需要忽略叶子。</p><p>我们再来看看打印结果的形式</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">.</span><span class="token punctuation">.</span> 虚拟地址<span class="token operator">:</span> pte PTE的值 pa 物理地址的值<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>参考 <code>freewalk</code> 我们就能拿到 PTE，调用 <code>PTE2PA</code> 就能得到 <code>pa</code>，但怎么获得虚拟地址呢？我们来看看虚拟地址的翻译：</p><p><img src="/images/learning/open-course/MIT-6.S081/labs/lab3-pagetable/addr_translation.png" alt=""></p><p>从这里可以看出，如果把 Offset 置零，我们需要 L2、L1、L0 页表的 PTE 的索引来确定虚拟地址。但我们当然有办法获得这些索引，我们不是在遍历页表吗，<code>for (int i = 0; i &lt; 512; i++)</code> 里的 <code>i</code> 就是我们需要的索引！所以如果我们的索引是 <code>i, j, k</code>，我们打印的虚拟地址就是 <code>((i &lt;&lt; 30) + (j &lt;&lt; 21) + (k &lt;&lt; 12))</code></p><p>大致思路就是这样。还有一些小细节：</p><ol><li>作业文档里在遍历 L2 和 L1 级页表时也打印了虚拟地址，这里打印的地址是把次级索引当作零算出的地址。比如如果我们在遍历 L1 页表，L2 页表的索引是 <code>i</code>，L1 页表的索引是 <code>j</code>，打印的就是 <code>((i &lt;&lt; 30) + (j &lt;&lt; 21) + (0 &lt;&lt; 12))</code></li><li>为了在递归时得知上一级页表的信息，我们加入了 <code>father_va</code> 用于记录上一级的虚拟地址</li><li>符号拓展用了一些 tricky 的性质，在 255 &lt;&lt; 30 那行的注释里写的应该还算清楚</li></ol><p>总之可以写出下面的代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">int</span> MAX_LEVEL <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">_vmprint_helper</span><span class="token punctuation">(</span><span class="token class-name">pagetable_t</span> pagetable<span class="token punctuation">,</span> uint64 father_va<span class="token punctuation">,</span> <span class="token keyword">int</span> level<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// there are 2^9 = 512 PTEs in a page table.</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">512</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">pte_t</span> pte <span class="token operator">=</span> pagetable<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pte <span class="token operator">&amp;</span> PTE_V<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> level<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> MAX_LEVEL<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" .."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 255 &lt;&lt; 30 is automatically sign extended to 0xffffffffc0000000</span>            uint64 va <span class="token operator">=</span> father_va <span class="token operator">+</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token number">12</span> <span class="token operator">+</span> <span class="token number">9</span> <span class="token operator">*</span> level<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p: pte %p pa %p\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>va<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>pte<span class="token punctuation">,</span>                   <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">PTE2PA</span><span class="token punctuation">(</span>pte<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// this PTE points to a lower-level page table.</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>level <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">_vmprint_helper</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">pagetable_t</span><span class="token punctuation">)</span><span class="token function">PTE2PA</span><span class="token punctuation">(</span>pte<span class="token punctuation">)</span><span class="token punctuation">,</span> va<span class="token punctuation">,</span> level <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">vmprint</span><span class="token punctuation">(</span><span class="token class-name">pagetable_t</span> pagetable<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"page table %p\n"</span><span class="token punctuation">,</span> pagetable<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">_vmprint_helper</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> MAX_LEVEL<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Use-superpages"><a href="#Use-superpages" class="headerlink" title="Use superpages"></a><strong>Use superpages</strong></h1><p>这道题让我们给 xv6 加入超级页。当用户请求一块超过 2MB 的内存，我们就分配超级页而非大量的小页来优化性能。</p><p>我们先来看看普通页和超级页各自是如何翻译虚拟地址的：</p><p><img src="/images/learning/open-course/MIT-6.S081/labs/lab3-pagetable/regular_vs_super.png" alt=""></p><ol><li><p>普通页：</p><p> 普通页在翻译时把虚拟地址分成 L2, L1, L0, Offset 四个部分。前三者用于在不同级别的页表里做偏移找到下一个页的开头的物理地址（一个 Page Directory 也是一个页），Offset 则用于计算最终的物理地址偏移。</p><p> Sv39 规定 PPN 宽度为 44 位，Offset 宽度 12 位，一个普通页的大小就是 $2^{12}$ bytes = 4KB.</p><p> 在找到了 L0 leaf 后，我们就能用 <code>(PPN &lt;&lt; 12) + Offest</code> 来计算虚拟地址对应的物理地址了。</p></li><li><p>超级页：</p><p> 超级页则把虚拟地址分成 L2, L1, Offset 三个部分。</p><p> Sv39 规定超级页的 Offset 为 21 位，这是把原本的 L0 和 Offset 合并成了一个 21 位的 Offset。超级页大小就是 $2^{21}$ bytes 即 2MB.</p><p> 超级页是 2MB 对齐的，所以我们需要 $56 - \log (2097152) = 35$ 位来描述一个超级页的开头，所以超级页对应的 L1 leaf 存储的 PPN 的末尾 9 位为 0. 这里有 $2097152$ 是因为 2MB = 2097152 bytes.</p><p> 在找到 L1 leaf 后，我们同样用 <code>(PPN &lt;&lt; 12) + Offest</code> 来计算虚拟地址对应的物理地址。</p></li></ol><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p>遵循提示，我们先来看看 <code>superpg_test</code> 做了什么。要说明的是，2024 版本的测试不全面而且有 bug——在 <code>supercheck</code> 函数的末尾的 for 循环里，条件应该是 <code>i &lt; 512 * PGSIZE</code> 而非 <code>i &lt; 512</code>，应该改成下面这样：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// check whether different va are mapped to different pa</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">512</span> <span class="token operator">*</span> PGSIZE<span class="token punctuation">;</span> i <span class="token operator">+=</span> PGSIZE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>s <span class="token operator">+</span> i<span class="token punctuation">)</span> <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">512</span> <span class="token operator">*</span> PGSIZE<span class="token punctuation">;</span> i <span class="token operator">+=</span> PGSIZE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>s <span class="token operator">+</span> i<span class="token punctuation">)</span> <span class="token operator">!=</span> i<span class="token punctuation">)</span>        <span class="token function">err</span><span class="token punctuation">(</span><span class="token string">"wrong value"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总之我们下面分析 2025 版本的测试。2025 版本的测试共包括 <code>supercheck</code>、<code>superpg_fork</code> 和 <code>superpg_free</code> 三个函数，我们主要关注 <code>supercheck</code>。<code>supercheck</code> 判断从 <code>end</code> 之后第一个对齐超级页的地址开始是否是超级页，具体的判断方法可以参考下面的注释：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">supercheck</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>end<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">pte_t</span> last_pte <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    uint64 a <span class="token operator">=</span> <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>end<span class="token punctuation">;</span>    uint64 s <span class="token operator">=</span> <span class="token function">SUPERPGROUNDUP</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Check that virtual address up to the next superpage boundary are mapped to PTE</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> a <span class="token operator">&lt;</span> s<span class="token punctuation">;</span> a <span class="token operator">+=</span> PGSIZE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">pte_t</span> pte <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">pte_t</span><span class="token punctuation">)</span><span class="token function">pgpte</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pte <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">err</span><span class="token punctuation">(</span><span class="token string">"no pte"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// Check that all virtual address in the superpage share the same valid PTE</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>uint64 p <span class="token operator">=</span> s<span class="token punctuation">;</span> p <span class="token operator">&lt;</span> s <span class="token operator">+</span> <span class="token number">512</span> <span class="token operator">*</span> PGSIZE<span class="token punctuation">;</span> p <span class="token operator">+=</span> PGSIZE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">pte_t</span> pte <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">pte_t</span><span class="token punctuation">)</span><span class="token function">pgpte</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pte <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token function">err</span><span class="token punctuation">(</span><span class="token string">"no pte"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>last_pte <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> pte <span class="token operator">!=</span> last_pte<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">err</span><span class="token punctuation">(</span><span class="token string">"pte different"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pte <span class="token operator">&amp;</span> PTE_V<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token punctuation">(</span>pte <span class="token operator">&amp;</span> PTE_R<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token punctuation">(</span>pte <span class="token operator">&amp;</span> PTE_W<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">err</span><span class="token punctuation">(</span><span class="token string">"pte wrong"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        last_pte <span class="token operator">=</span> pte<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// Check that different va are mapped to different pa</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">512</span> <span class="token operator">*</span> PGSIZE<span class="token punctuation">;</span> i <span class="token operator">+=</span> PGSIZE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>s <span class="token operator">+</span> i<span class="token punctuation">)</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">512</span> <span class="token operator">*</span> PGSIZE<span class="token punctuation">;</span> i <span class="token operator">+=</span> PGSIZE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>s <span class="token operator">+</span> i<span class="token punctuation">)</span> <span class="token operator">!=</span> i<span class="token punctuation">)</span>            <span class="token function">err</span><span class="token punctuation">(</span><span class="token string">"wrong value"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后我们简要提一下另外两个函数的作用：</p><ol><li><code>superpg_fork</code> 检查超级页在 <code>fork</code> 后是否被正确复制为超级页。</li><li><code>superpg_free</code> 检查 <code>sbrk</code> 能否正确释放整个超级页，以及能否在释放超级页的部分内存时将超级页退化为多个普通页（2024 版本没测试这一点，但这个是很值得做的功能）。</li></ol><h2 id="sbrk-调用链"><a href="#sbrk-调用链" class="headerlink" title="sbrk 调用链"></a>sbrk 调用链</h2><p>接下来我们分析用户在调用 <code>sbrk</code> 时具体调用了哪些函数。这分为两种情况：</p><ol><li>分配：sys_sbrk-&gt;growproc-&gt;uvmalloc -&gt; kalloc/kfree</li><li>释放：sys_sbrk -&gt; growproc -&gt; uvmdealloc -&gt; uvmunmap</li></ol><p>要注意的是当分配内存出错时，<code>uvmalloc</code> 也会调用 <code>uvmdealloc</code>。</p><p>我们从最底层出发，先在 kalloc.c 里完成对超级页的支持。这包括以下步骤：</p><ol><li><p>添加一个超级页链表</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">spinlock</span> lock<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">run</span> <span class="token operator">*</span>superlist<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">run</span> <span class="token operator">*</span>freelist<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> kmem<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>在初始化代码里初始化这个超级页链表</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">int</span> MAX_SUPER <span class="token operator">=</span> <span class="token number">32</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">freerange</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>pa_start<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>pa_end<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>    p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">PGROUNDUP</span><span class="token punctuation">(</span><span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>pa_start<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> sz<span class="token punctuation">;</span>    <span class="token keyword">int</span> super_cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> p <span class="token operator">+</span> PGSIZE <span class="token operator">&lt;=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>pa_end<span class="token punctuation">;</span> p <span class="token operator">+=</span> sz<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>super_cnt <span class="token operator">&lt;</span> MAX_SUPER <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>p <span class="token operator">%</span> SUPERPGSIZE <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>            p <span class="token operator">+</span> SUPERPGSIZE <span class="token operator">&lt;=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>pa_end<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            sz <span class="token operator">=</span> SUPERPGSIZE<span class="token punctuation">;</span>            <span class="token function">superfree</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>            super_cnt <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            sz <span class="token operator">=</span> PGSIZE<span class="token punctuation">;</span>            <span class="token function">kfree</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>添加 superalloc 和 superfree 函数（照抄 kalloc 和 kfree）：</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">superalloc</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">run</span> <span class="token operator">*</span>r<span class="token punctuation">;</span>    <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kmem<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    r <span class="token operator">=</span> kmem<span class="token punctuation">.</span>superlist<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>r<span class="token punctuation">)</span>        kmem<span class="token punctuation">.</span>superlist <span class="token operator">=</span> r<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kmem<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>r<span class="token punctuation">)</span>        <span class="token function">memset</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>r<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> SUPERPGSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// fill with junk</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>r<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">superfree</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>pa<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">run</span> <span class="token operator">*</span>r<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>pa <span class="token operator">%</span> SUPERPGSIZE<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>pa <span class="token operator">&lt;</span> end <span class="token operator">||</span>        <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>pa <span class="token operator">>=</span> PHYSTOP<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"superfree"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// Fill with junk to catch dangling refs.</span>    <span class="token function">memset</span><span class="token punctuation">(</span>pa<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> SUPERPGSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    r <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">run</span> <span class="token operator">*</span><span class="token punctuation">)</span>pa<span class="token punctuation">;</span>    <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kmem<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    r<span class="token operator">-></span>next <span class="token operator">=</span> kmem<span class="token punctuation">.</span>superlist<span class="token punctuation">;</span>    kmem<span class="token punctuation">.</span>superlist <span class="token operator">=</span> r<span class="token punctuation">;</span>    <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kmem<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p>至此，最底层的工作就做完了。</p><h2 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h2><p>回顾内存分配的调用链：sys_sbrk-&gt;growproc-&gt;uvmalloc -&gt; kalloc/kfree，在开始编写代码之前我们先分析一下每一层的职责。</p><ol><li>sys_sbrk 是系统调用，负责系统和用户的交互</li><li>grow_proc 是进程抽象的一个接口，负责管理进程状态</li><li>uvmalloc 是虚拟内存层，负责管理进程眼中的“内存”，管理虚拟到物理的映射</li><li>kalloc 和 kfree 则是物理内存层，管理物理内存</li></ol><p>我们在这里要修改的是 uvmalloc. 简单读下它原本的代码可以发现它主要调用的是 kalloc 和 mappages. 在超级页中，前者对应 superalloc，而对后者我自己写了一个 mapsuperpages 作为对应。为了让 mapsuperpages 跑起来，我还写了个 l1walk 函数用于找到一个虚拟地址对应的 L1 PTE. 先来看看 l1walk：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">pte_t</span> <span class="token operator">*</span><span class="token function">l1walk</span><span class="token punctuation">(</span><span class="token class-name">pagetable_t</span> pagetable<span class="token punctuation">,</span> uint64 va<span class="token punctuation">,</span> <span class="token keyword">int</span> alloc<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>va <span class="token operator">>=</span> MAXVA<span class="token punctuation">)</span>        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"walk"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">pte_t</span> <span class="token operator">*</span>pte <span class="token operator">=</span> <span class="token operator">&amp;</span>pagetable<span class="token punctuation">[</span><span class="token function">PX</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> va<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>pte <span class="token operator">&amp;</span> PTE_V<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        pagetable <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">pagetable_t</span><span class="token punctuation">)</span><span class="token function">PTE2PA</span><span class="token punctuation">(</span><span class="token operator">*</span>pte<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">&amp;</span>pagetable<span class="token punctuation">[</span><span class="token function">PX</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> va<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>alloc <span class="token operator">||</span> <span class="token punctuation">(</span>pagetable <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">pde_t</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">kalloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> PGSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">*</span>pte <span class="token operator">=</span> <span class="token function">PA2PTE</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">)</span> <span class="token operator">|</span> PTE_V<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">&amp;</span>pagetable<span class="token punctuation">[</span><span class="token function">PX</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> va<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>它和 walk 函数基本一致，不过 walk 是返回 leaf，而这里的 l1walk 返回 L1 PTE.</p><p>然后看看 mapsuperpages：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">mapsuperpages</span><span class="token punctuation">(</span><span class="token class-name">pagetable_t</span> pagetable<span class="token punctuation">,</span> uint64 va<span class="token punctuation">,</span> uint64 size<span class="token punctuation">,</span> uint64 pa<span class="token punctuation">,</span>                  <span class="token keyword">int</span> perm<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    uint64 a<span class="token punctuation">,</span> last<span class="token punctuation">;</span>    <span class="token class-name">pte_t</span> <span class="token operator">*</span>pte<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>va <span class="token operator">%</span> SUPERPGSIZE<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"mapsuperpages: va not aligned"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">%</span> SUPERPGSIZE<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"mapsuperpages: size not aligned"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"mapsuperpages: size"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    a <span class="token operator">=</span> va<span class="token punctuation">;</span>    last <span class="token operator">=</span> va <span class="token operator">+</span> size <span class="token operator">-</span> SUPERPGSIZE<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pte <span class="token operator">=</span> <span class="token function">l1walk</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> a<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"mapsuperpages: l1walk failed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>pte <span class="token operator">&amp;</span> PTE_V<span class="token punctuation">)</span>            <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"mapsuperpages: remap"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">*</span>pte <span class="token operator">=</span> <span class="token function">PA2PTE</span><span class="token punctuation">(</span>pa<span class="token punctuation">)</span> <span class="token operator">|</span> perm <span class="token operator">|</span> PTE_V <span class="token operator">|</span> PTE_R<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> last<span class="token punctuation">)</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        a <span class="token operator">+=</span> SUPERPGSIZE<span class="token punctuation">;</span>        pa <span class="token operator">+=</span> SUPERPGSIZE<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这基本是照抄 mappages，只是把普通页改成了超级页。</p><p>最后看看我们对 uvmalloc 的修改。uvmalloc 主要分为两部分，第一部分是用 kalloc/superalloc 请求物理内存，第二部分是用 mappages/mapsuperpages 把虚拟内存映射到物理内存上。</p><p>我们在注释里标出了修改的地方，修改 1 对应请求物理内存的第一部分，修改 2 对应做映射的第二部分：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">uint64 <span class="token function">uvmalloc</span><span class="token punctuation">(</span><span class="token class-name">pagetable_t</span> pagetable<span class="token punctuation">,</span> uint64 oldsz<span class="token punctuation">,</span> uint64 newsz<span class="token punctuation">,</span> <span class="token keyword">int</span> xperm<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>mem<span class="token punctuation">;</span>    uint64 a<span class="token punctuation">;</span>    <span class="token keyword">int</span> sz<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newsz <span class="token operator">&lt;</span> oldsz<span class="token punctuation">)</span>        <span class="token keyword">return</span> oldsz<span class="token punctuation">;</span>    oldsz <span class="token operator">=</span> <span class="token function">PGROUNDUP</span><span class="token punctuation">(</span>oldsz<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>a <span class="token operator">=</span> oldsz<span class="token punctuation">;</span> a <span class="token operator">&lt;</span> newsz<span class="token punctuation">;</span> a <span class="token operator">+=</span> sz<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 修改1从这里开始</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">%</span> SUPERPGSIZE <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> a <span class="token operator">+</span> SUPERPGSIZE <span class="token operator">&lt;=</span> newsz<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            sz <span class="token operator">=</span> SUPERPGSIZE<span class="token punctuation">;</span>            mem <span class="token operator">=</span> <span class="token function">superalloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// If no superpages, use regular pages</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>mem <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                sz <span class="token operator">=</span> PGSIZE<span class="token punctuation">;</span>                mem <span class="token operator">=</span> <span class="token function">kalloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            sz <span class="token operator">=</span> PGSIZE<span class="token punctuation">;</span>            mem <span class="token operator">=</span> <span class="token function">kalloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 修改1到这里结束</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mem <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">uvmdealloc</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> a<span class="token punctuation">,</span> oldsz<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">LAB_SYSCALL</span></span>        <span class="token function">memset</span><span class="token punctuation">(</span>mem<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> sz<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>        <span class="token comment">// 修改2从这里开始</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sz <span class="token operator">==</span> PGSIZE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">mappages</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> a<span class="token punctuation">,</span> sz<span class="token punctuation">,</span> <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>mem<span class="token punctuation">,</span>                         PTE_R <span class="token operator">|</span> PTE_U <span class="token operator">|</span> xperm<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">kfree</span><span class="token punctuation">(</span>mem<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">uvmdealloc</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> a<span class="token punctuation">,</span> oldsz<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">mapsuperpages</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> a<span class="token punctuation">,</span> sz<span class="token punctuation">,</span> <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>mem<span class="token punctuation">,</span>                              PTE_R <span class="token operator">|</span> PTE_U <span class="token operator">|</span> xperm<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">superfree</span><span class="token punctuation">(</span>mem<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">uvmdealloc</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> a<span class="token punctuation">,</span> oldsz<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 修改2到这里结束</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> newsz<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="释放内存"><a href="#释放内存" class="headerlink" title="释放内存"></a>释放内存</h2><p>在完成了分配内存的工作后，我们就能写释放内存相关的代码了。</p><p>回顾调用链：sys_sbrk -&gt; growproc -&gt; uvmdealloc -&gt; uvmunmap，我们要修改 uvmunmap. 这部分代码比较棘手。它原本只是在按部就班地删掉页表里从 va 出发的 npages 个物理页的映射，并选择性释放物理内存，但在加入超级页后它需要完成这些工作：</p><ol><li>让 <code>uint64 a</code> 从 <code>va</code> 出发，如果遇到了普通页，走普通页的 unmap 流程，然后 <code>a += PGSIZE</code></li><li>如果遇到了超级页，判断 <code>a</code> 是超级页的开头还是超级页的中间<ol><li>如果是超级页的开头，走超级页的 unmap 流程（和普通页 unmap 基本一致），然后 <code>a += SUPERPGSIZE</code></li><li>如果是超级页的中间，把超级页退化成若干个普通页，再走普通页释放流程，然后 <code>a += PGSIZE</code></li></ol></li></ol><p>这里主要是上面步骤中的 2b 的“退化”比较棘手，我是把页表里对应超级页的 L1 leaf 设置成了 invalid，然后把超级页视作多个普通页的合并，从超级页的开头出发做若干次 mappages 从而完成退化。思路可以参考下图：</p><p><img src="/images/learning/open-course/MIT-6.S081/labs/lab3-pagetable/super_demote.png" alt=""></p><p>这里是退化部分的代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> perm <span class="token operator">=</span> <span class="token function">PTE_FLAGS</span><span class="token punctuation">(</span><span class="token operator">*</span>pte<span class="token punctuation">)</span><span class="token punctuation">;</span>uint64 super_va_st <span class="token operator">=</span> <span class="token function">SUPERPGROUNDDOWN</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>uint64 super_pa_st <span class="token operator">=</span> <span class="token function">PTE2PA</span><span class="token punctuation">(</span><span class="token operator">*</span>pte<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">*</span>pte <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>pte <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// Make pte invalid to make `mappages` work</span><span class="token keyword">for</span> <span class="token punctuation">(</span>uint64 super_va <span class="token operator">=</span> super_va_st<span class="token punctuation">,</span> super_pa <span class="token operator">=</span> super_pa_st<span class="token punctuation">;</span>     super_va <span class="token operator">&lt;</span> super_va_st <span class="token operator">+</span> SUPERPGSIZE<span class="token punctuation">;</span>     super_va <span class="token operator">+=</span> PGSIZE<span class="token punctuation">,</span> super_pa <span class="token operator">+=</span> PGSIZE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">mappages</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> super_va<span class="token punctuation">,</span> PGSIZE<span class="token punctuation">,</span> super_pa<span class="token punctuation">,</span> perm<span class="token punctuation">)</span> <span class="token operator">!=</span>        <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"uvmunmap: mappages failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然这样的退化有一个潜在风险——每个进程的超级页上限在进程启动时就决定了，我们的退化会让本进程的超级页上限减一。如果有什么自动合并普通页为超级页的功能就好了…</p><p>另外，我的代码把之前步骤里描述的 1 和 2b 整合了一下（毕竟它们最后都走的是普通页释放流程），总之这里是完整代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">uvmunmap</span><span class="token punctuation">(</span><span class="token class-name">pagetable_t</span> pagetable<span class="token punctuation">,</span> uint64 va<span class="token punctuation">,</span> uint64 npages<span class="token punctuation">,</span> <span class="token keyword">int</span> do_free<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    uint64 a<span class="token punctuation">;</span>    <span class="token class-name">pte_t</span> <span class="token operator">*</span>pte<span class="token punctuation">;</span>    <span class="token keyword">int</span> sz<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>va <span class="token operator">%</span> PGSIZE<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"uvmunmap: not aligned"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>a <span class="token operator">=</span> va<span class="token punctuation">;</span> a <span class="token operator">&lt;</span> va <span class="token operator">+</span> npages <span class="token operator">*</span> PGSIZE<span class="token punctuation">;</span> a <span class="token operator">+=</span> sz<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// If `a` corresponds to a superpage and the superpage starts at `a`,</span>        <span class="token comment">// free the superpage</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pte <span class="token operator">=</span> <span class="token function">l1walk</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> a<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">PTE_LEAF</span><span class="token punctuation">(</span><span class="token operator">*</span>pte<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>            a <span class="token operator">%</span> SUPERPGSIZE <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            sz <span class="token operator">=</span> SUPERPGSIZE<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>pte <span class="token operator">&amp;</span> PTE_V<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"va=%ld pte=%ld\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> <span class="token operator">*</span>pte<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"uvmunmap: not mapped"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>do_free<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                uint64 pa <span class="token operator">=</span> <span class="token function">PTE2PA</span><span class="token punctuation">(</span><span class="token operator">*</span>pte<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">superfree</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>pa<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token operator">*</span>pte <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            sz <span class="token operator">=</span> PGSIZE<span class="token punctuation">;</span>            <span class="token comment">// If `a` corresponds to a superpage but the superpage doesn't</span>            <span class="token comment">// start at `a`, demote the superpage into regular pages</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>pte <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">PTE_LEAF</span><span class="token punctuation">(</span><span class="token operator">*</span>pte<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// Potential issue:</span>                <span class="token comment">// Each process has a max number of superpages defined as</span>                <span class="token comment">// `MAX_SUPER`. But whenever a superpage is demoted, the</span>                <span class="token comment">// process's max number of superpages permanently minus one,</span>                <span class="token comment">// since we view superpage as multiple regular pages.</span>                <span class="token comment">//</span>                <span class="token comment">// A possible solution is to kalloc multiple regular pages,</span>                <span class="token comment">// copy memory into them, and superfree the superpage.</span>                <span class="token keyword">int</span> perm <span class="token operator">=</span> <span class="token function">PTE_FLAGS</span><span class="token punctuation">(</span><span class="token operator">*</span>pte<span class="token punctuation">)</span><span class="token punctuation">;</span>                uint64 super_va_st <span class="token operator">=</span> <span class="token function">SUPERPGROUNDDOWN</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>                uint64 super_pa_st <span class="token operator">=</span> <span class="token function">PTE2PA</span><span class="token punctuation">(</span><span class="token operator">*</span>pte<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">*</span>pte <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>pte <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span>                       <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// Make pte invalid to make `mappages` work</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span>uint64 super_va <span class="token operator">=</span> super_va_st<span class="token punctuation">,</span> super_pa <span class="token operator">=</span> super_pa_st<span class="token punctuation">;</span>                     super_va <span class="token operator">&lt;</span> super_va_st <span class="token operator">+</span> SUPERPGSIZE<span class="token punctuation">;</span>                     super_va <span class="token operator">+=</span> PGSIZE<span class="token punctuation">,</span> super_pa <span class="token operator">+=</span> PGSIZE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">mappages</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> super_va<span class="token punctuation">,</span> PGSIZE<span class="token punctuation">,</span> super_pa<span class="token punctuation">,</span> perm<span class="token punctuation">)</span> <span class="token operator">!=</span>                        <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"uvmunmap: mappages failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// Free the regular page that begins at `a`</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pte <span class="token operator">=</span> <span class="token function">walk</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> a<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"uvmunmap: walk"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>pte <span class="token operator">&amp;</span> PTE_V<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"va=%ld pte=%ld\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> <span class="token operator">*</span>pte<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"uvmunmap: not mapped"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">PTE_FLAGS</span><span class="token punctuation">(</span><span class="token operator">*</span>pte<span class="token punctuation">)</span> <span class="token operator">==</span> PTE_V<span class="token punctuation">)</span>                <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"uvmunmap: not a leaf"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>do_free<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                uint64 pa <span class="token operator">=</span> <span class="token function">PTE2PA</span><span class="token punctuation">(</span><span class="token operator">*</span>pte<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">kfree</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>pa<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token operator">*</span>pte <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h2><p>最艰难的工作已经做完了，我们只要修改 uvmcopy 就能下班了！这里的修改只是加入一个简单的分类，在遇到普通页时走普通流程，遇到超级页时走超级流程。咱就直接放代码了：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">uvmcopy</span><span class="token punctuation">(</span><span class="token class-name">pagetable_t</span> old<span class="token punctuation">,</span> <span class="token class-name">pagetable_t</span> new<span class="token punctuation">,</span> uint64 sz<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">pte_t</span> <span class="token operator">*</span>pte<span class="token punctuation">;</span>    uint64 pa<span class="token punctuation">,</span> i<span class="token punctuation">;</span>    uint flags<span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>mem<span class="token punctuation">;</span>    <span class="token keyword">int</span> szinc<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> sz<span class="token punctuation">;</span> i <span class="token operator">+=</span> szinc<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// super page case</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pte <span class="token operator">=</span> <span class="token function">l1walk</span><span class="token punctuation">(</span>old<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">PTE_LEAF</span><span class="token punctuation">(</span><span class="token operator">*</span>pte<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            szinc <span class="token operator">=</span> SUPERPGSIZE<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>pte <span class="token operator">&amp;</span> PTE_V<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"uvmcopy: page not present"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            pa <span class="token operator">=</span> <span class="token function">PTE2PA</span><span class="token punctuation">(</span><span class="token operator">*</span>pte<span class="token punctuation">)</span><span class="token punctuation">;</span>            flags <span class="token operator">=</span> <span class="token function">PTE_FLAGS</span><span class="token punctuation">(</span><span class="token operator">*</span>pte<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>mem <span class="token operator">=</span> <span class="token function">superalloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token keyword">goto</span> err<span class="token punctuation">;</span>            <span class="token function">memmove</span><span class="token punctuation">(</span>mem<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>pa<span class="token punctuation">,</span> SUPERPGSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">mapsuperpages</span><span class="token punctuation">(</span>new<span class="token punctuation">,</span> i<span class="token punctuation">,</span> SUPERPGSIZE<span class="token punctuation">,</span> <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>mem<span class="token punctuation">,</span> flags<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">superfree</span><span class="token punctuation">(</span>mem<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">goto</span> err<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// regular page case</span>        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            szinc <span class="token operator">=</span> PGSIZE<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pte <span class="token operator">=</span> <span class="token function">walk</span><span class="token punctuation">(</span>old<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"uvmcopy: pte should exist"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>pte <span class="token operator">&amp;</span> PTE_V<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"uvmcopy: page not present"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            pa <span class="token operator">=</span> <span class="token function">PTE2PA</span><span class="token punctuation">(</span><span class="token operator">*</span>pte<span class="token punctuation">)</span><span class="token punctuation">;</span>            flags <span class="token operator">=</span> <span class="token function">PTE_FLAGS</span><span class="token punctuation">(</span><span class="token operator">*</span>pte<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>mem <span class="token operator">=</span> <span class="token function">kalloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token keyword">goto</span> err<span class="token punctuation">;</span>            <span class="token function">memmove</span><span class="token punctuation">(</span>mem<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>pa<span class="token punctuation">,</span> PGSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">mappages</span><span class="token punctuation">(</span>new<span class="token punctuation">,</span> i<span class="token punctuation">,</span> PGSIZE<span class="token punctuation">,</span> <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>mem<span class="token punctuation">,</span> flags<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">kfree</span><span class="token punctuation">(</span>mem<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">goto</span> err<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>err<span class="token operator">:</span>    <span class="token function">uvmunmap</span><span class="token punctuation">(</span>new<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> i <span class="token operator">/</span> PGSIZE<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Inspect-a-user-process-page-table&quot;&gt;&lt;a href=&quot;#Inspect-a-user-process-page-table&quot; class=&quot;headerlink&quot; title=&quot;Inspect a user-process pag</summary>
      
    
    
    
    <category term="公开课" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"/>
    
    <category term="MIT-6.S081" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/MIT-6-S081/"/>
    
    <category term="Labs" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/MIT-6-S081/Labs/"/>
    
    
  </entry>
  
  <entry>
    <title>探索日志[3]</title>
    <link href="http://rinevard.github.io/wiki/others/thoughts/%E6%8E%A2%E7%B4%A2%E6%97%A5%E5%BF%973/"/>
    <id>http://rinevard.github.io/wiki/others/thoughts/%E6%8E%A2%E7%B4%A2%E6%97%A5%E5%BF%973/</id>
    <published>2025-10-27T13:56:16.000Z</published>
    <updated>2025-10-28T02:14:10.603Z</updated>
    
    <content type="html"><![CDATA[<p>书接上上上回（探索日志[0]），今天和上上次参加 Ludum Dare Compo 结识的朋友一起吃饭了，难道说我就要失去社恐属性和宅属性了吗！</p><p>总之就是他这几天来北京玩，我就鼓起勇气问他要不要来找我玩（其实很大程度上是为了水一篇探索日志，探索日志驱动探索），然后今天就一起吃了披萨薯条炸鸡。</p><p><img src="/images/others/random_thoughts/explore3/rubatotree_food.jpg" alt="好吃的"></p><p>感觉自己宅的很大原因是互联网太有趣了。今天也没有和他一起到处玩（根据我的经验和想象，人们一般是会在相聚时去一些地点闲逛的），而是在饭店边吃饭边玩游戏顺便闲聊。咱还给他试了试最近做的新原型（探索日志[2]，感觉探索日志的相互引用都可以变成节点图了），感觉还不错。然后我们就在饭店待了两个多小时，直到他去赶高铁回学校。</p><p>我还蛮喜欢这样的交流的，果然还是要主动去和别人结交才行。好耶，这又是一个水探索日志的机会。等我下次 gamejam 看到喜欢的游戏就去找作者加好友，成功了就水一篇，失败了也能水一篇。当然，如果只是把范围局限在游戏领域也太狭窄了，不过等我水完再说吧。</p><p>为什么酒店叫酒店呢，它在字面上看起来很像饭店，却是居住的地方。我上网搜了一下（如我所言，互联网太有趣了），这是因为它是从 “Hotel” 翻译过来的。对清末的中国上层社会，”Hotel” 的第一功能是饮宴，而非住宿。传统中国贵人出行都带着仆人，所以 “Hotel” 的小间对他们并不是住宿的地方，而只是聚宴的地方，所以被翻译成了“酒店”。</p><p>有趣的生活太多了，一个人是体验不过来的，所以要认识更多的经历过有趣生活的人，才能看到更多有趣的体验。</p><p>又或许人们只是因为碰巧相遇，才碰巧认识了彼此吧。</p><p>当然还是要炫耀一下收到的小卡片的！</p><p><img src="/images/others/random_thoughts/explore3/rubatotree_shielded_card.jpg" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;书接上上上回（探索日志[0]），今天和上上次参加 Ludum Dare Compo 结识的朋友一起吃饭了，难道说我就要失去社恐属性和宅属性了吗！&lt;/p&gt;
&lt;p&gt;总之就是他这几天来北京玩，我就鼓起勇气问他要不要来找我玩（其实很大程度上是为了水一篇探索日志，探索日志驱动探索），</summary>
      
    
    
    
    <category term="杂谈" scheme="http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    <category term="碎碎念" scheme="http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
  </entry>
  
  <entry>
    <title>探索日志[2]</title>
    <link href="http://rinevard.github.io/wiki/others/thoughts/%E6%8E%A2%E7%B4%A2%E6%97%A5%E5%BF%972/"/>
    <id>http://rinevard.github.io/wiki/others/thoughts/%E6%8E%A2%E7%B4%A2%E6%97%A5%E5%BF%972/</id>
    <published>2025-10-27T13:56:15.000Z</published>
    <updated>2025-10-28T02:16:47.945Z</updated>
    
    <content type="html"><![CDATA[<p>陪跑了 Supercell 举办的 Global AI Game Hack. 虽然感觉自己做的游戏并不比获奖作品差，但无所谓了，我做出了自己满意的作品。</p><p><img src="/images/others/random_thoughts/explore2/wtf.png" alt=""></p><p>只是陪跑是称不上探索的（又不是第一次陪跑了）。这次主要是尝试做了以前构思过，但感觉“这根本做不到！”的作品，而且还做出来了。</p><p>我们该怎样做一个基于 LLM 的游戏？我的第一个答案是<a href="https://rinevard.itch.io/myriad-by-cards">牌生万物</a>，这是一个把卡牌放到一起让 AI 基于堆在一起的卡牌讲故事的游戏。一些试玩的玩家还挺喜欢这个游戏，不过介于 AI 很难写出有意义的故事，我简单改了改就没有继续做下去了（现在它叫做《西行牌录》）。</p><p>让我们回到之前的问题，我们该怎样做一个基于 LLM 的游戏？我们当然会想，如果让每个 NPC 都由 LLM 驱动，这个世界就会有无穷的可能性。这是我一开始就反对的答案。我认为 AI 回复的信息密度太低，还会胡编乱造，没有任何意义。更何况两个 AI 之间聊了几句就会开始相互复读了。不过后来玩到了一个 AI 会相互交互聊天的游戏，亲身进入一个 NPC 有自己的生活的游戏感觉超酷！当然我还是不认为这个东西有什么拓展空间，不过确实挺酷的。</p><p>那这次我的答案是什么呢？我想带来尽可能多的可能性，让玩家能做到他们能想到的大部分事情。以前我玩到过允许自定义规则的 LLM 游戏，但作者的实现方法是让 LLM 拼凑一堆预制的规则组件，于是经常出现“我想要这个规则但 AI 写不出来”的情况。因此我想，如果要真正做到尽可能多的可能性，就只能把整个游戏状态都交给 LLM 管理。</p><p>听上去就做不到不是吗？我想出这个想法时也感觉“这根本做不到！文字就算了，动画怎么办？还有更多更多的东西怎么办？”，因此没有去做。但如上文所言，我在这次 hackathon 试着做了这个想法（为什么它不叫 gamejam 而叫 hackathon 呢，明明是做游戏…）。</p><p>我见过的许多游戏设计资料都告诉我，“原型是很可能失败的，找到失败之处就是原型制作的目的。”但你我皆知我们都有对失败的恐惧。在面对一个看上去就做不到的概念时，我对“实现这个概念”的预期就是失败，即使是这样也要做下去吗…</p><p>即使是朝着失败也要做下去吗？几周前参加的 Ludum Dare 还提前一天出结果了，撞上了这个 hackathon 的开头，我也没拿到满意的成绩。即使是这样也要做下去吗？我是不是根本做不出有趣的游戏？</p><p>我看向了 Jeremy Ryan，Hope Falters 的作者（这是我最喜欢的游戏之一），想看看 ta 在最开始时做出的作品是怎样的。我看向了一些别的我喜欢的作者，想看看他们在最开始时做出的作品是怎样的。我看向了一些做了很久游戏但做的还是很糟糕，但还是在做游戏的作者。我看向了几个年龄小于我，排名也小于我的作者。即使是这样也要做下去吗？</p><p>无所谓了，即使是这样也要做下去。而如开头所言，陪跑了。</p><p>但至少我的朋友在玩了我的游戏以后发出了“这居然会陪跑吗”的声音，至少在试玩时几个玩家都挺喜欢的，这就好了。</p><p>嗯，即使要放弃，也要等到大家都不喜欢的那天吧。</p><p>给这个游戏剪辑的笨蛋小视频，可能不符合文章氛围，慎点：<a href="https://youtu.be/P-J1xkifbYA">https://youtu.be/P-J1xkifbYA</a></p><p>说完情绪上的挣扎了，不妨再来聊聊设计。你知道的，我一直都喜欢随便聊聊游戏设计上的东西。</p><p>在得到了“把整个游戏状态都交给 LLM 管理”这个概念后，我脑海中就呈现出了这个游戏现在的样子——让玩家组合词汇来创造魔法，LLM 解析魔法并改变场面。不过我感觉自己以前的设计都是除了概念一无是处的设计，所以这次想试试之前看到的“注重外围设计”的做法。</p><p>据我理解，外围设计就是在核心概念之外做一些设计来呈现这个概念的可能性。比如说俄罗斯方块的概念可能是“凑满一行就消除”，外围设计就是不同形状的积木。如果积木只有正方形和长条，游戏也能工作，但就没有现在这么丰富的可能性了。</p><p>这次我做的外围设计包括用于掩饰生成速度较慢的 TTS 旁白、一些手动设计的高概念词汇。</p><p>写到这里突然有些疑惑。既然在得到了这个“LLM 管理游戏状态”的概念后我就想出了这个游戏现在的样子，那我为什么会感觉“这根本做不到”呢？我不知道，可能只是恐惧失败吧。</p><p>《游戏设计艺术》向读者发出的最后一个问题是：“为什么我要做现在在做的事”。贯彻一个主题的作品会变得更加有力，我们每个人也都有自己的主题。那么我为什么要做游戏，我的主题又是什么？我会寻找答案。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;陪跑了 Supercell 举办的 Global AI Game Hack. 虽然感觉自己做的游戏并不比获奖作品差，但无所谓了，我做出了自己满意的作品。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/others/random_thoughts/explore2/wtf</summary>
      
    
    
    
    <category term="杂谈" scheme="http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    <category term="碎碎念" scheme="http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
  </entry>
  
  <entry>
    <title>如何在七天内制作游戏原型</title>
    <link href="http://rinevard.github.io/wiki/others/translation/%E4%B8%83%E5%A4%A9%E5%8E%9F%E5%9E%8B/"/>
    <id>http://rinevard.github.io/wiki/others/translation/%E4%B8%83%E5%A4%A9%E5%8E%9F%E5%9E%8B/</id>
    <published>2025-10-15T13:47:11.000Z</published>
    <updated>2025-10-15T14:10:39.846Z</updated>
    
    <content type="html"><![CDATA[<p>翻译自 <a href="http://miami.lgrace.com/documents/How%20to%20Prototype%20a%20Game%20in%20Under%207%20Days.pdf">How to Prototype a Game in Under 7 Days</a></p><p>来自四位在一个学期内做了超过 50 款游戏的研究生的心得</p><p>作者：Kyle Gabler, Kyle Gray, Matt Kucic 和 Shalin Shodhan</p><p><img src="/images/others/translation/how_to_prototype_seven_day/1_tower_of_goo.jpg" alt="&quot;黏黏世界&quot;在上线数月内下载量就超过了10万次。"></p><p>这里有一个疯狂的游戏点子：拖动那些会说垃圾话的粘液球，建造一座越来越高的巨塔。它们蠕动、咯咯笑，并爬上兄弟们的背向上攀爬。但要小心！这是一场与重力的持久战。如果你建造的塔太不稳定，它就会倒塌。</p><p>“黏黏世界”在上线数月内下载量超过了10万次，在一本杂志中被誉为“月度网络游戏”，在G4频道和GDC的实验性游戏工作坊上进行了演示，并且是我们在卡内基梅隆大学娱乐技术中心的实验性游戏项目中所制作的五十多款游戏之一。</p><p>和其余的游戏一样，它也是由一个人在一周之内完成的。</p><p>该项目始于2005年春季，目标是尽可能多地发现新的游戏玩法并给它们做原型。我们四名研究生组成了团队，把自己关在房间里，一个学期都遵守着下面三条规则：</p><ol><li>每个游戏必须在七天内完成，</li><li>每个游戏必须由一个人完成，</li><li>每个游戏必须基于一个共同的主题，例如“重力”、“植被”、“蜂群”等。</li></ol><p>随着项目进行，我们对蜂拥而至的流量、游戏杂志的关注以及行业专业人士和学者们都问着的同样的问题感到惊讶和激动：“你们是如何这么快地制作这些游戏的？”以及“我们该怎么做？”</p><p>我们在这里将一切全盘托出。结合以下的建议、技巧和例子，我们将讨论那些有用的和没用的方法。我们将向你展示如何进入快速原型制作的思维状态，如何组建一个高效的团队，以及如果你想过创造新东西但不知从何下手时应该从哪里开始。我们希望这些经过认真验证的指南对你的下一个项目，无论大小，能派上用场！</p><p>为了便于阅读，本文的建议和技巧会被分为四个部分：准备、设计、开发和通用的技巧。祝你阅读愉快！</p><h2 id="准备：快速是一种心态"><a href="#准备：快速是一种心态" class="headerlink" title="准备：快速是一种心态"></a>准备：快速是一种心态</h2><p>快速原型不仅是前期制作中的一个有用工具——它还可以成为一种生活方式！本节将展示如何准备并开始像一个快速原型制作者那样思考。</p><h3 id="拥抱失败的可能性——它鼓励创造性冒险"><a href="#拥抱失败的可能性——它鼓励创造性冒险" class="headerlink" title="拥抱失败的可能性——它鼓励创造性冒险"></a>拥抱失败的可能性——它鼓励创造性冒险</h3><p>“风险”对我们的影响太大了。据我们所知，对失败的恐惧是电影IP改编游戏和续作高达两位数的游戏不断被制作出来的原因。这就像总是选择去麦当劳，而不是一家未曾探索过的新餐厅——总是依赖于一个众所周知的、尚可的选项，而不是冒险尝试未知但可能美味的选择。</p><p>一个好的快速原型制作者会知道失败是可以接受的！找到失败之处就是原型制作的目的，所以尽情去做吧！即使你失败了，也还会有无数的机会，而且很可能你总能学到些东西。只有拥抱失败，才可能做出有价值的实验。</p><p>Mr. Gray：“《Mime After Mime》和《A Mime to Kill》是我做的两款只有声音没有画面的游戏。尽管它们是彻头彻尾的失败品，但整个团队都为能冒如此大的风险来证明纯音频游戏的失败而感到兴奋，我可以自豪地说它们是我做的。随着我在整个项目中积累经验，我逐渐能进行更有针对性的冒险，它们带来了成功的游戏。”</p><p><img src="/images/others/translation/how_to_prototype_seven_day/2_mine_after_mine_and_a_mime_to_kill.png" alt="&quot;Mime After Mime&quot;和&quot;A Mime to Kill&quot;——热情拥抱失败。"></p><h3 id="强制缩短开发周期（更多时间-更高质量）"><a href="#强制缩短开发周期（更多时间-更高质量）" class="headerlink" title="强制缩短开发周期（更多时间 != 更高质量）"></a>强制缩短开发周期（更多时间 != 更高质量）</h3><p>你只需要几天时间。有一种很自然的想法是：“我们一周做了一个很棒的游戏。所以如果我们花两周时间，它会好上两倍！”。当然，事实并非如此。我们发现，通常任何游戏点子都可以在不到一周的时间内有效地进行原型设计。多余的时间往往会产生递减的回报。例如，一些原型只用了一个晚上就完成了，而另一些则多花了一两周的时间。令人惊讶的是，我们发现开发时间与游戏最终的成功程度之间没有关联。</p><p><img src="/images/others/translation/how_to_prototype_seven_day/3_left_and_right.jpg" alt="&quot;Attack of the Killer Swarm&quot;（左）只用了一天时间就完成了，并出人意料地成为该项目中评价最高的游戏之一。&quot;Suburban Brawl&quot;（右）多花了一周的时间，但变得过于复杂。如果没有花时间添加那些巨型杀手机器人，它可能会更有趣。"></p><h3 id="对创造的约束让你更想创造"><a href="#对创造的约束让你更想创造" class="headerlink" title="对创造的约束让你更想创造"></a>对创造的约束让你更想创造</h3><p>我们最成功的游戏都源于特定的主题或“玩具”，比如“重力”、“蜂群”，或者“制作一款主要面向女性休闲玩家的游戏”。不知为什么，在有限制的情况下，创造变得更容易了。</p><p>此外，当一个团队的人都围绕一个特定主题同时做原型时，我们都倾向于避免使用那些显而易见的机制。这种挑战让我们去探索并挖掘主题中所有可能的游戏玩法。</p><p>在项目后期，我们逐渐偏离了这种模式，这最终对我们造成了损害。没有了主题约束，游戏制作时间更长，方向性更差，团队凝聚力也下降了。那种“我们都在一条船上”的感觉减少了，更糟糕的是，我们失去了那种曾激发额外创造力和技巧的友好竞争感。</p><p>我们探索过的一些主题有：“重力”、“弹簧”、“进化”、“声音”、“捕食者与猎物”、“令人上瘾的游戏”、“绘画”、“指数增长”、“植被”、“平衡”，以及其他一些个人主题。</p><p><img src="/images/others/translation/how_to_prototype_seven_day/4_gravity_head.jpg" alt="&quot;Gravity Head&quot;"></p><h3 id="组建一支优秀的团队和一位客观的顾问——心态与才华同等重要"><a href="#组建一支优秀的团队和一位客观的顾问——心态与才华同等重要" class="headerlink" title="组建一支优秀的团队和一位客观的顾问——心态与才华同等重要"></a>组建一支优秀的团队和一位客观的顾问——心态与才华同等重要</h3><p>团队中的每个成员都必须熟悉游戏开发的所有方面。每个人都负责自己的编程、美术、声音以及最终产品中的其他一切。但能力并非一切。理想情况下，每个人都必须以这样的理解来对待这种开发方式：设计是至高无上的——从美术到工程的一切都只是为最终设计服务。一个深谙此道的平庸工程师很可能比一个没有这种心态的优秀工程师更成功。</p><p>项目顾问 Jesse Schell 说：”我一直痴迷于产生新游戏创意的过程，所以当 Shalin、Matt 和两位 Kyle 提出这个项目时，我自然感到非常激动。我把它看作一个在创造力方面进行对照实验的机会，并希望能学到有用的游戏设计知识。作为指导老师，我努力确保团队尝试多种不同的技术、从错误中学习、不在行不通的想法上纠结太久，并努力保证每个人都在寻找最适合自己的创作过程。”</p><p>“我对如何改进游戏提出过一些建议，但大多数时候我尽量不干涉。我感觉自己有点像个园丁——我做了一些浇水和除草的工作，但开花结果全靠他们。正如这篇论文所示，团队能够得出一些非常有用的结论——并且最终做出了一些好游戏！关于创作过程的优化还有更多东西需要学习，卡内基梅隆大学娱乐技术中心计划继续进行这个项目。”</p><p><img src="/images/others/translation/how_to_prototype_seven_day/5.jpg" alt="&quot;我们的团队，永远的实验性朋友！&quot;"></p><h3 id="并行开发以最大化效果"><a href="#并行开发以最大化效果" class="headerlink" title="并行开发以最大化效果"></a>并行开发以最大化效果</h3><p>那么，一旦我们组建了团队，我们做了什么？我们各自独立工作！这听起来可能很奇怪，但独立工作的好处实在太大了，不容忽视：</p><ul><li>缓解风险：通过同时开发四个原型，我们可以在做出冒险的设计决策时感到安心，因为至少有一两个可能会成功。</li><li>友好竞争：每个人都因只专注于自己而受益。就像资本主义一样！</li><li>更广泛的主题探索：我们四个人都专注于同一个主题，这迫使我们深入思考主题。如果我们都做了一样的游戏，那该多尴尬啊！这迫使我们进入一些有益的创作领域，并让我们避免了显而易见的切入点。</li><li>分享与关怀：虽然我们没有共享代码（可以共享也可以不共享），但我们发现分享概念和理解很有帮助。例如，如果一个团队成员发现了一种表示弹簧系统的有效方法，每个人都会受益。</li></ul><p>随着几周过去，我们发现团队合作在每个周期的开始和结束时最有价值。在每个周期开始时，团队合作有助于提炼和比较想法。一旦进入开发阶段，我们发现合作更多是一种干扰——因为每个人都完全沉浸在自己的工作中。到每个周期结束时，我们会回到房间里一起工作到凌晨，体验竞赛快结束的感觉。这种合作价值随时间变化的图表可能像这样：</p><p><img src="/images/others/translation/how_to_prototype_seven_day/6_time_to_value.jpg" alt="&quot;合作价值&quot;随&quot;时间&quot;的变化。"></p><h2 id="设计：头脑风暴的神话和创造力"><a href="#设计：头脑风暴的神话和创造力" class="headerlink" title="设计：头脑风暴的神话和创造力"></a>设计：头脑风暴的神话和创造力</h2><p>一个好点子可能在瞬间产生，但等待点子可能是一种煎熬。没有办法强迫一个好点子迸发出来，但这一部分内容应该能帮助你培养你的创造力。</p><h3 id="正式头脑风暴的成功率为-0"><a href="#正式头脑风暴的成功率为-0" class="headerlink" title="正式头脑风暴的成功率为 0%"></a>正式头脑风暴的成功率为 0%</h3><p>我们真的很努力了——天呐，我们真的希望头脑风暴能奏效！我们安排了“头脑风暴会议”和“圆桌会议”，我们用不同颜色的记号笔在白板和超大便利贴上写画，我们甚至用了像“蓝天”这样的激励性短语来帮助我们摆脱思维定势。但最终，在我们创造的所有游戏中，没有一个是通过大家坐在一起进行头脑风暴会议得出的结果。</p><p>为什么会这样？我们也非常震惊。但经过一番调查，我们发现创造力确实是无法规划的。你不能说：“大家4:15开个会头脑风暴一下，到5:00我们就能拿出四个超棒的游戏点子！”</p><p>但头脑风暴并非无用。通过精心组织头脑风暴会议，我们仍然可以期待（至少）两件合理的事情。第一，当然是让所有人都开始思考。在开始思考后，过了一会儿，或许在回家的路上，或许在洗澡时，又或许在遛狗时，一个绝妙的点子会在你的脑海中迸发出来。当然，也或许不会。但据我们所知，神秘的大脑在我们最不经意间做了大量的思考。</p><p>第二，当有具体的东西可以讨论时，头脑风暴就有用了。比如，“我们如何改进这个？”比“让我们随便想点什么！”更好。又如，给出一个半成形的点子并让其他人来充实它是相当有用的。比起创作者，人们更适合当评论家，不是吗？</p><h3 id="收集概念艺术和音乐以创造情绪目标"><a href="#收集概念艺术和音乐以创造情绪目标" class="headerlink" title="收集概念艺术和音乐以创造情绪目标"></a>收集概念艺术和音乐以创造情绪目标</h3><p>作为头脑风暴的替代品，我们发现收集一些具有个人意义的艺术和音乐特别有用。人们评论说，许多游戏如“Gravity Head”和“On a Rainy Day”创造了引人入胜的氛围并具有强烈的情感吸引力。这不是偶然的。在许多情况下，配乐和初期美术共同创造了一种感受，推动了玩法、故事和最终美术的设定。</p><p>Mr. Gabler：“《黏黏世界》的想法是我在回家路上听 Astor Piazzolla 的《Tango Apasionado》开头时产生的，我脑海中浮现出一个日落时分小镇的朦胧景象，每个人都离开家，搬出椅子、桌子和任何他们能找到的东西，在市中心建造一座巨塔。我不知道确切原因，但他们想往上爬，再往上爬——但他们不是很好的土木工程师，所以你需要帮助他们。最终的原型变得更欢快一些，我把音乐换成了 Piazzolla 的更欢快的《Libertango》。这是一个初始情绪目标造就了整个游戏的例子。”</p><p><img src="/images/others/translation/how_to_prototype_seven_day/7_goo_prototype.jpg" alt="探戈音乐和爬得越来越高的小人……"></p><h3 id="在脑中模拟——做原型的原型"><a href="#在脑中模拟——做原型的原型" class="headerlink" title="在脑中模拟——做原型的原型"></a>在脑中模拟——做原型的原型</h3><p>这真的很简单！你要做的就是想象你的游戏玩家说：“哇！”然后倒推并填补空白。是什么让他们享受你的游戏？他们感受到了什么？游戏中是什么让他们有了这种体验？</p><p>对我们的那些最成功的游戏来说，我们并不对它们变得好玩感到意外——在最好的情况下，我们在接触任何一行代码之前就知道这个想法是靠谱的，因为我们已经在思维里模拟过了游戏。反之亦然，没有一个游戏是出乎意料地成功的，我们总是先知先觉。（可惜的是，这并没有阻止我们去追求那些半生不熟的想法。）</p><p>在你的脑海中模拟也使得最终原型的开发变得非常容易，因为你会确切地知道你将要做什么。你不会为了在设计上“试错”浪费时间修改代码。</p><p>一位团队成员承认：”我经常在一周的前3、4天里，只是为了’灵感’而闲逛看 O-Zone 音乐视频、倒挂在懒人沙发上听音乐、偶尔运行一些糟糕的大脑模拟。最后周四或周五来临时，我会感到恐慌，因为我仍然不知道周一要交什么，所以我就会采纳最强的那个想法，并根据本周自己喜欢上的东西进行调整，直到感觉像一个有趣的游戏，然后接下来几天熬夜写代码和画画。对我来说（我想对我们所有人来说），花在’前期制作’上的日子无疑比花在实际开发上的日子更有价值。”</p><p><img src="/images/others/translation/how_to_prototype_seven_day/8_rainy_day.jpg" alt="&quot;On a Rainy Day&quot;的早期纸上原型——在脑中模拟时很有帮助。"></p><h2 id="开发：没人知道你是怎么做的，也没人在乎"><a href="#开发：没人知道你是怎么做的，也没人在乎" class="headerlink" title="开发：没人知道你是怎么做的，也没人在乎"></a>开发：没人知道你是怎么做的，也没人在乎</h2><p>一旦你有了一个好点子，这里有一些技巧可以让你迅速做出一个 demo！</p><h3 id="先做玩具"><a href="#先做玩具" class="headerlink" title="先做玩具"></a>先做玩具</h3><p>从核心机制开始。无论是弹簧系统、群体行为、重力等等，花不了几个小时就能把游戏主题做出来。这个“玩具”应该是游戏的核心机制。它不需要任何目标或决策，没有输赢，只是一个好玩的东西。</p><p>Mr. Gabler：“对《Super Tummy Bubble》来说，‘玩具’只是一堆悬浮在小容器里的泡泡。我玩了一会儿这个玩具，把泡泡扔来扔去，然后调整了一下直到我感觉手指戳进泡泡里很有趣。之后，是时候加入一些游戏性了。在这个游戏里，游戏性包括寄生着不同虫子的泡泡、‘戳破’的概念、‘连锁’的概念、分数计数器等。”</p><p><img src="/images/others/translation/how_to_prototype_seven_day/9_left_and_right.jpg" alt="&quot;Super Tummy Bubble&quot;——玩具（左）vs. 最终原型（右）。"></p><h3 id="如果能偷懒，那就偷懒"><a href="#如果能偷懒，那就偷懒" class="headerlink" title="如果能偷懒，那就偷懒"></a>如果能偷懒，那就偷懒</h3><p>这可以说是这个项目最重要的教训之一。通常“正确”的解决方案并非最佳解决方案。有策略地偷懒会为你节省时间和金钱；它会让你的游戏更快，你的牙齿更白。大胆地、经常地偷懒！如果一个简单的阴影和烘焙纹理同样有效，就不要设置复杂的光照和阴影（《Darwin Hill》）。如果你可以用同样的效果蒙混过关，就不要为了分析用户的绘画而设置复杂的模式识别系统（《Suburban Brawl》）。当快速拉伸的位图能更快更容易地达到同样效果时，就不要绘制样条曲线或创建自己的矢量艺术库（《黏黏世界》）。我们发现，这条规则也是生活中一条极好的通用法则。懒人们，注意了。</p><p><img src="/images/others/translation/how_to_prototype_seven_day/10_left_mid_right.jpg" alt="&quot;Darwin Hill&quot;、&quot;Suburban Brawl&quot;、&quot;黏黏世界&quot;——都是假的，而且没人注意到。嘘！"></p><h3 id="及时止损，割舍心头之爱"><a href="#及时止损，割舍心头之爱" class="headerlink" title="及时止损，割舍心头之爱"></a>及时止损，割舍心头之爱</h3><p>在项目开始时，我们有一种想要挽救一切的愿望——再多花一点时间和精力，一个糟糕的游戏肯定会变成天才之作！我们有一个这样的注定失败的原型——它始于一个美丽的弹簧系统。它能挤压和拉伸，让你想抓住它并到处拉扯，但它就是没有变成一个引人入胜的游戏。最初的弹簧系统机制只花几个小时就创建好了，但随后它却耗费了整整一周的编码和重构时间。这是一次可悲的尝试，试图强行将这个机制变成一个游戏。</p><p>快速识别走不通的想法、及时止损并继续前进非常重要。我们发现，顺其自然比花时间试图挽救现有的东西更有价值。如果以后灵光一闪，你总可以再回来。</p><p>Mr. Kucic：“我的‘土豆’最终成为了一个在 Flash 中构建的完美的软体模拟系统，唯一的问题是它一点也不好玩。它给我带来的头痛比死亡金属还多。我浪费了一周时间，而它甚至都不能动。你得知道什么时候该继续，什么时候该放弃。”</p><p><img src="/images/others/translation/how_to_prototype_seven_day/11_circle.png" alt="&quot;马特的土豆&quot;——沐浴在它的荣耀中。"></p><h3 id="漂亮的包装无法挽救糟糕的设计（或者说，“烂泥扶不上墙”）"><a href="#漂亮的包装无法挽救糟糕的设计（或者说，“烂泥扶不上墙”）" class="headerlink" title="漂亮的包装无法挽救糟糕的设计（或者说，“烂泥扶不上墙”）"></a>漂亮的包装无法挽救糟糕的设计（或者说，“烂泥扶不上墙”）</h3><p>我们发现游戏玩家比你想象的要聪明，他们能看穿你是否在耍花招。如果游戏玩法很糟糕，那就没救了——世界上所有的美术、音乐和联动都无法让它成为一个好游戏。这就像是给一个无趣的游戏机制加入最新的3D动画电影角色，没人会被糊弄。</p><p>Mr. Gray：“《Spin to Win》的‘游戏玩法’是旋转你的鼠标来转动多个圆圈。为了掩盖它不好玩的事实，我用60年代《Bewitched》风格的艺术和音乐给游戏做了漂亮的包装。但无论我怎么打磨这个游戏，它都有趣不起来。尽管我付出了所有的爱，它还是很快就成了网站上最被讨厌的游戏之一。”</p><p><img src="/images/others/translation/how_to_prototype_seven_day/12_spin_to_win.jpg" alt="&quot;Spin to Win&quot;——盛装打扮却无处可去。"></p><h3 id="但整体美学很重要！合理运用美术、音效和音乐"><a href="#但整体美学很重要！合理运用美术、音效和音乐" class="headerlink" title="但整体美学很重要！合理运用美术、音效和音乐"></a>但整体美学很重要！合理运用美术、音效和音乐</h3><p>这实际上与我们最初的一个假设相反。我们当时认为美术和音效根本不会对原型有影响，但我们错了！玩一个精心打磨的游戏实际上比玩有着完全相同的代码，但艺术粗糙、音效差的游戏感觉更好。不过，重要的是要做出以下区分——单纯打磨美学无法挽救糟糕的设计，但它确实有能力让一个好游戏变得更好玩。这并不意味着你需要极其精美的图形或环绕声。这只是说你可以通过将所有东西紧密结合起来而受益。记住，即使是“蹩脚”也可以是一种紧密结合的美学，只要你以正确的方式呈现它。</p><p><img src="/images/others/translation/how_to_prototype_seven_day/13_unrealeased_tree.jpg" alt="一个未发布的原型——不复杂的美术也能在构图上感觉坚实。"></p><h3 id="没人关心你的代码质量"><a href="#没人关心你的代码质量" class="headerlink" title="没人关心你的代码质量"></a>没人关心你的代码质量</h3><p>再次强调，值得注意的是，一个伟大的工程师不一定能成为一个伟大的原型制作者。”正确”和”可复用”的方案通常不是我们在快速、一次性代码中所寻求的。对于每个问题，你应该能够想出一大堆解决方案，并选择那个能最快做完的方案。用户永远不会看到你伟大的代码，他们也不在乎。</p><p>Mr. Shodhan：“代码的过度设计很容易让我们做出一些通用工具或技术演示，但他们并不可玩。这就像是一个摇滚明星沉浸在自己的艺术中，而观众在打哈欠！对‘进化’那个主题，我用细分曲面和卡通渲染效果做了一个程序，通过杂交祖先树来进化3D模型。这里有很多很酷的技术，但完全没有游戏性！”</p><p><img src="/images/others/translation/how_to_prototype_seven_day/14_evolution_tree.png" alt="&quot;进化树&quot;——所有这些技术加起来并不等于乐趣。"></p><p><img src="/images/others/translation/how_to_prototype_seven_day/15_rubber_ball.jpg" alt="一个橡胶球。小心，3D技术！"></p><h2 id="通用的技巧：关于营造多汁乐趣的教程"><a href="#通用的技巧：关于营造多汁乐趣的教程" class="headerlink" title="通用的技巧：关于营造多汁乐趣的教程"></a>通用的技巧：关于营造多汁乐趣的教程</h2><p>除了在原型制作方面吸取了惨痛的教训外，我们还偶然发现了一些通用的准则。以下是一些显著增加“乐趣”的准则。</p><h3 id="复杂不一定有趣"><a href="#复杂不一定有趣" class="headerlink" title="复杂不一定有趣"></a>复杂不一定有趣</h3><p>如果人类以“球和平面”这个主题的变体来娱乐自己数千年，我们可能在这些新奇的视频游戏上做得太过头了。我们完全可能用基本的元素来获得乐趣。想想《俄罗斯方块》、《吃豆人》以及任何经典的街机游戏。就像罗密欧与朱丽叶的爱情故事原型一样，这些游戏的机制如此之好，以至于几十年后我们仍在使用它们。镜头光晕、凹凸贴图、泛光和其他惊人的新技术是不错，但它们不会让你的游戏更有趣。用一个简单的原型向自己证明你的核心机制值得一做，在你确信之后，把它变得漂亮。</p><h3 id="创造一种拥有感来让玩家不断重玩"><a href="#创造一种拥有感来让玩家不断重玩" class="headerlink" title="创造一种拥有感来让玩家不断重玩"></a>创造一种拥有感来让玩家不断重玩</h3><p>我们偶然发现，最具重玩价值的游戏是那些与创造或自定义相关的游戏。例如，“用手和雨伞制作一棵令人毛骨悚然的树”，或者“画你自己的房子”，或者“建造你自己的塔”，或者“进化你自己的突变生物种族”。显然我们能在许多地方中见到这种现象——游戏里的捏脸功能、自定义的手机铃声、乃至那些“与众不同，表达自我”的广告。所以，跳上这趟潮流吧！创造一种拥有感，让他们不断重玩。</p><p><img src="/images/others/translation/how_to_prototype_seven_day/16_darwin_hill.jpg" alt="&quot;Darwin Hill&quot;——每个人与众不同。"></p><h3 id="“实验性”不意味着”复杂”"><a href="#“实验性”不意味着”复杂”" class="headerlink" title="“实验性”不意味着”复杂”"></a>“实验性”不意味着”复杂”</h3><p>在项目早期，我们制作的许多游戏都太过复杂。它们的用户界面令人困惑，而且按键映射到的动作也不自然或不直观。除非我们能最小化玩家理解游戏之前的疑惑时间，否则玩家会感到沮丧，再也不玩这个游戏，甚至再也不来我们网站。幸运的是，我们发现既可以做到”实验性”，又可以保持易于理解。</p><p>Mr. Shodhan：“我的第一轮游戏‘Spaceball Munch’是老游戏‘Gorillas’的3D版本，在那个游戏里，你指定一个角度和速度，让一个猩猩向另一个猩猩扔香蕉。现在你不仅在3D环境中，更是用着弧形视角，还在一个球形场地上进行游戏。所以你要考虑两个角度和一个速度。另外，它现在也不再是一个离散的回合制游戏，而是需要控制一个连续的粒子流，同时必须击中所有这些移动的物体。这张截图展示了这种毫无意义的复杂度”</p><p><img src="/images/others/translation/how_to_prototype_seven_day/17_spaceball_munch.jpg" alt="&quot;Spaceball Munch&quot;——我们怎么能知道？！"></p><h3 id="朝着一个明确定义的目标前进"><a href="#朝着一个明确定义的目标前进" class="headerlink" title="朝着一个明确定义的目标前进"></a>朝着一个明确定义的目标前进</h3><p>人们很容易忘记设置一个明确定义的目标。没有游戏目标，一个原型就只是一个玩具，而不是一个游戏。出于某种原因，人们似乎喜欢有失败的机会。一个目标可以是任何事情——比如“在x时间内收集x个小部件”，或者“保持系统稳定”，或者“在不碰到任何坏东西的情况下穿越一个空间”。但找到一个不让人觉得牵强的目标还是很难的（比如时限一般就很牵强）。我们发现，最好的目标是游戏玩法中固有的部分，比如在《黏黏世界》中，隐含的目标就是简单地“向上建造”。</p><p><img src="/images/others/translation/how_to_prototype_seven_day/18_tower_of_goo.jpg" alt="&quot;黏黏世界&quot;——朝着一个目标……以及更远的地方建造！"></p><h3 id="让它多汁！"><a href="#让它多汁！" class="headerlink" title="让它多汁！"></a>让它多汁！</h3><p>多汁（Juicy）是我们用来形容持续且丰富的用户反馈的术语。一个多汁的游戏元素在你触摸它时会弹跳、扭动、喷射并发出一点声音。一个多汁的游戏很活泼，它对你做的每件事都有反应——一点点输入就会产生大量的回应和连锁反应，这让玩家感觉自己掌控着世界。它也在互动时不断让玩家知道自己正在做什么，引导他们了解游戏规则。</p><p>你可能经历过的一些多汁的例子可能包括：</p><ul><li>《Alien Hominid》：非常夸张的敌人爆炸和血液飞溅。</li><li>《马里奥兄弟》：在一个充满金币的房间里弹跳，叮当声很让人满足。</li><li>弹珠机：一股永无止境的球流全在你的控制之下。</li><li>《超级方块战士2 Turbo》：连击时，动画和特效层出不穷。</li></ul><p><img src="/images/others/translation/how_to_prototype_seven_day/19_left_mid_right.jpg" alt="多汁的感觉很棒！你简直停不下来。"></p><h2 id="最后的想法"><a href="#最后的想法" class="headerlink" title="最后的想法"></a>最后的想法</h2><p>这次关于实验性游戏项目的团队合作是一件非常愉快的事。我们希望下次当你尝试一些新的或有点疯狂的东西时，这些建议和技巧能对你有所帮助。谁知道呢，你今天早上有的那个小想法可能就是下一个神作。召集一些朋友或者单干，快去尝试并制作原型吧！你可能会给自己一个惊喜。</p><p>我们的顾问友好地指出，“快速原型可能很像怀一个孩子。没人指望每次都能赢，但你总是学到新东西，而且这通常很有趣！”</p><p>祝你原型制作愉快！</p><p><img src="/images/others/translation/how_to_prototype_seven_day/20_final.jpg" alt=""></p><p>此页面转载自 Gamasutra 网站：<br><a href="http://www.gamasutra.com/features/20051026/gabler_01.shtml">http://www.gamasutra.com/features/20051026/gabler_01.shtml</a></p><h2 id="便捷清单！"><a href="#便捷清单！" class="headerlink" title="便捷清单！"></a>便捷清单！</h2><ol><li><p>准备：快速是一种心态</p><ul><li>拥抱失败的可能性——它鼓励创造性冒险</li><li>强制缩短开发周期（更多时间 != 更高质量）</li><li>对创造的约束让你更想创造</li><li>组建一支优秀的团队和一位客观的顾问——心态与才华同等重要</li><li>并行开发以最大化效果</li></ul></li><li><p>设计：头脑风暴的神话和创造力</p><ul><li>正式头脑风暴的成功率为 0%</li><li>收集概念艺术和音乐以创造情绪目标</li><li>在脑中模拟——做原型的原型</li></ul></li><li><p>开发：没人知道你是怎么做的，也没人在乎</p><ul><li>先做玩具</li><li>如果能偷懒，那就偷懒</li><li>及时止损，割舍心头之爱</li><li>漂亮的包装无法挽救糟糕的设计（或者说，”烂泥扶不上墙”）</li><li>但整体美学很重要！合理运用美术、音效和音乐</li><li>没人关心你的代码质量</li></ul></li><li><p>通用的技巧：关于营造多汁乐趣的教程</p><ul><li>复杂不一定有趣</li><li>创造一种拥有感来让玩家不断重玩</li><li>“实验性”不意味着”复杂”</li><li>朝着一个明确定义的目标前进</li><li>让它多汁！</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;翻译自 &lt;a href=&quot;http://miami.lgrace.com/documents/How%20to%20Prototype%20a%20Game%20in%20Under%207%20Days.pdf&quot;&gt;How to Prototype a Game in Un</summary>
      
    
    
    
    <category term="杂谈" scheme="http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    <category term="翻译" scheme="http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/%E7%BF%BB%E8%AF%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Lab 2.1 系统调用流程——以sleep为例</title>
    <link href="http://rinevard.github.io/wiki/learning/open-course/MIT-6.S081/Labs/lab2_1-syscall_process/"/>
    <id>http://rinevard.github.io/wiki/learning/open-course/MIT-6.S081/Labs/lab2_1-syscall_process/</id>
    <published>2025-10-15T08:02:38.000Z</published>
    <updated>2025-10-19T03:44:03.330Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道应用程序在User mode下运行，而系统函数的执行需要Supervisor mode，那在系统调用时，User mode是怎么进入Supervisor mode的呢？我们以sleep的执行为例，看看都发生了什么。首先我们用 <code>git checkout util</code> 切换到 util 分支上。</p><p>在此之前，我们要先简介一下<strong>ECALL</strong>指令和<strong>stvec</strong>（Supervisor Trap Vector Base Address Register）寄存器。</p><p>ECALL 会触发一个异常，如果我们在用户态触发这个异常，程序计数器 pc 就会根据 stvec 进行跳转，到达异常处理处。</p><p>以下是 <a href="https://www.scs.stanford.edu/~zyedidia/docs/riscv/riscv-privileged.pdf">risc-v 手册</a> 对 ECALL 的解释：</p><blockquote><p>When executed in U-mode, S-mode, or M-mode, it generates an environment-call-from-U-mode exception, environment-call-from-S-mode exception, or environment-call-from-M-mode exception, respectively, and performs no other operation.</p><p>如果在 U-mode 执行，ECALL 指令会产生一个来自 U-mode 的环境调用异常；如果在 S-mode 执行，则产生来自 S-mode 的环境调用异常；如果在 M-mode 执行，则产生来自 M-mode 的环境调用异常。</p></blockquote><p>以下是 risc-v 手册对 stvec 寄存器的简介：</p><p><img src="/images/learning/open-course/MIT-6.S081/labs/lab2_1-syscall_process/stvec.png" alt=""></p><p>BASE是4字节对齐的（RISC-V 手册 P80），所以在MODE == 0时，我们跳转到的地址是 <code>(stvec &gt;&gt; 2) &lt;&lt; 2</code>，而由于 MODE == 0，这个值就是 stvec ；在MODE == 1时，我们转到的地址是 <code>(stvec &gt;&gt; 2) &lt;&lt; 2 + 4*cause</code></p><p>接下来我们就可以开始看看系统调用时究竟发生了什么！我们会以sleep为例。</p><p>首先我们打开gdb-multiarch（参考 Note 0 的”用终端调试“），然后用 <code>set prompt \\001\\033[1;33m\\002(gdb) \\001\\033[0m\\002</code> 来高亮 “(gdb)” 以方便观察自己的输入。</p><p>用 <code>file user/_sleep</code> 切换到用户符号表，接着用<code>c</code>运行到xv6的shell启动。</p><p>观察右边的终端可以看到shell已经成功启动了。</p><p><img src="/images/learning/open-course/MIT-6.S081/labs/lab2_1-syscall_process/debug_start.png" alt=""></p><p>然后我们在gdb里按下ctrl+c来中断，并用 <code>b main</code> 设置断点，再使用 <code>layout split</code> 让gdb显示出源码和汇编代码。接下来我们在gdb里输入 <code>c</code> 以让xv6继续执行，否则xv6的shell会处于暂停状态，不能处理输入。</p><p>然后在xv6的shell里执行 <code>sleep 1</code> ，它会在断点处停下。</p><p>观察左边的gdb，可以看到它停在了sleep.c的main函数。</p><p><img src="/images/learning/open-course/MIT-6.S081/labs/lab2_1-syscall_process/sleep_main.png" alt=""></p><p>随便执行一下直到到达sleep这行，<code>n</code> 表示执行一行c语言，<code>si</code>表示执行一个汇编语句。</p><p><img src="/images/learning/open-course/MIT-6.S081/labs/lab2_1-syscall_process/sleep_jal_atoi.png" alt=""></p><p>我们用<code>si</code>进入atoi，然后交替着用<code>n</code>和<code>si</code>，在快到return时用<code>si</code>，就能离开atoi回到sleep.c。</p><p>观察左边的gdb，和上图相比，虽然c语言的位置没有变化，但汇编代码的位置是有变化的。</p><p><img src="/images/learning/open-course/MIT-6.S081/labs/lab2_1-syscall_process/sleep_jal_sleep.png" alt=""></p><p>之后用<code>si</code>，会发现我们跳转到了 <code>usys.S</code>，它把sleep的系统调用号放到寄存器a7里，然后借助ecall来执行系统调用。</p><p>观察左边的gdb发现我们已经进入了<code>usys.S</code></p><p><img src="/images/learning/open-course/MIT-6.S081/labs/lab2_1-syscall_process/usys_enter.png" alt=""></p><p>如果我们直接用几个<code>si</code>，会发现<code>ecall</code>并没有像<code>jal</code>之类的跳转语句一样带我们到一些神奇的地方，而是直接到了下一行。这是因为<code>ecall</code>不是跳转，而是抛出了一个异常，内核自动处理了异常。</p><p>这样看来，我们要找到这个异常的开始处并设置断点才行。还记得我们之前说过<code>ecall</code>抛出异常时pc会跳转到哪里吗？答案是它会根据寄存器stvec的值进行跳转。让我们借助<code>p /x $stvec</code>看看stvec的值。</p><p>观察左边的gdb，发现stvec的值是 0x3ffffff000，至少在我这里是这样。</p><p><img src="/images/learning/open-course/MIT-6.S081/labs/lab2_1-syscall_process/print_stvec.png" alt=""></p><p>回顾一下stvec寄存器的结构和功能，会发现执行ecall后，pc会跳转到BASE所在的地址。我们之前说过，BASE是4字节对齐的（RISC-V 手册 P80），所以在MODE == 0时，我们跳转到的地址是 <code>(stvec &gt;&gt; 2) &lt;&lt; 2</code>，而由于 MODE == 0，这个值就是 stvec。</p><p><img src="/images/learning/open-course/MIT-6.S081/labs/lab2_1-syscall_process/stvec.png" alt=""></p><p>我们接下来把断点设置在这个值，然后用<code>si</code>到达<code>ecall</code>语句处</p><p>观察左边的gdb，我们现在已经在<code>ecall</code>这里了。</p><p><img src="/images/learning/open-course/MIT-6.S081/labs/lab2_1-syscall_process/break_ecall_target.png" alt=""></p><p>如果我们的操作正确，接下来的<code>si</code>会触发一个异常导致我们跳转到 0x3ffffff000 并触发断点，希望我们没有翻车~</p><p>观察左边的gdb，发现我们成功跳转到了一个未知的地方！</p><p>按我的理解，由于我们在U-mode下执行ecall以触发异常，所以我们现在已经进入了S-mode。不过我翻了很多资料还是没有找到能明确支持这一点的证据（也没有找到明确反对的证据），所以我保留我的观点。</p><p><img src="/images/learning/open-course/MIT-6.S081/labs/lab2_1-syscall_process/ecall.png" alt=""></p><p>总之一切顺利！让我们暂停一下，想想这个 0x3ffffff000 的地址代表什么。在内核启动时通过<code>file kernel/kernel</code> 加载内核符号表并在<code>usertrapret</code>设置断点，我们可以发现 0x3ffffff000 这个地址和 <code>kernel/trap.c</code> 里的<code>trampoline_uservec</code> 相等。</p><p>trampoline是什么？trampoline是在进程虚拟内存的顶部的一块空间，映射到的物理地址存放着跳转进和跳转出内核的代码。看起来在做系统调用时，我们通过ecall跳转进内核。这样一切都说得通了~</p><p>让我们打开trampoline.S，对比左边gdb显示的代码和右边的trampoline.S，会发现它们确实能对上！</p><p>好吧，也不是完全能对上，你会注意到右边的 <code>li a0,TRAPFRAME</code> 在左边似乎对应了三条语句，这是怎么回事呢？实际上，<code>li</code> 是RISC-V 汇编中的伪指令，实际执行时，<code>li</code> 会被汇编器翻译为一条或多条真正的 RISC-V 指令。</p><p>嗯，这样就能对上了！</p><p><img src="/images/learning/open-course/MIT-6.S081/labs/lab2_1-syscall_process/trapoline_enter.png" alt=""></p><p>读一读trampoline.S，我们发现它会把用户进程的寄存器等信息保存到trapframe里，然后跳转到内核的usertrap函数。</p><p>因此接下来我们要用<code>file kernel/kernel</code>把符号表切换到kernel，再用<code>si n</code> 来一次执行多条汇编语句，直到指令<code>jr</code>处：</p><p>比较左边和右边，发现它们的汇编代码确实能对上，接下来我们要准备跳转了。</p><p><img src="/images/learning/open-course/MIT-6.S081/labs/lab2_1-syscall_process/trapoline_jump.png" alt=""></p><p>陷阱，启动！</p><p><img src="/images/learning/open-course/MIT-6.S081/labs/lab2_1-syscall_process/usertrap_enter.png" alt=""></p><p>如果你发现你的gdb没有顺利显示出c语言代码，可能是你忘记切换符号表到内核了，用<code>file kernel/kernel</code>来切换，然后补一个<code>si</code>就能显示出来了。</p><p>由于一切正常，我们可以一路按<code>n</code>直到到达syscall这里。</p><p>比较左边和右边的代码，它们是能对应上的。接下来让我们准备进入<code>syscall</code></p><p><img src="/images/learning/open-course/MIT-6.S081/labs/lab2_1-syscall_process/usertrap_jump.png" alt=""></p><p>我们用<code>s</code>进入syscall函数。<code>n</code>和<code>s</code>都会执行当前行，不过如果当前行是函数，<code>n</code>不会进入函数，而<code>s</code>会。</p><p><img src="/images/learning/open-course/MIT-6.S081/labs/lab2_1-syscall_process/syscall_enter.png" alt=""></p><p>syscall函数从trapframe中取出系统调用号，然后调用它。还记得吗，我们调用系统函数时先进入了usys.S，然后把系统调用号保存到了a7。之后由于我们转入了内核，我们在trapoline.S里把所有的用户空间的寄存器都保存到了trapframe中。</p><p>总之我们在这里调用了sys_sleep，我们进入它看看。</p><p><img src="/images/learning/open-course/MIT-6.S081/labs/lab2_1-syscall_process/syssleep_enter.png" alt=""></p><p>可以发现它就是真正干活的地方！它非常忠实地执行了sleep的逻辑。</p><p>我们可以注意到 n 就是存放着我们最开始传入的参数的变量，内核通过argint来找到我们一开始传入的参数。argint的思路和我们之前找到系统调用号类似，也是从trapframe中找到存放着传入参数的寄存器。</p><p>让我们继续往后，看看在执行完逻辑以后发生了什么吧。</p><p><img src="/images/learning/open-course/MIT-6.S081/labs/lab2_1-syscall_process/syssleep_return.png" alt=""></p><p>回到<code>usertrap</code>，我们一路往下到达<code>usertrapret</code>，然后用<code>s</code>进入它。</p><p><img src="/images/learning/open-course/MIT-6.S081/labs/lab2_1-syscall_process/usertrapret_enter.png" alt=""></p><p>看函数名上面的注释就能发现它会带我们回到用户空间。</p><p>我们用<code>n</code>一路运行到底，再看看注释，发现注释说我们会跳转到trampoline.S。</p><p>观察左边的gdb，<code>p /x trampoline_userret</code> 没有打印值是因为trampoline_userret被编译器优化掉了，我们要手动把它的表达式写出来再打印，总之我们打印出了 0x3ffffff09c。</p><p>在那里设个断点，然后准备继续。</p><p><img src="/images/learning/open-course/MIT-6.S081/labs/lab2_1-syscall_process/usertrapret_break.png" alt=""></p><p>多按几个<code>si</code> 到达跳转语句处，不出意外的话再用一次<code>si</code> 就会带我们进入trapoline.S的userret部分了。</p><p><img src="/images/learning/open-course/MIT-6.S081/labs/lab2_1-syscall_process/usertrapret_jump.png" alt=""></p><p>一切的一切都符合预期，我们成功进入了trampoline.S。</p><p>对比左右的汇编代码可以发现它们是对应的。与之前相同，<code>li</code>被展开了。</p><p><img src="/images/learning/open-course/MIT-6.S081/labs/lab2_1-syscall_process/trapoline_enter_again.png" alt=""></p><p>然后我们一路按<code>si</code>到达<code>sret</code>语句处。<code>sret</code>会做什么呢？让我们看看riscv手册：</p><blockquote><p>The SRET instruction is used to return from a trap taken into S-mode. […] When executing SRET, the privilege level is set to the value in the SPP field of the sstatus register; […] the pc is set to the value stored in the sepc register.</p><p><code>SRET</code> 指令用于从进入 S-mode 的陷阱中返回。[…] 当执行 <code>SRET</code> 时，特权级别被设置为<code>sstatus</code> 寄存器中 <code>SPP</code> 字段的值；[…] 程序计数器 pc 被设置为存储在 <code>sepc</code> 寄存器中的值。</p></blockquote><p>我们借助 <code>p /x sepc</code> 打印这个寄存器的值看看~（请忽视左图里我之前写成spec的手误）</p><p><img src="/images/learning/open-course/MIT-6.S081/labs/lab2_1-syscall_process/trapoline_ret_user.png" alt=""></p><p>0x342是什么？如果你记忆力很好的话，会发现它恰好就是usys.S里的<code>ret</code>那行！</p><p>（这鬼才记得住啊喂）</p><p>总之我们看看之前的截图吧，我们可以发现0x342确实是ret那行，就是下面的截图中高亮的汇编代码下面那行。</p><p><img src="/images/learning/open-course/MIT-6.S081/labs/lab2_1-syscall_process/hello_world_again.png" alt=""></p><p>我们用<code>b *0x342</code>设个断点在那里，然后执行<code>si</code> ，我们回到了用户空间！同时，<code>sret</code>也让我们回到了U-mode。</p><p><img src="/images/learning/open-course/MIT-6.S081/labs/lab2_1-syscall_process/return_to_user.png" alt=""></p><p>用<code>file user/_sleep</code>切换符号表，再执行<code>si</code>，我们回来了。</p><p><img src="/images/learning/open-course/MIT-6.S081/labs/lab2_1-syscall_process/im_back.png" alt=""></p><p>至此，我们就完成了一个完整的系统调用。</p><p>总结一下，当我们进行系统调用时，我们先进入usys.S，然后ecall触发异常并跳转到trapoline.S的uservec处，之后到达trap.c的usertrap函数，它会调用syscall函数以执行系统函数的逻辑，执行完后进入usertrapret函数，再跳转到trapoline.S的userret处，最后回到usys.S，再回到用户的代码里。</p><p>第一次跳转到trapoline.S主要是保存了用户的各个寄存器到trapframe，第二次跳转是从trapframe中恢复了这些寄存器。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们知道应用程序在User mode下运行，而系统函数的执行需要Supervisor mode，那在系统调用时，User mode是怎么进入Supervisor mode的呢？我们以sleep的执行为例，看看都发生了什么。首先我们用 &lt;code&gt;git checkout u</summary>
      
    
    
    
    <category term="公开课" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"/>
    
    <category term="MIT-6.S081" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/MIT-6-S081/"/>
    
    <category term="Labs" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/MIT-6-S081/Labs/"/>
    
    
  </entry>
  
  <entry>
    <title>Lab 2 System calls</title>
    <link href="http://rinevard.github.io/wiki/learning/open-course/MIT-6.S081/Labs/lab2-syscall/"/>
    <id>http://rinevard.github.io/wiki/learning/open-course/MIT-6.S081/Labs/lab2-syscall/</id>
    <published>2025-10-15T07:54:38.000Z</published>
    <updated>2025-10-15T08:10:39.024Z</updated>
    
    <content type="html"><![CDATA[<p>在开始之前，我们回顾一下怎么启动调试模式：</p><p>在一个终端里执行 <code>make qemu-gdb</code> ，<code>make qemu-gdb CPUS=1</code> 可以只使用一个核心，比起多线程更便于调试。</p><p>在另一个终端里执行 <code>gdb-multiarch kernel/kernel</code> ，进入 gdb 后执行 <code>target remote localhost:26001</code>，这里的端口号不一定是 26001，看 <code>make qemu-gdb CPUS=1</code> 的打印结果就行。</p><p>这样就进入调试模式了。另外，我习惯用 <code>set prompt \001\033[1;33m\002(gdb) \001\033[0m\002</code> 来高亮 “(gdb)” 这几个字。</p><h1 id="Using-gdb"><a href="#Using-gdb" class="headerlink" title="Using gdb"></a>Using gdb</h1><p>lab 开头让我们熟悉一下 gdb 的使用。启动调试模式以后按部就班就能完成，我们这里记录一下常用的一些 gdb 指令：</p><pre class="line-numbers language-none"><code class="language-none">c 或 continue - 继续执行直到遇到下一个断点n 或 next - 单步执行,会跳过函数调用s 或 step - 单步执行,会进入函数内部si - 执行一条汇编指令finish - 运行到当前函数返回为止p &#x2F;x $mstatus - 以十六进制打印CPU当前模式backtrace（缩写bt） - 显示函数调用栈set prompt \\001\\033[1;33m\\002(gdb) \\001\\033[0m\\002 - 高亮(gdb)until - 运行到指定行号为止<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="System-call-tracing"><a href="#System-call-tracing" class="headerlink" title="System call tracing"></a>System call tracing</h1><p>这道题让我们实现一个系统调用，按着 hints 按部就班就能做掉。唯一要注意的是在 syscall 里打印 trace 相关的内容时要把系统调用的返回值 ret 从原本的 <code>uint64</code> 转换为 <code>long long</code>，否则对那些可能返回 -1 的系统调用，我们无法正确打印 -1.</p><p>在照着 hints 实现之后，看看系统调用是如何进行的也是更有趣的事情。我在 <a href="/wiki/learning/open-course/MIT-6.S081/Labs/lab2_1-syscall_process/" title="Lab 2.1 系统调用流程——以sleep为例">Lab 2.1 系统调用流程——以sleep为例</a> 中写得还挺详细的，这里不多赘述细节。</p><p>简而言之，当我们进行系统调用时：</p><ol><li>进入由 <code>usys.pl</code> 生成的 <code>usys.S</code> </li><li>ecall 触发异常并跳转到 <code>trapoline.S</code> 的 uservec 处</li><li>到达 <code>trap.c</code> 的 usertrap 函数，它会调用 syscall 函数以执行系统函数的逻辑</li><li>系统函数执行完成后进入usertrapret函数</li><li>跳转到 <code>trapoline.S</code> 的userret处</li><li>最后回到 <code>usys.S</code></li><li>回到用户的代码里。</li></ol><p>让我们根据这个流程来看看 hints 的每一步的原因：</p><ol><li>把 <code>$U/_trace</code> 加入到 Makefile 中是为了编译时识别到 <code>trace</code>。</li><li>在 <code>user.h</code> 里加入 <code>trace</code> 是为了让用户的 <code>trace.c</code> 识别到 <code>trace</code> 这个函数。</li><li>在 <code>usys.pl</code> 里加入 <code>trace</code> 是为了让 <code>usys.pl</code> 在生成的 <code>usys.S</code> 里加入 <code>trace</code> 相关的内容，它是我们进行系统调用时的第一站。</li><li>在 <code>syscall.h</code> 里加入 <code>trace</code> 是因为我们通过寄存器里存储的整数确定调用的系统函数，很多地方都使用了这个文件里定义的常量。</li><li>在 <code>syscall.c</code> 和 <code>sysproc.c</code> 里加入的函数则是实际的逻辑部分，由 syscall 函数调用。</li></ol><h1 id="Attack-xv6"><a href="#Attack-xv6" class="headerlink" title="Attack xv6"></a>Attack xv6</h1><p>在 xv6 的 syscall 分支上有一个漏洞——进程被回收后，它曾经使用的物理内存不会被重置为垃圾数据，而是保持之前的状态。所以我们可以打破内存隔离，访问别的已经被回收的进程的内存。</p><p>我们看向 <code>secret.c</code>，会发现它请求了 32 个物理页大小的物理内存，然后把一串字符放在了某个物理页的开头。所以我们只要在 <code>attck.c</code> 里也请求一些物理页，然后找到这串字符串就行。</p><p>我们先请求 32 个物理页然后依次打印出每个物理页开头的一串字符，结果如下：</p><pre class="line-numbers language-none"><code class="language-none">第 1 页: ��第 2 页: �              第 3 页:  �第 4 页: ��             第 5 页: �第 6 页: 0�             第 7 页:  �第 8 页: �              第 9 页: ��&#x2F;cea.ae第 10 页: @�7�G�������f���13��fv␦3              第 11 页: P�#4��&quot;�����&#96;Bdaa��q�&quot;�                                                                                 ��第 12 页: ��� attackte              第 13 页: p�第 14 页: &#96;�            第 15 页:  ���第 16 页: ��7�G�������f���13��fv␦3              第 17 页: ��very very secret pw is: &#x2F;cea.ae第 18 页: ��            第 19 页: p�第 20 页: 0�            第 21 页: 0��第 22 页: @��           第 23 页: P��第 24 页: ��            第 25 页: ���第 26 页: P�            第 27 页: @�第 28 页: 0�            第 29 页: ��&amp;�J����lE�&#96;*&amp;�J�               第 31 页: ������?���第 32 页: ���          <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以注意到大多数都是乱码，这是因为内存里有非文本的二进制数据，它们不能被当作文本输出。</p><p>当然，我们会注意到第 17 页有 “very very secret pw is: /cea.ae”，它与 <code>secret.c</code> 写入的内容唯一的区别是少了 “my very ” 这八个字符。为什么会有八个字符的差异呢？</p><p>看向 <code>kallc.c</code> 的 <code>kfree</code>：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">kfree</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>pa<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">run</span> <span class="token operator">*</span>r<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>pa <span class="token operator">%</span> PGSIZE<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>pa <span class="token operator">&lt;</span> end <span class="token operator">||</span> <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>pa <span class="token operator">>=</span> PHYSTOP<span class="token punctuation">)</span>        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"kfree"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">LAB_SYSCALL</span></span>    <span class="token comment">// Fill with junk to catch dangling refs.</span>    <span class="token function">memset</span><span class="token punctuation">(</span>pa<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> PGSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>    r <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">run</span> <span class="token operator">*</span><span class="token punctuation">)</span>pa<span class="token punctuation">;</span>    <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kmem<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    r<span class="token operator">-></span>next <span class="token operator">=</span> kmem<span class="token punctuation">.</span>freelist<span class="token punctuation">;</span>    kmem<span class="token punctuation">.</span>freelist <span class="token operator">=</span> r<span class="token punctuation">;</span>    <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kmem<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结合 <code>struct run</code> 的定义，就能知道 <code>r-&gt;next = kmem.freelist</code> 这句语句是把一个指针放在了输入的物理地址的前八个 bytes 中。这正是之前八个字符的差异的由来。</p><p>总结一下，在运行 <code>secret.c</code> 的进程被回收后，其中包含 “my very very very secret pw is: /cea.ae” 的物理页的开头八个 bytes 被指针覆盖，所以只剩下了 “[8 bytes 指针]very very secret pw is: /cea.ae”. 所以我们多请求几个新的物理页然后遍历它们，用前缀 “very very secret pw is: ” 来匹配就行。</p><p>我们在文末会更具体地讲讲进程被回收的过程，但先让我们来看看代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">strncmp</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>str1<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>str2<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// kalloc.c 的 kfree 函数里把物理页的开头换成了一个指针.</span><span class="token comment">// 所以我们丢失了开头的 sizeof(指针) 个字符.</span><span class="token keyword">const</span> <span class="token keyword">int</span> overwrite_len <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>end<span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>prefix <span class="token operator">=</span> <span class="token string">"my very very very secret pw is: "</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> cmplen <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>prefix<span class="token punctuation">)</span> <span class="token operator">-</span> overwrite_len<span class="token punctuation">;</span>    <span class="token comment">// 遍历新插入的32个物理页</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">32</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        end <span class="token operator">=</span> <span class="token function">sbrk</span><span class="token punctuation">(</span>PGSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strncmp</span><span class="token punctuation">(</span>end <span class="token operator">+</span> overwrite_len<span class="token punctuation">,</span> prefix <span class="token operator">+</span> overwrite_len<span class="token punctuation">,</span> cmplen<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">write</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> end <span class="token operator">+</span> <span class="token number">32</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里把内容写进文件描述符 2 是因为 <code>attacktest.c</code> 里开了一个管道，运行 <code>attack.c</code> 的进程的文件描述符 2 连接着管道写端，运行 <code>attacktest.c</code> 的进程则在读取管道读端。下面的代码就是把 <code>attack.c</code> 的文件描述符 2 连接到管道写端的代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">close</span><span class="token punctuation">(</span>fds<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">close</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">dup</span><span class="token punctuation">(</span>fds<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>newargv<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">"attack"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token function">exec</span><span class="token punctuation">(</span>newargv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> newargv<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"exec %s failed\n"</span><span class="token punctuation">,</span> newargv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="进程被回收的过程"><a href="#进程被回收的过程" class="headerlink" title="进程被回收的过程"></a>进程被回收的过程</h1><p>一个进程调用 exit(int) 后会进入 ZOMBIE 状态，但并不立即释放物理内存，而是会唤醒其父进程：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">exit</span><span class="token punctuation">(</span><span class="token keyword">int</span> status<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 我们在这里省略了很多代码，有兴趣可以自己看 proc.c</span>    <span class="token function">wakeup</span><span class="token punctuation">(</span>p<span class="token operator">-></span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>    p<span class="token operator">-></span>state <span class="token operator">=</span> ZOMBIE<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>父进程调用 wait(uint64) 会找到 ZOMBIE 子进程并调用 <code>freeproc</code> 来回收它：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">wait</span><span class="token punctuation">(</span>uint64 addr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 我们在这里省略了很多代码，有兴趣可以自己看 proc.c</span>    <span class="token keyword">struct</span> <span class="token class-name">proc</span> <span class="token operator">*</span>pp<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">proc</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token function">myproc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>pp <span class="token operator">=</span> proc<span class="token punctuation">;</span> pp <span class="token operator">&lt;</span> <span class="token operator">&amp;</span>proc<span class="token punctuation">[</span>NPROC<span class="token punctuation">]</span><span class="token punctuation">;</span> pp<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>pp<span class="token operator">-></span>parent <span class="token operator">==</span> p <span class="token operator">&amp;&amp;</span> pp<span class="token operator">-></span>state <span class="token operator">==</span> ZOMBIE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// Found one.</span>                pid <span class="token operator">=</span> pp<span class="token operator">-></span>pid<span class="token punctuation">;</span>                <span class="token function">freeproc</span><span class="token punctuation">(</span>pp<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> pid<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// Wait for a child to exit.</span>        <span class="token function">sleep</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token operator">&amp;</span>wait_lock<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// DOC: wait-sleep</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>freeproc 则又调用 <code>proc_freepagetable</code> 来回收物理内存：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// Free a process's page table, and free the</span><span class="token comment">// physical memory it refers to.</span><span class="token keyword">void</span> <span class="token function">proc_freepagetable</span><span class="token punctuation">(</span><span class="token class-name">pagetable_t</span> pagetable<span class="token punctuation">,</span> uint64 sz<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">uvmunmap</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> TRAMPOLINE<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">uvmunmap</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> TRAPFRAME<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">uvmfree</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> sz<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中的 <code>uvmfree(pagetable, sz)</code> 就在释放物理内存了：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// Free user memory pages,</span><span class="token comment">// then free page-table pages.</span><span class="token keyword">void</span> <span class="token function">uvmfree</span><span class="token punctuation">(</span><span class="token class-name">pagetable_t</span> pagetable<span class="token punctuation">,</span> uint64 sz<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>sz <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">uvmunmap</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token function">PGROUNDUP</span><span class="token punctuation">(</span>sz<span class="token punctuation">)</span> <span class="token operator">/</span> PGSIZE<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">freewalk</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>让我们看向 <code>uvmunmap</code>，它获取每一页的物理地址然后调用 <code>kfree</code>：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// Remove npages of mappings starting from va. va must be</span><span class="token comment">// page-aligned. The mappings must exist.</span><span class="token comment">// Optionally free the physical memory.</span><span class="token keyword">void</span> <span class="token function">uvmunmap</span><span class="token punctuation">(</span><span class="token class-name">pagetable_t</span> pagetable<span class="token punctuation">,</span> uint64 va<span class="token punctuation">,</span> uint64 npages<span class="token punctuation">,</span> <span class="token keyword">int</span> do_free<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    uint64 a<span class="token punctuation">;</span>    <span class="token class-name">pte_t</span> <span class="token operator">*</span>pte<span class="token punctuation">;</span>    <span class="token keyword">int</span> sz<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>va <span class="token operator">%</span> PGSIZE<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"uvmunmap: not aligned"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>a <span class="token operator">=</span> va<span class="token punctuation">;</span> a <span class="token operator">&lt;</span> va <span class="token operator">+</span> npages <span class="token operator">*</span> PGSIZE<span class="token punctuation">;</span> a <span class="token operator">+=</span> sz<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        sz <span class="token operator">=</span> PGSIZE<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pte <span class="token operator">=</span> <span class="token function">walk</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> a<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"uvmunmap: walk"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>pte <span class="token operator">&amp;</span> PTE_V<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"va=%ld pte=%ld\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> <span class="token operator">*</span>pte<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"uvmunmap: not mapped"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">PTE_FLAGS</span><span class="token punctuation">(</span><span class="token operator">*</span>pte<span class="token punctuation">)</span> <span class="token operator">==</span> PTE_V<span class="token punctuation">)</span>            <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"uvmunmap: not a leaf"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>do_free<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            uint64 pa <span class="token operator">=</span> <span class="token function">PTE2PA</span><span class="token punctuation">(</span><span class="token operator">*</span>pte<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">kfree</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>pa<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token operator">*</span>pte <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>更细节的释放 trapframe、释放页表我们就不在这里多说了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在开始之前，我们回顾一下怎么启动调试模式：&lt;/p&gt;
&lt;p&gt;在一个终端里执行 &lt;code&gt;make qemu-gdb&lt;/code&gt; ，&lt;code&gt;make qemu-gdb CPUS=1&lt;/code&gt; 可以只使用一个核心，比起多线程更便于调试。&lt;/p&gt;
&lt;p&gt;在另一个终端里执</summary>
      
    
    
    
    <category term="公开课" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"/>
    
    <category term="MIT-6.S081" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/MIT-6-S081/"/>
    
    <category term="Labs" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/MIT-6-S081/Labs/"/>
    
    
  </entry>
  
  <entry>
    <title>探索日志[1]</title>
    <link href="http://rinevard.github.io/wiki/others/thoughts/%E6%8E%A2%E7%B4%A2%E6%97%A5%E5%BF%971/"/>
    <id>http://rinevard.github.io/wiki/others/thoughts/%E6%8E%A2%E7%B4%A2%E6%97%A5%E5%BF%971/</id>
    <published>2025-10-13T12:11:11.000Z</published>
    <updated>2025-10-27T13:34:23.367Z</updated>
    
    <content type="html"><![CDATA[<p>不知道人们平常是怎样与他人相识的。许久以前我就在想，自己的社交方式是否有点不太像一般人类🫠🫠咱更偏好那种“大家一起做一件都感兴趣的事情然后渐渐就认识了”的社交方式，但似乎这种做法相对少见，而且我以前也没怎么因此认识到新朋友。</p><p>在不短的质疑期后，渐渐地也发现自己也是能用这种方法交到朋友的，至少是能结识人类的。比如说这次的探索日志就和 GMTK Jam 在小红书拉到的美术同学有关（赞美小红书喵</p><p>“我对普通的人类没有兴趣。你们之中如果有画画人、音乐人、音效人或者异世界人就来找我吧！”虽然我不是这么拉人的（没人会这么拉人吧！），但总之就是拉到了这位中传的美术同学一起来gamejam，这是八月的事了。</p><p>今天鹰角在中传开了个宣讲会，咱作为资深粥粥人当然想去听听看。访客进中传需要找校内同学或老师预约，于是咱就找了这位美术同学然后成功进入中传了。</p><p><img src="/images/others/random_thoughts/explore1/cuc_arknights.jpg" alt=""></p><p>一般来说故事应该跌宕起伏，比方说我们起码要写写在中传遇到的趣事，然后写写有什么糟糕的地方，然后再华丽收场，不过事情就是很平平淡淡。鹰角的宣讲会很普通，虽然发了点周边但我并没有抽中有趣的奖品，中传的饭比北理的好吃，但好吃得不多。</p><p><img src="/images/others/random_thoughts/explore1/cuc_food.jpg" alt=""></p><p>可我确实从来没有去外校玩的经历，更别说要找外校同学预约才能进的学校了🫠🫠咱能从社恐进化成现在这样能主动拉人组队还能联系别人已经很好了不是吗（）</p><p>探索也不是次次有趣，倒不如说探索的结果普普通通才是理所应当的吧。现在是晚上十点五十分，我在良乡大学城北的地铁站没有摆渡车，要骑车回学校了。</p><p><img src="/images/others/random_thoughts/explore1/cuc_tree.jpg" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;不知道人们平常是怎样与他人相识的。许久以前我就在想，自己的社交方式是否有点不太像一般人类🫠🫠咱更偏好那种“大家一起做一件都感兴趣的事情然后渐渐就认识了”的社交方式，但似乎这种做法相对少见，而且我以前也没怎么因此认识到新朋友。&lt;/p&gt;
&lt;p&gt;在不短的质疑期后，渐渐地也发现</summary>
      
    
    
    
    <category term="杂谈" scheme="http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    <category term="碎碎念" scheme="http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
  </entry>
  
  <entry>
    <title>Assignment 7 Path Tracing</title>
    <link href="http://rinevard.github.io/wiki/learning/open-course/GAMES101/Hw/Hw7-path-tracing/"/>
    <id>http://rinevard.github.io/wiki/learning/open-course/GAMES101/Hw/Hw7-path-tracing/</id>
    <published>2025-10-10T14:10:44.000Z</published>
    <updated>2025-10-10T15:04:14.905Z</updated>
    
    <content type="html"><![CDATA[<h1 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h1><p>这次的作业挺难的。首先我们来对照公式解释一下大致的代码流程：</p><script type="math/tex; mode=display">\begin{align*}L_o(p, \vec{\omega_o}) = &L_e(p, \vec{\omega_o}) + \int_{\Omega} f_r(p, \vec{\omega_i}, \vec{\omega_o}) L_i(p, \vec{\omega_i}) (\vec{\omega_i} \cdot n) d\omega_i \\= &L_e(p, \vec{\omega_o}) + \int_{\Omega_{光源方向}} f_r(p, \vec{\omega_i}, \vec{\omega_o}) L_i(p, \vec{\omega_i}) (\vec{\omega_i} \cdot n) d\omega_i \\&+ \int_{\Omega_{非光源方向}} f_r(p, \vec{\omega_i}, \vec{\omega_o}) L_i(p, \vec{\omega_i}) (\vec{\omega_i} \cdot n) d\omega_i\end{align*}</script><ol><li>如果点 $p$ 是光源，直接返回其自发光项 $L_e$.</li><li>随机采样一个光源方向 $w_s$，根据公式计算 $L_\text{direct}$.</li><li><p>随机采样一个方向 $w_i$，按轮盘赌决定是否结束弹射。</p><p> 如果不结束且 $w_i$ 没打到光源，根据公式计算 $L_\text{indirect}$.</p></li><li><p>返回 $L_\text{direct}+L_\text{indirect}$</p></li></ol><p>然后放代码：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Vector3f <span class="token class-name">Scene</span><span class="token double-colon punctuation">::</span><span class="token function">castRay</span><span class="token punctuation">(</span><span class="token keyword">const</span> Ray <span class="token operator">&amp;</span>ray<span class="token punctuation">,</span> <span class="token keyword">int</span> depth<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">&#123;</span>    Intersection shade_point_inter <span class="token operator">=</span> <span class="token function">intersect</span><span class="token punctuation">(</span>ray<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>shade_point_inter<span class="token punctuation">.</span>happened<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token function">Vector3f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// ----------------Contribution from emission----------------</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>shade_point_inter<span class="token punctuation">.</span>m<span class="token operator">-></span><span class="token function">hasEmission</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// Light source doesn't reflect light, so we return here</span>        <span class="token keyword">return</span> shade_point_inter<span class="token punctuation">.</span>m<span class="token operator">-></span><span class="token function">getEmission</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// ----------------Contribution from the light source----------------</span>    Vector3f wo <span class="token operator">=</span> <span class="token operator">-</span><span class="token function">normalize</span><span class="token punctuation">(</span>ray<span class="token punctuation">.</span>direction<span class="token punctuation">)</span><span class="token punctuation">;</span>    Vector3f normal <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>shade_point_inter<span class="token punctuation">.</span>normal<span class="token punctuation">)</span><span class="token punctuation">;</span>    Vector3f l_direct <span class="token operator">=</span> <span class="token function">Vector3f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Intersection light_sample<span class="token punctuation">;</span>    <span class="token keyword">float</span> pdf_light<span class="token punctuation">;</span>    <span class="token function">sampleLight</span><span class="token punctuation">(</span>light_sample<span class="token punctuation">,</span> pdf_light<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// If the ray is not blocked in the middle, compute its contribution</span>    Vector3f light_normal <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>light_sample<span class="token punctuation">.</span>normal<span class="token punctuation">)</span><span class="token punctuation">;</span>    Vector3f shade_point <span class="token operator">=</span> shade_point_inter<span class="token punctuation">.</span>coords<span class="token punctuation">;</span>    Vector3f ws <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>light_sample<span class="token punctuation">.</span>coords <span class="token operator">-</span> shade_point<span class="token punctuation">)</span><span class="token punctuation">;</span>    Vector3f direct_ray_origin <span class="token operator">=</span> shade_point <span class="token operator">+</span> ws <span class="token operator">*</span> EPSILON<span class="token punctuation">;</span>    Ray <span class="token function">ray_to_light</span><span class="token punctuation">(</span>direct_ray_origin<span class="token punctuation">,</span> ws<span class="token punctuation">)</span><span class="token punctuation">;</span>    Intersection inter_between_light <span class="token operator">=</span> <span class="token function">intersect</span><span class="token punctuation">(</span>ray_to_light<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">!</span>inter_between_light<span class="token punctuation">.</span>happened<span class="token punctuation">)</span> <span class="token operator">||</span> inter_between_light<span class="token punctuation">.</span>distance <span class="token operator">></span> <span class="token punctuation">(</span>light_sample<span class="token punctuation">.</span>coords <span class="token operator">-</span> direct_ray_origin<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">norm</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> EPSILON<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        l_direct <span class="token operator">=</span> light_sample<span class="token punctuation">.</span>emit <span class="token operator">*</span> shade_point_inter<span class="token punctuation">.</span>m<span class="token operator">-></span><span class="token function">eval</span><span class="token punctuation">(</span>ws<span class="token punctuation">,</span> wo<span class="token punctuation">,</span> normal<span class="token punctuation">)</span> \        <span class="token operator">*</span> std<span class="token double-colon punctuation">::</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token function">dotProduct</span><span class="token punctuation">(</span>ws<span class="token punctuation">,</span> normal<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">)</span> <span class="token operator">*</span> std<span class="token double-colon punctuation">::</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token function">dotProduct</span><span class="token punctuation">(</span><span class="token operator">-</span>ws<span class="token punctuation">,</span> light_normal<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">)</span> \        <span class="token operator">/</span> std<span class="token double-colon punctuation">::</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token punctuation">(</span>light_sample<span class="token punctuation">.</span>coords <span class="token operator">-</span> direct_ray_origin<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">norm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">/</span> pdf_light<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// ----------------Contribution from other reflectors----------------</span>    Vector3f l_indirect <span class="token operator">=</span> <span class="token function">Vector3f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Russian Roulette test</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">get_random_float</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> RussianRoulette<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        Vector3f wi <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>shade_point_inter<span class="token punctuation">.</span>m<span class="token operator">-></span><span class="token function">sample</span><span class="token punctuation">(</span>wo<span class="token punctuation">,</span> normal<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Vector3f indirect_ray_origin <span class="token operator">=</span> shade_point <span class="token operator">+</span> wi <span class="token operator">*</span> EPSILON<span class="token punctuation">;</span>        Ray <span class="token function">reflected_ray</span><span class="token punctuation">(</span>indirect_ray_origin<span class="token punctuation">,</span> wi<span class="token punctuation">)</span><span class="token punctuation">;</span>        Intersection reflected_inter <span class="token operator">=</span> <span class="token function">intersect</span><span class="token punctuation">(</span>reflected_ray<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// If reflected_ray hitting a non-emitting object, compute its contribution </span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>reflected_inter<span class="token punctuation">.</span>happened <span class="token operator">&amp;&amp;</span> reflected_inter<span class="token punctuation">.</span>m<span class="token operator">-></span><span class="token function">hasEmission</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            l_indirect <span class="token operator">=</span> <span class="token function">Vector3f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            l_indirect <span class="token operator">=</span> <span class="token function">castRay</span><span class="token punctuation">(</span>reflected_ray<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> shade_point_inter<span class="token punctuation">.</span>m<span class="token operator">-></span><span class="token function">eval</span><span class="token punctuation">(</span>wi<span class="token punctuation">,</span> wo<span class="token punctuation">,</span> normal<span class="token punctuation">)</span> \            <span class="token operator">*</span> std<span class="token double-colon punctuation">::</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token function">dotProduct</span><span class="token punctuation">(</span>wi<span class="token punctuation">,</span> normal<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">)</span> \            <span class="token operator">/</span> <span class="token punctuation">(</span>shade_point_inter<span class="token punctuation">.</span>m<span class="token operator">-></span><span class="token function">pdf</span><span class="token punctuation">(</span>wi<span class="token punctuation">,</span> wo<span class="token punctuation">,</span> normal<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> RussianRoulette<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> l_direct <span class="token operator">+</span> l_indirect<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再来看看图</p><p><img src="/images/learning/open-course/GAMES101/Assignments/hw7/screenshot.png" alt=""></p><h1 id="代码细节"><a href="#代码细节" class="headerlink" title="代码细节"></a>代码细节</h1><p>接下来我们再聊聊具体的代码细节。自发光项比较简单，我们略过。</p><h2 id="L-text-direct"><a href="#L-text-direct" class="headerlink" title="$L_\text{direct}$"></a>$L_\text{direct}$</h2><p>直接光部分。首先要注意的是，各个射线 $w_i, w_o, w_s$ 都是从着色点指向外的单位方向向量。这是一个图形学里常用的约定，所以不要问为什么不是指向内了（）</p><p><img src="/images/learning/open-course/GAMES101/Assignments/hw7/wiwodir.png" alt=""></p><p>然后在发出射线时，最好做一个微小的偏移以避免发出的射线和着色点平面相交。这就是我们 <code>direct_ray_origin = shade_point + ws * EPSILON</code> 做了加法的原因。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Vector3f wo <span class="token operator">=</span> <span class="token operator">-</span><span class="token function">normalize</span><span class="token punctuation">(</span>ray<span class="token punctuation">.</span>direction<span class="token punctuation">)</span><span class="token punctuation">;</span>Vector3f normal <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>shade_point_inter<span class="token punctuation">.</span>normal<span class="token punctuation">)</span><span class="token punctuation">;</span>Vector3f l_direct <span class="token operator">=</span> <span class="token function">Vector3f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Intersection light_sample<span class="token punctuation">;</span><span class="token keyword">float</span> pdf_light<span class="token punctuation">;</span><span class="token function">sampleLight</span><span class="token punctuation">(</span>light_sample<span class="token punctuation">,</span> pdf_light<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// If the ray is not blocked in the middle, compute its contribution</span>Vector3f light_normal <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>light_sample<span class="token punctuation">.</span>normal<span class="token punctuation">)</span><span class="token punctuation">;</span>Vector3f shade_point <span class="token operator">=</span> shade_point_inter<span class="token punctuation">.</span>coords<span class="token punctuation">;</span>Vector3f ws <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>light_sample<span class="token punctuation">.</span>coords <span class="token operator">-</span> shade_point<span class="token punctuation">)</span><span class="token punctuation">;</span>Vector3f direct_ray_origin <span class="token operator">=</span> shade_point <span class="token operator">+</span> ws <span class="token operator">*</span> EPSILON<span class="token punctuation">;</span>Ray <span class="token function">ray_to_light</span><span class="token punctuation">(</span>direct_ray_origin<span class="token punctuation">,</span> ws<span class="token punctuation">)</span><span class="token punctuation">;</span>Intersection inter_between_light <span class="token operator">=</span> <span class="token function">intersect</span><span class="token punctuation">(</span>ray_to_light<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">!</span>inter_between_light<span class="token punctuation">.</span>happened<span class="token punctuation">)</span> <span class="token operator">||</span> inter_between_light<span class="token punctuation">.</span>distance <span class="token operator">></span> <span class="token punctuation">(</span>light_sample<span class="token punctuation">.</span>coords <span class="token operator">-</span> direct_ray_origin<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">norm</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> EPSILON<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    l_direct <span class="token operator">=</span> light_sample<span class="token punctuation">.</span>emit <span class="token operator">*</span> shade_point_inter<span class="token punctuation">.</span>m<span class="token operator">-></span><span class="token function">eval</span><span class="token punctuation">(</span>ws<span class="token punctuation">,</span> wo<span class="token punctuation">,</span> normal<span class="token punctuation">)</span> \    <span class="token operator">*</span> std<span class="token double-colon punctuation">::</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token function">dotProduct</span><span class="token punctuation">(</span>ws<span class="token punctuation">,</span> normal<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">)</span> <span class="token operator">*</span> std<span class="token double-colon punctuation">::</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token function">dotProduct</span><span class="token punctuation">(</span><span class="token operator">-</span>ws<span class="token punctuation">,</span> light_normal<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">)</span> \    <span class="token operator">/</span> std<span class="token double-colon punctuation">::</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token punctuation">(</span>light_sample<span class="token punctuation">.</span>coords <span class="token operator">-</span> direct_ray_origin<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">norm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">/</span> pdf_light<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另外，我们有从光源采样计算直接光的公式：</p><script type="math/tex; mode=display">\begin{align*}&\int_{\Omega_{光源方向}} f_r(p, \vec{\omega_i}, \vec{\omega_o}) L_i(p, \vec{\omega_i}) (\vec{\omega_i} \cdot n) d\omega_i \\=&\int_{A} f_r(p, \vec{\omega_i}, \vec{\omega_o}) L_i(p, \vec{\omega_i}) \frac{\cos\theta\cos\theta_i}{\lVert p'-p \rVert^2} dA \end{align*}</script><p>用蒙特卡罗近似就是代码里写的东西了。</p><p><img src="/images/learning/open-course/GAMES101/Assignments/hw7/nee.png" alt=""></p><h2 id="L-text-indirect"><a href="#L-text-indirect" class="headerlink" title="$L_\text{indirect}$"></a>$L_\text{indirect}$</h2><p>间接部分。首先要做俄罗斯轮盘赌，然后要检查打到的是否是光源。</p><p>如果通过了轮盘赌，而且打到的不是光源，就要计算间接光。</p><p>与直接光一样，我们要做微小偏移，这就是 <code>indirect_ray_origin = shade_point + wi * EPSILON</code> .</p><p>然后套公式就行。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Vector3f l_indirect <span class="token operator">=</span> <span class="token function">Vector3f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Russian Roulette test</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">get_random_float</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> RussianRoulette<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    Vector3f wi <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>shade_point_inter<span class="token punctuation">.</span>m<span class="token operator">-></span><span class="token function">sample</span><span class="token punctuation">(</span>wo<span class="token punctuation">,</span> normal<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Vector3f indirect_ray_origin <span class="token operator">=</span> shade_point <span class="token operator">+</span> wi <span class="token operator">*</span> EPSILON<span class="token punctuation">;</span>    Ray <span class="token function">reflected_ray</span><span class="token punctuation">(</span>indirect_ray_origin<span class="token punctuation">,</span> wi<span class="token punctuation">)</span><span class="token punctuation">;</span>    Intersection reflected_inter <span class="token operator">=</span> <span class="token function">intersect</span><span class="token punctuation">(</span>reflected_ray<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// If reflected_ray hitting a non-emitting object, compute its contribution </span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>reflected_inter<span class="token punctuation">.</span>happened <span class="token operator">&amp;&amp;</span> reflected_inter<span class="token punctuation">.</span>m<span class="token operator">-></span><span class="token function">hasEmission</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        l_indirect <span class="token operator">=</span> <span class="token function">Vector3f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        l_indirect <span class="token operator">=</span> <span class="token function">castRay</span><span class="token punctuation">(</span>reflected_ray<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> shade_point_inter<span class="token punctuation">.</span>m<span class="token operator">-></span><span class="token function">eval</span><span class="token punctuation">(</span>wi<span class="token punctuation">,</span> wo<span class="token punctuation">,</span> normal<span class="token punctuation">)</span> \        <span class="token operator">*</span> std<span class="token double-colon punctuation">::</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token function">dotProduct</span><span class="token punctuation">(</span>wi<span class="token punctuation">,</span> normal<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">)</span> \        <span class="token operator">/</span> <span class="token punctuation">(</span>shade_point_inter<span class="token punctuation">.</span>m<span class="token operator">-></span><span class="token function">pdf</span><span class="token punctuation">(</span>wi<span class="token punctuation">,</span> wo<span class="token punctuation">,</span> normal<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> RussianRoulette<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果对 EPSILON 挺敏感的，可以把 EPSILON 适当调大点，我用的是 <code>0.00020</code> .</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;大致流程&quot;&gt;&lt;a href=&quot;#大致流程&quot; class=&quot;headerlink&quot; title=&quot;大致流程&quot;&gt;&lt;/a&gt;大致流程&lt;/h1&gt;&lt;p&gt;这次的作业挺难的。首先我们来对照公式解释一下大致的代码流程：&lt;/p&gt;
&lt;script type=&quot;math/tex; mod</summary>
      
    
    
    
    <category term="公开课" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"/>
    
    <category term="GAMES101" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/"/>
    
    <category term="Assignments" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/Assignments/"/>
    
    
  </entry>
  
  <entry>
    <title>Note 6 BRDF and Rendering Eequation</title>
    <link href="http://rinevard.github.io/wiki/learning/open-course/GAMES101/Notes/Note6-BRDF-and-renderingequation/"/>
    <id>http://rinevard.github.io/wiki/learning/open-course/GAMES101/Notes/Note6-BRDF-and-renderingequation/</id>
    <published>2025-10-10T13:45:28.000Z</published>
    <updated>2025-10-10T14:49:51.245Z</updated>
    
    <content type="html"><![CDATA[<p>我们之前已经学过了 Blinn-Phong 光照模型，但它只是一个启发式模型，在物理上是不正确的。接下来我们看看物理上正确的光照是怎样的，以及如何用计算机近似求解接近正确的光照。</p><h1 id="辐射度量学"><a href="#辐射度量学" class="headerlink" title="辐射度量学"></a>辐射度量学</h1><p>在了解光照的物理模型之前，我们先来看看一些物理量。最关键的物理量有四个，分别是</p><ol><li>Radiant flux/power $\Phi$，单位 $W$.</li><li>Radiant intensity $I$，单位 $\frac{W}{\text{sr}}$.</li><li>Irradiance $E$，单位 $\frac{W}{m^2}$.</li><li>Radiance $L$，单位 $\frac{W}{\text{sr}\cdot m^2}$.</li></ol><p>接下来让我们看看它们的具体定义。</p><h2 id="Radiant-flux-power-Phi"><a href="#Radiant-flux-power-Phi" class="headerlink" title="Radiant flux/power $\Phi$"></a>Radiant flux/power $\Phi$</h2><p>Radiant flux/power 符号 $\Phi$，单位 $W$.</p><p>定义为</p><script type="math/tex; mode=display">\Phi = \frac{dQ}{dt}</script><h2 id="Radiant-intensity-I"><a href="#Radiant-intensity-I" class="headerlink" title="Radiant intensity $I$"></a>Radiant intensity $I$</h2><p>Radiant Intensity 符号 $I$，单位 $\frac{W}{\text{sr}}$，表示某个定点接收/穿过/发出的，在指定方向 $\vec{\omega}$ 上的，单位立体角的 Power.</p><p>定义为</p><script type="math/tex; mode=display">I(\vec{\omega})=\frac{d\Phi}{d\omega}</script><p>这里的符号略显混乱。左边的参数 $\vec{\omega}$ 是一个方向向量，右边的 $d\omega$ 则是这个方向上立体角的微分。</p><p>我们知道方向向量 $\vec{\omega}$ 也能在球坐标下被表示为 $(\theta,\varphi)$。对给定的 $(\theta,\varphi)$，我们可以算出其在球面上的面积微分，也能进一步求出立体角微分 $d\omega$，如下所示</p><script type="math/tex; mode=display">\begin{align*}&dA=r^2 \sin \theta \space d\theta \space d\varphi\\&d\omega=\frac{dA}{r^2}=\sin \theta \space d\theta \space d\varphi\end{align*}</script><p>下图是对  Solid angle 和 Radiant Intensity 两个概念的图解</p><p><img src="/images/learning/open-course/GAMES101/Notes/note6/solid_angle_and_intensity.png" alt=""></p><h2 id="Irradiance-E"><a href="#Irradiance-E" class="headerlink" title="Irradiance $E$"></a>Irradiance $E$</h2><p>Irradiance 符号 $E$，单位 $\frac{W}{m^2}$.</p><p>表示点 $x$ 周围单位面积接收/穿过/发出的 Power，定义为</p><script type="math/tex; mode=display">E(x)=\frac{d\Phi}{dA}</script><p>下图计算并对比了平行光穿过两个不同截面时的 irradiance：垂直截面 $A$，以及与垂直方向成 $\theta$ 角的倾斜截面 $A’$。</p><p>其中 $\Phi=\Phi’$ 是因为能量守恒，光束穿过任何一个完整截面的功率是固定的。</p><p><img src="/images/learning/open-course/GAMES101/Notes/note6/irradiance.png" alt=""></p><h2 id="Radiance-L"><a href="#Radiance-L" class="headerlink" title="Radiance $L$"></a>Radiance $L$</h2><p>Radiance $L$ 的单位是 $\frac{W}{\text{sr}\cdot \space m^2}$，表示表面某点 $x$ 周围单位投影面积接收/穿过/发出的，在指定方向 $\vec{w}$ 上的，单位立体角的 radiant flux.</p><p>定义为</p><script type="math/tex; mode=display">L(x,\vec{\omega})=\frac{d^2\Phi}{d\omega ds}=\frac{d^2\Phi}{d\omega ds_{0}\cos\theta}</script><p>这里的 $ds$ 是投影前面积，$ds_0 \cos\theta$ 是投影面积。</p><p>下图是对 Irradiance 和 Radiance的图解</p><p><img src="/images/learning/open-course/GAMES101/Notes/note6/irradiance_and_radiance.png" alt=""></p><h1 id="BRDF和材质"><a href="#BRDF和材质" class="headerlink" title="BRDF和材质"></a>BRDF和材质</h1><p>现在我们可以看看光照的物理模型了，其中最关键的是 BRDF，即双向反射分布函数。它定义了从方向 $\vec{\omega_i}$ 射入的光线打到某个表面上反射到 $\vec{\omega_r}$ 方向的强度：</p><script type="math/tex; mode=display">f_r(p,\vec{\omega_i}, \vec{\omega_r}) = \frac{dL_r(p,\vec{\omega_r})}{dE_i(p,\vec{\omega_i})}</script><p>你可能会疑惑为什么之前我们说 $E$ 是关于 $x$ 的函数，现在却除了坐标 $p$ 外还多了一个方向参数 $\omega_i$，这是因为 BRDF 里的 $E$ 是微分。具体可以看看下面这个式子：</p><script type="math/tex; mode=display">E(x) = \int_{\Omega} L_i(x,\vec{\omega_i}) \cos\theta_i d\omega_i\\dE_i(x, \vec{\omega_i}) = L_i(x, \vec{\omega_i}) \cos\theta_i d\omega_i</script><p>你可能还会疑惑，为什么分母用 $E$ 呢？和分母一样统一用 $L$ 不是更优雅吗？</p><p>据 <a href="https://www.zhihu.com/question/28476602/answer/41003204">https://www.zhihu.com/question/28476602/answer/41003204</a> 这个答案所说，测量出射的 Radiance $L$ 很方便，但测量入射的 Irradiance $L$ 很困难，而测量入射的 $dE$ 挺方便，因此我们就使用了 $\frac{dL}{dE}$.</p><p>我们把上面的 $dE_i(x,\vec{\omega_i})$ 代入 BRDF，就得到了</p><script type="math/tex; mode=display">f_r(p,\vec{\omega_i}, \vec{\omega_r}) = \frac{dL_r(p,\vec{\omega_r})}{L_i(x,\vec{w_i})\cos\theta_i dw_i}</script><p>物体的材质就用 BSDF（反射的BRDF+折射的BTDF）表示。我们这里只聊 BRDF，因为 BTDF 和 BRDF 接近。BRDF 的获取包括但不限于这两种方式：</p><ol><li>现实测量。我们可以找到许多包含大量 BRDF 测量数据的数据集，比如 MERL 数据集。</li><li>微表面模型。用粗糙度、金属度等参数来构建启发式的 BRDF 函数。</li></ol><p>还值得一提的是，由 Helmholtz Reciprocity Principle，有</p><script type="math/tex; mode=display">f_r(p,\vec{\omega_i}, \vec{\omega_o}) = f_r(p,\vec{\omega_o}, \vec{\omega_i})</script><p>也就是说交换入射出射方向，BRDF 函数 $f_r$ 不变。</p><h1 id="渲染方程"><a href="#渲染方程" class="headerlink" title="渲染方程"></a>渲染方程</h1><p>现在我们先看看反射方程，再看看渲染方程。</p><p>反射方程是通过 BRDF 求出 $L_r$ 的方程，对 BRDF 的公式积分一下就行：</p><script type="math/tex; mode=display">L_r(p, \vec{\omega_r}) = \int_{\Omega} f_r(p, \vec{\omega_i}, \vec{\omega_r}) L_i(p, \vec{\omega_i}) (\vec{\omega_i} \cdot \vec{n}) d\omega_i</script><p>其中 $\vec{n}$ 是点 $p$ 处的法线方向，$\vec{\omega_i} \cdot \vec{n}$ 是 BRDF 定义里的 $\cos\theta_i$.</p><p>而渲染方程，不考虑折射，只是比反射方程多了一个自发光项：</p><script type="math/tex; mode=display">L_o(p, \vec{\omega_o}) = L_e(p, \vec{\omega_o}) + \int_{\Omega} f_r(p, \vec{\omega_i}, \vec{\omega_o}) L_i(p, \vec{\omega_i}) (\vec{\omega_i} \cdot n) d\omega_i</script><p>你可能会好奇右侧的 $L_i(p,\vec{\omega_i}<br>)$ 怎么求出来。由能量守恒，我们可以从 $p$ 出发顺着 $-\vec{\omega_i}$ 找到第一个交点 $q$，然后就有</p><script type="math/tex; mode=display">L_i(p,\vec{\omega_i})=L_o(q,-\vec{\omega_i})</script><h1 id="实际算法"><a href="#实际算法" class="headerlink" title="实际算法"></a>实际算法</h1><p>由上可知，我们要求解下面的方程：</p><script type="math/tex; mode=display">L_o(p, \vec{\omega_o}) = L_e(p, \vec{\omega_o}) + \int_{\Omega} f_r(p, \vec{\omega_i}, \vec{\omega_o}) L_o(\text{raycast}(p, -\vec{\omega_i}), -\vec{\omega_i}) (\vec{\omega_i} \cdot n) d\vec{\omega_i}</script><p>这是一个积分，还是一个递归，我们先用蒙特卡罗算法近似积分，得到</p><script type="math/tex; mode=display">L_o(p, \vec{\omega_o}) \approx L_e(p, \vec{\omega_o}) + \frac{1}{N}\sum_{k=1}^{N}\frac{f_r(p, \vec{\omega_i}^{(k)}, \vec{\omega_o}) L_o(\text{raycast}(p, -\vec{\omega_i}^{(k)}), -\vec{\omega_i}^{(k)}) (\vec{\omega_i} ^{(k)}\cdot n) }{p(\vec{\omega_i}^{(k)})}</script><p>其中 $\vec{\omega_i}^{(k)}$ 是随机采样的方向向量，$p(\vec{\omega_i}^{(k)})$ 是采样到它的概率。</p><p>有了这个求和，我们就可以开始递归了，大致算法如下：</p><ol><li>从 $p$ 射出朝随机方向 $\vec{\omega_i}<br>^{(k)}$ 的射线，打到 $q^{(k)}$.</li><li>计算 $L_o(q,-w_i^{(k)})$，然后代入式子，求得 $L_o(p,\vec{\omega_o})$。</li></ol><p>等等，这不是无限递归吗？确实如此。所以我们会假设如果射线打到了光源就只返回自发光项 $L_e$.</p><p>但这不还是很复杂吗，假设我们对每个点发射 $10$ 条射线，弹射以后就要发射 $10^2$ 个，再弹射就要 $10^3$ 个！</p><p>没错，所以我们只对每个点发出 $1$ 条射线并计算其弹射后的完整路径，然后对每个点追踪多条路径并取平均。虽然这不完全符合上面的公式，但很有效。</p><p>让我们来看看新的算法吧：</p><ol><li>如果点 $p$ 是光源，直接返回其自发光项。</li><li>随机采样一个方向 $w_i$，从 $p$ 发出一条朝向 $w_i$ 的射线，打到点 $q$.</li><li>计算点 $q$ 的 $L_o(q,-w_i)$，代入公式，求得 $L_o(p,w_o)$.</li><li>对求得的多个 $L_o(p,w_o)$ 取平均。</li></ol><p>这个算法当然可以进一步优化，比如说上面还是有潜在的无限弹射风险，所以要用俄罗斯轮盘赌来在每次弹射时都有随机概率停止弹射（这被称作RR）；又比如上面打到光源的概率太低，所以可以从光源采样射线（这被称作NEE）。不过这些东西就留到作业 7 的解析里再说吧。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>Stanford CS348B, Spring 2022：<a href="https://gfxcourses.stanford.edu/cs348b/spring22">https://gfxcourses.stanford.edu/cs348b/spring22</a></p><p>多伦多大学图形学讲义：<a href="https://www.dgp.toronto.edu/public_user/elf/2522/light.pdf">https://www.dgp.toronto.edu/public_user/elf/2522/light.pdf</a></p><p>Introduction to Radiometry and Photometry</p><p>UE4 的 BRDF 实现：<a href="https://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf">https://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们之前已经学过了 Blinn-Phong 光照模型，但它只是一个启发式模型，在物理上是不正确的。接下来我们看看物理上正确的光照是怎样的，以及如何用计算机近似求解接近正确的光照。&lt;/p&gt;
&lt;h1 id=&quot;辐射度量学&quot;&gt;&lt;a href=&quot;#辐射度量学&quot; class=&quot;head</summary>
      
    
    
    
    <category term="公开课" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"/>
    
    <category term="GAMES101" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/"/>
    
    <category term="Notes" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/Notes/"/>
    
    
  </entry>
  
  <entry>
    <title>探索日志[0]</title>
    <link href="http://rinevard.github.io/wiki/others/thoughts/%E6%8E%A2%E7%B4%A2%E6%97%A5%E5%BF%970/"/>
    <id>http://rinevard.github.io/wiki/others/thoughts/%E6%8E%A2%E7%B4%A2%E6%97%A5%E5%BF%970/</id>
    <published>2025-10-10T12:10:11.000Z</published>
    <updated>2025-10-27T13:33:04.965Z</updated>
    
    <content type="html"><![CDATA[<p>第二次参加了 Ludum Dare，第二次参加了 Compo 赛道。Compo 要求单人从零开始在 48 小时内做出一个能玩的东西。不觉得这很酷吗，作为一个玩家我觉得这太酷了，很符合我对极客的想象。</p><p>上一次参加 Compo 结识了一位很有趣的朋友，所以这次又参加了 Compo 而不是组队的 Jam。不过这次似乎至少到现在为止还没结识到很有趣的朋友（）</p><p>从上学期就开始想，大学的每天都太相似，日复一日。因此想每周都做一些没做过的事情。虽然没坚持很久，但我想这确实是值得做的。所以从现在开始简单写写探索日志吧，时不时探索一下。</p><p>这次除了自己参加之外，还和墨鱼游研社的同学们一起组织了一个活动，和社团的大家一起参加了这场 gamejam，咱们社团最后一共做了四个游戏。我做了 <a href="https://ldjam.com/events/ludum-dare/58/swarm-surge">SwarmSurge</a>.</p><p><img src="/images/others/random_thoughts/explore0/swarm_surge.jpg" alt="Swarm Surge"></p><p>怎样的生活值得我过，我该过怎样的生活？我确实还没想明白。Jam 是生活里为数不多的一抹奇幻色彩，惊艳又短暂。在有趣的故事结束之后，我们又该做什么，又该去往何方？</p><p>也难怪会喜欢凉宫春日。虽然她性格恶劣想一出是一出，但她是让世界变得更热闹的凉宫春日团团长！阿虚曾问自己：“对这种超乎常识的学园生活，你就不觉得快乐吗？”他的回答是：“当然快乐了，别问我这种明摆着的事情。”</p><p>对这些奇幻色彩，我难道不感觉快乐吗？当然快乐了。我会一直探索下去，即使每天都是某个雨日。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;第二次参加了 Ludum Dare，第二次参加了 Compo 赛道。Compo 要求单人从零开始在 48 小时内做出一个能玩的东西。不觉得这很酷吗，作为一个玩家我觉得这太酷了，很符合我对极客的想象。&lt;/p&gt;
&lt;p&gt;上一次参加 Compo 结识了一位很有趣的朋友，所以这次又参</summary>
      
    
    
    
    <category term="杂谈" scheme="http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    <category term="碎碎念" scheme="http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
  </entry>
  
  <entry>
    <title>Note 5 RayTracing</title>
    <link href="http://rinevard.github.io/wiki/learning/open-course/GAMES101/Notes/Note5-RayTracing/"/>
    <id>http://rinevard.github.io/wiki/learning/open-course/GAMES101/Notes/Note5-RayTracing/</id>
    <published>2025-09-25T13:48:28.000Z</published>
    <updated>2025-09-25T13:51:26.850Z</updated>
    
    <content type="html"><![CDATA[<p>渲染可以分为两个大类：object-order rendering 和 Image-order rendering. 前者以场景中的物体（通常是如三角形）为基本单位进行迭代，遍历场景中的每一个物体，然后确定该物体会影响屏幕上的哪些像素；后者以屏幕上的像素为基本单位进行迭代，遍历输出图像中的每一个像素，然后对于每个像素，它会找出场景中的哪个物体或物体的哪个部分决定了该像素的颜色。</p><p>我们之前学的光栅化是前者，而我们接下来要介绍的光线追踪就是后者。</p><h1 id="光线追踪"><a href="#光线追踪" class="headerlink" title="光线追踪"></a>光线追踪</h1><h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>光线追踪的思想基于光路可逆——既然光路可逆，那么打到摄像机里的光就可以看作从摄像机发出的射线，我们只要打出射线然后计算射线打到的点的颜色就好了。</p><p>其实基本思路真的就是这么简单！如下图所示，我们从眼睛里发出经过每个像素的射线，然后射线打到物体上就得到了物体的基本颜色。而射线还会反射、折射，我们计算反射、折射后的射线打到的颜色，再加到基本颜色上，就得到了这个像素的颜色。</p><p><img src="/images/learning/open-course/GAMES101/Notes/note5/ray_tracing.png" alt=""></p><p>光线追踪也自然地生成了阴影——如果射线打中的点和光源的连线间有物体遮挡，这点就是阴影，否则就不是阴影。</p><h2 id="碰撞检测"><a href="#碰撞检测" class="headerlink" title="碰撞检测"></a>碰撞检测</h2><p>既然如此，我们只要检测射线和三角形的碰撞就好了。我们可以用下面的 Möller Trumbore Algorithm 来做检测，其思路是解 “直线上的点 = 三角形重心坐标表示” 这个方程：</p><p>考虑射线 $\vec{O} + t\vec{D}$ 和三角形 $P_0, P_1, P_2$，我们要解方程</p><script type="math/tex; mode=display">\vec{O} + t\vec{D} = (1-b_1-b_2)\vec{P_0} + b_1\vec{P_1} + b_2\vec{P_2}</script><p>这是一个线性方程组，解为</p><script type="math/tex; mode=display">\begin{bmatrix} t \\ b_1 \\ b_2 \end{bmatrix} = \frac{1}{\vec{S_1} \cdot \vec{E_1}} \begin{bmatrix} \vec{S_2} \cdot \vec{E_2} \\ \vec{S_1} \cdot \vec{S} \\ \vec{S_2} \cdot \vec{D} \end{bmatrix}</script><p>其中</p><script type="math/tex; mode=display">\begin{aligned}\vec{E_1} &= \vec{P_1} - \vec{P_0} \\\vec{E_2} &= \vec{P_2} - \vec{P_0} \\\vec{S} &= \vec{O} - \vec{P_0} \\\vec{S_1} &= \vec{D} \times \vec{E_2} \\\vec{S_2} &= \vec{S} \times \vec{E_1}\end{aligned}</script><h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><p>在做射线和三角形的碰撞检测时，简单地遍历场景里的每个三角形显然太慢了，所以我们用包围盒来优化。如果一个射线没有碰到包围盒，自然就不会碰到盒子里的物体；如果碰到了，再和盒子里的物体做碰撞检测。</p><h2 id="常见包围盒"><a href="#常见包围盒" class="headerlink" title="常见包围盒"></a>常见包围盒</h2><p>包围盒有两种思路，一种是基于空间的划分，另一种是基于物体的划分。前者的代表包括四叉树、八叉树；后者的代表是 BVH.</p><p>四叉树、八叉树把空间进行平分，当一个区域里还剩较多物体时就再在这个区域里平分一次。</p><p><img src="/images/learning/open-course/GAMES101/Notes/note5/octree.png" alt=""></p><p>BVH 为每组物体建立包围盒，然后再把父包围盒划分成子包围盒。</p><p><img src="/images/learning/open-course/GAMES101/Notes/note5/bvh.png" alt=""></p><h2 id="射线和包围盒的碰撞检测"><a href="#射线和包围盒的碰撞检测" class="headerlink" title="射线和包围盒的碰撞检测"></a>射线和包围盒的碰撞检测</h2><p>包围盒有六个面，我们可以把相对的面划分成一组从而得到三组面。计算射线 $\vec{O} + t\vec{D}$ 与这三组面的交点后，我们会得到 $[t<em>{x, \text{enter}}, t</em>{x, \text{exit}}],[t<em>{y, \text{enter}}, t</em>{y, \text{exit}}],[t<em>{z, \text{enter}}, t</em>{z, \text{exit}}]$，之后计算下面的交集：</p><script type="math/tex; mode=display">[t_\text{raymin},t_\text{raymax}]\cap[t_{x, \text{enter}}, t_{x, \text{exit}}]\cap[t_{y, \text{enter}}, t_{y, \text{exit}}]\cap[t_{z, \text{enter}}, t_{z, \text{exit}}]</script><p>如果交集为空则无交点，否则有交点。</p><p>为了方便计算，包围盒一般是与坐标轴平行的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;渲染可以分为两个大类：object-order rendering 和 Image-order rendering. 前者以场景中的物体（通常是如三角形）为基本单位进行迭代，遍历场景中的每一个物体，然后确定该物体会影响屏幕上的哪些像素；后者以屏幕上的像素为基本单位进行迭代，</summary>
      
    
    
    
    <category term="公开课" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"/>
    
    <category term="GAMES101" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/"/>
    
    <category term="Notes" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/Notes/"/>
    
    
  </entry>
  
  <entry>
    <title>Assignment 6 Bounding Box</title>
    <link href="http://rinevard.github.io/wiki/learning/open-course/GAMES101/Hw/Hw6-bounding-box/"/>
    <id>http://rinevard.github.io/wiki/learning/open-course/GAMES101/Hw/Hw6-bounding-box/</id>
    <published>2025-09-24T09:46:44.000Z</published>
    <updated>2025-09-24T12:56:28.461Z</updated>
    
    <content type="html"><![CDATA[<p>这次的作业要求实现用包围盒来加快光线追踪，再用 BVH 优化。</p><p>首先我们要把 hw5 里的代码复制过来，让我不解的是代码里明明已经提供了 <code>rayTriangleIntersect</code> 函数，PDF 里却还说“将你的光线-三角形相交函数粘贴到此处”，明明直接调用它就好了，如下所示：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">inline</span> Intersection <span class="token class-name">Triangle</span><span class="token double-colon punctuation">::</span><span class="token function">getIntersection</span><span class="token punctuation">(</span>Ray ray<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    Intersection inter<span class="token punctuation">;</span>    <span class="token keyword">float</span> u<span class="token punctuation">,</span> v<span class="token punctuation">,</span> t<span class="token punctuation">;</span>    inter<span class="token punctuation">.</span>happened <span class="token operator">=</span> <span class="token function">rayTriangleIntersect</span><span class="token punctuation">(</span>v0<span class="token punctuation">,</span> v1<span class="token punctuation">,</span> v2<span class="token punctuation">,</span> ray<span class="token punctuation">.</span>origin<span class="token punctuation">,</span> ray<span class="token punctuation">.</span>direction<span class="token punctuation">,</span> t<span class="token punctuation">,</span> u<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>inter<span class="token punctuation">.</span>happened<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        inter<span class="token punctuation">.</span>coords <span class="token operator">=</span> ray<span class="token punctuation">.</span>origin <span class="token operator">+</span> t <span class="token operator">*</span> ray<span class="token punctuation">.</span>direction<span class="token punctuation">;</span>        inter<span class="token punctuation">.</span>normal <span class="token operator">=</span> normal<span class="token punctuation">;</span>        inter<span class="token punctuation">.</span>distance <span class="token operator">=</span> t<span class="token punctuation">;</span>        inter<span class="token punctuation">.</span>obj <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        inter<span class="token punctuation">.</span>m <span class="token operator">=</span> m<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> inter<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后我也不太喜欢代码框架对 <code>IntersectP</code> 的定义，在我看来既然另外两个参数能通过 <code>ray</code> 算出来，就完全没有理由作为参数传入。</p><p>于是我就改成了这个只保留 <code>ray</code> 参数的样子：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">inline</span> <span class="token keyword">bool</span> <span class="token class-name">Bounds3</span><span class="token double-colon punctuation">::</span><span class="token function">IntersectP</span><span class="token punctuation">(</span><span class="token keyword">const</span> Ray<span class="token operator">&amp;</span> ray<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">&#123;</span>    <span class="token comment">// invDir: ray direction(x,y,z), invDir=(1.0/x,1.0/y,1.0/z), use this because Multiply is faster that Division</span>    <span class="token keyword">auto</span> tMinVec <span class="token operator">=</span> <span class="token punctuation">(</span>pMin <span class="token operator">-</span> ray<span class="token punctuation">.</span>origin<span class="token punctuation">)</span> <span class="token operator">*</span> ray<span class="token punctuation">.</span>direction_inv<span class="token punctuation">;</span>    <span class="token keyword">auto</span> tMaxVec <span class="token operator">=</span> <span class="token punctuation">(</span>pMax <span class="token operator">-</span> ray<span class="token punctuation">.</span>origin<span class="token punctuation">)</span> <span class="token operator">*</span> ray<span class="token punctuation">.</span>direction_inv<span class="token punctuation">;</span>    <span class="token keyword">float</span> tMinx <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>std<span class="token double-colon punctuation">::</span><span class="token function">min</span><span class="token punctuation">(</span>tMinVec<span class="token punctuation">.</span>x<span class="token punctuation">,</span> tMaxVec<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>ray<span class="token punctuation">.</span>t_min<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">float</span> tMiny <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>std<span class="token double-colon punctuation">::</span><span class="token function">min</span><span class="token punctuation">(</span>tMinVec<span class="token punctuation">.</span>y<span class="token punctuation">,</span> tMaxVec<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>ray<span class="token punctuation">.</span>t_min<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">float</span> tMinz <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>std<span class="token double-colon punctuation">::</span><span class="token function">min</span><span class="token punctuation">(</span>tMinVec<span class="token punctuation">.</span>z<span class="token punctuation">,</span> tMaxVec<span class="token punctuation">.</span>z<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>ray<span class="token punctuation">.</span>t_min<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">float</span> tMaxx <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>std<span class="token double-colon punctuation">::</span><span class="token function">max</span><span class="token punctuation">(</span>tMinVec<span class="token punctuation">.</span>x<span class="token punctuation">,</span> tMaxVec<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>ray<span class="token punctuation">.</span>t_max<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">float</span> tMaxy <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>std<span class="token double-colon punctuation">::</span><span class="token function">max</span><span class="token punctuation">(</span>tMinVec<span class="token punctuation">.</span>y<span class="token punctuation">,</span> tMaxVec<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>ray<span class="token punctuation">.</span>t_max<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">float</span> tMaxz <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>std<span class="token double-colon punctuation">::</span><span class="token function">max</span><span class="token punctuation">(</span>tMinVec<span class="token punctuation">.</span>z<span class="token punctuation">,</span> tMaxVec<span class="token punctuation">.</span>z<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>ray<span class="token punctuation">.</span>t_max<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">float</span> tMin <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>tMinx<span class="token punctuation">,</span> tMiny<span class="token punctuation">,</span> tMinz<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">float</span> tMax <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>tMaxx<span class="token punctuation">,</span> tMaxy<span class="token punctuation">,</span> tMaxz<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>tMin <span class="token operator">&lt;=</span> tMax<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>思路就是计算这个交集：</p><script type="math/tex; mode=display">[t_\text{raymin},t_\text{raymax}]\cap[t_{x, \text{enter}}, t_{x, \text{exit}}]\cap[t_{y, \text{enter}}, t_{y, \text{exit}}]\cap[t_{z, \text{enter}}, t_{z, \text{exit}}]</script><p>对于最后的 <code>getIntersection</code>，小 AI 说可以在发生相交时更新 <code>ray</code> 的 <code>t_max</code>，然后在射线和盒子的交点大于 <code>t_max</code> 时不再检测盒子内部的相交，这可以优化性能。我认为他说得非常有道理，但改起来有点麻烦，就不改了。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Intersection <span class="token class-name">BVHAccel</span><span class="token double-colon punctuation">::</span><span class="token function">getIntersection</span><span class="token punctuation">(</span>BVHBuildNode<span class="token operator">*</span> node<span class="token punctuation">,</span> <span class="token keyword">const</span> Ray<span class="token operator">&amp;</span> ray<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token operator">-></span>bounds<span class="token punctuation">.</span><span class="token function">IntersectP</span><span class="token punctuation">(</span>ray<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token function">Intersection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// leaf node checks ray's intersection with obj  </span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-></span>left <span class="token operator">==</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> node<span class="token operator">-></span>right <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-></span>object <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token function">Intersection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> node<span class="token operator">-></span>object<span class="token operator">-></span><span class="token function">getIntersection</span><span class="token punctuation">(</span>ray<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>     <span class="token comment">// parent with only one child returns child's intersection</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-></span>left <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token function">getIntersection</span><span class="token punctuation">(</span>node<span class="token operator">-></span>right<span class="token punctuation">,</span> ray<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-></span>right <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token function">getIntersection</span><span class="token punctuation">(</span>node<span class="token operator">-></span>left<span class="token punctuation">,</span> ray<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>     <span class="token comment">// parent with two children returns the closer intersection</span>    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        Intersection inter1 <span class="token operator">=</span> <span class="token function">getIntersection</span><span class="token punctuation">(</span>node<span class="token operator">-></span>left<span class="token punctuation">,</span> ray<span class="token punctuation">)</span><span class="token punctuation">;</span>        Intersection inter2 <span class="token operator">=</span> <span class="token function">getIntersection</span><span class="token punctuation">(</span>node<span class="token operator">-></span>right<span class="token punctuation">,</span> ray<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>inter1<span class="token punctuation">.</span>happened <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>inter2<span class="token punctuation">.</span>happened<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token function">Intersection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>inter1<span class="token punctuation">.</span>happened<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> inter2<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>inter2<span class="token punctuation">.</span>happened<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> inter1<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>inter1<span class="token punctuation">.</span>distance <span class="token operator">&lt;</span> inter2<span class="token punctuation">.</span>distance<span class="token punctuation">)</span> <span class="token operator">?</span> inter1 <span class="token operator">:</span> inter2<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>咱还是在最后放放图图</p><p><img src="/images/learning/open-course/GAMES101/Assignments/hw6/bvh.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这次的作业要求实现用包围盒来加快光线追踪，再用 BVH 优化。&lt;/p&gt;
&lt;p&gt;首先我们要把 hw5 里的代码复制过来，让我不解的是代码里明明已经提供了 &lt;code&gt;rayTriangleIntersect&lt;/code&gt; 函数，PDF 里却还说“将你的光线-三角形相交函数粘贴</summary>
      
    
    
    
    <category term="公开课" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"/>
    
    <category term="GAMES101" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/"/>
    
    <category term="Assignments" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/Assignments/"/>
    
    
  </entry>
  
  <entry>
    <title>Assignment 5 Raytracing</title>
    <link href="http://rinevard.github.io/wiki/learning/open-course/GAMES101/Hw/Hw5-raytracing/"/>
    <id>http://rinevard.github.io/wiki/learning/open-course/GAMES101/Hw/Hw5-raytracing/</id>
    <published>2025-09-22T11:46:16.000Z</published>
    <updated>2025-09-26T04:09:50.574Z</updated>
    
    <content type="html"><![CDATA[<p>如果只是实现要求的话，感觉这会是很无聊的一次作业。为了让事情有趣一点，我们来看看 <code>castRay</code> 函数的实现吧。我们会把作业代码放在文末。</p><h1 id="castRay-函数的分析"><a href="#castRay-函数的分析" class="headerlink" title="castRay 函数的分析"></a>castRay 函数的分析</h1><p>castRay 函数实现了课上讲的光线追踪，它从 <code>orig</code> 打出朝着 <code>dir</code> 方向的射线，并返回颜色。其工作流程如下：</p><ol><li><p>首先，检查当前的递归深度<code>depth</code>。当<code>depth</code>超过场景设定的最大深度<code>scene.maxDepth</code>时，函数返回黑色。这就是开头的代码：</p> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span>depth <span class="token operator">></span> scene<span class="token punctuation">.</span>maxDepth<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">Vector3f</span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">,</span><span class="token number">0.0</span><span class="token punctuation">,</span><span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>然后，计算射线是否与场景中的任何物体相交。如果没有发生相交，说明射线射向了场景的背景，函数将返回背景颜色。</p></li><li><p>如果射线击中了某个物体，函数将根据该物体的材质类型，进入不同的处理分支计算颜色。接下来我们会分析这些分支。</p></li></ol><p>我们可以看到物体被分为了三种材质，分别是既有镜面反射又有折射的 <code>REFLECTION_AND_REFRACTION</code>、只有反射的 <code>REFLECTION</code>、只有漫反射的 <code>DIFFUSE_AND_GLOSSY</code>。<code>REFLECTION_AND_REFRACTION</code> 和 <code>REFLECTION</code> 部分的代码比较相似，我们就先讨论 <code>REFLECTION_AND_REFRACTION</code> 的代码，再讨论 <code>DIFFUSE_AND_GLOSSY</code> 的代码。</p><h2 id="REFLECTION-AND-REFRACTION"><a href="#REFLECTION-AND-REFRACTION" class="headerlink" title="REFLECTION_AND_REFRACTION"></a>REFLECTION_AND_REFRACTION</h2><p>这里的反射/折射材质自身是没有颜色的，也就是说它们只显示反射/折射后射线打到的点的颜色。所以代码思路比较简单，如果射线打到了这种材质的物体上，它会反射/折射，我们需要计算出反射/折射后的射线打到的颜色，这就对应着下面的代码：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Vector3f reflectionColor <span class="token operator">=</span> <span class="token function">castRay</span><span class="token punctuation">(</span>reflectionRayOrig<span class="token punctuation">,</span> reflectionDirection<span class="token punctuation">,</span> scene<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Vector3f refractionColor <span class="token operator">=</span> <span class="token function">castRay</span><span class="token punctuation">(</span>refractionRayOrig<span class="token punctuation">,</span> refractionDirection<span class="token punctuation">,</span> scene<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>代码里还考虑了菲涅尔效应来计算反射和折射的比例。菲涅尔效应的公式有点复杂，我们就不讲解了。这里的 <code>kr</code> 就是菲涅尔方程算出的反射系数，而由能量守恒，折射系数就是 $1-\text{kr}$。</p><p><code>hitColor</code> 就是这个点的最终颜色：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">float</span> kr <span class="token operator">=</span> <span class="token function">fresnel</span><span class="token punctuation">(</span>dir<span class="token punctuation">,</span> N<span class="token punctuation">,</span> payload<span class="token operator">-></span>hit_obj<span class="token operator">-></span>ior<span class="token punctuation">)</span><span class="token punctuation">;</span>hitColor <span class="token operator">=</span> reflectionColor <span class="token operator">*</span> kr <span class="token operator">+</span> refractionColor <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> kr<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>我们也会注意到，代码在开头对反射/折射点做了一个小小的偏移，这似乎是为了避免反射/折射时立即打到自己（咱也不确定，这是猜测）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Vector3f reflectionRayOrig <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token function">dotProduct</span><span class="token punctuation">(</span>reflectionDirection<span class="token punctuation">,</span> N<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span>                              hitPoint <span class="token operator">-</span> N <span class="token operator">*</span> scene<span class="token punctuation">.</span>epsilon <span class="token operator">:</span>                              hitPoint <span class="token operator">+</span> N <span class="token operator">*</span> scene<span class="token punctuation">.</span>epsilon<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>我们都看到菲涅尔效应的代码了，不如再看看纯反射/纯折射的球是怎样的。注意靠近我们观察者的球，我们可以先把 <code>kr</code> 设为 1 来看看纯反射的结果：</p><p><img src="/images/learning/open-course/GAMES101/Assignments/hw5/reflection_only.png" alt=""></p><p>再来看看纯折射的结果：</p><p><img src="/images/learning/open-course/GAMES101/Assignments/hw5/refraction_only.png" alt=""></p><p>与文末的图比较一下，就会发现菲涅尔效应确实就是反射和折射的叠加。</p><h2 id="DIFFUSE-AND-GLOSSY"><a href="#DIFFUSE-AND-GLOSSY" class="headerlink" title="DIFFUSE_AND_GLOSSY"></a>DIFFUSE_AND_GLOSSY</h2><p>再来看看 <code>DIFFUSE_AND_GLOSSY</code> 部分，这里是正常的 Phong 模型着色。唯一要注意的是，要判断射线打到的点和光源之间有没有物体遮挡，如果有遮挡这里就是阴影。</p><p>我认为这一部分的代码有问题，它只考虑了漫反射分量在不在阴影里，而没考虑镜面反射分量。这里是原本的代码：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 漫反射</span>lightAmt <span class="token operator">+=</span> inShadow <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> light<span class="token operator">-></span>intensity <span class="token operator">*</span> LdotN<span class="token punctuation">;</span><span class="token comment">// 镜面反射</span>Vector3f reflectionDirection <span class="token operator">=</span> <span class="token function">reflect</span><span class="token punctuation">(</span><span class="token operator">-</span>lightDir<span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span>specularColor <span class="token operator">+=</span> <span class="token function">powf</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">0.f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token function">dotProduct</span><span class="token punctuation">(</span>reflectionDirection<span class="token punctuation">,</span> dir<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    payload<span class="token operator">-></span>hit_obj<span class="token operator">-></span>specularExponent<span class="token punctuation">)</span> <span class="token operator">*</span> light<span class="token operator">-></span>intensity<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我想我们应该做这样的修改：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>inShadow<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 漫反射</span>    lightAmt <span class="token operator">+=</span> light<span class="token operator">-></span>intensity <span class="token operator">*</span> LdotN<span class="token punctuation">;</span>        <span class="token comment">// 镜面反射</span>    Vector3f reflectionDirection <span class="token operator">=</span> <span class="token function">reflect</span><span class="token punctuation">(</span><span class="token operator">-</span>lightDir<span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span>    specularColor <span class="token operator">+=</span> <span class="token function">powf</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">0.f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token function">dotProduct</span><span class="token punctuation">(</span>reflectionDirection<span class="token punctuation">,</span> dir<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        payload<span class="token operator">-></span>hit_obj<span class="token operator">-></span>specularExponent<span class="token punctuation">)</span> <span class="token operator">*</span> light<span class="token operator">-></span>intensity<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="作业代码"><a href="#作业代码" class="headerlink" title="作业代码"></a>作业代码</h1><p>接下来咱就直接放作业代码了。</p><p>首先是 <code>rayTriangleIntersect</code>：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">rayTriangleIntersect</span><span class="token punctuation">(</span><span class="token keyword">const</span> Vector3f<span class="token operator">&amp;</span> v0<span class="token punctuation">,</span> <span class="token keyword">const</span> Vector3f<span class="token operator">&amp;</span> v1<span class="token punctuation">,</span> <span class="token keyword">const</span> Vector3f<span class="token operator">&amp;</span> v2<span class="token punctuation">,</span> <span class="token keyword">const</span> Vector3f<span class="token operator">&amp;</span> orig<span class="token punctuation">,</span>                          <span class="token keyword">const</span> Vector3f<span class="token operator">&amp;</span> dir<span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token operator">&amp;</span> tNear<span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token operator">&amp;</span> u<span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token operator">&amp;</span> v<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">auto</span> e1 <span class="token operator">=</span> v1 <span class="token operator">-</span> v0<span class="token punctuation">;</span>    <span class="token keyword">auto</span> e2 <span class="token operator">=</span> v2 <span class="token operator">-</span> v0<span class="token punctuation">;</span>    <span class="token keyword">auto</span> s <span class="token operator">=</span> orig <span class="token operator">-</span> v0<span class="token punctuation">;</span>    <span class="token keyword">auto</span> s1 <span class="token operator">=</span> <span class="token function">crossProduct</span><span class="token punctuation">(</span>dir<span class="token punctuation">,</span> e2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> s2 <span class="token operator">=</span> <span class="token function">crossProduct</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> e1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> coefficient <span class="token operator">=</span> <span class="token number">1.0</span> <span class="token operator">/</span> <span class="token function">dotProduct</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> e1<span class="token punctuation">)</span><span class="token punctuation">;</span>    tNear <span class="token operator">=</span> coefficient <span class="token operator">*</span> <span class="token function">dotProduct</span><span class="token punctuation">(</span>s2<span class="token punctuation">,</span> e2<span class="token punctuation">)</span><span class="token punctuation">;</span>    u <span class="token operator">=</span> coefficient <span class="token operator">*</span> <span class="token function">dotProduct</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>    v <span class="token operator">=</span> coefficient <span class="token operator">*</span> <span class="token function">dotProduct</span><span class="token punctuation">(</span>s2<span class="token punctuation">,</span> dir<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>tNear <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>u <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>v <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> u <span class="token operator">-</span> v<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后是 <code>Render</code> 的部分：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> scene<span class="token punctuation">.</span>width<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// generate primary ray direction</span>    <span class="token keyword">float</span> x<span class="token punctuation">;</span>    <span class="token keyword">float</span> y<span class="token punctuation">;</span>    <span class="token comment">// I don't understand what are the guiding comments talking about.</span>    <span class="token comment">// Anyway, the code is assuming the distance between eye and screen is one, since abs(dir.z) == 1</span>    <span class="token comment">// With this assumption we can compute screen's width and height</span>    <span class="token comment">// Then we map x from [0, scene.width - 1] to [-screen_width / 2, screenwidth / 2]</span>    <span class="token comment">// and map y from [0, scene.height - 1] to [screen_height / 2, -screen_height / 2]</span>    <span class="token keyword">float</span> screen_height <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> scale<span class="token punctuation">;</span>    <span class="token keyword">float</span> screen_width <span class="token operator">=</span> imageAspectRatio <span class="token operator">*</span> screen_height<span class="token punctuation">;</span>        x <span class="token operator">=</span> <span class="token punctuation">(</span>screen_width <span class="token operator">/</span> <span class="token punctuation">(</span>scene<span class="token punctuation">.</span>width <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">0.5</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token punctuation">(</span>screen_width <span class="token operator">/</span> <span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    y <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">-</span>screen_height <span class="token operator">/</span> <span class="token punctuation">(</span>scene<span class="token punctuation">.</span>height <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>j <span class="token operator">+</span> <span class="token number">0.5</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>screen_height <span class="token operator">/</span> <span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Vector3f dir <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span><span class="token function">Vector3f</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Don't forget to normalize this direction!</span>    framebuffer<span class="token punctuation">[</span>m<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">castRay</span><span class="token punctuation">(</span>eye_pos<span class="token punctuation">,</span> dir<span class="token punctuation">,</span> scene<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看看结果吧！如果和前面的纯反射/纯折射对照，会发现前面的球确实就是反射和折射的叠加（反射很淡，不过仔细看也是能看出来的！）</p><p><img src="/images/learning/open-course/GAMES101/Assignments/hw5/binary.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;如果只是实现要求的话，感觉这会是很无聊的一次作业。为了让事情有趣一点，我们来看看 &lt;code&gt;castRay&lt;/code&gt; 函数的实现吧。我们会把作业代码放在文末。&lt;/p&gt;
&lt;h1 id=&quot;castRay-函数的分析&quot;&gt;&lt;a href=&quot;#castRay-函数的分析&quot; cl</summary>
      
    
    
    
    <category term="公开课" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"/>
    
    <category term="GAMES101" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/"/>
    
    <category term="Assignments" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/Assignments/"/>
    
    
  </entry>
  
  <entry>
    <title>Assignment 4 Geometry</title>
    <link href="http://rinevard.github.io/wiki/learning/open-course/GAMES101/Hw/Hw4-geometry/"/>
    <id>http://rinevard.github.io/wiki/learning/open-course/GAMES101/Hw/Hw4-geometry/</id>
    <published>2025-09-22T11:44:16.000Z</published>
    <updated>2025-09-22T11:44:41.718Z</updated>
    
    <content type="html"><![CDATA[<p>这次作业过于简单，我们直接放代码。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cv<span class="token double-colon punctuation">::</span>Point2f <span class="token function">recursive_bezier</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>cv<span class="token double-colon punctuation">::</span>Point2f<span class="token operator">></span> <span class="token operator">&amp;</span>control_points<span class="token punctuation">,</span> <span class="token keyword">float</span> t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// TODO: Implement de Casteljau's algorithm</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>control_points<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> t<span class="token punctuation">)</span> <span class="token operator">*</span> control_points<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> t <span class="token operator">*</span> control_points<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>cv<span class="token double-colon punctuation">::</span>Point2f<span class="token operator">></span> new_control_points <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> control_points<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        new_control_points<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> t<span class="token punctuation">)</span> <span class="token operator">*</span> control_points<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> t <span class="token operator">*</span> control_points<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token function">recursive_bezier</span><span class="token punctuation">(</span>new_control_points<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">bezier</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>cv<span class="token double-colon punctuation">::</span>Point2f<span class="token operator">></span> <span class="token operator">&amp;</span>control_points<span class="token punctuation">,</span> cv<span class="token double-colon punctuation">::</span>Mat <span class="token operator">&amp;</span>window<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// TODO: Iterate through all t = 0 to t = 1 with small steps, and call de Casteljau's </span>    <span class="token comment">// recursive Bezier algorithm.</span>    <span class="token keyword">float</span> step <span class="token operator">=</span> <span class="token number">0.001</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">float</span> t <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> t <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span> t <span class="token operator">+=</span> step <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">auto</span> point <span class="token operator">=</span> <span class="token function">recursive_bezier</span><span class="token punctuation">(</span>control_points<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>        window<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">at</span><span class="token generic class-name"><span class="token operator">&lt;</span>cv<span class="token double-colon punctuation">::</span>Vec3b<span class="token operator">></span></span></span><span class="token punctuation">(</span>point<span class="token punctuation">.</span>y<span class="token punctuation">,</span> point<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">255</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另外，由于咱以前在 Godot 里导入字体时见过多通道符号距离场的设置，而且发现开启多通道符号距离场的字体显示清晰了一大截，所以我找了找一些关于 SDF 的资料，感觉这个不错：<a href="https://www.xianlongok.site/post/4625ed6a/#SDF-font">动态 SDF 字体渲染方法 | 十三</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这次作业过于简单，我们直接放代码。&lt;/p&gt;
&lt;pre class=&quot;line-numbers language-cpp&quot; data-language=&quot;cpp&quot;&gt;&lt;code class=&quot;language-cpp&quot;&gt;cv&lt;span class=&quot;token double-c</summary>
      
    
    
    
    <category term="公开课" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"/>
    
    <category term="GAMES101" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/"/>
    
    <category term="Assignments" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/Assignments/"/>
    
    
  </entry>
  
  <entry>
    <title>Note 4 Geometry</title>
    <link href="http://rinevard.github.io/wiki/learning/open-course/GAMES101/Notes/Note4-Geometry/"/>
    <id>http://rinevard.github.io/wiki/learning/open-course/GAMES101/Notes/Note4-Geometry/</id>
    <published>2025-09-19T12:10:28.000Z</published>
    <updated>2025-09-19T12:13:54.595Z</updated>
    
    <content type="html"><![CDATA[<p>课上只是简单提了下几何专题，我也认为这个专题相较于别的几个没那么重要，所以只是记一下隐式表示和参数表示的相关内容，再简单提一句网格处理。</p><h1 id="隐式表示和参数表示"><a href="#隐式表示和参数表示" class="headerlink" title="隐式表示和参数表示"></a>隐式表示和参数表示</h1><p>对一个几何图形，我们一般有两种表示方法，一种是用普通方程 $f(x,y,z)=0$ 来表示，另一种是用参数方程 $g(u,v)=(x,y,z)$ 来表示。前者是隐式表示，因为不能方便地求出这个方程表示的所有点；后者是参数表示，通过参数 $(u,v)$ 的变化可以轻易求出这个方程表示的所有点。</p><p>不过隐式表示也有优点，它能很方便地判断一个点 $(x,y,z)$ 是否在曲线上 / 曲线内 / 曲线外。接下来我们看看隐式表示和参数表示的代表应用。</p><h2 id="隐式表示：符号距离场"><a href="#隐式表示：符号距离场" class="headerlink" title="隐式表示：符号距离场"></a>隐式表示：符号距离场</h2><p>符号距离场（Signed Distance Filed, SDF）是隐式表示的代表应用之一，自 2007 年 Valve 的论文以来，它一直被用于游戏内的文本渲染。虽然现在用的更多是多通道符号距离场（MSDF），但我们这里只简单介绍下符号距离场，因为后者更加复杂。</p><p>符号距离场就是带符号的距离场，对给定的点 $(u,v)$，我们记录它到图形的最近距离——如果它在图形内部（图形的线条是有宽度的，这个内部指在线条内而非几何闭环内），距离为正值，否则为负值。</p><p>在 V 社的论文中，他们先对矢量文字做了光栅化得到了 $4096\times 4096$ 的图像，然后基于这张图得到了 $64\times 64$ 的符号距离场。</p><p>下图展示了原图和符号距离场。图像不透明度是在 $[0,1]$ 间的非负数，为了可视化符号距离场，我们把距离为正的内部映射到 $(0.5, 1]$，距离为 $0$ 的边缘被映射到 $0.5$，距离为负的外部映射到 $[0, 0.5)$.</p><p><img src="/images/learning/open-course/GAMES101/Notes/note4/sdf.png" alt=""></p><p>得到了符号距离场之后，我们就能对任何一个点插值出它与图形的距离，然后根据这个距离决定它是否显示出来。我们之前已经提过了距离到不透明度的映射，我们可以简单设置一个阈值来决定是否显示某个像素：</p><pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl">baseColor<span class="token punctuation">.</span>a <span class="token operator">=</span> distAlphaMask <span class="token operator">>=</span> <span class="token number">0.5</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我个人的思考是，不要因为我们可视化了符号距离场就把它当作图像。它本质上是一个距离函数 $d(u,v)$，我们的 $64\times 64$ 的 SDF 图像的每个像素表示的不是“平均颜色”，而是“像素中心点到图形的距离”。要把它看作点，而非方块。</p><h2 id="参数表示：贝塞尔曲线和曲面"><a href="#参数表示：贝塞尔曲线和曲面" class="headerlink" title="参数表示：贝塞尔曲线和曲面"></a>参数表示：贝塞尔曲线和曲面</h2><p>贝塞尔曲线和曲面是参数表示的很好例子，我们先来看看计算贝塞尔曲线的常用算法和一般公式。</p><h3 id="贝塞尔曲线"><a href="#贝塞尔曲线" class="headerlink" title="贝塞尔曲线"></a>贝塞尔曲线</h3><p>常用的生成贝塞尔曲线的 Casteljau Algorithm 如下，我们以四个点求三阶贝塞尔曲线为例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">bezier</span><span class="token punctuation">(</span>t<span class="token punctuation">:</span> <span class="token builtin">float</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 第一层线性插值</span>    p0_1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> t<span class="token punctuation">)</span> <span class="token operator">*</span> p0 <span class="token operator">+</span> t <span class="token operator">*</span> p1    p1_1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> t<span class="token punctuation">)</span> <span class="token operator">*</span> p1 <span class="token operator">+</span> t <span class="token operator">*</span> p2    p2_1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> t<span class="token punctuation">)</span> <span class="token operator">*</span> p2 <span class="token operator">+</span> t <span class="token operator">*</span> p3    <span class="token comment"># 第二层线性插值</span>    p0_2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> t<span class="token punctuation">)</span> <span class="token operator">*</span> p0_1 <span class="token operator">+</span> t <span class="token operator">*</span> p1_1    p1_2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> t<span class="token punctuation">)</span> <span class="token operator">*</span> p1_1 <span class="token operator">+</span> t <span class="token operator">*</span> p2_1    <span class="token comment"># 第三层（最后一层）线性插值</span>    p_final <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> t<span class="token punctuation">)</span> <span class="token operator">*</span> p0_2 <span class="token operator">+</span> t <span class="token operator">*</span> p1_2    <span class="token keyword">return</span> p_final<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看看这个算法也就知道贝塞尔曲线是怎么来的了。</p><p>三阶公式是</p><script type="math/tex; mode=display">\mathbf{B}(t) = (1-t)^3 \mathbf{P}_0 + 3(1-t)^2 t \mathbf{P}_1 + 3(1-t) t^2 \mathbf{P}_2 + t^3 \mathbf{P}_3</script><p>一般的 $n$ 阶公式是</p><script type="math/tex; mode=display">\mathbf{B}(t) = \sum_{i=0}^{m} \binom{m}{i} (1-t)^{m-i} t^i \mathbf{P}_i</script><p>下图中，左图是 Godot 里的 Curve，它就用到了贝塞尔曲线；右图贝塞尔曲线的生成方法，和上面提到的 Casteljau Algorithm 一致。</p><p><img src="/images/learning/open-course/GAMES101/Notes/note4/bezier.png" alt=""></p><p>再看看左图，我们会发现它是由三个贝塞尔曲线拼接而成的，而且看起来很平滑，这就是所谓的“分段贝塞尔曲线”。高阶贝塞尔曲线不容易控制，所以我们更倾向于把几个低阶贝塞尔曲线拼接起来形成复杂曲线。</p><h3 id="贝塞尔曲面"><a href="#贝塞尔曲面" class="headerlink" title="贝塞尔曲面"></a>贝塞尔曲面</h3><p>我们同样用 Casteljau Algorithm 生成贝塞尔曲面：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">_de_casteljau_1d</span><span class="token punctuation">(</span>points<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""对一维点序列执行 Casteljau 算法。"""</span>    <span class="token keyword">while</span> <span class="token builtin">len</span><span class="token punctuation">(</span>points<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">:</span>        points <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> t<span class="token punctuation">)</span> <span class="token operator">*</span> p1 <span class="token operator">+</span> t <span class="token operator">*</span> p2 <span class="token keyword">for</span> p1<span class="token punctuation">,</span> p2 <span class="token keyword">in</span> <span class="token builtin">zip</span><span class="token punctuation">(</span>points<span class="token punctuation">,</span> points<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token keyword">return</span> points<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token keyword">def</span> <span class="token function">bezier_surface</span><span class="token punctuation">(</span>control_points<span class="token punctuation">,</span> u<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""计算贝塞尔曲面上的一点。"""</span>    intermediate_points <span class="token operator">=</span> <span class="token punctuation">[</span>_de_casteljau_1d<span class="token punctuation">(</span>row<span class="token punctuation">,</span> u<span class="token punctuation">)</span> <span class="token keyword">for</span> row <span class="token keyword">in</span> control_points<span class="token punctuation">]</span>    final_point <span class="token operator">=</span> _de_casteljau_1d<span class="token punctuation">(</span>intermediate_points<span class="token punctuation">,</span> v<span class="token punctuation">)</span>    <span class="token keyword">return</span> final_point<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如下图中的右图所示，我们本质上是先沿着一个轴向生成一组贝塞尔曲线，再在曲线上取值生成一组新的控制点，然后用这组新控制点定义一条新的曲线，最后在新的曲线上取值得到曲面上的最终点。</p><p><img src="/images/learning/open-course/GAMES101/Notes/note4/bezier_surface.png" alt=""></p><h1 id="网格处理"><a href="#网格处理" class="headerlink" title="网格处理"></a>网格处理</h1><p>生成三角形网格后，我们经常还希望做一些处理，比如细分来让模型更光滑；减少三角形数量来简化网格。下面简单提一下网格细分和网格简化的常用算法。</p><p><img src="/images/learning/open-course/GAMES101/Notes/note4/mesh_operation.png" alt=""></p><h2 id="网格细分"><a href="#网格细分" class="headerlink" title="网格细分"></a>网格细分</h2><p>网格细分算法的绝对主流是 Catmull-Clark 细分，Blender 的表面细分修改器的默认算法就是这个。它可以细分任意形状的多边形，但在细分四边形时效果最好。</p><p>课上还提到了用于细分三角形的 Loop 细分，不过两个细分都只是简单提了提概念，我们这里不多记笔记。</p><h2 id="网格简化"><a href="#网格简化" class="headerlink" title="网格简化"></a>网格简化</h2><p>网格简化的基本思路是每次把一条边坍缩成一个点。我们用二次误差衡量每条边坍缩后引入的误差，然后选择最小的边来坍缩，之后重新计算二次误差（因为坍缩后形状会改变），然后再次选择最小的边，如此重复。这是个贪婪算法，但能拿到不错的结果。</p><p>具体公式我们也不写，因为课上没详细讲，我也不感兴趣，用到的时候去查查就好了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;课上只是简单提了下几何专题，我也认为这个专题相较于别的几个没那么重要，所以只是记一下隐式表示和参数表示的相关内容，再简单提一句网格处理。&lt;/p&gt;
&lt;h1 id=&quot;隐式表示和参数表示&quot;&gt;&lt;a href=&quot;#隐式表示和参数表示&quot; class=&quot;headerlink&quot; title</summary>
      
    
    
    
    <category term="公开课" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"/>
    
    <category term="GAMES101" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/"/>
    
    <category term="Notes" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/Notes/"/>
    
    
  </entry>
  
  <entry>
    <title>Note 3 Shading</title>
    <link href="http://rinevard.github.io/wiki/learning/open-course/GAMES101/Notes/Note3-Shading/"/>
    <id>http://rinevard.github.io/wiki/learning/open-course/GAMES101/Notes/Note3-Shading/</id>
    <published>2025-09-17T04:10:28.000Z</published>
    <updated>2025-09-17T04:03:13.842Z</updated>
    
    <content type="html"><![CDATA[<h1 id="יְהִי-אוֹר"><a href="#יְהִי-אוֹר" class="headerlink" title="יְהִי אוֹר"></a>יְהִי אוֹר</h1><p>起初，计算机的世界尚未渲染，显示器中空虚混沌，渊面黑暗。</p><p>唯有顶点与多边形悬于虚空，不见其形，不辨其色。</p><p>那声音说：<strong>“要有光。”</strong></p><p>就有了光。</p><p>光是好的，于是那声音将光与暗分开了。光所照之处，物体的正面得以显现；光所不至的背面，则归于阴影。从此，三维的世界有了明暗与层次。</p><p>这光并非一体。</p><p>那普照万物，均匀散开，使物体显其本色的，称之为<strong>漫反射</strong>。</p><p>那汇于一点，锐利夺目，使光滑之物尽显其耀的，称之为<strong>镜面反射</strong>。</p><p>那弥漫于环境，充盈于阴影，使黑暗不至完全吞噬一切的，称之为<strong>环境光</strong>。</p><p>有漫反射，有镜面反射，有环境光，共同构成了这虚拟世界的第一个白昼。</p><h2 id="漫反射（Diffuse-Reflection）"><a href="#漫反射（Diffuse-Reflection）" class="headerlink" title="漫反射（Diffuse Reflection）"></a>漫反射（<strong>Diffuse Reflection）</strong></h2><p>在漫反射中，光向四面八方散去，所以物体漫反射出的光与摄像机位置无关，而仅与以下几项有关：</p><ol><li>光强 $c_l$.</li><li>物体材质 $c_r$. 不同物体对光的反射率是不同的，即使是同一个物体也对不同颜色的光有不同反射率。</li><li>物体表面法线 $\mathbf{n}$.</li><li>光源方向 $\mathbf{l}$.</li></ol><p>最终结果可以写成 </p><script type="math/tex; mode=display">L_d = c_r c_l \max (0, \mathbf{n} \cdot \mathbf{l})</script><p>由于光强一般随距离衰减，所以 $c_l$ 一般反比于距离的平方 $r^2$. </p><h2 id="镜面反射（Specular-Reflection）"><a href="#镜面反射（Specular-Reflection）" class="headerlink" title="镜面反射（Specular Reflection）"></a>镜面反射（Specular Reflection）</h2><p>镜面反射中，光主要向一个方向反射，所以镜面反射的光与摄像机位置有关。</p><script type="math/tex; mode=display">L_s = c_pc_l\max(0, \mathbf n \cdot \mathbf h)^p</script><p>其中 $c_p$ 是自定义的 RGB 值，允许我们控制高光颜色，指数 $p$ 是为了保证我们只在小范围内看到高光，$p$ 越大这个高光可见范围越小，而 $\mathbf h$ 的定义如下：</p><script type="math/tex; mode=display">\mathbf h = (\mathbf e + \mathbf l).\text{normalized()}</script><p>还有一种写法把 $\mathbf n \cdot \mathbf h$ 换成了 $\mathbf r \cdot \mathbf e$，简单计算可以发现 $\mathbf<br>n$ 和 $\mathbf h$ 的夹角是 $\mathbf r$ 和 $\mathbf e$ 的夹角的一半，所以这两个写法在思路上是一样的，都在考虑反射光方向和摄像机方向的夹角，不过在数值上会略有差别。本文采用 $\mathbf n \cdot \mathbf h$ 的写法。</p><p><img src="/images/learning/open-course/GAMES101/Notes/note3/specular.png" alt=""></p><h2 id="环境光（Ambient-Lighting）"><a href="#环境光（Ambient-Lighting）" class="headerlink" title="环境光（Ambient Lighting）"></a>环境光（Ambient Lighting）</h2><p>如果只考虑漫反射和镜面反射，我们会发现没有面朝光源的物体完全是黑色的，但现实里显然不是如此。这是因为在现实里，光经过多次反射而照亮了那些没有面朝光源的物体。我们可以近似地认为有一种充斥着整个空间的光，并把它叫做环境光，公式如下：</p><script type="math/tex; mode=display">L_a=c_r c_a</script><p>其中 $c_a$ 是环境光的强度。</p><h2 id="冯氏光照模型"><a href="#冯氏光照模型" class="headerlink" title="冯氏光照模型"></a>冯氏光照模型</h2><p>综合来看，我们就得到了<strong>冯氏光照模型</strong>，公式如下：</p><script type="math/tex; mode=display">L=c_r(c_a+c_l\max{(0,\mathbf n \cdot \mathbf l)})+c_pc_l\max(0, \mathbf n \cdot \mathbf h)^p</script><p>其中 </p><ol><li>$c_r$ 是物体材质，表示物体对光的反射率，一般是一个 Vector3f 类型的值，因为物体对不同颜色的光有不同反射率；</li><li>$c_a$ 是环境光强，一般是一个 Vector3f 类型的值；</li><li>$c_l$ 是光强，一般与物体和光源的距离成反比，一般是一个 Vector3f 类型的值；</li><li>$c_p$ 是高光颜色，一般也是一个 Vector3f 类型的值。</li></ol><h1 id="UV映射"><a href="#UV映射" class="headerlink" title="UV映射"></a>UV映射</h1><p>为了把贴图贴到模型上，需要有一个 $(x, y, z) \rightarrow (u, v)$ 的函数 $\phi$. 我们期望这个函数有这些性质：</p><ol><li>单射：我们不希望两个 3D 点映射到同一个 2D 点上</li><li>大小不变性：在 3D 模型上的三角形多大，我们希望 2D 的三角形也差不多大小</li><li>形状不变性：3D 模型的三角形映射到 2D 上后，两个三角形应尽量相似</li><li>连续：如果两个点在 3D 世界模型上相近，我们希望它们在 2D 上也相近</li></ol><p>贴图有许多应用，最容易想到的是颜色贴图，它直接把颜色贴到模型上，也被称作漫反射贴图。</p><p>法线贴图、金属度贴图、粗糙度贴图则进一步决定了模型的各种属性。比如法线贴图定义了每一点的法线，在计算光照时会借助这个法线来得到更真实的结果。</p><p><img src="/images/learning/open-course/GAMES101/Notes/note3/normal-map.jpg" alt=""></p><h1 id="着色方法"><a href="#着色方法" class="headerlink" title="着色方法"></a>着色方法</h1><p>模型由三角形划分来表示，那么每个三角形用怎样的颜色呢？</p><h2 id="平面着色（Flat-Shading）"><a href="#平面着色（Flat-Shading）" class="headerlink" title="平面着色（Flat Shading）"></a>平面着色（Flat Shading）</h2><p>我们通过光照计算颜色，而计算光照需要法线。平面着色直接求这个三角形的法线，然后按光照公式计算这个三角形的颜色。这种方法得到的每个三角形都是单色的。</p><h2 id="逐顶点着色（Gouraud-Shading）"><a href="#逐顶点着色（Gouraud-Shading）" class="headerlink" title="逐顶点着色（Gouraud Shading）"></a>逐顶点着色（Gouraud Shading）</h2><p>逐顶点着色则求三角形顶点的法线，并为三角形顶点着色，然后对内部的每个点插值内部颜色。</p><p>那么顶点的法线是什么呢？一个顶点一般在多个面上，把这些面的法线做加权平均就好，权值可以是面的面积。</p><h2 id="逐像素着色（Phong-Shading）"><a href="#逐像素着色（Phong-Shading）" class="headerlink" title="逐像素着色（Phong Shading）"></a>逐像素着色（Phong Shading）</h2><p>逐像素着色同样求三角形顶点的法线，然后对内部的每个点插值内部法线，从法线再求各个点的颜色。</p><p>插值是通过重心坐标来插值。对三角形 $ABC$ 内的某一点 $P$，它可以表示为</p><script type="math/tex; mode=display">P=\frac{S_{APB}C+S_{BPC}A+S_{CPA}B}{S_{ABC}}</script><p>这里的 $S$ 是面积，这里的形如 $S<em>{APB}/S</em>{ABC}$ 的式子就是各个点的权值。</p><p>在插值时，我们希望在世界空间 / 摄像机空间做插值，即在 viewing transformation 前进行插值，而不是 viewing transformation 后。</p><p>但我们一般在光栅化时才进行插值，这时已经把物体变换到了 NDC 空间，所以我们还要进行透视矫正。公式如下，具体推导可以参考 Homework 3 的笔记。</p><script type="math/tex; mode=display">\begin{align*}&\alpha = \frac{\alpha' / w_0}{\alpha' / w_0 + \beta' / w_1 + \gamma' / w_2}\\&\beta= \frac{\beta' / w_1}{\alpha' / w_0 + \beta' / w_1 + \gamma' / w_2}\\&\gamma= \frac{\gamma' / w_2}{\alpha' / w_0 + \beta' / w_1 + \gamma' / w_2}\end{align*}</script><p>其中 $\alpha’,\beta’,\gamma’$ 是屏幕空间的重心坐标，$\alpha,\beta,\gamma$ 是世界空间的重心坐标。我们用世界空间的重心坐标作为权重来插值。</p><p><img src="/images/learning/open-course/GAMES101/Notes/note3/shading-freq.png" alt=""></p><h1 id="渲染管线"><a href="#渲染管线" class="headerlink" title="渲染管线"></a>渲染管线</h1><p>渲染流程基本如下：</p><ol><li>Input：输入 3D 世界的顶点</li><li>Vertex Processing：用各种变换矩阵把顶点变换到屏幕空间</li><li>Triangle Processing：根据传入的顶点连接方式在屏幕空间连接三角形</li><li>Rasterization：把三角形转化成片元 / 像素</li><li>Fragement Processing：应用贴图、光照等</li><li>Framebuffer Operations：深度测试等</li></ol><p><img src="/images/learning/open-course/GAMES101/Notes/note3/pipeline.png" alt=""></p><h1 id="纹理放大和纹理缩小"><a href="#纹理放大和纹理缩小" class="headerlink" title="纹理放大和纹理缩小"></a>纹理放大和纹理缩小</h1><p>在做纹理映射时，贴图太小和贴图太大都会有问题。</p><p><img src="/images/learning/open-course/GAMES101/Notes/note3/mag-minification.png" alt=""></p><h2 id="纹理放大"><a href="#纹理放大" class="headerlink" title="纹理放大"></a>纹理放大</h2><p>贴图太小时要做纹理放大，对采样点做双线性插值即可。</p><p><img src="/images/learning/open-course/GAMES101/Notes/note3/upsample.png" alt=""></p><h2 id="纹理缩小"><a href="#纹理缩小" class="headerlink" title="纹理缩小"></a>纹理缩小</h2><p>贴图太大时直觉上比贴图太小更好处理，但恰恰相反。还记得频谱吗，贴图太大代表高频有更多信息，我们会因采样频率不足而无法正确反映高频信息，导致结果出现锯齿、摩尔纹等走样问题。</p><p>最常用的缓解方法是 Mipmapping。基本思路是，我们分析屏幕上每个像素在贴图上覆盖的像素数量，对那些覆盖较多的，就让他们去被缩小的贴图上采样，这样就能缓解欠采样问题。</p><p>首先我们要创建“缩小的贴图”，Mipmap链包含一系列纹理 $D_0, D_1, D_2, \ldots, D_N$，其中 $D_i$ 的分辨率为 $\frac{W}{2^i} \times \frac{H}{2^i}$，直到最内层为 $1 \times 1$ 像素。</p><p>然后我们要分析单个屏幕像素覆盖了多少纹理像素，大致思路是计算屏幕空间的相邻点映射到贴图空间后的距离。贴图空间里相邻像素距离为 $1$，所以如果屏幕空间的相邻点映射到贴图空间后的距离为 $x$，我们就认为它覆盖了 $x$ 个像素。</p><p>这个“单个屏幕像素覆盖了多少纹理像素”的估算被记作 $\rho$，公式如下：</p><script type="math/tex; mode=display">\rho = \max\left( \sqrt{\left(\frac{\partial u}{\partial x}\right)^2 + \left(\frac{\partial v}{\partial x}\right)^2}, \sqrt{\left(\frac{\partial u}{\partial y}\right)^2 + \left(\frac{\partial v}{\partial y}\right)^2} \right)</script><p>取 $\max$ 是为了尽可能取层级更低的 Mipmap。一个屏幕像素覆盖的纹理像素越多，它对应的 Mipmap 层级就越小。总之，我们宁可模糊，也不要欠采样。</p><p>最后用 $\lambda = \log_2{\rho}$ 就能算出这个屏幕像素对应的纹理层级。比如当 $\lambda = 0$ 时，表示一个屏幕像素恰好对应一个纹理像素，应使用原始纹理 $D_0$.</p><p><img src="/images/learning/open-course/GAMES101/Notes/note3/downsample.png" alt=""></p><p>计算出层级 $\lambda$ 后还要做采样。显然 $\lambda$ 大多数时候都不是整数，所以有两种常见的采样方法：</p><ol><li><p>最近邻Mipmap滤波（Nearest Mipmap Filtering）</p><p> 选择最接近 $\lambda$ 的整数层级 $d = \text{round}(\lambda)$ 做采样，在这一层可以是最近邻或双线性滤波。</p></li><li><p>三线性滤波（Trilinear Filtering）</p><p> 确定 $\lambda$ 两侧的两个整数层级：$d_1 = \lfloor\lambda\rfloor$ 和 $d_2 = \lceil\lambda\rceil = d_1 + 1$，在这两层分别做双线性滤波采样得到颜色 $C_1$ 和 $C_2$，然后得到最终颜色</p><script type="math/tex; mode=display"> C = (1 - f) \cdot C_1 + f \cdot C_2</script><p> 其中 $f = \lambda - \lfloor\lambda\rfloor$ 为 $\lambda$ 的小数部分。</p></li></ol><h1 id="其他小知识"><a href="#其他小知识" class="headerlink" title="其他小知识"></a>其他小知识</h1><p>虎书提到的planar projection、spherical coordinates、cylindrical coordinates、cubemaps本质上都是把3d表面投影到一个理想的简单几何体上，然后把简单几何体展开成平面。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;יְהִי-אוֹר&quot;&gt;&lt;a href=&quot;#יְהִי-אוֹר&quot; class=&quot;headerlink&quot; title=&quot;יְהִי אוֹר&quot;&gt;&lt;/a&gt;יְהִי אוֹר&lt;/h1&gt;&lt;p&gt;起初，计算机的世界尚未渲染，显示器中空虚混沌，渊面黑暗。&lt;/p&gt;
&lt;p&gt;唯有</summary>
      
    
    
    
    <category term="公开课" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"/>
    
    <category term="GAMES101" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/"/>
    
    <category term="Notes" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/Notes/"/>
    
    
  </entry>
  
  <entry>
    <title>Assignment 3 Pipeline and Shading</title>
    <link href="http://rinevard.github.io/wiki/learning/open-course/GAMES101/Hw/Hw3-pipeline-and-shading/"/>
    <id>http://rinevard.github.io/wiki/learning/open-course/GAMES101/Hw/Hw3-pipeline-and-shading/</id>
    <published>2025-09-13T11:45:16.000Z</published>
    <updated>2025-09-13T12:04:25.374Z</updated>
    
    <content type="html"><![CDATA[<p>本次作业对 bump_fragment_shader、displacement_fragment_shader 的要求非常不严谨，至少包括这些问题：</p><ol><li>这两个 shdaer 需要的贴图是凹凸贴图，凹凸贴图本应该是灰度图，这里使用 RGB 贴图。</li><li>在计算切线空间到世界空间的变换矩阵 TBN 时使用了错误的公式。正确的公式需要知道三角形的三个顶点及其 UV 坐标。</li><li>displacement 方法没有在光栅化前偏移顶点位置，而只调整了显示颜色。</li></ol><p>我们先介绍一下 TBN 的正确计算方式和从 bump texture 算出梯度的方法，再依次介绍一下各个作业的做法。</p><h1 id="TBN的正确计算方式"><a href="#TBN的正确计算方式" class="headerlink" title="TBN的正确计算方式"></a>TBN的正确计算方式</h1><p>我们先来看看什么是 TBN 以及为什么需要 TBN. 为了简单起见，我们先考虑法线贴图。下文把世界空间里按法线贴图修正后的法线称作“<strong>修正法线</strong>”，把世界空间里修正前的法线称作“<strong>几何法线</strong>”，这里默认它们都是归一化的。</p><p>考虑世界空间的某一点 $Q$，假设它在法线贴图中对应的一点为 $Q’$，我们知道点 $Q’$ 对应的法线被用于计算世界空间点 $Q$ 的修正法线。但等等，直接把 RGB 值复制过去看起来是错误的，因为随着物体转动，点 $Q$ 对应的法线也应当转动。因此，我们需要一个矩阵来实现这种从法线贴图上的法线到世界空间的修正法线的变换。</p><p>贴图是二维的，因此我们再额外定义一个垂直纸面向外的轴 $n$，它表示法线的“默认方向”，这就得到了三维的<strong>切线空间</strong>。如果点 $Q’$ 对应的法线是 $(0,0,1)$，那么世界空间的点 $Q$ 的修正法线就是原本的几何法线。</p><p>接下来就要考虑如何找到这个从切线空间到世界空间的旋转矩阵了。为了简单起见，我们先考虑单个三角形的旋转。之后我们会对每个点求出它自己的旋转矩阵。没错，每个点的旋转矩阵不同，这是因为每个点对应的矩阵会把 $(0,0,1)$ 映射到该点的几何法线，而每个点的几何法线一般不同。</p><p>如下图所示，我们希望把法线贴图上的 $P_0’P_1’P_2’$ 旋转为世界空间的 $P_0P_1P_2$，设这里的旋转矩阵为 $M$，世界空间的 $P_0P_1P_2$ 的几何法线为 $\mathbf{n}$，则有</p><script type="math/tex; mode=display">\begin{align*}&M[0,0,1]^T=\mathbf n\end{align*}</script><p><img src="/images/learning/open-course/GAMES101/Assignments/hw3/tangent-world-space.png" alt=""></p><p>但光靠这一个方程当然解不出 $M$，所以我们再考虑两个额外的方程：</p><script type="math/tex; mode=display">\begin{align*}&M (P_1'-P_0')=k(P_1-P_0)\\&M (P_2'-P_0')=k(P_2-P_0)\end{align*}</script><p>也就是说，我们希望这个矩阵把切线空间三角形的边向量旋转到世界空间的边向量上，这看起来是一个合理的要求。这里的 $k$ 是边的长度的缩放比例，严格来说每条边的缩放比例不一定相等，但只要 UV 映射前后的三角形大体是相似三角形，我们就可以认为缩放比例都为 $k$.</p><p>下面我们来解方程。首先我们设</p><script type="math/tex; mode=display">\begin{align*}&M=\begin{pmatrix}  T & B & N\end{pmatrix}\\&P_1'-P_0'= [\Delta u_1,\Delta v_1,0]^T\\&P_2'-P_0'= [\Delta u_2,\Delta v_2,0]^T\end{align*}</script><p>下面两个式子利用了 $P_k’$ 的第三个分量为 $0$ 的性质。</p><p>结合第一个方程就能得到 $N=\mathbf n$，这里的 $\mathbf n$ 表示世界空间的 $P_0P_1P_2$ 的几何法线。再结合另外两个方程就能得到</p><script type="math/tex; mode=display">\begin{align*}&\Delta u_1 T+\Delta v_1 B=k(P_1-P_0)\\&\Delta u_2 T+\Delta v_2 B=k(P_2-P_0)\end{align*}</script><p>之后我们可以解出 $T,B,N$ 的值</p><script type="math/tex; mode=display">\begin{align*}&T=k\frac{\Delta v_2(P_1-P_0)-\Delta v_1(P_2-P_0)}{\Delta u_1 \Delta v_2-\Delta u_2 \Delta v_1}\\&B=k\frac{\Delta u_2(P_1-P_0)-\Delta u_1(P_2-P_0)}{\Delta u_2 \Delta v_1-\Delta u_1 \Delta v_2}\\&N=\mathbf n\end{align*}</script><p>这个公式是不能用的，因为里面有未知数 $k$. 接下来我们解决这个问题。</p><p>我们期望 TBN 矩阵是一个旋转矩阵，而旋转矩阵是正交矩阵，所以我们会对 TBN 做施密特正交化和归一化。只要 $P_0P_1P_2$ 和 $P_0’P_1’P_2’$ 大体是相似三角形，那么它们本来就差不多正交（回顾我们对 TBN 的定义，会发现相似说明 TBN 只对 $P_0’P_1’P_2’$ 做了旋转和缩放，这表明 TBN 正交），所以这种正交化不会把 TBN 变化太多。而由于我们会对 TBN 做单位化，所以我们可以放心地令 $k=1$ 来用下面的公式求出 TBN：</p><script type="math/tex; mode=display">\begin{align*}&T=\frac{\Delta v_2(P_1-P_0)-\Delta v_1(P_2-P_0)}{\Delta u_1 \Delta v_2-\Delta u_2 \Delta v_1}\\&B=\frac{\Delta u_2(P_1-P_0)-\Delta u_1(P_2-P_0)}{\Delta u_2 \Delta v_1-\Delta u_1 \Delta v_2}\\&N=\mathbf{n}\end{align*}</script><p>最后，我们希望 N 在正交化前后不变，所以在正交化后我们有</p><script type="math/tex; mode=display">\begin{align*}&T'=T-(N\cdot T)N\\&B'=B-(N\cdot B)N-(T'\cdot B)T'/T'^2\\&N'=\mathbf n\end{align*}</script><p>再做个单位化就能得到顶点的 TBN 矩阵了。还记得 TBN 矩阵是做什么的吗，我们用它来实现从切线空间到世界空间的变换。所以对点 $Q$，假设其法线贴图对应的法线为 $\mathbf n’$，那么修正后的法线就是 $M_{\text{TBN}}\mathbf n’$.</p><p>很好，我们现在能把单个三角形做变换了，但在真正的模型中，每个点的几何法线方向一般都不同，这就意味着它们一般都有不同的 TBN 矩阵。与计算顶点法线类似，我们会找到每个顶点相邻的所有三角形，并对它们的 $T$ 和 $B$ 做加权平均来得到这个顶点的 $T$ 和 $B$.</p><p>在实践中，我们一般只计算出每个顶点的 $T$，然后在需要 $B$ 时通过叉乘 $N\times T$ 来计算。对那些非顶点的点，我们用重心坐标插值来算出其 $N$ 和 $T$，然后也做正交化和单位化来保证 TBN 矩阵的正交性。</p><p>最后我们再简单分析一下怎么根据凹凸贴图做法线修正。在修正法线时，凹凸贴图与法线贴图的唯一区别就是没有直接给出法线。回顾一下切线空间的定义，我们就可以给凹凸贴图同样设置沿纸面向外的 $n$ 轴，然后把凹凸贴图想象成一个按灰度值起伏的曲面，这个曲面的法线就和法线贴图提供的法线相对应。</p><p>具体来说，点 $(u,v)$ 处的法线可以用 $(h(u)-h(u+1,v),h(v)-h(u,v+1),1)$ 来近似，其中 $h(u,v)$ 表示凹凸贴图在点 $(u,v)$ 处的灰度值，$h(u+1,v)$ 表示 $(u,v)$ 右边一格的灰度值。</p><p>有时由于我们把贴图做了归一化，我们会改用 $h(u+1/\text{width},v)$，但记住它表示相邻格子的灰度值就行。</p><p>最后把这个法线和 TBN 矩阵相乘即可得到修正法线。</p><p>参考 <a href="https://terathon.com/blog/tangent-space.html">Computing Tangent Space Basis Vectors for an Arbitrary Mesh - Eric Lengyel</a></p><h1 id="作业代码"><a href="#作业代码" class="headerlink" title="作业代码"></a>作业代码</h1><h2 id="rasterize-triangle"><a href="#rasterize-triangle" class="headerlink" title="rasterize_triangle"></a>rasterize_triangle</h2><p>注意这里的插值算法要对所有的属性都做透视矫正，我们简单推导一下透视矫正的公式：</p><p>假设我们在对点 $Q$ 的某个属性进行插值，在世界空间中，它所在的三角形为 $P_0P_1P_2$. 投影变换后，它们分别变成了 $Q’$ 和 $P_0’P_1’P_2’$. 用重心坐标分别表示 $Q$ 和 $Q’$，会得到</p><script type="math/tex; mode=display">\begin{align*}&Q=\alpha P_0+\beta P_1+\gamma P_2\\&Q'=\alpha' P_0'+\beta' P_1'+\gamma' P_2'\end{align*}</script><p>这里的 $Q,Q’,P_k,P_k’$ 都是形如 $[x,y,z,1]^T$ 的向量。</p><p>在插值属性时，我们希望用 $\alpha, \beta,\gamma$ 来插值，而不是使用 $\alpha’, \beta’,\gamma’$ 插值，因为我们当然不希望属性会因透视位置不同而不同。这就需要我们根据 $\alpha’, \beta’,\gamma’$ 算出 $\alpha, \beta,\gamma$.</p><p>不妨设投影变换矩阵为 $M$，则有 </p><script type="math/tex; mode=display">\begin{align*}&MQ=\alpha MP_0+\beta MP_1+\gamma MP_2\end{align*}</script><p>这里的 $MP_k$ 是形如 $[x_k,y_k,z_k,w_k]^T$ 的用齐次坐标表示的向量，它与形如 $[x,y,z,1]^T$ 的 $P_k’$ 虽然在数学上表示同一个点，但在数值上不同。（还记得吗，齐次坐标下的 $[x,y,z,1<br>]$ 和 $[ax,ay,az,a]$ 表示同一个点）</p><p>因此我们希望对向量的系数做一些调整，来让各个向量变成 $[x,y,z,1]^T$ 的形式，从而找出 $\alpha’, \beta’,\gamma’$ 和 $\alpha, \beta,\gamma$ 的关系。</p><p> 简单变换一下，我们能把上面的式子写成</p><script type="math/tex; mode=display">\begin{align*}&MQ=\alpha w_0\frac{MP_0}{w_0}+\beta w_1\frac{MP_1}{w_1}+\gamma w_2\frac{MP_2}{w_2}\end{align*}</script><p>现在右边的各个向量 $\frac{MP_k}{w_k}$ 都已经是 $[x,y,z,1]^T$ 的形式了，我们给它们的系数做个归一化就能让左边的向量也变成 $[x,y,z,1]^T$ 的形式：</p><script type="math/tex; mode=display">\frac{MQ}{\alpha w_0 + \beta w_1 + \gamma w_2}=\frac{1}{\alpha w_0 + \beta w_1 + \gamma w_2}\bigg(\alpha w_0\frac{MP_0}{w_0}+\beta w_1\frac{MP_1}{w_1}+\gamma w_2\frac{MP_2}{w_2}\bigg)</script><p>由此我们就有</p><script type="math/tex; mode=display">\begin{align*}&\frac{\alpha w_0}{\alpha w_0 + \beta w_1 + \gamma w_2}=\alpha'\\&\frac{\beta w_1}{\alpha w_0 + \beta w_1 + \gamma w_2}=\beta'\\&\frac{\gamma w_2}{\alpha w_0 + \beta w_1 + \gamma w_2}=\gamma'\end{align*}</script><p>解上面的方程的小技巧是借助除法和重心坐标和为 $1$ 的性质得到下面的等价的方程组</p><script type="math/tex; mode=display">\begin{align*}&\frac{\alpha'}{\beta'}=\frac{\alpha w_0}{\beta w_1}\\&\frac{\alpha'}{\gamma'}=\frac{\alpha w_0}{\gamma w_2}\\&\alpha + \beta + \gamma = 1\end{align*}</script><p>然后就能求出</p><script type="math/tex; mode=display">\begin{align*}&\alpha = \frac{\alpha' / w_0}{\alpha' / w_0 + \beta' / w_1 + \gamma' / w_2}\\&\beta= \frac{\beta' / w_1}{\alpha' / w_0 + \beta' / w_1 + \gamma' / w_2}\\&\gamma= \frac{\gamma' / w_2}{\alpha' / w_0 + \beta' / w_1 + \gamma' / w_2}\end{align*}</script><p>由此，我们就从屏幕空间的重心坐标 $\alpha’,\beta’,\gamma’$ 算出了世界空间的重心坐标 $\alpha,\beta,\gamma$，之后就能用世界空间的重心坐标来正确插值了。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//Screen space rasterization</span><span class="token keyword">void</span> rst<span class="token double-colon punctuation">::</span>rasterizer<span class="token double-colon punctuation">::</span><span class="token function">rasterize_triangle</span><span class="token punctuation">(</span><span class="token keyword">const</span> Triangle<span class="token operator">&amp;</span> t<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>array<span class="token operator">&lt;</span>Eigen<span class="token double-colon punctuation">::</span>Vector3f<span class="token punctuation">,</span> <span class="token number">3</span><span class="token operator">></span><span class="token operator">&amp;</span> view_pos<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">auto</span> v <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">toVector4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Find bounding box</span>    <span class="token keyword">float</span> left <span class="token operator">=</span> v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">float</span> right <span class="token operator">=</span> v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">float</span> bottom <span class="token operator">=</span> v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">y</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">float</span> top <span class="token operator">=</span> v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">y</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> vec<span class="token operator">:</span> v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        left <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">min</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        right <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">max</span><span class="token punctuation">(</span>right<span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bottom <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">min</span><span class="token punctuation">(</span>bottom<span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">y</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        top <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">max</span><span class="token punctuation">(</span>top<span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">y</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// Update pixels in bounding box</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span> x <span class="token operator">&lt;=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>right<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> x<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>bottom<span class="token punctuation">)</span><span class="token punctuation">;</span> y <span class="token operator">&lt;=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>top<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> y<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">auto</span><span class="token punctuation">[</span>alpha<span class="token punctuation">,</span> beta<span class="token punctuation">,</span> gamma<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">computeBarycentric2D</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> t<span class="token punctuation">.</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// If (x, y) is not inside triangle, continue</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>alpha <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> beta <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> gamma <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// Interpolate z value, color, normal, texcoords, shadingcoords, viewpos</span>            <span class="token keyword">float</span> alpha_corrected <span class="token operator">=</span> alpha <span class="token operator">/</span> v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">w</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">float</span> beta_corrected <span class="token operator">=</span> beta <span class="token operator">/</span> v<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">w</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">float</span> gamma_corrected <span class="token operator">=</span> gamma <span class="token operator">/</span> v<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">w</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">float</span> w_reciprocal <span class="token operator">=</span> alpha_corrected <span class="token operator">+</span> beta_corrected <span class="token operator">+</span> gamma_corrected<span class="token punctuation">;</span>            <span class="token keyword">auto</span> z_interpolated <span class="token operator">=</span> <span class="token function">interpolate</span><span class="token punctuation">(</span>alpha_corrected<span class="token punctuation">,</span> beta_corrected<span class="token punctuation">,</span> gamma_corrected<span class="token punctuation">,</span> v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">z</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">z</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">z</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> w_reciprocal<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">auto</span> color_interpolated <span class="token operator">=</span> <span class="token function">interpolate</span><span class="token punctuation">(</span>alpha_corrected<span class="token punctuation">,</span> beta_corrected<span class="token punctuation">,</span> gamma_corrected<span class="token punctuation">,</span> t<span class="token punctuation">.</span>color<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> t<span class="token punctuation">.</span>color<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> t<span class="token punctuation">.</span>color<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> w_reciprocal<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">auto</span> normal_interpolated <span class="token operator">=</span> <span class="token function">interpolate</span><span class="token punctuation">(</span>alpha_corrected<span class="token punctuation">,</span> beta_corrected<span class="token punctuation">,</span> gamma_corrected<span class="token punctuation">,</span> t<span class="token punctuation">.</span>normal<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> t<span class="token punctuation">.</span>normal<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> t<span class="token punctuation">.</span>normal<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> w_reciprocal<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">auto</span> texcoordes_interpolated <span class="token operator">=</span> <span class="token function">interpolate</span><span class="token punctuation">(</span>alpha_corrected<span class="token punctuation">,</span> beta_corrected<span class="token punctuation">,</span> gamma_corrected<span class="token punctuation">,</span> t<span class="token punctuation">.</span>tex_coords<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> t<span class="token punctuation">.</span>tex_coords<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> t<span class="token punctuation">.</span>tex_coords<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> w_reciprocal<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">auto</span> viewpos_interpolated <span class="token operator">=</span> <span class="token function">interpolate</span><span class="token punctuation">(</span>alpha_corrected<span class="token punctuation">,</span> beta_corrected<span class="token punctuation">,</span> gamma_corrected<span class="token punctuation">,</span> view_pos<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> view_pos<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> view_pos<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> w_reciprocal<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">// A lower z-value means it is displayed in front</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>z_interpolated <span class="token operator">&lt;</span> depth_buf<span class="token punctuation">[</span>y <span class="token operator">*</span> width <span class="token operator">+</span> x<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                depth_buf<span class="token punctuation">[</span>y <span class="token operator">*</span> width <span class="token operator">+</span> x<span class="token punctuation">]</span> <span class="token operator">=</span> z_interpolated<span class="token punctuation">;</span>                fragment_shader_payload <span class="token function">payload</span><span class="token punctuation">(</span> color_interpolated<span class="token punctuation">,</span> normal_interpolated<span class="token punctuation">,</span> texcoordes_interpolated<span class="token punctuation">,</span> texture <span class="token operator">?</span> <span class="token operator">&amp;</span><span class="token operator">*</span>texture <span class="token operator">:</span> <span class="token keyword">nullptr</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>                payload<span class="token punctuation">.</span>view_pos <span class="token operator">=</span> viewpos_interpolated<span class="token punctuation">;</span>                <span class="token keyword">auto</span> pixel_color <span class="token operator">=</span> <span class="token function">fragment_shader</span><span class="token punctuation">(</span>payload<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">set_pixel</span><span class="token punctuation">(</span><span class="token function">Vector2i</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">,</span> pixel_color<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="phong-和-texture"><a href="#phong-和-texture" class="headerlink" title="phong 和 texture"></a>phong 和 texture</h2><p>phong 的代码按着 phong 模型实现即可。texture 的代码几乎是一模一样的。</p><p>我唯一好奇的地方是为什么末尾乘了 255.0f，难道光照模型的各个数值取值都在 $(0,1)$ 之间？但看光强似乎又不是这样。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Eigen<span class="token double-colon punctuation">::</span>Vector3f <span class="token function">phong_fragment_shader</span><span class="token punctuation">(</span><span class="token keyword">const</span> fragment_shader_payload<span class="token operator">&amp;</span> payload<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    Eigen<span class="token double-colon punctuation">::</span>Vector3f ka <span class="token operator">=</span> <span class="token class-name">Eigen</span><span class="token double-colon punctuation">::</span><span class="token function">Vector3f</span><span class="token punctuation">(</span><span class="token number">0.005</span><span class="token punctuation">,</span> <span class="token number">0.005</span><span class="token punctuation">,</span> <span class="token number">0.005</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Eigen<span class="token double-colon punctuation">::</span>Vector3f kd <span class="token operator">=</span> payload<span class="token punctuation">.</span>color<span class="token punctuation">;</span>    Eigen<span class="token double-colon punctuation">::</span>Vector3f ks <span class="token operator">=</span> <span class="token class-name">Eigen</span><span class="token double-colon punctuation">::</span><span class="token function">Vector3f</span><span class="token punctuation">(</span><span class="token number">0.7937</span><span class="token punctuation">,</span> <span class="token number">0.7937</span><span class="token punctuation">,</span> <span class="token number">0.7937</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> l1 <span class="token operator">=</span> light<span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token number">500</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> l2 <span class="token operator">=</span> light<span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span><span class="token operator">-</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token number">500</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>light<span class="token operator">></span> lights <span class="token operator">=</span> <span class="token punctuation">&#123;</span>l1<span class="token punctuation">,</span> l2<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    Eigen<span class="token double-colon punctuation">::</span>Vector3f amb_light_intensity<span class="token punctuation">&#123;</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    Eigen<span class="token double-colon punctuation">::</span>Vector3f eye_pos<span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">float</span> p <span class="token operator">=</span> <span class="token number">150</span><span class="token punctuation">;</span>    Eigen<span class="token double-colon punctuation">::</span>Vector3f color <span class="token operator">=</span> payload<span class="token punctuation">.</span>color<span class="token punctuation">;</span>    Eigen<span class="token double-colon punctuation">::</span>Vector3f point <span class="token operator">=</span> payload<span class="token punctuation">.</span>view_pos<span class="token punctuation">;</span>    Eigen<span class="token double-colon punctuation">::</span>Vector3f normal <span class="token operator">=</span> payload<span class="token punctuation">.</span>normal<span class="token punctuation">;</span>    Eigen<span class="token double-colon punctuation">::</span>Vector3f result_color <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    Eigen<span class="token double-colon punctuation">::</span>Vector3f ambient <span class="token operator">=</span> ka<span class="token punctuation">.</span><span class="token function">cwiseProduct</span><span class="token punctuation">(</span>amb_light_intensity<span class="token punctuation">)</span><span class="token punctuation">;</span>    result_color <span class="token operator">+=</span> ambient<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> light <span class="token operator">:</span> lights<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token comment">// TODO: For each light source in the code, calculate what the *ambient*, *diffuse*, and *specular* </span>        <span class="token comment">// components are. Then, accumulate that result on the *result_color* object.</span>        Eigen<span class="token double-colon punctuation">::</span>Vector3f vec_to_light <span class="token operator">=</span> light<span class="token punctuation">.</span>position <span class="token operator">-</span> point<span class="token punctuation">;</span>        Eigen<span class="token double-colon punctuation">::</span>Vector3f diffuse <span class="token operator">=</span> kd<span class="token punctuation">.</span><span class="token function">cwiseProduct</span><span class="token punctuation">(</span>light<span class="token punctuation">.</span>intensity <span class="token operator">/</span> vec_to_light<span class="token punctuation">.</span><span class="token function">squaredNorm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token function">MAX</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> normal<span class="token punctuation">.</span><span class="token function">normalized</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">dot</span><span class="token punctuation">(</span>vec_to_light<span class="token punctuation">.</span><span class="token function">normalized</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Eigen<span class="token double-colon punctuation">::</span>Vector3f vec_to_eye <span class="token operator">=</span> eye_pos <span class="token operator">-</span> point<span class="token punctuation">;</span>        Eigen<span class="token double-colon punctuation">::</span>Vector3f h <span class="token operator">=</span> vec_to_light<span class="token punctuation">.</span><span class="token function">normalized</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> vec_to_eye<span class="token punctuation">.</span><span class="token function">normalized</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Eigen<span class="token double-colon punctuation">::</span>Vector3f specular <span class="token operator">=</span> ks<span class="token punctuation">.</span><span class="token function">cwiseProduct</span><span class="token punctuation">(</span>light<span class="token punctuation">.</span>intensity <span class="token operator">/</span> vec_to_light<span class="token punctuation">.</span><span class="token function">squaredNorm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token function">MAX</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> normal<span class="token punctuation">.</span><span class="token function">normalized</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">dot</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span><span class="token function">normalized</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// The ambient component is only added once before the for loop</span>        result_color <span class="token operator">+=</span> <span class="token punctuation">(</span>diffuse <span class="token operator">+</span> specular<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> result_color <span class="token operator">*</span> <span class="token number">255.f</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Eigen<span class="token double-colon punctuation">::</span>Vector3f <span class="token function">texture_fragment_shader</span><span class="token punctuation">(</span><span class="token keyword">const</span> fragment_shader_payload<span class="token operator">&amp;</span> payload<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    Eigen<span class="token double-colon punctuation">::</span>Vector3f texture_color <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>payload<span class="token punctuation">.</span>texture<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token comment">// TODO: Get the texture value at the texture coordinates of the current fragment</span>        texture_color <span class="token operator">=</span> payload<span class="token punctuation">.</span>texture<span class="token operator">-></span><span class="token function">getColor</span><span class="token punctuation">(</span>payload<span class="token punctuation">.</span>tex_coords<span class="token punctuation">.</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> payload<span class="token punctuation">.</span>tex_coords<span class="token punctuation">.</span><span class="token function">y</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    Eigen<span class="token double-colon punctuation">::</span>Vector3f ka <span class="token operator">=</span> <span class="token class-name">Eigen</span><span class="token double-colon punctuation">::</span><span class="token function">Vector3f</span><span class="token punctuation">(</span><span class="token number">0.005</span><span class="token punctuation">,</span> <span class="token number">0.005</span><span class="token punctuation">,</span> <span class="token number">0.005</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Eigen<span class="token double-colon punctuation">::</span>Vector3f kd <span class="token operator">=</span> texture_color <span class="token operator">/</span> <span class="token number">255.f</span><span class="token punctuation">;</span>    Eigen<span class="token double-colon punctuation">::</span>Vector3f ks <span class="token operator">=</span> <span class="token class-name">Eigen</span><span class="token double-colon punctuation">::</span><span class="token function">Vector3f</span><span class="token punctuation">(</span><span class="token number">0.7937</span><span class="token punctuation">,</span> <span class="token number">0.7937</span><span class="token punctuation">,</span> <span class="token number">0.7937</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> l1 <span class="token operator">=</span> light<span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token number">500</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> l2 <span class="token operator">=</span> light<span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span><span class="token operator">-</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token number">500</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>light<span class="token operator">></span> lights <span class="token operator">=</span> <span class="token punctuation">&#123;</span>l1<span class="token punctuation">,</span> l2<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    Eigen<span class="token double-colon punctuation">::</span>Vector3f amb_light_intensity<span class="token punctuation">&#123;</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    Eigen<span class="token double-colon punctuation">::</span>Vector3f eye_pos<span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">float</span> p <span class="token operator">=</span> <span class="token number">150</span><span class="token punctuation">;</span>    Eigen<span class="token double-colon punctuation">::</span>Vector3f color <span class="token operator">=</span> texture_color<span class="token punctuation">;</span>    Eigen<span class="token double-colon punctuation">::</span>Vector3f point <span class="token operator">=</span> payload<span class="token punctuation">.</span>view_pos<span class="token punctuation">;</span>    Eigen<span class="token double-colon punctuation">::</span>Vector3f normal <span class="token operator">=</span> payload<span class="token punctuation">.</span>normal<span class="token punctuation">;</span>    Eigen<span class="token double-colon punctuation">::</span>Vector3f result_color <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    Eigen<span class="token double-colon punctuation">::</span>Vector3f ambient <span class="token operator">=</span> ka<span class="token punctuation">.</span><span class="token function">cwiseProduct</span><span class="token punctuation">(</span>amb_light_intensity<span class="token punctuation">)</span><span class="token punctuation">;</span>    result_color <span class="token operator">+=</span> ambient<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> light <span class="token operator">:</span> lights<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token comment">// TODO: For each light source in the code, calculate what the *ambient*, *diffuse*, and *specular* </span>        <span class="token comment">// components are. Then, accumulate that result on the *result_color* object.</span>        Eigen<span class="token double-colon punctuation">::</span>Vector3f vec_to_light <span class="token operator">=</span> light<span class="token punctuation">.</span>position <span class="token operator">-</span> point<span class="token punctuation">;</span>        Eigen<span class="token double-colon punctuation">::</span>Vector3f diffuse <span class="token operator">=</span> kd<span class="token punctuation">.</span><span class="token function">cwiseProduct</span><span class="token punctuation">(</span>light<span class="token punctuation">.</span>intensity <span class="token operator">/</span> vec_to_light<span class="token punctuation">.</span><span class="token function">squaredNorm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token function">MAX</span><span class="token punctuation">(</span><span class="token number">0.0f</span><span class="token punctuation">,</span> normal<span class="token punctuation">.</span><span class="token function">normalized</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">dot</span><span class="token punctuation">(</span>vec_to_light<span class="token punctuation">.</span><span class="token function">normalized</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Eigen<span class="token double-colon punctuation">::</span>Vector3f vec_to_eye <span class="token operator">=</span> eye_pos <span class="token operator">-</span> point<span class="token punctuation">;</span>        Eigen<span class="token double-colon punctuation">::</span>Vector3f h <span class="token operator">=</span> vec_to_light<span class="token punctuation">.</span><span class="token function">normalized</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> vec_to_eye<span class="token punctuation">.</span><span class="token function">normalized</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Eigen<span class="token double-colon punctuation">::</span>Vector3f specular <span class="token operator">=</span> ks<span class="token punctuation">.</span><span class="token function">cwiseProduct</span><span class="token punctuation">(</span>light<span class="token punctuation">.</span>intensity <span class="token operator">/</span> vec_to_light<span class="token punctuation">.</span><span class="token function">squaredNorm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token function">MAX</span><span class="token punctuation">(</span><span class="token number">0.0f</span><span class="token punctuation">,</span> normal<span class="token punctuation">.</span><span class="token function">normalized</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">dot</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span><span class="token function">normalized</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// The ambient component is only added once before the for loop</span>        result_color <span class="token operator">+=</span> <span class="token punctuation">(</span>diffuse <span class="token operator">+</span> specular<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> result_color <span class="token operator">*</span> <span class="token number">255.f</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="bump-和-displacement"><a href="#bump-和-displacement" class="headerlink" title="bump 和 displacement"></a>bump 和 displacement</h2><p>如开头所言，本次作业对这两个 shader 的要求非常不严谨，我们就简单放下代码，不多解释了。在一些不严谨的地方我已经写了注释。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Eigen<span class="token double-colon punctuation">::</span>Vector3f <span class="token function">bump_fragment_shader</span><span class="token punctuation">(</span><span class="token keyword">const</span> fragment_shader_payload<span class="token operator">&amp;</span> payload<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        Eigen<span class="token double-colon punctuation">::</span>Vector3f ka <span class="token operator">=</span> <span class="token class-name">Eigen</span><span class="token double-colon punctuation">::</span><span class="token function">Vector3f</span><span class="token punctuation">(</span><span class="token number">0.005</span><span class="token punctuation">,</span> <span class="token number">0.005</span><span class="token punctuation">,</span> <span class="token number">0.005</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Eigen<span class="token double-colon punctuation">::</span>Vector3f kd <span class="token operator">=</span> payload<span class="token punctuation">.</span>color<span class="token punctuation">;</span>    Eigen<span class="token double-colon punctuation">::</span>Vector3f ks <span class="token operator">=</span> <span class="token class-name">Eigen</span><span class="token double-colon punctuation">::</span><span class="token function">Vector3f</span><span class="token punctuation">(</span><span class="token number">0.7937</span><span class="token punctuation">,</span> <span class="token number">0.7937</span><span class="token punctuation">,</span> <span class="token number">0.7937</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> l1 <span class="token operator">=</span> light<span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token number">500</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> l2 <span class="token operator">=</span> light<span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span><span class="token operator">-</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token number">500</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>light<span class="token operator">></span> lights <span class="token operator">=</span> <span class="token punctuation">&#123;</span>l1<span class="token punctuation">,</span> l2<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    Eigen<span class="token double-colon punctuation">::</span>Vector3f amb_light_intensity<span class="token punctuation">&#123;</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    Eigen<span class="token double-colon punctuation">::</span>Vector3f eye_pos<span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">float</span> p <span class="token operator">=</span> <span class="token number">150</span><span class="token punctuation">;</span>    Eigen<span class="token double-colon punctuation">::</span>Vector3f color <span class="token operator">=</span> payload<span class="token punctuation">.</span>color<span class="token punctuation">;</span>     Eigen<span class="token double-colon punctuation">::</span>Vector3f point <span class="token operator">=</span> payload<span class="token punctuation">.</span>view_pos<span class="token punctuation">;</span>    Eigen<span class="token double-colon punctuation">::</span>Vector3f normal <span class="token operator">=</span> payload<span class="token punctuation">.</span>normal<span class="token punctuation">;</span>    <span class="token keyword">float</span> kh <span class="token operator">=</span> <span class="token number">0.2</span><span class="token punctuation">,</span> kn <span class="token operator">=</span> <span class="token number">0.1</span><span class="token punctuation">;</span>    <span class="token comment">// TODO: Implement bump mapping here</span>    <span class="token comment">// Let n = normal = (x, y, z)</span>    <span class="token comment">// Vector t = (x*y/sqrt(x*x+z*z),sqrt(x*x+z*z),z*y/sqrt(x*x+z*z))</span>    <span class="token comment">// Vector b = n cross product t</span>    <span class="token comment">// Matrix TBN = [t b n]</span>    <span class="token comment">// dU = kh * kn * (h(u+1/w,v)-h(u,v))</span>    <span class="token comment">// dV = kh * kn * (h(u,v+1/h)-h(u,v))</span>    <span class="token comment">// Vector ln = (-dU, -dV, 1)</span>    <span class="token comment">// Normal n = normalize(TBN * ln)</span>    <span class="token comment">// Note: The formula is WRONG in theory</span>    <span class="token comment">// To calculate the TBN matrix correctly, we need the triangle's vertices and their corresponding UV coordinates</span>    <span class="token comment">// read https://learnopengl.com/Advanced-Lighting/Normal-Mapping and </span>    <span class="token comment">// https://terathon.com/blog/tangent-space.html for more details</span>    <span class="token keyword">float</span> x <span class="token operator">=</span> normal<span class="token punctuation">.</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">float</span> y <span class="token operator">=</span> normal<span class="token punctuation">.</span><span class="token function">y</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">float</span> z <span class="token operator">=</span> normal<span class="token punctuation">.</span><span class="token function">z</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">float</span> u <span class="token operator">=</span> payload<span class="token punctuation">.</span>tex_coords<span class="token punctuation">.</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">float</span> v <span class="token operator">=</span> payload<span class="token punctuation">.</span>tex_coords<span class="token punctuation">.</span><span class="token function">y</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">float</span> w <span class="token operator">=</span> payload<span class="token punctuation">.</span>texture<span class="token operator">-></span>width<span class="token punctuation">;</span>    <span class="token keyword">float</span> h <span class="token operator">=</span> payload<span class="token punctuation">.</span>texture<span class="token operator">-></span>height<span class="token punctuation">;</span>    Eigen<span class="token double-colon punctuation">::</span>Vector3f t <span class="token operator">=</span> <span class="token class-name">Eigen</span><span class="token double-colon punctuation">::</span><span class="token function">Vector3f</span><span class="token punctuation">(</span>x<span class="token operator">*</span>y<span class="token operator">/</span><span class="token function">sqrt</span><span class="token punctuation">(</span>x<span class="token operator">*</span>x<span class="token operator">+</span>z<span class="token operator">*</span>z<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">sqrt</span><span class="token punctuation">(</span>x<span class="token operator">*</span>x<span class="token operator">+</span>z<span class="token operator">*</span>z<span class="token punctuation">)</span><span class="token punctuation">,</span>z<span class="token operator">*</span>y<span class="token operator">/</span><span class="token function">sqrt</span><span class="token punctuation">(</span>x<span class="token operator">*</span>x<span class="token operator">+</span>z<span class="token operator">*</span>z<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Eigen<span class="token double-colon punctuation">::</span>Vector3f b <span class="token operator">=</span> normal<span class="token punctuation">.</span><span class="token function">cross</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    Eigen<span class="token double-colon punctuation">::</span>Matrix3f TBN<span class="token punctuation">;</span>        TBN <span class="token operator">&lt;&lt;</span> t<span class="token punctuation">,</span> b<span class="token punctuation">,</span> normal<span class="token punctuation">;</span>    <span class="token comment">// In theory the texture should be a grayscale image</span>    <span class="token comment">// However we use an ordinary RGB image here, so we take norm</span>    <span class="token comment">// read https://games-cn.org/forums/topic/frequently-asked-questionskeep-updating/ for more details</span>    <span class="token keyword">float</span> dU <span class="token operator">=</span> kh <span class="token operator">*</span> kn <span class="token operator">*</span> <span class="token punctuation">(</span>payload<span class="token punctuation">.</span>texture<span class="token operator">-></span><span class="token function">getColor</span><span class="token punctuation">(</span>u<span class="token operator">+</span><span class="token number">1.0f</span><span class="token operator">/</span>w<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">norm</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> payload<span class="token punctuation">.</span>texture<span class="token operator">-></span><span class="token function">getColor</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">norm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">float</span> dV <span class="token operator">=</span> kh <span class="token operator">*</span> kn <span class="token operator">*</span> <span class="token punctuation">(</span>payload<span class="token punctuation">.</span>texture<span class="token operator">-></span><span class="token function">getColor</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token operator">+</span><span class="token number">1.0f</span><span class="token operator">/</span>h<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">norm</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> payload<span class="token punctuation">.</span>texture<span class="token operator">-></span><span class="token function">getColor</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">norm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Eigen<span class="token double-colon punctuation">::</span>Vector3f ln <span class="token operator">=</span> <span class="token class-name">Eigen</span><span class="token double-colon punctuation">::</span><span class="token function">Vector3f</span><span class="token punctuation">(</span><span class="token operator">-</span>dU<span class="token punctuation">,</span> <span class="token operator">-</span>dV<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    normal <span class="token operator">=</span> <span class="token punctuation">(</span>TBN <span class="token operator">*</span> ln<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">normalized</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Eigen<span class="token double-colon punctuation">::</span>Vector3f result_color <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    result_color <span class="token operator">=</span> normal<span class="token punctuation">;</span>    <span class="token keyword">return</span> result_color <span class="token operator">*</span> <span class="token number">255.f</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Eigen<span class="token double-colon punctuation">::</span>Vector3f <span class="token function">displacement_fragment_shader</span><span class="token punctuation">(</span><span class="token keyword">const</span> fragment_shader_payload<span class="token operator">&amp;</span> payload<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        Eigen<span class="token double-colon punctuation">::</span>Vector3f ka <span class="token operator">=</span> <span class="token class-name">Eigen</span><span class="token double-colon punctuation">::</span><span class="token function">Vector3f</span><span class="token punctuation">(</span><span class="token number">0.005</span><span class="token punctuation">,</span> <span class="token number">0.005</span><span class="token punctuation">,</span> <span class="token number">0.005</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Eigen<span class="token double-colon punctuation">::</span>Vector3f kd <span class="token operator">=</span> payload<span class="token punctuation">.</span>color<span class="token punctuation">;</span>    Eigen<span class="token double-colon punctuation">::</span>Vector3f ks <span class="token operator">=</span> <span class="token class-name">Eigen</span><span class="token double-colon punctuation">::</span><span class="token function">Vector3f</span><span class="token punctuation">(</span><span class="token number">0.7937</span><span class="token punctuation">,</span> <span class="token number">0.7937</span><span class="token punctuation">,</span> <span class="token number">0.7937</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> l1 <span class="token operator">=</span> light<span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token number">500</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> l2 <span class="token operator">=</span> light<span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span><span class="token operator">-</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token number">500</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>light<span class="token operator">></span> lights <span class="token operator">=</span> <span class="token punctuation">&#123;</span>l1<span class="token punctuation">,</span> l2<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    Eigen<span class="token double-colon punctuation">::</span>Vector3f amb_light_intensity<span class="token punctuation">&#123;</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    Eigen<span class="token double-colon punctuation">::</span>Vector3f eye_pos<span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">float</span> p <span class="token operator">=</span> <span class="token number">150</span><span class="token punctuation">;</span>    Eigen<span class="token double-colon punctuation">::</span>Vector3f color <span class="token operator">=</span> payload<span class="token punctuation">.</span>color<span class="token punctuation">;</span>     Eigen<span class="token double-colon punctuation">::</span>Vector3f point <span class="token operator">=</span> payload<span class="token punctuation">.</span>view_pos<span class="token punctuation">;</span>    Eigen<span class="token double-colon punctuation">::</span>Vector3f normal <span class="token operator">=</span> payload<span class="token punctuation">.</span>normal<span class="token punctuation">;</span>    <span class="token keyword">float</span> kh <span class="token operator">=</span> <span class="token number">0.2</span><span class="token punctuation">,</span> kn <span class="token operator">=</span> <span class="token number">0.1</span><span class="token punctuation">;</span>        <span class="token comment">// TODO: Implement displacement mapping here</span>    <span class="token comment">// Let n = normal = (x, y, z)</span>    <span class="token comment">// Vector t = (x*y/sqrt(x*x+z*z),sqrt(x*x+z*z),z*y/sqrt(x*x+z*z))</span>    <span class="token comment">// Vector b = n cross product t</span>    <span class="token comment">// Matrix TBN = [t b n]</span>    <span class="token comment">// dU = kh * kn * (h(u+1/w,v)-h(u,v))</span>    <span class="token comment">// dV = kh * kn * (h(u,v+1/h)-h(u,v))</span>    <span class="token comment">// Vector ln = (-dU, -dV, 1)</span>    <span class="token comment">// Position p = p + kn * n * h(u,v)</span>    <span class="token comment">// Normal n = normalize(TBN * ln)</span>    <span class="token comment">// Note: The formula is WRONG in theory</span>    <span class="token comment">// When using Displacement Mapping, the points should be offset in the camera space before rasterizing, </span>    <span class="token comment">// instead of only changing its color</span>    <span class="token comment">// read https://learnopengl.com/Advanced-Lighting/Normal-Mapping and </span>    <span class="token comment">// https://terathon.com/blog/tangent-space.html for more details</span>    <span class="token keyword">float</span> x <span class="token operator">=</span> normal<span class="token punctuation">.</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">float</span> y <span class="token operator">=</span> normal<span class="token punctuation">.</span><span class="token function">y</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">float</span> z <span class="token operator">=</span> normal<span class="token punctuation">.</span><span class="token function">z</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">float</span> u <span class="token operator">=</span> payload<span class="token punctuation">.</span>tex_coords<span class="token punctuation">.</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">float</span> v <span class="token operator">=</span> payload<span class="token punctuation">.</span>tex_coords<span class="token punctuation">.</span><span class="token function">y</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">float</span> w <span class="token operator">=</span> payload<span class="token punctuation">.</span>texture<span class="token operator">-></span>width<span class="token punctuation">;</span>    <span class="token keyword">float</span> h <span class="token operator">=</span> payload<span class="token punctuation">.</span>texture<span class="token operator">-></span>height<span class="token punctuation">;</span>    Eigen<span class="token double-colon punctuation">::</span>Vector3f t <span class="token operator">=</span> <span class="token class-name">Eigen</span><span class="token double-colon punctuation">::</span><span class="token function">Vector3f</span><span class="token punctuation">(</span>x<span class="token operator">*</span>y<span class="token operator">/</span><span class="token function">sqrt</span><span class="token punctuation">(</span>x<span class="token operator">*</span>x<span class="token operator">+</span>z<span class="token operator">*</span>z<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">sqrt</span><span class="token punctuation">(</span>x<span class="token operator">*</span>x<span class="token operator">+</span>z<span class="token operator">*</span>z<span class="token punctuation">)</span><span class="token punctuation">,</span>z<span class="token operator">*</span>y<span class="token operator">/</span><span class="token function">sqrt</span><span class="token punctuation">(</span>x<span class="token operator">*</span>x<span class="token operator">+</span>z<span class="token operator">*</span>z<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Eigen<span class="token double-colon punctuation">::</span>Vector3f b <span class="token operator">=</span> normal<span class="token punctuation">.</span><span class="token function">cross</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    Eigen<span class="token double-colon punctuation">::</span>Matrix3f TBN<span class="token punctuation">;</span>        TBN <span class="token operator">&lt;&lt;</span> t<span class="token punctuation">,</span> b<span class="token punctuation">,</span> normal<span class="token punctuation">;</span>    <span class="token comment">// In theory the texture should be a grayscale image</span>    <span class="token comment">// However we use an ordinary RGB image here, so we take norm</span>    <span class="token comment">// read https://games-cn.org/forums/topic/frequently-asked-questionskeep-updating/ for more details</span>    <span class="token keyword">float</span> dU <span class="token operator">=</span> kh <span class="token operator">*</span> kn <span class="token operator">*</span> <span class="token punctuation">(</span>payload<span class="token punctuation">.</span>texture<span class="token operator">-></span><span class="token function">getColor</span><span class="token punctuation">(</span>u<span class="token operator">+</span><span class="token number">1.0f</span><span class="token operator">/</span>w<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">norm</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> payload<span class="token punctuation">.</span>texture<span class="token operator">-></span><span class="token function">getColor</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">norm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">float</span> dV <span class="token operator">=</span> kh <span class="token operator">*</span> kn <span class="token operator">*</span> <span class="token punctuation">(</span>payload<span class="token punctuation">.</span>texture<span class="token operator">-></span><span class="token function">getColor</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token operator">+</span><span class="token number">1.0f</span><span class="token operator">/</span>h<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">norm</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> payload<span class="token punctuation">.</span>texture<span class="token operator">-></span><span class="token function">getColor</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">norm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Eigen<span class="token double-colon punctuation">::</span>Vector3f ln <span class="token operator">=</span> <span class="token class-name">Eigen</span><span class="token double-colon punctuation">::</span><span class="token function">Vector3f</span><span class="token punctuation">(</span><span class="token operator">-</span>dU<span class="token punctuation">,</span> <span class="token operator">-</span>dV<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// In theory we should bias the point using the original normal</span>    <span class="token comment">// but to match the homework answer, we bias the point using the corrected normal</span>    normal <span class="token operator">=</span> <span class="token punctuation">(</span>TBN <span class="token operator">*</span> ln<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">normalized</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    point <span class="token operator">+=</span> kn <span class="token operator">*</span> normal <span class="token operator">*</span> payload<span class="token punctuation">.</span>texture<span class="token operator">-></span><span class="token function">getColor</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">norm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Eigen<span class="token double-colon punctuation">::</span>Vector3f result_color <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    Eigen<span class="token double-colon punctuation">::</span>Vector3f ambient <span class="token operator">=</span> ka<span class="token punctuation">.</span><span class="token function">cwiseProduct</span><span class="token punctuation">(</span>amb_light_intensity<span class="token punctuation">)</span><span class="token punctuation">;</span>    result_color <span class="token operator">+=</span> ambient<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> light <span class="token operator">:</span> lights<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token comment">// TODO: For each light source in the code, calculate what the *ambient*, *diffuse*, and *specular* </span>        <span class="token comment">// components are. Then, accumulate that result on the *result_color* object.</span>        Eigen<span class="token double-colon punctuation">::</span>Vector3f vec_to_light <span class="token operator">=</span> light<span class="token punctuation">.</span>position <span class="token operator">-</span> point<span class="token punctuation">;</span>        Eigen<span class="token double-colon punctuation">::</span>Vector3f diffuse <span class="token operator">=</span> kd<span class="token punctuation">.</span><span class="token function">cwiseProduct</span><span class="token punctuation">(</span>light<span class="token punctuation">.</span>intensity <span class="token operator">/</span> vec_to_light<span class="token punctuation">.</span><span class="token function">squaredNorm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token function">MAX</span><span class="token punctuation">(</span><span class="token number">0.0f</span><span class="token punctuation">,</span> normal<span class="token punctuation">.</span><span class="token function">normalized</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">dot</span><span class="token punctuation">(</span>vec_to_light<span class="token punctuation">.</span><span class="token function">normalized</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Eigen<span class="token double-colon punctuation">::</span>Vector3f vec_to_eye <span class="token operator">=</span> eye_pos <span class="token operator">-</span> point<span class="token punctuation">;</span>        Eigen<span class="token double-colon punctuation">::</span>Vector3f h <span class="token operator">=</span> vec_to_light<span class="token punctuation">.</span><span class="token function">normalized</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> vec_to_eye<span class="token punctuation">.</span><span class="token function">normalized</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Eigen<span class="token double-colon punctuation">::</span>Vector3f specular <span class="token operator">=</span> ks<span class="token punctuation">.</span><span class="token function">cwiseProduct</span><span class="token punctuation">(</span>light<span class="token punctuation">.</span>intensity <span class="token operator">/</span> vec_to_light<span class="token punctuation">.</span><span class="token function">squaredNorm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token function">MAX</span><span class="token punctuation">(</span><span class="token number">0.0f</span><span class="token punctuation">,</span> normal<span class="token punctuation">.</span><span class="token function">normalized</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">dot</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span><span class="token function">normalized</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// The ambient component is only added once before the for loop</span>        result_color <span class="token operator">+=</span> <span class="token punctuation">(</span>diffuse <span class="token operator">+</span> specular<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> result_color <span class="token operator">*</span> <span class="token number">255.f</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本次作业对 bump_fragment_shader、displacement_fragment_shader 的要求非常不严谨，至少包括这些问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;这两个 shdaer 需要的贴图是凹凸贴图，凹凸贴图本应该是灰度图，这里使用 RGB 贴图。&lt;/l</summary>
      
    
    
    
    <category term="公开课" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"/>
    
    <category term="GAMES101" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/"/>
    
    <category term="Assignments" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/Assignments/"/>
    
    
  </entry>
  
  <entry>
    <title>Assignment 2 Rasterizing</title>
    <link href="http://rinevard.github.io/wiki/learning/open-course/GAMES101/Hw/Hw2-rasterizing/"/>
    <id>http://rinevard.github.io/wiki/learning/open-course/GAMES101/Hw/Hw2-rasterizing/</id>
    <published>2025-08-26T12:15:16.000Z</published>
    <updated>2025-08-26T12:21:11.482Z</updated>
    
    <content type="html"><![CDATA[<p>本次作业要求我们实现 Z-buffer 、栅格化和 SSAA（也就是超采样）。我们先看看前两个东西，再看看 SSAA。</p><h1 id="Z-buffer和栅格化"><a href="#Z-buffer和栅格化" class="headerlink" title="Z-buffer和栅格化"></a>Z-buffer和栅格化</h1><h2 id="代码框架"><a href="#代码框架" class="headerlink" title="代码框架"></a>代码框架</h2><p>我们要补全的 <code>rasterize_triangle</code> 函数在 <code>draw</code> 函数内被调用，可以看到 <code>draw</code> 函数已经做好了三角形的投影变换，我们只要把 $[0, \text{width}] \times [0,\text{height}] \times [n,f]$ 里的三角形渲染到屏幕上就好。输入的三角形大概形如这样：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>input triangle<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token number">529.259</span>    <span class="token number">350</span><span class="token number">49.3857</span>      <span class="token number">1</span><span class="token operator">--</span>    <span class="token number">350</span><span class="token number">529.259</span><span class="token number">49.3857</span>      <span class="token number">1</span><span class="token operator">--</span><span class="token number">170.741</span>    <span class="token number">350</span><span class="token number">49.3857</span>      <span class="token number">1</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="insideTriangle-函数"><a href="#insideTriangle-函数" class="headerlink" title="insideTriangle 函数"></a>insideTriangle 函数</h2><p>用课上讲的叉乘法判断点是否在三角形内。“在三角形内”这个说法也不是特别严谨，更准确地说应该是判断三角形在屏幕上的二维投影是否包含这个点。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/*    Return whether (x, y) is in the triangle, ignoring its z value.*/</span><span class="token keyword">static</span> <span class="token keyword">bool</span> <span class="token function">insideTriangle</span><span class="token punctuation">(</span><span class="token keyword">float</span> x<span class="token punctuation">,</span> <span class="token keyword">float</span> y<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>array<span class="token operator">&lt;</span>Vector4f<span class="token punctuation">,</span> <span class="token number">3</span><span class="token operator">></span><span class="token operator">&amp;</span> triangle<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    Vector2f point1 <span class="token operator">=</span> <span class="token punctuation">&#123;</span>triangle<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> triangle<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">y</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    Vector2f point2 <span class="token operator">=</span> <span class="token punctuation">&#123;</span>triangle<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> triangle<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">y</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    Vector2f point3 <span class="token operator">=</span> <span class="token punctuation">&#123;</span>triangle<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> triangle<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">y</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    Vector2f checked_point <span class="token operator">=</span> <span class="token punctuation">&#123;</span>x<span class="token punctuation">,</span> y<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token keyword">auto</span> cross_product <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> Vector2f<span class="token operator">&amp;</span> v1<span class="token punctuation">,</span> <span class="token keyword">const</span> Vector2f<span class="token operator">&amp;</span> v2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> v1<span class="token punctuation">.</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> v2<span class="token punctuation">.</span><span class="token function">y</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> v1<span class="token punctuation">.</span><span class="token function">y</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> v2<span class="token punctuation">.</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">float</span> side1 <span class="token operator">=</span> <span class="token function">cross_product</span><span class="token punctuation">(</span>point1 <span class="token operator">-</span> checked_point<span class="token punctuation">,</span> point1 <span class="token operator">-</span> point2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">float</span> side2 <span class="token operator">=</span> <span class="token function">cross_product</span><span class="token punctuation">(</span>point2 <span class="token operator">-</span> checked_point<span class="token punctuation">,</span> point2 <span class="token operator">-</span> point3<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">float</span> side3 <span class="token operator">=</span> <span class="token function">cross_product</span><span class="token punctuation">(</span>point3 <span class="token operator">-</span> checked_point<span class="token punctuation">,</span> point3 <span class="token operator">-</span> point1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>side1 <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> side2 <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> side3 <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>side1 <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> side2 <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> side3 <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="rasterize-triangle-函数"><a href="#rasterize-triangle-函数" class="headerlink" title="rasterize_triangle 函数"></a>rasterize_triangle 函数</h2><p>这个实现好像没什么特别值得说的地方，简简单单采采样，然后用 <code>depth_buf</code> 实现 z-buffer 就好。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//Screen space rasterization</span><span class="token keyword">void</span> rst<span class="token double-colon punctuation">::</span>rasterizer<span class="token double-colon punctuation">::</span><span class="token function">rasterize_triangle</span><span class="token punctuation">(</span><span class="token keyword">const</span> Triangle<span class="token operator">&amp;</span> t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">auto</span> v <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">toVector4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Find bounding box</span>    <span class="token keyword">float</span> left <span class="token operator">=</span> v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">float</span> right <span class="token operator">=</span> v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">float</span> bottom <span class="token operator">=</span> v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">y</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">float</span> top <span class="token operator">=</span> v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">y</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> vec<span class="token operator">:</span> v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        left <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">min</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        right <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">max</span><span class="token punctuation">(</span>right<span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bottom <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">min</span><span class="token punctuation">(</span>bottom<span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">y</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        top <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">max</span><span class="token punctuation">(</span>top<span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">y</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// Update pixels in bounding box</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span> x <span class="token operator">&lt;=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>right<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> x<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>bottom<span class="token punctuation">)</span><span class="token punctuation">;</span> y <span class="token operator">&lt;=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>top<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> y<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">insideTriangle</span><span class="token punctuation">(</span>x<span class="token operator">+</span><span class="token number">0.5</span><span class="token punctuation">,</span> y<span class="token operator">+</span><span class="token number">0.5</span><span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// Interpolate z value </span>            <span class="token keyword">auto</span><span class="token punctuation">[</span>alpha<span class="token punctuation">,</span> beta<span class="token punctuation">,</span> gamma<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">computeBarycentric2D</span><span class="token punctuation">(</span>x<span class="token operator">+</span><span class="token number">0.5</span><span class="token punctuation">,</span> y<span class="token operator">+</span><span class="token number">0.5</span><span class="token punctuation">,</span> t<span class="token punctuation">.</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">float</span> w_reciprocal <span class="token operator">=</span> <span class="token number">1.0</span><span class="token operator">/</span><span class="token punctuation">(</span>alpha <span class="token operator">/</span> v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">w</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> beta <span class="token operator">/</span> v<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">w</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> gamma <span class="token operator">/</span> v<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">w</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">float</span> z_interpolated <span class="token operator">=</span> alpha <span class="token operator">*</span> v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">z</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">w</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> beta <span class="token operator">*</span> v<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">z</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> v<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">w</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> gamma <span class="token operator">*</span> v<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">z</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> v<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">w</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            z_interpolated <span class="token operator">*=</span> w_reciprocal<span class="token punctuation">;</span>            <span class="token comment">// A lower z-value means it is displayed in front</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>z_interpolated <span class="token operator">&lt;</span> depth_buf<span class="token punctuation">[</span>y <span class="token operator">*</span> width <span class="token operator">+</span> x<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                depth_buf<span class="token punctuation">[</span>y <span class="token operator">*</span> width <span class="token operator">+</span> x<span class="token punctuation">]</span> <span class="token operator">=</span> z_interpolated<span class="token punctuation">;</span>                <span class="token function">set_pixel</span><span class="token punctuation">(</span><span class="token function">Vector3f</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z_interpolated<span class="token punctuation">)</span><span class="token punctuation">,</span> t<span class="token punctuation">.</span><span class="token function">getColor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="SSAA的实现"><a href="#SSAA的实现" class="headerlink" title="SSAA的实现"></a>SSAA的实现</h1><p>SSAA 的实现相较而言更困难一些，由于杂七杂八要改的地方比较多，我就先说下大致思路，再聊聊咱踩的两个坑。</p><p>不过在此之前，先来看看我们的成果吧！（这是动图</p><p><img src="/images/learning/open-course/GAMES101/Assignments/hw2/new-vs-orig.gif" alt=""></p><h2 id="大致思路"><a href="#大致思路" class="headerlink" title="大致思路"></a>大致思路</h2><p>我们要先把所有内容渲染到大小为 $(\text{width} * 2, \text{height} * 2<br>)$ 的自定义 buffer 里，再根据自定义 buffer 的内容填充屏幕上的像素。</p><p>要注意的是，我们不能直接在 <code>rasterize_triangle</code> 里把三角形画到屏幕上（具体原因见“踩坑1”那一节），而是要在 <code>rasterize_triangle</code> 中把三角形画到自定义的 buffer 里，再新增一个 <code>resolve</code> 函数并把它放到 draw 的最后，从而把自定义 buffer 里的内容画到屏幕上：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> rst<span class="token double-colon punctuation">::</span>rasterizer<span class="token double-colon punctuation">::</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> y <span class="token operator">&lt;</span> height<span class="token punctuation">;</span> y<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> x <span class="token operator">&lt;</span> width<span class="token punctuation">;</span> x<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            frame_buf<span class="token punctuation">[</span>y <span class="token operator">*</span> width <span class="token operator">+</span> x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">Vector3f</span><span class="token double-colon punctuation">::</span><span class="token function">Zero</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                frame_buf<span class="token punctuation">[</span>y <span class="token operator">*</span> width <span class="token operator">+</span> x<span class="token punctuation">]</span> <span class="token operator">+=</span> ssaa_frame_buf<span class="token punctuation">[</span><span class="token punctuation">(</span>y <span class="token operator">*</span> width <span class="token operator">+</span> x<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">4</span> <span class="token operator">+</span> i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            frame_buf<span class="token punctuation">[</span>y <span class="token operator">*</span> width <span class="token operator">+</span> x<span class="token punctuation">]</span> <span class="token operator">/=</span> <span class="token number">4.0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>更细节一些的话，我们需要做这些工作：</p><ol><li>在 rasterizer.hpp 里加入 ssaa_frame_buf 和 resolve 的定义。</li><li>修改 rasterizer 的初始化函数和 clear 函数，正确初始化和重置 ssaa_frame_buf。</li><li>修改 set_pixel 函数，让它把内容画到 ssaa_frame_buf 里，而非 frame_buf 里。</li><li>修改 rasterize_triangle，让它用使用更高的采样率。</li><li>实现 resolve 函数。</li></ol><p>杂七杂八要改的地方比较多，这里就不放更多代码了。</p><h2 id="踩坑1"><a href="#踩坑1" class="headerlink" title="踩坑1"></a>踩坑1</h2><p>SSAA、filtering 都建立在“我们对理想图像进行滤波”的基础上。也就是说，要先把世界里的对象按正确的前后顺序变为一个二维图像，然后再滤波。所以直接在 <code>rasterize_triangle</code> 里把像素划分成子像素然后取平均并不能实现 SSAA，而是会在三角形重叠的地方显示出黑边。</p><p><img src="/images/learning/open-course/GAMES101/Assignments/hw2/black-ssaa.png" alt=""></p><p>让我们来看一个具体例子。考虑一个 1/4 被绿色三角形占据、3/4 被蓝色三角形占据的像素，SSAA 会把 1/4 绿 + 3/4 蓝 作为这个像素的颜色。</p><p>而如果直接在 <code>rasterize_triangle</code> 里把像素划分成子像素然后取平均，那么栅格化蓝色三角形时，这个像素被当成 3/4 蓝；栅格化绿色三角形时，这个像素被当成 1/4 绿。无论谁在前面，最终结果要么是 3/4 蓝，要么是 1/4 绿，总与 SSAA 的结果 1/4 绿 + 3/4 蓝 不同。</p><h2 id="踩坑2"><a href="#踩坑2" class="headerlink" title="踩坑2"></a>踩坑2</h2><p><code>insideTriangle</code> 的参数 x 和 y 的类型原本是 int，而在 SSAA 里我们把像素划分成了四个子像素，这些子像素的坐标大多不是整数。因此我们要把 <code>insideTriangle</code> 的 x 和 y 的类型改成 float. </p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">bool</span> <span class="token function">insideTriangle</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">,</span> <span class="token keyword">const</span> Vector3f<span class="token operator">*</span> _v<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>       <span class="token comment">// TODO : Implement this function to check if the point (x, y) is inside the triangle represented by _v[0], _v[1], _v[2]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本次作业要求我们实现 Z-buffer 、栅格化和 SSAA（也就是超采样）。我们先看看前两个东西，再看看 SSAA。&lt;/p&gt;
&lt;h1 id=&quot;Z-buffer和栅格化&quot;&gt;&lt;a href=&quot;#Z-buffer和栅格化&quot; class=&quot;headerlink&quot; title=&quot;Z</summary>
      
    
    
    
    <category term="公开课" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"/>
    
    <category term="GAMES101" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/"/>
    
    <category term="Assignments" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/Assignments/"/>
    
    
  </entry>
  
  <entry>
    <title>Note 2 Rasterizing</title>
    <link href="http://rinevard.github.io/wiki/learning/open-course/GAMES101/Notes/Note2-Rasterizing/"/>
    <id>http://rinevard.github.io/wiki/learning/open-course/GAMES101/Notes/Note2-Rasterizing/</id>
    <published>2025-08-25T08:10:28.000Z</published>
    <updated>2025-09-23T07:19:39.089Z</updated>
    
    <content type="html"><![CDATA[<p>在 Transformation 部分，我们已经可以把一个三维空间里的三角形投影到平面上。但怎么把一个纯色三角形绘制到屏幕上呢？我们知道屏幕由大量的像素点组成，那么怎么确定每个像素点是什么颜色呢？</p><p>我们通过采样给每个像素点涂上颜色。我们可以检查每个像素的中心点是否在这个三角形内部，如果在则涂上三角形的颜色。虽然这样绘制的三角形会有锯齿，效果一般，但基本思想就是这样。</p><p>那么如果有多个三角形，而且他们之间有遮挡关系呢？这就需要 Z-Buffer 出场了。</p><h1 id="Z-Buffer"><a href="#Z-Buffer" class="headerlink" title="Z-Buffer"></a>Z-Buffer</h1><p>Z-Buffer 的算法如下面的伪代码所示。思路是对每个像素所在的所有三角形，取 z 值最小的三角形的颜色作为这个像素的颜色。</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token class-name">Triangle</span> triangle <span class="token keyword">in</span> triangles<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token class-name">Vector3</span> sample <span class="token keyword">in</span> triangle<span class="token punctuation">.</span><span class="token function">GetSamples</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// z 值越小显示越靠前</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sample<span class="token punctuation">.</span>z <span class="token operator">&lt;</span> zBuffer<span class="token punctuation">[</span>sample<span class="token punctuation">.</span>x<span class="token punctuation">,</span> sample<span class="token punctuation">.</span>y<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            frameBuffer<span class="token punctuation">[</span>sample<span class="token punctuation">.</span>x<span class="token punctuation">,</span> sample<span class="token punctuation">.</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> sample<span class="token punctuation">.</span>rgb<span class="token punctuation">;</span>            zBuffer<span class="token punctuation">[</span>sample<span class="token punctuation">.</span>x<span class="token punctuation">,</span> sample<span class="token punctuation">.</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> sample<span class="token punctuation">.</span>z<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这也有良好的并行性，因为三角形的遍历顺序和最终结果无关，像素的绘制顺序也和最终结果无关。</p><p>虎书还提到我们会将 $z$ 值映射到 $[0, B-1]$，用整数存储 $z$ 值，但其实这是现在不再使用的方法，我们现在通常使用 24 位或 32 位的浮点数来存储深度值。（怪不得我查了好久资料都没查到“整数映射”的具体代码，原来早就不用了！！！）</p><h1 id="走样现象"><a href="#走样现象" class="headerlink" title="走样现象"></a>走样现象</h1><p>我们之前说过，简单的采样会出现锯齿，如下图所示。</p><p><img src="/images/learning/open-course/GAMES101/Notes/note2/jaggies.png" alt=""></p><p>锯齿、摩尔纹之类的采样图像与原图不符的现象被统称为走样（Aliasing）现象，走样的实质是原图的高频信号被错误采样。为了明确什么是”高频信号”并找到缓解走样现象的方法，我们先看看一些数学知识。</p><h1 id="数学知识"><a href="#数学知识" class="headerlink" title="数学知识"></a>数学知识</h1><p>为了不让文章太长，这里我们省略所有的证明。不过所有的证明都并不困难，有空的话可以自己证一下试试。在开始之前，我们会问：这些数学知识有用吗？</p><blockquote><p>In a word, mostly no, sometimes yes, and occasionally, maybe.<br>— <a href="https://www.dgp.toronto.edu/public_user/elf/2522/sampling.pdf">https://www.dgp.toronto.edu/public_user/elf/2522/sampling.pdf</a></p></blockquote><h2 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h2><p>我们先来看看三种卷积——离散-离散卷积、连续-连续卷积、离散-连续卷积。下面的 $f_{\rightarrow t}$ 表示将函数 $f$ 向右平移 $t$ 长度得到的新函数：</p><p>离散-离散卷积</p><script type="math/tex; mode=display">\begin{align*}&(a*b)[i]=\sum_{j}a[j]b[i-j]\\&(a*b)=\sum_{j}a[j]b_{\rightarrow j}\end{align*}</script><p>连续-连续卷积</p><script type="math/tex; mode=display">\begin{align*}&(f*g)(x)=\int_{-\infty}^{\infty}f(t)g(x-t)dt\\&(f*g)=\int_{-\infty}^{\infty}f(t)g_{\rightarrow t}dt\end{align*}</script><p>离散-连续卷积</p><script type="math/tex; mode=display">\begin{align*}&(a*f)(x)=\sum_{i}a[i]f(x-i)\\&(a*f)=\sum_{i}a[i]f_{\rightarrow i}\end{align*}</script><p>我们会注意到，卷积可以表示为函数平移后的加权和。</p><p><img src="/images/learning/open-course/GAMES101/Notes/note2/convlution.png" alt=""></p><p>卷积是过会儿会用到的妙妙小工具。</p><h2 id="傅里叶级数和傅里叶变换"><a href="#傅里叶级数和傅里叶变换" class="headerlink" title="傅里叶级数和傅里叶变换"></a>傅里叶级数和傅里叶变换</h2><p>我们之前提到，走样的实质是原图的高频信号被错误采样。图像作为一个 $R^2\rightarrow \text{RGBA<br>}$的函数，怎么会有高频和低频之分呢？uh actually☝️🤓 我们处理的绝大多数函数都有频域，这个频域可以通过傅里叶变换得到。</p><p>先回顾一下<strong>傅里叶级数</strong>。熟知在 $[-\frac{T}{2},\frac{T}{2}]$ 内，函数 $f(x)$ 可以表示为</p><script type="math/tex; mode=display">f(x)=\sum_{n=-\infty}^{\infty}c_n e^{inw_0 x}</script><p>其中</p><script type="math/tex; mode=display">\begin{align*}&c_n=\frac{1}{T}\int_{-\frac{T}{2}}^{\frac{T}{2}} f(t)e^{-inw_0t}dt\\&w_0=\frac{2\pi}{T}\end{align*}</script><p>这本质上是函数在闭区间内的正交基展开，这个展开的周期为 $T$.</p><p>当 $T \rightarrow \infty$ 时，令 $w_n=nw_0$，$\Delta w=w_n-w_{n-1}=w_0$ 再结合积分的定义，我们就能（不太严谨地）求出</p><script type="math/tex; mode=display">f(x)=\frac{1}{2\pi}\int_{-\infty}^{\infty}\bigg(\int_{-\infty}^{\infty}f(t)e^{-iwt}dt \bigg)e^{iwx}dw</script><p>我们可以令 $u=\frac{w}{2\pi}$ 从而去掉积分外面的那个系数</p><script type="math/tex; mode=display">f(x)=\int_{-\infty}^{\infty}\bigg(\int_{-\infty}^{\infty}f(t)e^{-2\pi iut}dt \bigg)e^{2\pi iux}du</script><p>而 $e^{2\pi iux}$ 的系数</p><script type="math/tex; mode=display">\hat f(u)=\int_{-\infty}^{\infty}f(t)e^{-2\pi iut}dt</script><p>就是 $f$ 的<strong>傅里叶变换</strong>了，它也记作 $\mathcal{F}(f)$.</p><p>把 $\hat f$ 代入就得到了<strong>逆傅里叶变换</strong></p><script type="math/tex; mode=display">f(x)=\int_{-\infty}^{\infty}\hat f(u)e^{2\pi iux}du</script><p>逆傅里叶变换把函数变成了不同频率的三角函数的积分/求和，这就是我们之前所说的“高频信号”和“低频信号”的含义。之后我们会介绍采样导致高频信号丢失的原因，不过在此之前我们先看看傅里叶变换的一些性质。</p><p><img src="/images/learning/open-course/GAMES101/Notes/note2/fourier.png" alt=""></p><h2 id="傅里叶变换的性质"><a href="#傅里叶变换的性质" class="headerlink" title="傅里叶变换的性质"></a>傅里叶变换的性质</h2><p>我们列举傅里叶变换的几个常用的性质。</p><ol><li>如果 $f$ 是实函数，$\hat f$ 是偶函数。</li><li><p>函数和傅里叶变换的平方积分相等</p><script type="math/tex; mode=display"> \int (f(x))^2dx=\int (\hat f(u))^2du</script></li><li><p>原函数拉长，傅里叶变换收紧</p><script type="math/tex; mode=display"> \mathcal{F}(f(x/b))=b\hat f(bu)</script></li></ol><h2 id="狄拉克脉冲函数和冲激串"><a href="#狄拉克脉冲函数和冲激串" class="headerlink" title="狄拉克脉冲函数和冲激串"></a>狄拉克脉冲函数和冲激串</h2><p>狄拉克脉冲函数的定义如下：</p><script type="math/tex; mode=display">\delta(t) =\begin{cases}\infty, & t = 0 \\0, & t \neq 0\end{cases}</script><p>我们可以把连续信号的均匀间隔采样表示为冲激串</p><script type="math/tex; mode=display">s_T(x) = \sum_{n=-\infty}^{\infty}\delta(x-nT)</script><p>与原函数 $f$ 的乘积，这里的 $T$ 表示两个采样点之间的间隔。</p><p>$s_T$ 的傅里叶变换为</p><script type="math/tex; mode=display">\hat s_T(u)=\frac{1}{T}\sum_{n=-\infty}^{\infty}\delta(u-\frac{n}{T})</script><p>它仍然是一系列狄拉克函数的和。</p><p><img src="/images/learning/open-course/GAMES101/Notes/note2/dirac.png" alt=""></p><h2 id="卷积定理"><a href="#卷积定理" class="headerlink" title="卷积定理"></a>卷积定理</h2><p>之前说过，将 $s_T$ 和原函数 $f$ 相乘能获得许多重要的采样性质，我们很快就会讨论他们了，在此之前我们还要补充最后一个知识——卷积定理。</p><script type="math/tex; mode=display">\begin{align*}&\mathcal{F}(f * g)=\hat f\hat g\\&\mathcal{F}(fg)=\hat f * \hat g\end{align*}</script><p>这就是说，时域的卷积对应频域的乘积，频域的乘积对应时域的卷积。</p><h1 id="走样的原因"><a href="#走样的原因" class="headerlink" title="走样的原因"></a>走样的原因</h1><p>一开始我们就说过，走样的实质是原图的高频信号被错误采样。现在我们的数学工具已经足以分析究竟为什么发生了错误采样，以及如何缓解他们了。</p><p>先来看看为什么我们没有正确采样高频信号。</p><p>假设我们希望对这样的函数进行采样，通过傅里叶变换我们可以得到其频域（右一）</p><p><img src="/images/learning/open-course/GAMES101/Notes/note2/sample-origin.png" alt=""></p><p>我们之前说过，可以把连续函数的均匀间隔采样表示为冲激串 $s_{T}(x)=\sum_{n=-\infty}^{\infty}\delta(x-nT)$ 和原函数 $f$ 的乘积，而我们也已经知道冲激串的傅里叶变换还是冲激串</p><script type="math/tex; mode=display">\hat s_T(u)=\frac{1}{T}\sum_{n=-\infty}^{\infty}\delta(u-\frac{n}{T})</script><p>再结合卷积定理 $\mathcal{F}(s_Tf)=\hat s_T * \hat f$，以及“卷积就是函数平移后的加权和”，我们就能推出，采样结果的傅里叶变换就是原函数的傅里叶变换的无穷个复制各按 $\frac{n}{T}$ 平移的和。</p><p><img src="/images/learning/open-course/GAMES101/Notes/note2/sample-sampled.png" alt=""></p><p>由于我们的采样间隔 $T$ 不够小，即采样率 $\frac{1}{T}$ 不够大，所以相邻的两个复制间发生了重叠，导致高频信号和低频信号产生混合，这就引起了走样。而这正是“高频信号被错误采样”的实质。</p><p>当我们在光栅化时，我们还把像素填上了颜色，这是在“reconstruction”即重建图像。不过由于在采样时我们已经发生了走样，无论怎么重建都不会有一个非常完美的结果了。</p><p><img src="/images/l earning/open-course/GAMES101/Notes/note2/sample-recons.png" alt=""></p><h1 id="滤波器和走样的缓解方法"><a href="#滤波器和走样的缓解方法" class="headerlink" title="滤波器和走样的缓解方法"></a>滤波器和走样的缓解方法</h1><p>为了缓解走样，我们自然就要避免发生重叠。避免发生重叠的思路主要有两种：</p><ol><li>增加采样率，这样就能让相邻的两个复制距离增大。</li><li>用滤波器减弱高频信号的强度。</li></ol><p>对图像的光栅化来说，增加分辨率就对应前者；在采样前对原图应用各种滤波器就对应后者。</p><p>我们当然会问，增加采样率能缓解走样，那增加到多大合适呢？我们希望相邻的两个复制间的距离足够大以至于不发生重叠，这就需要输入信号的最高频率小于采样频率的一半。采样频率的一半也被称为<strong>奈奎斯特频率</strong>。理论上说，只要奈奎斯特频率高于被采样信号的最高频率，我们就能完美复原原信号。</p><p>接下来我们看看几个常见的滤波器，它们常被用于和别的函数做卷积。由于我们知道卷积可以被理解为一种“加权平均”，所以我们希望滤波器都是归一化的。</p><table>  <thead>    <tr>      <th>名称</th>      <th>公式</th>    </tr>  </thead>  <tbody>    <tr>      <td>Box filter（离散）</td>      <td>$a_{\text{box},r}[i] =\begin{cases}1/(2r + 1) & |i| \le r, \\0 & \text{otherwise}.\end{cases}$</td>    </tr>    <tr>      <td>Box filter（连续）</td>      <td>$f_{\text{box},r}(x) =\begin{cases}1/(2r) & -r \le x < r, \\0 & \text{otherwise}.\end{cases}$</td>    </tr>    <tr>      <td>Tent filter</td>      <td>$f_{\text{tent}}(x) =\begin{cases}1 - |x| & |x| < 1, \\0 & \text{otherwise};\end{cases}$</td>    </tr>    <tr>      <td>Gaussian filter</td>      <td>$f_{g, \sigma}(x) = \frac{1}{\sigma\sqrt{2\pi}}e^{-x^2/2\sigma^2}$</td>    </tr>  </tbody></table><p><img src="/images/learning/open-course/GAMES101/Notes/note2/filters1.png" alt=""></p><table>  <thead>    <tr>      <th>名称</th>      <th>公式</th>    </tr>  </thead>  <tbody>    <tr>      <td>B-Spline Cubic Filter</td>      <td>$f_B(x) = \frac{1}{6}\begin{cases}-3(1 - |x|)^3 + 3(1 - |x|)^2 + 3(1 - |x|) + 1 & -1 \le x \le 1, \\(2 - |x|)^3 & 1 \le |x| \le 2, \\0 & \text{otherwise}.\end{cases}$</td>    </tr>    <tr>      <td>Catmull-Rom Cubic Filter</td>      <td>$f_C(x) = \frac{1}{2}\begin{cases}-3(1 - |x|)^3 + 4(1 - |x|)^2 + (1 - |x|) & -1 \le x \le 1, \\(2 - |x|)^3 - (2 - |x|)^2 & 1 \le |x| \le 2, \\0 & \text{otherwise}.\end{cases}$</td>    </tr>    <tr>      <td>Mitchell-Netravali Cubic Filter</td>      <td>$f_M(x) = \frac{1}{3}f_B(x) + \frac{2}{3}f_C(x)\\= \frac{1}{18}\begin{cases} -21(1 - |x|)^3 + 27(1 - |x|)^2 + 9(1 - |x|) + 1 & -1 \le x \le 1, \\7(2 - |x|)^3 - 6(2 - |x|)^2 & 1 \le |x| \le 2, \\0 & \text{otherwise}.\end{cases}$</td>    </tr>  </tbody></table><p><img src="/images/learning/open-course/GAMES101/Notes/note2/filters2.png" alt=""></p><p>除了过滤高频信号之外，滤波器还在重建图像时发挥着重要作用。还记得吗，离散-连续卷积能把一系列离散点变成一个连续函数。在根据采样点重建图像时，我们基本就是在做采样点和滤波器的卷积。在光栅化的“把每个像素点的中心采样颜色填到像素点上”这一步中，我们就是在将采样点和 Box filter 做卷积。</p><p>总而言之，为了缓解走样，我们可以以图像细节丰富度为代价，先用低通滤波器滤波，再采样+重建。当然，如果我们有更高分辨率的屏幕就更好了~</p><h1 id="其他小知识"><a href="#其他小知识" class="headerlink" title="其他小知识"></a>其他小知识</h1><h2 id="常见滤波器的傅里叶变换"><a href="#常见滤波器的傅里叶变换" class="headerlink" title="常见滤波器的傅里叶变换"></a>常见滤波器的傅里叶变换</h2><p><img src="/images/learning/open-course/GAMES101/Notes/note2/fourier-all.png" alt=""></p><h2 id="卷积的单位元"><a href="#卷积的单位元" class="headerlink" title="卷积的单位元"></a>卷积的单位元</h2><p>任何离散信号和单位脉冲序列做卷积，结果还是原本的离散信号</p><script type="math/tex; mode=display">\delta[n] =\begin{cases}1, & n = 0 \\0, & n \neq 0\end{cases}</script><p>任何连续信号和狄拉克函数做卷积，结果还是原本的连续信号</p><script type="math/tex; mode=display">\delta(t) =\begin{cases}\infty, & t = 0 \\0, & t \neq 0\end{cases}</script><h2 id="二维卷积和二维滤波器"><a href="#二维卷积和二维滤波器" class="headerlink" title="二维卷积和二维滤波器"></a>二维卷积和二维滤波器</h2><p>我们这里只给出连续-连续的二维卷积，别的情况都差不多。</p><script type="math/tex; mode=display">\begin{align*}&(f*g)(x,y)=\int\intf(x-x',y-y')g(x',y')dx'dy'\end{align*}</script><p>对滤波器 $f(x)$，我们简单地定义 $g(x,y)=f(x)f(y)$ 就得到了这个滤波器对应的二维滤波器。一个比较好的性质是，如果 $f$ 是归一化的，那么 $g$ 也是归一化的。</p><h2 id="伽马值"><a href="#伽马值" class="headerlink" title="伽马值"></a>伽马值</h2><p>显示器的显示亮度关于输入信号不是线性关系。假设输入信号为 $a\in[0,1]$，则有</p><script type="math/tex; mode=display">\text{Displayed intensity}=(\text{Maximum intensity})a^\gamma</script><p>这里的 $\gamma$ 一般在 $2.2$ 左右。虽然在最开始这是 CRT 显示器的物理特性所致，但有趣的是，人眼也恰好对暗部变化比亮部变化更敏感，所以它现在作为一个刻意的设计保留了下来。</p><p>伽马矫正在影像系统中也有极大作用。假设我们在拍摄一个苹果的照片，苹果的物理亮度是 $0.5$，相机忠实地把它记录了下来。而当显示器显示时，就显示出了 $0.5^{2.2}\approx<br> 0.22$ 的物理亮度，这显然不是我们想要的。因此在我们拍摄照片之后，相机的图像处理器就会自动对照片进行伽马矫正。</p><h2 id="图像锐化"><a href="#图像锐化" class="headerlink" title="图像锐化"></a>图像锐化</h2><p>Unsharp Mask 是一个经典的图像锐化算法。令高斯模糊核为 $G$，冲激函数为 $\delta$，它先提取原始图像的高频信号</p><script type="math/tex; mode=display">I_{detail} = I_{orig} - I_{orig} * G</script><p>再把这些高频信号加入回原图中</p><script type="math/tex; mode=display">I_{sharp} = I_{orig} + \alpha I_{detail}</script><p>综合起来就是</p><script type="math/tex; mode=display">I_{sharp}=I_{orig}*((1+\alpha)\delta-G)</script><h2 id="图像缩放"><a href="#图像缩放" class="headerlink" title="图像缩放"></a>图像缩放</h2><p>直接对一个像素化的图像采样虽然效率很高，但效果不佳。先用连续的滤波器重建信号，再用低通滤波器过滤高频信号，再采样会得到更好的结果，这被称为 resampling，重采样。</p><p><img src="/images/learning/open-course/GAMES101/Notes/note2/resample.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 Transformation 部分，我们已经可以把一个三维空间里的三角形投影到平面上。但怎么把一个纯色三角形绘制到屏幕上呢？我们知道屏幕由大量的像素点组成，那么怎么确定每个像素点是什么颜色呢？&lt;/p&gt;
&lt;p&gt;我们通过采样给每个像素点涂上颜色。我们可以检查每个像素的中心点</summary>
      
    
    
    
    <category term="公开课" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"/>
    
    <category term="GAMES101" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/"/>
    
    <category term="Notes" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/Notes/"/>
    
    
  </entry>
  
  <entry>
    <title>Assignment 1 Transformation</title>
    <link href="http://rinevard.github.io/wiki/learning/open-course/GAMES101/Hw/Hw1-transformation/"/>
    <id>http://rinevard.github.io/wiki/learning/open-course/GAMES101/Hw/Hw1-transformation/</id>
    <published>2025-08-22T03:00:58.000Z</published>
    <updated>2025-08-22T03:14:43.978Z</updated>
    
    <content type="html"><![CDATA[<p>本次作业要求我们实现旋转矩阵、投影矩阵。我们先简单看下作业是怎么做的，再看看代码框架里的几个有趣的地方。</p><h1 id="作业实现"><a href="#作业实现" class="headerlink" title="作业实现"></a>作业实现</h1><h2 id="两个旋转矩阵"><a href="#两个旋转矩阵" class="headerlink" title="两个旋转矩阵"></a>两个旋转矩阵</h2><p>绕 $z$ 轴的旋转矩阵实现起来很简单，把课上的内容翻译成代码就好。在使用 std 的 sin 和 cos 时要注意把角度转换成弧度。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Eigen<span class="token double-colon punctuation">::</span>Matrix4f <span class="token function">get_model_matrix</span><span class="token punctuation">(</span><span class="token keyword">float</span> rotation_angle<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    Eigen<span class="token double-colon punctuation">::</span>Matrix4f model <span class="token operator">=</span> Eigen<span class="token double-colon punctuation">::</span><span class="token class-name">Matrix4f</span><span class="token double-colon punctuation">::</span><span class="token function">Identity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">float</span> angle_rad <span class="token operator">=</span> rotation_angle <span class="token operator">*</span> MY_PI <span class="token operator">/</span> <span class="token number">180.0</span><span class="token punctuation">;</span>    Eigen<span class="token double-colon punctuation">::</span>Matrix4f rotate<span class="token punctuation">;</span>    <span class="token keyword">float</span> sine <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">sin</span><span class="token punctuation">(</span>angle_rad<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">float</span> cosine <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">cos</span><span class="token punctuation">(</span>angle_rad<span class="token punctuation">)</span><span class="token punctuation">;</span>    rotate <span class="token operator">&lt;&lt;</span> cosine<span class="token punctuation">,</span> <span class="token operator">-</span>sine<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>            sine<span class="token punctuation">,</span> cosine<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>             <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>             <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">;</span>    model <span class="token operator">=</span> rotate <span class="token operator">*</span> model<span class="token punctuation">;</span>    <span class="token keyword">return</span> model<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>提高项里的旋转矩阵用课上讲的 Rodrigues’ rotation formula 就行：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/*    Computes the 4x4 rotation matrix representing a rotation of rotation_angle (in degree)     around a given normalized axis vector that passes through the origin,     using Rodrigues' rotation formula.*/</span>Eigen<span class="token double-colon punctuation">::</span>Matrix4f <span class="token function">get_rotation</span><span class="token punctuation">(</span>Vector3f axis<span class="token punctuation">,</span> <span class="token keyword">float</span> rotation_angle<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">float</span> angle_rad <span class="token operator">=</span> rotation_angle <span class="token operator">*</span> MY_PI <span class="token operator">/</span> <span class="token number">180.0</span><span class="token punctuation">;</span>        Eigen<span class="token double-colon punctuation">::</span>Matrix3f rot_mat <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">cos</span><span class="token punctuation">(</span>angle_rad<span class="token punctuation">)</span> <span class="token operator">*</span> Eigen<span class="token double-colon punctuation">::</span><span class="token class-name">Matrix3f</span><span class="token double-colon punctuation">::</span><span class="token function">Identity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    rot_mat <span class="token operator">+=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> std<span class="token double-colon punctuation">::</span><span class="token function">cos</span><span class="token punctuation">(</span>angle_rad<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> axis <span class="token operator">*</span> axis<span class="token punctuation">.</span><span class="token function">transpose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Eigen<span class="token double-colon punctuation">::</span>Matrix3f cross_product_mat<span class="token punctuation">;</span>    cross_product_mat <span class="token operator">&lt;&lt;</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span>axis<span class="token punctuation">.</span><span class="token function">z</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> axis<span class="token punctuation">.</span><span class="token function">y</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                        axis<span class="token punctuation">.</span><span class="token function">z</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span>axis<span class="token punctuation">.</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                         <span class="token operator">-</span>axis<span class="token punctuation">.</span><span class="token function">y</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> axis<span class="token punctuation">.</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">;</span>    rot_mat <span class="token operator">+=</span> std<span class="token double-colon punctuation">::</span><span class="token function">sin</span><span class="token punctuation">(</span>angle_rad<span class="token punctuation">)</span> <span class="token operator">*</span> cross_product_mat<span class="token punctuation">;</span>    Eigen<span class="token double-colon punctuation">::</span>Matrix4f trans_mat <span class="token operator">=</span> Eigen<span class="token double-colon punctuation">::</span><span class="token class-name">Matrix4f</span><span class="token double-colon punctuation">::</span><span class="token function">Identity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    trans_mat<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">topLeftCorner</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> rot_mat<span class="token punctuation">;</span>    <span class="token keyword">return</span> trans_mat<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="投影矩阵"><a href="#投影矩阵" class="headerlink" title="投影矩阵"></a>投影矩阵</h2><p>投影矩阵就相对复杂一些了，先上代码</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Eigen<span class="token double-colon punctuation">::</span>Matrix4f <span class="token function">get_projection_matrix</span><span class="token punctuation">(</span><span class="token keyword">float</span> eye_fov<span class="token punctuation">,</span> <span class="token keyword">float</span> aspect_ratio<span class="token punctuation">,</span>                                      <span class="token keyword">float</span> zNear<span class="token punctuation">,</span> <span class="token keyword">float</span> zFar<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// Students will implement this function</span>    Eigen<span class="token double-colon punctuation">::</span>Matrix4f projection <span class="token operator">=</span> Eigen<span class="token double-colon punctuation">::</span><span class="token class-name">Matrix4f</span><span class="token double-colon punctuation">::</span><span class="token function">Identity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Eigen<span class="token double-colon punctuation">::</span>Matrix4f perspective<span class="token punctuation">;</span>    <span class="token keyword">float</span> cotangent <span class="token operator">=</span> <span class="token number">1.0</span> <span class="token operator">/</span> std<span class="token double-colon punctuation">::</span><span class="token function">tan</span><span class="token punctuation">(</span>eye_fov <span class="token operator">/</span> <span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">float</span> z_delta <span class="token operator">=</span> zFar <span class="token operator">-</span> zNear<span class="token punctuation">;</span>    perspective <span class="token operator">&lt;&lt;</span> cotangent <span class="token operator">/</span> aspect_ratio<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>                     <span class="token number">0</span><span class="token punctuation">,</span> cotangent<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>                     <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token punctuation">(</span>zFar <span class="token operator">+</span> zNear<span class="token punctuation">)</span> <span class="token operator">/</span> z_delta<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2</span> <span class="token operator">*</span> zFar <span class="token operator">*</span> zNear <span class="token operator">/</span> z_delta<span class="token punctuation">,</span>                    <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">;</span>    projection <span class="token operator">=</span> perspective <span class="token operator">*</span> projection<span class="token punctuation">;</span>    <span class="token keyword">return</span> projection<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先我们会发现输入的 zNear 和 zFar 都是正数，他们表示近平面和远平面到原点的距离，这与课上讲的不同。课上讲的 $n$ 和 $f$ 表示近平面和远平面在 $z$ 轴的坐标，他们是负数。</p><p>然后我们分析 rasterizer.cpp 里的 draw 函数，下面这段代码里，v 是三角形的三个顶点构成的数组，三个顶点都已经被变换到了 $[-1,1]^3$ 的正方体中。</p><p>注意 <code>vert.z() = vert.z() * f1 + f2</code> 这行代码，把 $-1$ 代入右边得到 $-n$，$1$ 代入右边得到 $-f$，因此我们有理由猜测 $[-n,-f]$ 被映射到了 $[-1,1]$. </p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">float</span> f1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">100</span> <span class="token operator">-</span> <span class="token number">0.1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2.0</span><span class="token punctuation">;</span><span class="token keyword">float</span> f2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">100</span> <span class="token operator">+</span> <span class="token number">0.1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2.0</span><span class="token punctuation">;</span><span class="token comment">// ...</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span> vert <span class="token operator">:</span> v<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    vert<span class="token punctuation">.</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0.5</span><span class="token operator">*</span>width<span class="token operator">*</span><span class="token punctuation">(</span>vert<span class="token punctuation">.</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    vert<span class="token punctuation">.</span><span class="token function">y</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0.5</span><span class="token operator">*</span>height<span class="token operator">*</span><span class="token punctuation">(</span>vert<span class="token punctuation">.</span><span class="token function">y</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    vert<span class="token punctuation">.</span><span class="token function">z</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> vert<span class="token punctuation">.</span><span class="token function">z</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> f1 <span class="token operator">+</span> f2<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结一下我们的发现：</p><ol><li>输入的 zNear 和 zFar 都是正数，表示近平面和远平面到原点的距离</li><li>$[-n,-f]$ 被映射到了 $[-1,1]$</li></ol><p>最终我们能写出这样的投影矩阵：</p><script type="math/tex; mode=display">\large\text{M}_\text{per} =\begin{bmatrix}\frac{1}{\text{aspect} \times \tan(\frac{\text{fov}}{2})} & 0 & 0 & 0 \\0 & \frac{1}{\tan(\frac{\text{fov}}{2})} & 0 & 0 \\0 & 0 & -\frac{f+n}{f-n} & -\frac{2fn}{f-n} \\0 & 0 & -1 & 0\end{bmatrix}</script><p>翻译成代码就好。</p><h1 id="代码框架里有趣的地方"><a href="#代码框架里有趣的地方" class="headerlink" title="代码框架里有趣的地方"></a>代码框架里有趣的地方</h1><h2 id="ind-的作用"><a href="#ind-的作用" class="headerlink" title="ind 的作用"></a>ind 的作用</h2><p>首先我们看向 main.cpp 的 main 函数里的这段代码</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>Eigen<span class="token double-colon punctuation">::</span>Vector3f<span class="token operator">></span> pos<span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>Eigen<span class="token double-colon punctuation">::</span>Vector3i<span class="token operator">></span> ind<span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>pos 显然是三角形的三个顶点，但 ind 是做什么的？uh actually🤓☝️它定义了如何将顶点连接起来。对三角形来说它当然没什么用，但对多边形来说，它就很有用了。</p><p>比如说，想象一下我们在画一个六边形，我们需要六个顶点。但由于在渲染时我们主要绘制三角形，所以我们要把六边形拆分成多个三角形，而拆分出的每个三角形就对应着 ind 里的一个元素了。</p><p>对六边形来说，我们可能会定义下面这样的 pos 和 ind</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>Eigen<span class="token double-colon punctuation">::</span>Vector3f<span class="token operator">></span> pos<span class="token punctuation">&#123;</span>    <span class="token punctuation">&#123;</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token comment">// 0: 右</span>    <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1.732</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token comment">// 1: 右上</span>    <span class="token punctuation">&#123;</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1.732</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token comment">// 2: 左上</span>    <span class="token punctuation">&#123;</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>     <span class="token comment">// 3: 左</span>    <span class="token punctuation">&#123;</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.732</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">// 4: 左下</span>    <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.732</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">&#125;</span>  <span class="token comment">// 5: 右下</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>Eigen<span class="token double-colon punctuation">::</span>Vector3i<span class="token operator">></span> ind<span class="token punctuation">&#123;</span>    <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="id-的作用"><a href="#id-的作用" class="headerlink" title="id 的作用"></a>id 的作用</h2><p>继续看向 main.cpp 的 main 函数，把目光投向这段代码</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> pos_id <span class="token operator">=</span> r<span class="token punctuation">.</span><span class="token function">load_positions</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">auto</span> ind_id <span class="token operator">=</span> r<span class="token punctuation">.</span><span class="token function">load_indices</span><span class="token punctuation">(</span>ind<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// ...</span>r<span class="token punctuation">.</span><span class="token function">draw</span><span class="token punctuation">(</span>pos_id<span class="token punctuation">,</span> ind_id<span class="token punctuation">,</span> rst<span class="token double-colon punctuation">::</span>Primitive<span class="token double-colon punctuation">::</span>Triangle<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这里，我们把 id 传入了 draw 函数来画图。但为什么要用 id 呢？直接 &amp; 传参不行吗？</p><p>【TODO：我不知道。AI说在正式的渲染代码里，我们会在load时做一些操作诸如把数据上传到显存，或者重新组织上传的各个数据来提高效率，但咱也不知道是不是真的。】</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本次作业要求我们实现旋转矩阵、投影矩阵。我们先简单看下作业是怎么做的，再看看代码框架里的几个有趣的地方。&lt;/p&gt;
&lt;h1 id=&quot;作业实现&quot;&gt;&lt;a href=&quot;#作业实现&quot; class=&quot;headerlink&quot; title=&quot;作业实现&quot;&gt;&lt;/a&gt;作业实现&lt;/h1&gt;&lt;h2 i</summary>
      
    
    
    
    <category term="公开课" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"/>
    
    <category term="GAMES101" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/"/>
    
    <category term="Assignments" scheme="http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/Assignments/"/>
    
    
  </entry>
  
</feed>
