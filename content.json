{"meta":{"title":"Rinevard","subtitle":"","description":"","author":"Rinevard","url":"http://rinevard.github.io","root":"/"},"pages":[{"title":"About","date":"2025-07-21T02:01:28.976Z","updated":"2025-07-21T02:01:28.976Z","comments":true,"path":"about/index.html","permalink":"http://rinevard.github.io/about/index.html","excerpt":"","text":"这里是 Rinevard. 喜欢独立游戏之类的新鲜事物。我应该主要会在站里放一些杂谈和游戏相关的文章，欢迎来看！ 偶尔会出现的爱好是取名，我还用过 Lyraine、鲤鱼、江知鹤（读起来和 rinevard 蛮像的）之类的名字。 如果想和我联系，欢迎发邮件到 rinevard@outlook.com！（不过不一定会看） 我的 Github 账号: Rinevard. 另外，欢迎到我的 itch 主页上玩我的游戏！"},{"title":"人来人往的路","date":"2025-02-14T06:44:57.617Z","updated":"2025-02-14T06:44:57.617Z","comments":true,"path":"secret/many-people-path.html","permalink":"http://rinevard.github.io/secret/many-people-path.html","excerpt":"","text":"/* 草书效果相关样式 */ .center-cursive-text { font-family: 'Brush Script MT', cursive; font-size: 24px; color: black; text-align: center; margin: 20px 0; line-height: 1.5; cursor: default; } /* 重叠文字效果 */ .text-overlay-container { position: relative; height: 100px; margin: 20px 0; } .overlapping-text { position: absolute; width: 100%; font-family: 'Brush Script MT', cursive; font-size: 24px; text-align: center; color: black; opacity: 0.15; cursor: default; } /* 为每行文字设置不同的位置和透明度 */ .text-1 { top: 0; opacity: 0.8; } .text-2 { top: 12px; opacity: 0.6; } .text-3 { top: 24px; opacity: 0.4; } .text-4 { top: 36px; opacity: 0.2; } .text-5 { top: 48px; opacity: 0.1; } .text-6 { top: 60px; color: transparent; } 一片树林里分出两条路—— 而我选择了人来人往的一条， 只看到了六道印迹。 脚印 脚印 脚印 脚印 脚印 脚印"},{"title":"人迹罕至的路","date":"2025-02-14T06:12:25.238Z","updated":"2025-02-14T06:12:25.238Z","comments":true,"path":"secret/jurora-path.html","permalink":"http://rinevard.github.io/secret/jurora-path.html","excerpt":"","text":"/* 草书效果相关样式 */ .center-cursive-text { font-family: 'Brush Script MT', cursive; font-size: 24px; color: darkred; text-align: center; margin: 20px 0; /* padding: 20px; */ line-height: 1.5; cursor: default; } /* 隐藏草书 */ .hidden-fancy-text { font-family: 'Brush Script MT', cursive; font-size: 24px; text-align: center; margin: 20px 0; /* padding: 20px; */ line-height: 1.5; color: transparent; } .hidden-fancy-text::selection { color: darkred; background: white; } /* 人迹罕至的路 */ .secret-message { color: transparent; cursor: default; font-family: 'Brush Script MT', cursive; /* 使用草书字体 */ font-size: 24px; text-align: center; margin: 20px 0; line-height: 1.5; } .secret-message:hover { color: darkred; transition: color 0.5s ease; /* 稍微延长过渡时间 */ } 一片树林里分出两条路—— 而我选择了人迹更少的一条， &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 从此决定了我一生的道路。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"},{"title":"Tags","date":"2025-02-06T02:37:47.887Z","updated":"2025-02-06T02:37:47.887Z","comments":true,"path":"tags/index.html","permalink":"http://rinevard.github.io/tags/index.html","excerpt":"","text":"这里什么也没有哦~文件夹已经很方便了，为什么还要用标签呢？"},{"title":"Categories","date":"2025-02-06T02:38:03.136Z","updated":"2025-02-06T02:38:03.136Z","comments":true,"path":"categories/index.html","permalink":"http://rinevard.github.io/categories/index.html","excerpt":"","text":"这里什么也没有哦~文件夹已经很方便了，为什么还要用分类呢？"},{"title":"探索的奖励","date":"2025-02-11T02:04:52.000Z","updated":"2025-08-20T11:13:48.889Z","comments":true,"path":"secret/index.html","permalink":"http://rinevard.github.io/secret/index.html","excerpt":"","text":"/* 隐藏文本相关样式 */ .secret-text::selection { color: white; background: black; } .secret-text { background: transparent; cursor: default; /* 鼠标样式保持默认 */ } #output { white-space: pre; font-family: monospace; font-size: 12px; line-height: 12px; letter-spacing: unset; transform: unset; overflow-y: hidden; background: transparent; cursor: default; /* 鼠标样式保持默认 */ } /* 草书效果相关样式 */ .cursive-text { font-family: 'Brush Script MT', cursive; font-size: 20px; color: darkred; /* text-align: center; */ margin: 20px 0; /* padding: 20px; */ line-height: 1.5; cursor: default; } /* 草书效果相关样式 */ .center-cursive-text { font-family: 'Brush Script MT', cursive; font-size: 20px; color: darkred; text-align: center; margin: 20px 0; /* padding: 20px; */ line-height: 1.5; cursor: default; } /* 隐藏草书 */ .hidden-fancy-text { font-family: 'Brush Script MT', cursive; font-size: 22px; /* text-align: center; */ margin: 20px 0; /* padding: 20px; */ line-height: 1.5; color: transparent; cursor: default; } .hidden-fancy-text::selection { color: darkred; background: white; } /* 人迹罕至的路 */ .paths-container { display: flex; justify-content: center; margin: 20px 0; font-family: 'Brush Script MT', cursive; font-size: 20px; } /* 修改链接样式 */ .paths-container a.path { padding: 15px; text-decoration: none !important; border: none; /* 移除可能的边框 */ background: none; /* 移除可能的背景 */ } /* 有人的路径样式 */ .paths-container a.path-visible { color: #5a3921 !important; /* 使用 !important 来确保优先级 */ } /* 隐藏的路径样式 */ .paths-container a.path-hidden { color: transparent !important; /* 使用 !important 来确保优先级 */ } /* 悬停效果 */ .paths-container a.path-hidden:hover { color: #5a3921 !important; transition: color 0.3s ease; } /* visited状态 */ .paths-container a.path-visible:visited { color: #5a3921 !important; } .paths-container a.path-hidden:visited { color: transparent !important; } .paths-container a.path-hidden:hover:visited { color: #5a3921 !important; } 对不起骗了大家这么久，其实我是一条鲤鱼。 ..-*=. ......:::....... .:=*****:. ..:=++*++=---------=++**+=:.. .:+********-. ...+*+:.. ..:=*+:.-***************-. ..:-*+.. .=***************: .:=+*=**: .:***************+. ..-=- +*: .:****************: ..:+ +*: .:****************- .+* ** +*: .:****************- .-** +*: .:****************: +...+ +*: .:****************. :.:=****-. .:***************- ..:-++-.. ..-++-*************=. ..:=**+=:..... .....:-+**+:....-**********=.. ...:-===++++++==-:... .-*******=. ..=***+. ..-*:. 嗯，实在是太敷衍了，所以我稍微加了点东西。 祝你好运，也祝你玩得开心。 黄昏的树林里分出两条路， 所幸在此我能同时去涉足 人来人往的路 人迹罕至的路 或许哪天还会再来看看这里的变化？启程了，再见啦。"},{"title":"无穷的远方，无尽的人们","date":"2025-03-20T13:12:59.559Z","updated":"2025-03-20T13:12:59.559Z","comments":true,"path":"links/index.html","permalink":"http://rinevard.github.io/links/index.html","excerpt":"","text":"这里是一些有趣的人们，我的生活因他们而增添了一抹奇幻色彩。你知道的，我并没有很多社交技能点，所以便用这种方法来告诉未来的自己——我曾遇见过一些有趣的人。 北理工先是一些算是同辈的人吧 示例链接 1 - 描述文字 示例链接 2 - 描述文字 示例链接 3 - 描述文字 然后是一些前辈，虽然年龄也差不太多就是了 范滇东的博客 - 如果没有前辈开发的 bit101，我的北理生活想必不会那么有趣。 周弈帆的博客 - 一个有趣的前辈，写的博客对我有启发。 这个页面是突发奇想做出来的，如果它让我和人们有了更多的联系，那实在很有趣！抱着对这份奇幻色彩的期待，便觉得这些文字值得写了。"}],"posts":[{"title":"Assignment 3 Pipeline and Shading","slug":"learning/open-course/GAMES101/Hw/Hw3-pipeline-and-shading","date":"2025-09-13T11:45:16.000Z","updated":"2025-09-13T12:04:25.374Z","comments":true,"path":"wiki/learning/open-course/GAMES101/Hw/Hw3-pipeline-and-shading/","permalink":"http://rinevard.github.io/wiki/learning/open-course/GAMES101/Hw/Hw3-pipeline-and-shading/","excerpt":"","text":"本次作业对 bump_fragment_shader、displacement_fragment_shader 的要求非常不严谨，至少包括这些问题： 这两个 shdaer 需要的贴图是凹凸贴图，凹凸贴图本应该是灰度图，这里使用 RGB 贴图。 在计算切线空间到世界空间的变换矩阵 TBN 时使用了错误的公式。正确的公式需要知道三角形的三个顶点及其 UV 坐标。 displacement 方法没有在光栅化前偏移顶点位置，而只调整了显示颜色。 我们先介绍一下 TBN 的正确计算方式和从 bump texture 算出梯度的方法，再依次介绍一下各个作业的做法。 TBN的正确计算方式我们先来看看什么是 TBN 以及为什么需要 TBN. 为了简单起见，我们先考虑法线贴图。下文把世界空间里按法线贴图修正后的法线称作“修正法线”，把世界空间里修正前的法线称作“几何法线”，这里默认它们都是归一化的。 考虑世界空间的某一点 $Q$，假设它在法线贴图中对应的一点为 $Q’$，我们知道点 $Q’$ 对应的法线被用于计算世界空间点 $Q$ 的修正法线。但等等，直接把 RGB 值复制过去看起来是错误的，因为随着物体转动，点 $Q$ 对应的法线也应当转动。因此，我们需要一个矩阵来实现这种从法线贴图上的法线到世界空间的修正法线的变换。 贴图是二维的，因此我们再额外定义一个垂直纸面向外的轴 $n$，它表示法线的“默认方向”，这就得到了三维的切线空间。如果点 $Q’$ 对应的法线是 $(0,0,1)$，那么世界空间的点 $Q$ 的修正法线就是原本的几何法线。 接下来就要考虑如何找到这个从切线空间到世界空间的旋转矩阵了。为了简单起见，我们先考虑单个三角形的旋转。之后我们会对每个点求出它自己的旋转矩阵。没错，每个点的旋转矩阵不同，这是因为每个点对应的矩阵会把 $(0,0,1)$ 映射到该点的几何法线，而每个点的几何法线一般不同。 如下图所示，我们希望把法线贴图上的 $P_0’P_1’P_2’$ 旋转为世界空间的 $P_0P_1P_2$，设这里的旋转矩阵为 $M$，世界空间的 $P_0P_1P_2$ 的几何法线为 $\\mathbf{n}$，则有 \\begin{align*} &M[0,0,1]^T=\\mathbf n \\end{align*} 但光靠这一个方程当然解不出 $M$，所以我们再考虑两个额外的方程： \\begin{align*} &M (P_1'-P_0')=k(P_1-P_0) \\\\ &M (P_2'-P_0')=k(P_2-P_0) \\end{align*}也就是说，我们希望这个矩阵把切线空间三角形的边向量旋转到世界空间的边向量上，这看起来是一个合理的要求。这里的 $k$ 是边的长度的缩放比例，严格来说每条边的缩放比例不一定相等，但只要 UV 映射前后的三角形大体是相似三角形，我们就可以认为缩放比例都为 $k$. 下面我们来解方程。首先我们设 \\begin{align*} &M=\\begin{pmatrix} T & B & N \\end{pmatrix} \\\\ &P_1'-P_0'= [\\Delta u_1,\\Delta v_1,0]^T \\\\ &P_2'-P_0'= [\\Delta u_2,\\Delta v_2,0]^T \\end{align*}下面两个式子利用了 $P_k’$ 的第三个分量为 $0$ 的性质。 结合第一个方程就能得到 $N=\\mathbf n$，这里的 $\\mathbf n$ 表示世界空间的 $P_0P_1P_2$ 的几何法线。再结合另外两个方程就能得到 \\begin{align*} &\\Delta u_1 T+\\Delta v_1 B=k(P_1-P_0) \\\\ &\\Delta u_2 T+\\Delta v_2 B=k(P_2-P_0) \\end{align*}之后我们可以解出 $T,B,N$ 的值 \\begin{align*} &T=k\\frac{\\Delta v_2(P_1-P_0)-\\Delta v_1(P_2-P_0)}{\\Delta u_1 \\Delta v_2-\\Delta u_2 \\Delta v_1} \\\\ &B=k\\frac{\\Delta u_2(P_1-P_0)-\\Delta u_1(P_2-P_0)}{\\Delta u_2 \\Delta v_1-\\Delta u_1 \\Delta v_2} \\\\ &N=\\mathbf n \\end{align*}这个公式是不能用的，因为里面有未知数 $k$. 接下来我们解决这个问题。 我们期望 TBN 矩阵是一个旋转矩阵，而旋转矩阵是正交矩阵，所以我们会对 TBN 做施密特正交化和归一化。只要 $P_0P_1P_2$ 和 $P_0’P_1’P_2’$ 大体是相似三角形，那么它们本来就差不多正交（回顾我们对 TBN 的定义，会发现相似说明 TBN 只对 $P_0’P_1’P_2’$ 做了旋转和缩放，这表明 TBN 正交），所以这种正交化不会把 TBN 变化太多。而由于我们会对 TBN 做单位化，所以我们可以放心地令 $k=1$ 来用下面的公式求出 TBN： \\begin{align*} &T=\\frac{\\Delta v_2(P_1-P_0)-\\Delta v_1(P_2-P_0)}{\\Delta u_1 \\Delta v_2-\\Delta u_2 \\Delta v_1} \\\\ &B=\\frac{\\Delta u_2(P_1-P_0)-\\Delta u_1(P_2-P_0)}{\\Delta u_2 \\Delta v_1-\\Delta u_1 \\Delta v_2} \\\\ &N=\\mathbf{n} \\end{align*}最后，我们希望 N 在正交化前后不变，所以在正交化后我们有 \\begin{align*} &T'=T-(N\\cdot T)N \\\\ &B'=B-(N\\cdot B)N-(T'\\cdot B)T'/T'^2 \\\\ &N'=\\mathbf n \\end{align*}再做个单位化就能得到顶点的 TBN 矩阵了。还记得 TBN 矩阵是做什么的吗，我们用它来实现从切线空间到世界空间的变换。所以对点 $Q$，假设其法线贴图对应的法线为 $\\mathbf n’$，那么修正后的法线就是 $M_{\\text{TBN}}\\mathbf n’$. 很好，我们现在能把单个三角形做变换了，但在真正的模型中，每个点的几何法线方向一般都不同，这就意味着它们一般都有不同的 TBN 矩阵。与计算顶点法线类似，我们会找到每个顶点相邻的所有三角形，并对它们的 $T$ 和 $B$ 做加权平均来得到这个顶点的 $T$ 和 $B$. 在实践中，我们一般只计算出每个顶点的 $T$，然后在需要 $B$ 时通过叉乘 $N\\times T$ 来计算。对那些非顶点的点，我们用重心坐标插值来算出其 $N$ 和 $T$，然后也做正交化和单位化来保证 TBN 矩阵的正交性。 最后我们再简单分析一下怎么根据凹凸贴图做法线修正。在修正法线时，凹凸贴图与法线贴图的唯一区别就是没有直接给出法线。回顾一下切线空间的定义，我们就可以给凹凸贴图同样设置沿纸面向外的 $n$ 轴，然后把凹凸贴图想象成一个按灰度值起伏的曲面，这个曲面的法线就和法线贴图提供的法线相对应。 具体来说，点 $(u,v)$ 处的法线可以用 $(h(u)-h(u+1,v),h(v)-h(u,v+1),1)$ 来近似，其中 $h(u,v)$ 表示凹凸贴图在点 $(u,v)$ 处的灰度值，$h(u+1,v)$ 表示 $(u,v)$ 右边一格的灰度值。 有时由于我们把贴图做了归一化，我们会改用 $h(u+1/\\text{width},v)$，但记住它表示相邻格子的灰度值就行。 最后把这个法线和 TBN 矩阵相乘即可得到修正法线。 参考 Computing Tangent Space Basis Vectors for an Arbitrary Mesh - Eric Lengyel 作业代码rasterize_triangle注意这里的插值算法要对所有的属性都做透视矫正，我们简单推导一下透视矫正的公式： 假设我们在对点 $Q$ 的某个属性进行插值，在世界空间中，它所在的三角形为 $P_0P_1P_2$. 投影变换后，它们分别变成了 $Q’$ 和 $P_0’P_1’P_2’$. 用重心坐标分别表示 $Q$ 和 $Q’$，会得到 \\begin{align*} &Q=\\alpha P_0+\\beta P_1+\\gamma P_2 \\\\ &Q'=\\alpha' P_0'+\\beta' P_1'+\\gamma' P_2' \\end{align*}这里的 $Q,Q’,P_k,P_k’$ 都是形如 $[x,y,z,1]^T$ 的向量。 在插值属性时，我们希望用 $\\alpha, \\beta,\\gamma$ 来插值，而不是使用 $\\alpha’, \\beta’,\\gamma’$ 插值，因为我们当然不希望属性会因透视位置不同而不同。这就需要我们根据 $\\alpha’, \\beta’,\\gamma’$ 算出 $\\alpha, \\beta,\\gamma$. 不妨设投影变换矩阵为 $M$，则有 \\begin{align*} &MQ=\\alpha MP_0+\\beta MP_1+\\gamma MP_2 \\end{align*}这里的 $MP_k$ 是形如 $[x_k,y_k,z_k,w_k]^T$ 的用齐次坐标表示的向量，它与形如 $[x,y,z,1]^T$ 的 $P_k’$ 虽然在数学上表示同一个点，但在数值上不同。（还记得吗，齐次坐标下的 $[x,y,z,1]$ 和 $[ax,ay,az,a]$ 表示同一个点） 因此我们希望对向量的系数做一些调整，来让各个向量变成 $[x,y,z,1]^T$ 的形式，从而找出 $\\alpha’, \\beta’,\\gamma’$ 和 $\\alpha, \\beta,\\gamma$ 的关系。 简单变换一下，我们能把上面的式子写成 \\begin{align*} &MQ=\\alpha w_0\\frac{MP_0}{w_0}+\\beta w_1\\frac{MP_1}{w_1}+\\gamma w_2\\frac{MP_2}{w_2} \\end{align*}现在右边的各个向量 $\\frac{MP_k}{w_k}$ 都已经是 $[x,y,z,1]^T$ 的形式了，我们给它们的系数做个归一化就能让左边的向量也变成 $[x,y,z,1]^T$ 的形式： \\frac{MQ}{\\alpha w_0 + \\beta w_1 + \\gamma w_2} = \\frac{1}{\\alpha w_0 + \\beta w_1 + \\gamma w_2} \\bigg( \\alpha w_0\\frac{MP_0}{w_0}+\\beta w_1\\frac{MP_1}{w_1}+\\gamma w_2\\frac{MP_2}{w_2} \\bigg)由此我们就有 \\begin{align*} &\\frac{\\alpha w_0}{\\alpha w_0 + \\beta w_1 + \\gamma w_2}=\\alpha' \\\\ &\\frac{\\beta w_1}{\\alpha w_0 + \\beta w_1 + \\gamma w_2}=\\beta' \\\\ &\\frac{\\gamma w_2}{\\alpha w_0 + \\beta w_1 + \\gamma w_2}=\\gamma' \\end{align*}解上面的方程的小技巧是借助除法和重心坐标和为 $1$ 的性质得到下面的等价的方程组 \\begin{align*} &\\frac{\\alpha'}{\\beta'}=\\frac{\\alpha w_0}{\\beta w_1} \\\\ &\\frac{\\alpha'}{\\gamma'}=\\frac{\\alpha w_0}{\\gamma w_2} \\\\ &\\alpha + \\beta + \\gamma = 1 \\end{align*}然后就能求出 \\begin{align*} &\\alpha = \\frac{\\alpha' / w_0}{\\alpha' / w_0 + \\beta' / w_1 + \\gamma' / w_2} \\\\ &\\beta= \\frac{\\beta' / w_1}{\\alpha' / w_0 + \\beta' / w_1 + \\gamma' / w_2} \\\\ &\\gamma= \\frac{\\gamma' / w_2}{\\alpha' / w_0 + \\beta' / w_1 + \\gamma' / w_2} \\end{align*}由此，我们就从屏幕空间的重心坐标 $\\alpha’,\\beta’,\\gamma’$ 算出了世界空间的重心坐标 $\\alpha,\\beta,\\gamma$，之后就能用世界空间的重心坐标来正确插值了。 //Screen space rasterization void rst::rasterizer::rasterize_triangle(const Triangle&amp; t, const std::array&lt;Eigen::Vector3f, 3>&amp; view_pos) &#123; auto v = t.toVector4(); // Find bounding box float left = v[0].x(); float right = v[0].x(); float bottom = v[0].y(); float top = v[0].y(); for (auto&amp; vec: v) &#123; left = std::min(left, vec.x()); right = std::max(right, vec.x()); bottom = std::min(bottom, vec.y()); top = std::max(top, vec.y()); &#125; // Update pixels in bounding box for (int x = static_cast&lt;int>(left); x &lt;= static_cast&lt;int>(right) + 1; x++) &#123; for (int y = static_cast&lt;int>(bottom); y &lt;= static_cast&lt;int>(top) + 1; y++) &#123; auto[alpha, beta, gamma] = computeBarycentric2D(x, y, t.v); // If (x, y) is not inside triangle, continue if (alpha &lt; 0 || beta &lt; 0 || gamma &lt; 0) &#123; continue; &#125; // Interpolate z value, color, normal, texcoords, shadingcoords, viewpos float alpha_corrected = alpha / v[0].w(); float beta_corrected = beta / v[1].w(); float gamma_corrected = gamma / v[2].w(); float w_reciprocal = alpha_corrected + beta_corrected + gamma_corrected; auto z_interpolated = interpolate(alpha_corrected, beta_corrected, gamma_corrected, v[0].z(), v[1].z(), v[2].z(), w_reciprocal); auto color_interpolated = interpolate(alpha_corrected, beta_corrected, gamma_corrected, t.color[0], t.color[1], t.color[2], w_reciprocal); auto normal_interpolated = interpolate(alpha_corrected, beta_corrected, gamma_corrected, t.normal[0], t.normal[1], t.normal[2], w_reciprocal); auto texcoordes_interpolated = interpolate(alpha_corrected, beta_corrected, gamma_corrected, t.tex_coords[0], t.tex_coords[1], t.tex_coords[2], w_reciprocal); auto viewpos_interpolated = interpolate(alpha_corrected, beta_corrected, gamma_corrected, view_pos[0], view_pos[1], view_pos[2], w_reciprocal); // A lower z-value means it is displayed in front if (z_interpolated &lt; depth_buf[y * width + x]) &#123; depth_buf[y * width + x] = z_interpolated; fragment_shader_payload payload( color_interpolated, normal_interpolated, texcoordes_interpolated, texture ? &amp;*texture : nullptr ); payload.view_pos = viewpos_interpolated; auto pixel_color = fragment_shader(payload); set_pixel(Vector2i(x, y), pixel_color); &#125; &#125; &#125; &#125; phong 和 texturephong 的代码按着 phong 模型实现即可。texture 的代码几乎是一模一样的。 我唯一好奇的地方是为什么末尾乘了 255.0f，难道光照模型的各个数值取值都在 $(0,1)$ 之间？但看光强似乎又不是这样。 Eigen::Vector3f phong_fragment_shader(const fragment_shader_payload&amp; payload) &#123; Eigen::Vector3f ka = Eigen::Vector3f(0.005, 0.005, 0.005); Eigen::Vector3f kd = payload.color; Eigen::Vector3f ks = Eigen::Vector3f(0.7937, 0.7937, 0.7937); auto l1 = light&#123;&#123;20, 20, 20&#125;, &#123;500, 500, 500&#125;&#125;; auto l2 = light&#123;&#123;-20, 20, 0&#125;, &#123;500, 500, 500&#125;&#125;; std::vector&lt;light> lights = &#123;l1, l2&#125;; Eigen::Vector3f amb_light_intensity&#123;10, 10, 10&#125;; Eigen::Vector3f eye_pos&#123;0, 0, 10&#125;; float p = 150; Eigen::Vector3f color = payload.color; Eigen::Vector3f point = payload.view_pos; Eigen::Vector3f normal = payload.normal; Eigen::Vector3f result_color = &#123;0, 0, 0&#125;; Eigen::Vector3f ambient = ka.cwiseProduct(amb_light_intensity); result_color += ambient; for (auto&amp; light : lights) &#123; // TODO: For each light source in the code, calculate what the *ambient*, *diffuse*, and *specular* // components are. Then, accumulate that result on the *result_color* object. Eigen::Vector3f vec_to_light = light.position - point; Eigen::Vector3f diffuse = kd.cwiseProduct(light.intensity / vec_to_light.squaredNorm()) * MAX(0, normal.normalized().dot(vec_to_light.normalized())); Eigen::Vector3f vec_to_eye = eye_pos - point; Eigen::Vector3f h = vec_to_light.normalized() + vec_to_eye.normalized(); Eigen::Vector3f specular = ks.cwiseProduct(light.intensity / vec_to_light.squaredNorm()) * pow(MAX(0, normal.normalized().dot(h.normalized())), p); // The ambient component is only added once before the for loop result_color += (diffuse + specular); &#125; return result_color * 255.f; &#125; Eigen::Vector3f texture_fragment_shader(const fragment_shader_payload&amp; payload) &#123; Eigen::Vector3f texture_color = &#123;0, 0, 0&#125;; if (payload.texture) &#123; // TODO: Get the texture value at the texture coordinates of the current fragment texture_color = payload.texture->getColor(payload.tex_coords.x(), payload.tex_coords.y()); &#125; Eigen::Vector3f ka = Eigen::Vector3f(0.005, 0.005, 0.005); Eigen::Vector3f kd = texture_color / 255.f; Eigen::Vector3f ks = Eigen::Vector3f(0.7937, 0.7937, 0.7937); auto l1 = light&#123;&#123;20, 20, 20&#125;, &#123;500, 500, 500&#125;&#125;; auto l2 = light&#123;&#123;-20, 20, 0&#125;, &#123;500, 500, 500&#125;&#125;; std::vector&lt;light> lights = &#123;l1, l2&#125;; Eigen::Vector3f amb_light_intensity&#123;10, 10, 10&#125;; Eigen::Vector3f eye_pos&#123;0, 0, 10&#125;; float p = 150; Eigen::Vector3f color = texture_color; Eigen::Vector3f point = payload.view_pos; Eigen::Vector3f normal = payload.normal; Eigen::Vector3f result_color = &#123;0, 0, 0&#125;; Eigen::Vector3f ambient = ka.cwiseProduct(amb_light_intensity); result_color += ambient; for (auto&amp; light : lights) &#123; // TODO: For each light source in the code, calculate what the *ambient*, *diffuse*, and *specular* // components are. Then, accumulate that result on the *result_color* object. Eigen::Vector3f vec_to_light = light.position - point; Eigen::Vector3f diffuse = kd.cwiseProduct(light.intensity / vec_to_light.squaredNorm()) * MAX(0.0f, normal.normalized().dot(vec_to_light.normalized())); Eigen::Vector3f vec_to_eye = eye_pos - point; Eigen::Vector3f h = vec_to_light.normalized() + vec_to_eye.normalized(); Eigen::Vector3f specular = ks.cwiseProduct(light.intensity / vec_to_light.squaredNorm()) * pow(MAX(0.0f, normal.normalized().dot(h.normalized())), p); // The ambient component is only added once before the for loop result_color += (diffuse + specular); &#125; return result_color * 255.f; &#125; bump 和 displacement如开头所言，本次作业对这两个 shader 的要求非常不严谨，我们就简单放下代码，不多解释了。在一些不严谨的地方我已经写了注释。 Eigen::Vector3f bump_fragment_shader(const fragment_shader_payload&amp; payload) &#123; Eigen::Vector3f ka = Eigen::Vector3f(0.005, 0.005, 0.005); Eigen::Vector3f kd = payload.color; Eigen::Vector3f ks = Eigen::Vector3f(0.7937, 0.7937, 0.7937); auto l1 = light&#123;&#123;20, 20, 20&#125;, &#123;500, 500, 500&#125;&#125;; auto l2 = light&#123;&#123;-20, 20, 0&#125;, &#123;500, 500, 500&#125;&#125;; std::vector&lt;light> lights = &#123;l1, l2&#125;; Eigen::Vector3f amb_light_intensity&#123;10, 10, 10&#125;; Eigen::Vector3f eye_pos&#123;0, 0, 10&#125;; float p = 150; Eigen::Vector3f color = payload.color; Eigen::Vector3f point = payload.view_pos; Eigen::Vector3f normal = payload.normal; float kh = 0.2, kn = 0.1; // TODO: Implement bump mapping here // Let n = normal = (x, y, z) // Vector t = (x*y/sqrt(x*x+z*z),sqrt(x*x+z*z),z*y/sqrt(x*x+z*z)) // Vector b = n cross product t // Matrix TBN = [t b n] // dU = kh * kn * (h(u+1/w,v)-h(u,v)) // dV = kh * kn * (h(u,v+1/h)-h(u,v)) // Vector ln = (-dU, -dV, 1) // Normal n = normalize(TBN * ln) // Note: The formula is WRONG in theory // To calculate the TBN matrix correctly, we need the triangle's vertices and their corresponding UV coordinates // read https://learnopengl.com/Advanced-Lighting/Normal-Mapping and // https://terathon.com/blog/tangent-space.html for more details float x = normal.x(); float y = normal.y(); float z = normal.z(); float u = payload.tex_coords.x(); float v = payload.tex_coords.y(); float w = payload.texture->width; float h = payload.texture->height; Eigen::Vector3f t = Eigen::Vector3f(x*y/sqrt(x*x+z*z),sqrt(x*x+z*z),z*y/sqrt(x*x+z*z)); Eigen::Vector3f b = normal.cross(t); Eigen::Matrix3f TBN; TBN &lt;&lt; t, b, normal; // In theory the texture should be a grayscale image // However we use an ordinary RGB image here, so we take norm // read https://games-cn.org/forums/topic/frequently-asked-questionskeep-updating/ for more details float dU = kh * kn * (payload.texture->getColor(u+1.0f/w, v).norm() - payload.texture->getColor(u, v).norm()); float dV = kh * kn * (payload.texture->getColor(u, v+1.0f/h).norm() - payload.texture->getColor(u, v).norm()); Eigen::Vector3f ln = Eigen::Vector3f(-dU, -dV, 1); normal = (TBN * ln).normalized(); Eigen::Vector3f result_color = &#123;0, 0, 0&#125;; result_color = normal; return result_color * 255.f; &#125; Eigen::Vector3f displacement_fragment_shader(const fragment_shader_payload&amp; payload) &#123; Eigen::Vector3f ka = Eigen::Vector3f(0.005, 0.005, 0.005); Eigen::Vector3f kd = payload.color; Eigen::Vector3f ks = Eigen::Vector3f(0.7937, 0.7937, 0.7937); auto l1 = light&#123;&#123;20, 20, 20&#125;, &#123;500, 500, 500&#125;&#125;; auto l2 = light&#123;&#123;-20, 20, 0&#125;, &#123;500, 500, 500&#125;&#125;; std::vector&lt;light> lights = &#123;l1, l2&#125;; Eigen::Vector3f amb_light_intensity&#123;10, 10, 10&#125;; Eigen::Vector3f eye_pos&#123;0, 0, 10&#125;; float p = 150; Eigen::Vector3f color = payload.color; Eigen::Vector3f point = payload.view_pos; Eigen::Vector3f normal = payload.normal; float kh = 0.2, kn = 0.1; // TODO: Implement displacement mapping here // Let n = normal = (x, y, z) // Vector t = (x*y/sqrt(x*x+z*z),sqrt(x*x+z*z),z*y/sqrt(x*x+z*z)) // Vector b = n cross product t // Matrix TBN = [t b n] // dU = kh * kn * (h(u+1/w,v)-h(u,v)) // dV = kh * kn * (h(u,v+1/h)-h(u,v)) // Vector ln = (-dU, -dV, 1) // Position p = p + kn * n * h(u,v) // Normal n = normalize(TBN * ln) // Note: The formula is WRONG in theory // When using Displacement Mapping, the points should be offset in the camera space before rasterizing, // instead of only changing its color // read https://learnopengl.com/Advanced-Lighting/Normal-Mapping and // https://terathon.com/blog/tangent-space.html for more details float x = normal.x(); float y = normal.y(); float z = normal.z(); float u = payload.tex_coords.x(); float v = payload.tex_coords.y(); float w = payload.texture->width; float h = payload.texture->height; Eigen::Vector3f t = Eigen::Vector3f(x*y/sqrt(x*x+z*z),sqrt(x*x+z*z),z*y/sqrt(x*x+z*z)); Eigen::Vector3f b = normal.cross(t); Eigen::Matrix3f TBN; TBN &lt;&lt; t, b, normal; // In theory the texture should be a grayscale image // However we use an ordinary RGB image here, so we take norm // read https://games-cn.org/forums/topic/frequently-asked-questionskeep-updating/ for more details float dU = kh * kn * (payload.texture->getColor(u+1.0f/w, v).norm() - payload.texture->getColor(u, v).norm()); float dV = kh * kn * (payload.texture->getColor(u, v+1.0f/h).norm() - payload.texture->getColor(u, v).norm()); Eigen::Vector3f ln = Eigen::Vector3f(-dU, -dV, 1); // In theory we should bias the point using the original normal // but to match the homework answer, we bias the point using the corrected normal normal = (TBN * ln).normalized(); point += kn * normal * payload.texture->getColor(u, v).norm(); Eigen::Vector3f result_color = &#123;0, 0, 0&#125;; Eigen::Vector3f ambient = ka.cwiseProduct(amb_light_intensity); result_color += ambient; for (auto&amp; light : lights) &#123; // TODO: For each light source in the code, calculate what the *ambient*, *diffuse*, and *specular* // components are. Then, accumulate that result on the *result_color* object. Eigen::Vector3f vec_to_light = light.position - point; Eigen::Vector3f diffuse = kd.cwiseProduct(light.intensity / vec_to_light.squaredNorm()) * MAX(0.0f, normal.normalized().dot(vec_to_light.normalized())); Eigen::Vector3f vec_to_eye = eye_pos - point; Eigen::Vector3f h = vec_to_light.normalized() + vec_to_eye.normalized(); Eigen::Vector3f specular = ks.cwiseProduct(light.intensity / vec_to_light.squaredNorm()) * pow(MAX(0.0f, normal.normalized().dot(h.normalized())), p); // The ambient component is only added once before the for loop result_color += (diffuse + specular); &#125; return result_color * 255.f; &#125;","categories":[{"name":"公开课","slug":"公开课","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"GAMES101","slug":"公开课/GAMES101","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/"},{"name":"Assignments","slug":"公开课/GAMES101/Assignments","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/Assignments/"}],"tags":[]},{"title":"Assignment 2 Rasterizing","slug":"learning/open-course/GAMES101/Hw/Hw2-rasterizing","date":"2025-08-26T12:15:16.000Z","updated":"2025-08-26T12:21:11.482Z","comments":true,"path":"wiki/learning/open-course/GAMES101/Hw/Hw2-rasterizing/","permalink":"http://rinevard.github.io/wiki/learning/open-course/GAMES101/Hw/Hw2-rasterizing/","excerpt":"","text":"本次作业要求我们实现 Z-buffer 、栅格化和 SSAA（也就是超采样）。我们先看看前两个东西，再看看 SSAA。 Z-buffer和栅格化代码框架我们要补全的 rasterize_triangle 函数在 draw 函数内被调用，可以看到 draw 函数已经做好了三角形的投影变换，我们只要把 $[0, \\text{width}] \\times [0,\\text{height}] \\times [n,f]$ 里的三角形渲染到屏幕上就好。输入的三角形大概形如这样： -------input triangle--------- 529.259 350 49.3857 1 -- 350 529.259 49.3857 1 -- 170.741 350 49.3857 1 -- ----------------------------- insideTriangle 函数用课上讲的叉乘法判断点是否在三角形内。“在三角形内”这个说法也不是特别严谨，更准确地说应该是判断三角形在屏幕上的二维投影是否包含这个点。 /* Return whether (x, y) is in the triangle, ignoring its z value. */ static bool insideTriangle(float x, float y, const std::array&lt;Vector4f, 3>&amp; triangle) &#123; Vector2f point1 = &#123;triangle[0].x(), triangle[0].y()&#125;; Vector2f point2 = &#123;triangle[1].x(), triangle[1].y()&#125;; Vector2f point3 = &#123;triangle[2].x(), triangle[2].y()&#125;; Vector2f checked_point = &#123;x, y&#125;; auto cross_product = [](const Vector2f&amp; v1, const Vector2f&amp; v2) &#123; return v1.x() * v2.y() - v1.y() * v2.x(); &#125;; float side1 = cross_product(point1 - checked_point, point1 - point2); float side2 = cross_product(point2 - checked_point, point2 - point3); float side3 = cross_product(point3 - checked_point, point3 - point1); return (side1 > 0 &amp;&amp; side2 > 0 &amp;&amp; side3 > 0) || (side1 &lt; 0 &amp;&amp; side2 &lt; 0 &amp;&amp; side3 &lt; 0); &#125; rasterize_triangle 函数这个实现好像没什么特别值得说的地方，简简单单采采样，然后用 depth_buf 实现 z-buffer 就好。 //Screen space rasterization void rst::rasterizer::rasterize_triangle(const Triangle&amp; t) &#123; auto v = t.toVector4(); // Find bounding box float left = v[0].x(); float right = v[0].x(); float bottom = v[0].y(); float top = v[0].y(); for (auto&amp; vec: v) &#123; left = std::min(left, vec.x()); right = std::max(right, vec.x()); bottom = std::min(bottom, vec.y()); top = std::max(top, vec.y()); &#125; // Update pixels in bounding box for (int x = static_cast&lt;int>(left); x &lt;= static_cast&lt;int>(right) + 1; x++) &#123; for (int y = static_cast&lt;int>(bottom); y &lt;= static_cast&lt;int>(top) + 1; y++) &#123; if (!insideTriangle(x+0.5, y+0.5, v)) &#123; continue; &#125; // Interpolate z value auto[alpha, beta, gamma] = computeBarycentric2D(x+0.5, y+0.5, t.v); float w_reciprocal = 1.0/(alpha / v[0].w() + beta / v[1].w() + gamma / v[2].w()); float z_interpolated = alpha * v[0].z() / v[0].w() + beta * v[1].z() / v[1].w() + gamma * v[2].z() / v[2].w(); z_interpolated *= w_reciprocal; // A lower z-value means it is displayed in front if (z_interpolated &lt; depth_buf[y * width + x]) &#123; depth_buf[y * width + x] = z_interpolated; set_pixel(Vector3f(x, y, z_interpolated), t.getColor()); &#125; &#125; &#125; &#125; SSAA的实现SSAA 的实现相较而言更困难一些，由于杂七杂八要改的地方比较多，我就先说下大致思路，再聊聊咱踩的两个坑。 不过在此之前，先来看看我们的成果吧！（这是动图 大致思路我们要先把所有内容渲染到大小为 $(\\text{width} * 2, \\text{height} * 2)$ 的自定义 buffer 里，再根据自定义 buffer 的内容填充屏幕上的像素。 要注意的是，我们不能直接在 rasterize_triangle 里把三角形画到屏幕上（具体原因见“踩坑1”那一节），而是要在 rasterize_triangle 中把三角形画到自定义的 buffer 里，再新增一个 resolve 函数并把它放到 draw 的最后，从而把自定义 buffer 里的内容画到屏幕上： void rst::rasterizer::resolve() &#123; for (int y = 0; y &lt; height; y++) &#123; for (int x = 0; x &lt; width; x++) &#123; frame_buf[y * width + x] = Vector3f::Zero(); for (int i = 0; i &lt; 4; i++) &#123; frame_buf[y * width + x] += ssaa_frame_buf[(y * width + x) * 4 + i]; &#125; frame_buf[y * width + x] /= 4.0; &#125; &#125; &#125; 更细节一些的话，我们需要做这些工作： 在 rasterizer.hpp 里加入 ssaa_frame_buf 和 resolve 的定义。 修改 rasterizer 的初始化函数和 clear 函数，正确初始化和重置 ssaa_frame_buf。 修改 set_pixel 函数，让它把内容画到 ssaa_frame_buf 里，而非 frame_buf 里。 修改 rasterize_triangle，让它用使用更高的采样率。 实现 resolve 函数。 杂七杂八要改的地方比较多，这里就不放更多代码了。 踩坑1SSAA、filtering 都建立在“我们对理想图像进行滤波”的基础上。也就是说，要先把世界里的对象按正确的前后顺序变为一个二维图像，然后再滤波。所以直接在 rasterize_triangle 里把像素划分成子像素然后取平均并不能实现 SSAA，而是会在三角形重叠的地方显示出黑边。 让我们来看一个具体例子。考虑一个 1/4 被绿色三角形占据、3/4 被蓝色三角形占据的像素，SSAA 会把 1/4 绿 + 3/4 蓝 作为这个像素的颜色。 而如果直接在 rasterize_triangle 里把像素划分成子像素然后取平均，那么栅格化蓝色三角形时，这个像素被当成 3/4 蓝；栅格化绿色三角形时，这个像素被当成 1/4 绿。无论谁在前面，最终结果要么是 3/4 蓝，要么是 1/4 绿，总与 SSAA 的结果 1/4 绿 + 3/4 蓝 不同。 踩坑2insideTriangle 的参数 x 和 y 的类型原本是 int，而在 SSAA 里我们把像素划分成了四个子像素，这些子像素的坐标大多不是整数。因此我们要把 insideTriangle 的 x 和 y 的类型改成 float. static bool insideTriangle(int x, int y, const Vector3f* _v) &#123; // TODO : Implement this function to check if the point (x, y) is inside the triangle represented by _v[0], _v[1], _v[2] &#125;","categories":[{"name":"公开课","slug":"公开课","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"GAMES101","slug":"公开课/GAMES101","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/"},{"name":"Assignments","slug":"公开课/GAMES101/Assignments","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/Assignments/"}],"tags":[]},{"title":"Note 2 Rasterizing","slug":"learning/open-course/GAMES101/Notes/Note2-Rasterizing","date":"2025-08-25T08:10:28.000Z","updated":"2025-08-27T00:57:52.860Z","comments":true,"path":"wiki/learning/open-course/GAMES101/Notes/Note2-Rasterizing/","permalink":"http://rinevard.github.io/wiki/learning/open-course/GAMES101/Notes/Note2-Rasterizing/","excerpt":"","text":"在 Transformation 部分，我们已经可以把一个三维空间里的三角形投影到平面上。但怎么把一个纯色三角形绘制到屏幕上呢？我们知道屏幕由大量的像素点组成，那么怎么确定每个像素点是什么颜色呢？ 我们通过采样给每个像素点涂上颜色。我们可以检查每个像素的中心点是否在这个三角形内部，如果在则涂上三角形的颜色。虽然这样绘制的三角形会有锯齿，效果一般，但基本思想就是这样。 那么如果有多个三角形，而且他们之间有遮挡关系呢？这就需要 Z-Buffer 出场了。 Z-BufferZ-Buffer 的算法如下面的伪代码所示。思路是对每个像素所在的所有三角形，取 z 值最小的三角形的颜色作为这个像素的颜色。 foreach (Triangle triangle in triangles) &#123; foreach (Vector3 sample in triangle.GetSamples()) &#123; // z 值越小显示越靠前 if (sample.z &lt; zBuffer[sample.x, sample.y]) &#123; frameBuffer[sample.x, sample.y] = sample.rgb; zBuffer[sample.x, sample.y] = sample.z; &#125; &#125; &#125; 这也有良好的并行性，因为三角形的遍历顺序和最终结果无关，像素的绘制顺序也和最终结果无关。 虎书还提到我们会将 $z$ 值映射到 $[0, B-1]$，用整数存储 $z$ 值，但其实这是现在不再使用的方法，我们现在通常使用 24 位或 32 位的浮点数来存储深度值。（怪不得我查了好久资料都没查到“整数映射”的具体代码，原来早就不用了！！！） 走样现象我们之前说过，简单的采样会出现锯齿，如下图所示。 锯齿、摩尔纹之类的采样图像与原图不符的现象被统称为走样（Aliasing）现象，走样的实质是原图的高频信号被错误采样。为了明确什么是”高频信号”并找到缓解走样现象的方法，我们先看看一些数学知识。 数学知识为了不让文章太长，这里我们省略所有的证明。不过所有的证明都并不困难，有空的话可以自己证一下试试。 卷积我们先来看看三种卷积——离散-离散卷积、连续-连续卷积、离散-连续卷积。下面的 $f_{\\rightarrow t}$ 表示将函数 $f$ 向右平移 $t$ 长度得到的新函数： 离散-离散卷积 \\begin{align*} &(a*b)[i]= \\sum_{j}a[j]b[i-j] \\\\ &(a*b)=\\sum_{j}a[j]b_{\\rightarrow j} \\end{align*}连续-连续卷积 \\begin{align*} &(f*g)(x)=\\int_{-\\infty}^{\\infty} f(t)g(x-t)dt \\\\ &(f*g)=\\int_{-\\infty}^{\\infty} f(t)g_{\\rightarrow t}dt \\end{align*}离散-连续卷积 \\begin{align*} &(a*f)(x)=\\sum_{i}a[i] f(x-i) \\\\ &(a*f)=\\sum_{i}a[i]f_{\\rightarrow i} \\end{align*}我们会注意到，卷积可以表示为函数平移后的加权和。 卷积是过会儿会用到的妙妙小工具。 傅里叶级数和傅里叶变换我们之前提到，走样的实质是原图的高频信号被错误采样。图像作为一个 $R^2\\rightarrow \\text{RGBA}$的函数，怎么会有高频和低频之分呢？uh actually☝️🤓 我们处理的绝大多数函数都有频域，这个频域可以通过傅里叶变换得到。 先回顾一下傅里叶级数。熟知在 $[-\\frac{T}{2},\\frac{T}{2}]$ 内，函数 $f(x)$ 可以表示为 f(x)=\\sum_{n=-\\infty}^{\\infty}c_n e^{inw_0 x}其中 \\begin{align*} &c_n=\\frac{1}{T}\\int_{-\\frac{T}{2}}^{\\frac{T}{2}} f(t)e^{-inw_0t}dt \\\\ &w_0=\\frac{2\\pi}{T} \\end{align*}这本质上是函数在闭区间内的正交基展开，这个展开的周期为 $T$. 当 $T \\rightarrow \\infty$ 时，令 $w_n=nw_0$，$\\Delta w=w_n-w_{n-1}=w_0$ 再结合积分的定义，我们就能（不太严谨地）求出 f(x)=\\frac{1}{2\\pi}\\int_{-\\infty}^{\\infty}\\bigg(\\int_{-\\infty}^{\\infty}f(t)e^{-iwt}dt \\bigg)e^{iwx}dw我们可以令 $u=\\frac{w}{2\\pi}$ 从而去掉积分外面的那个系数 f(x)=\\int_{-\\infty}^{\\infty}\\bigg(\\int_{-\\infty}^{\\infty}f(t)e^{-2\\pi iut}dt \\bigg)e^{2\\pi iux}du而 $e^{2\\pi iux}$ 的系数 \\hat f(u)=\\int_{-\\infty}^{\\infty}f(t)e^{-2\\pi iut}dt就是 $f$ 的傅里叶变换了，它也记作 $\\mathcal{F}(f)$. 把 $\\hat f$ 代入就得到了逆傅里叶变换 f(x)=\\int_{-\\infty}^{\\infty}\\hat f(u)e^{2\\pi iux}du逆傅里叶变换把函数变成了不同频率的三角函数的积分/求和，这就是我们之前所说的“高频信号”和“低频信号”的含义。之后我们会介绍采样导致高频信号丢失的原因，不过在此之前我们先看看傅里叶变换的一些性质。 傅里叶变换的性质我们列举傅里叶变换的几个常用的性质。 如果 $f$ 是实函数，$\\hat f$ 是偶函数。 函数和傅里叶变换的平方积分相等 \\int (f(x))^2dx=\\int (\\hat f(u))^2du 原函数拉长，傅里叶变换收紧 \\mathcal{F}(f(x/b))=b\\hat f(bu) 狄拉克脉冲函数和冲激串狄拉克脉冲函数的定义如下： \\delta(t) = \\begin{cases} \\infty, & t = 0 \\\\ 0, & t \\neq 0 \\end{cases}我们可以把连续信号的均匀间隔采样表示为冲激串 s_T(x) = \\sum_{n=-\\infty}^{\\infty}\\delta(x-nT)与原函数 $f$ 的乘积，这里的 $T$ 表示两个采样点之间的间隔。 $s_T$ 的傅里叶变换为 \\hat s_T(u)=\\frac{1}{T}\\sum_{n=-\\infty}^{\\infty}\\delta(u-\\frac{n}{T})它仍然是一系列狄拉克函数的和。 卷积定理之前说过，将 $s_T$ 和原函数 $f$ 相乘能获得许多重要的采样性质，我们很快就会讨论他们了，在此之前我们还要补充最后一个知识——卷积定理。 \\begin{align*} &\\mathcal{F}(f * g) =\\hat f\\hat g \\\\ &\\mathcal{F}(fg)=\\hat f * \\hat g \\end{align*}这就是说，时域的卷积对应频域的乘积，频域的乘积对应时域的卷积。 走样的原因一开始我们就说过，走样的实质是原图的高频信号被错误采样。现在我们的数学工具已经足以分析究竟为什么发生了错误采样，以及如何缓解他们了。 先来看看为什么我们没有正确采样高频信号。 假设我们希望对这样的函数进行采样，通过傅里叶变换我们可以得到其频域（右一） 我们之前说过，可以把连续函数的均匀间隔采样表示为冲激串 $s_{T}(x)=\\sum_{n=-\\infty}^{\\infty}\\delta(x-nT)$ 和原函数 $f$ 的乘积，而我们也已经知道冲激串的傅里叶变换还是冲激串 \\hat s_T(u)=\\frac{1}{T}\\sum_{n=-\\infty}^{\\infty}\\delta(u-\\frac{n}{T})再结合卷积定理 $\\mathcal{F}(s_Tf)=\\hat s_T * \\hat f$，以及“卷积就是函数平移后的加权和”，我们就能推出，采样结果的傅里叶变换就是原函数的傅里叶变换的无穷个复制各按 $\\frac{n}{T}$ 平移的和。 由于我们的采样间隔 $T$ 不够小，即采样率 $\\frac{1}{T}$ 不够大，所以相邻的两个复制间发生了重叠，导致高频信号和低频信号产生混合，这就引起了走样。而这正是“高频信号被错误采样”的实质。 当我们在光栅化时，我们还把像素填上了颜色，这是在“reconstruction”即重建图像。不过由于在采样时我们已经发生了走样，无论怎么重建都不会有一个非常完美的结果了。 滤波器和走样的缓解方法为了缓解走样，我们自然就要避免发生重叠。避免发生重叠的思路主要有两种： 增加采样率，这样就能让相邻的两个复制距离增大。 用滤波器减弱高频信号的强度。 对图像的光栅化来说，增加分辨率就对应前者；在采样前对原图应用各种滤波器就对应后者。 我们当然会问，增加采样率能缓解走样，那增加到多大合适呢？我们希望相邻的两个复制间的距离足够大以至于不发生重叠，这就需要输入信号的最高频率小于采样频率的一半。采样频率的一半也被称为奈奎斯特频率。理论上说，只要奈奎斯特频率高于被采样信号的最高频率，我们就能完美复原原信号。 接下来我们看看几个常见的滤波器，它们常被用于和别的函数做卷积。由于我们知道卷积可以被理解为一种“加权平均”，所以我们希望滤波器都是归一化的。 名称 公式 Box filter（离散） $a_{\\text{box},r}[i] = \\begin{cases} 1/(2r + 1) & |i| \\le r, \\\\ 0 & \\text{otherwise}. \\end{cases}$ Box filter（连续） $f_{\\text{box},r}(x) = \\begin{cases} 1/(2r) & -r \\le x < r, \\\\ 0 & \\text{otherwise}. \\end{cases}$ Tent filter $f_{\\text{tent}}(x) = \\begin{cases} 1 - |x| & |x| < 1, \\\\ 0 & \\text{otherwise}; \\end{cases}$ Gaussian filter $f_{g, \\sigma}(x) = \\frac{1}{\\sigma\\sqrt{2\\pi}}e^{-x^2/2\\sigma^2}$ 名称 公式 B-Spline Cubic Filter $f_B(x) = \\frac{1}{6} \\begin{cases} -3(1 - |x|)^3 + 3(1 - |x|)^2 + 3(1 - |x|) + 1 & -1 \\le x \\le 1, \\\\ (2 - |x|)^3 & 1 \\le |x| \\le 2, \\\\ 0 & \\text{otherwise}. \\end{cases}$ Catmull-Rom Cubic Filter $f_C(x) = \\frac{1}{2} \\begin{cases} -3(1 - |x|)^3 + 4(1 - |x|)^2 + (1 - |x|) & -1 \\le x \\le 1, \\\\ (2 - |x|)^3 - (2 - |x|)^2 & 1 \\le |x| \\le 2, \\\\ 0 & \\text{otherwise}. \\end{cases}$ Mitchell-Netravali Cubic Filter $f_M(x) = \\frac{1}{3}f_B(x) + \\frac{2}{3}f_C(x) \\\\ = \\frac{1}{18} \\begin{cases} -21(1 - |x|)^3 + 27(1 - |x|)^2 + 9(1 - |x|) + 1 & -1 \\le x \\le 1, \\\\ 7(2 - |x|)^3 - 6(2 - |x|)^2 & 1 \\le |x| \\le 2, \\\\ 0 & \\text{otherwise}. \\end{cases}$ 除了过滤高频信号之外，滤波器还在重建图像时发挥着重要作用。还记得吗，离散-连续卷积能把一系列离散点变成一个连续函数。在根据采样点重建图像时，我们基本就是在做采样点和滤波器的卷积。在光栅化的“把每个像素点的中心采样颜色填到像素点上”这一步中，我们就是在将采样点和 Box filter 做卷积。 总而言之，为了缓解走样，我们可以以图像细节丰富度为代价，先用低通滤波器滤波，再采样+重建。当然，如果我们有更高分辨率的屏幕就更好了~ 其他小知识常见滤波器的傅里叶变换 卷积的单位元任何离散信号和单位脉冲序列做卷积，结果还是原本的离散信号 \\delta[n] = \\begin{cases} 1, & n = 0 \\\\ 0, & n \\neq 0 \\end{cases}任何连续信号和狄拉克函数做卷积，结果还是原本的连续信号 \\delta(t) = \\begin{cases} \\infty, & t = 0 \\\\ 0, & t \\neq 0 \\end{cases}二维卷积和二维滤波器我们这里只给出连续-连续的二维卷积，别的情况都差不多。 \\begin{align*} &(f*g)(x,y)=\\int\\int f(x-x',y-y')g(x',y')dx'dy' \\end{align*}对滤波器 $f(x)$，我们简单地定义 $g(x,y)=f(x)f(y)$ 就得到了这个滤波器对应的二维滤波器。一个比较好的性质是，如果 $f$ 是归一化的，那么 $g$ 也是归一化的。 伽马值显示器的显示亮度关于输入信号不是线性关系。假设输入信号为 $a\\in[0,1]$，则有 \\text{Displayed intensity}=(\\text{Maximum intensity})a^\\gamma这里的 $\\gamma$ 一般在 $2.2$ 左右。虽然在最开始这是 CRT 显示器的物理特性所致，但有趣的是，人眼也恰好对暗部变化比亮部变化更敏感，所以它现在作为一个刻意的设计保留了下来。 伽马矫正在影像系统中也有极大作用。假设我们在拍摄一个苹果的照片，苹果的物理亮度是 $0.5$，相机忠实地把它记录了下来。而当显示器显示时，就显示出了 $0.5^{2.2}\\approx 0.22$ 的物理亮度，这显然不是我们想要的。因此在我们拍摄照片之后，相机的图像处理器就会自动对照片进行伽马矫正。 图像锐化Unsharp Mask 是一个经典的图像锐化算法。令高斯模糊核为 $G$，冲激函数为 $\\delta$，它先提取原始图像的高频信号 I_{detail} = I_{orig} - I_{orig} * G再把这些高频信号加入回原图中 I_{sharp} = I_{orig} + \\alpha I_{detail}综合起来就是 I_{sharp} =I_{orig}*((1+\\alpha)\\delta-G)图像缩放直接对一个像素化的图像采样虽然效率很高，但效果不佳。先用连续的滤波器重建信号，再用低通滤波器过滤高频信号，再采样会得到更好的结果，这被称为 resampling，重采样。","categories":[{"name":"公开课","slug":"公开课","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"GAMES101","slug":"公开课/GAMES101","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/"},{"name":"Notes","slug":"公开课/GAMES101/Notes","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/Notes/"}],"tags":[]},{"title":"Assignment 1 Transformation","slug":"learning/open-course/GAMES101/Hw/Hw1-transformation","date":"2025-08-22T03:00:58.000Z","updated":"2025-08-22T03:14:43.978Z","comments":true,"path":"wiki/learning/open-course/GAMES101/Hw/Hw1-transformation/","permalink":"http://rinevard.github.io/wiki/learning/open-course/GAMES101/Hw/Hw1-transformation/","excerpt":"","text":"本次作业要求我们实现旋转矩阵、投影矩阵。我们先简单看下作业是怎么做的，再看看代码框架里的几个有趣的地方。 作业实现两个旋转矩阵绕 $z$ 轴的旋转矩阵实现起来很简单，把课上的内容翻译成代码就好。在使用 std 的 sin 和 cos 时要注意把角度转换成弧度。 Eigen::Matrix4f get_model_matrix(float rotation_angle) &#123; Eigen::Matrix4f model = Eigen::Matrix4f::Identity(); float angle_rad = rotation_angle * MY_PI / 180.0; Eigen::Matrix4f rotate; float sine = std::sin(angle_rad); float cosine = std::cos(angle_rad); rotate &lt;&lt; cosine, -sine, 0, 0, sine, cosine, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1; model = rotate * model; return model; &#125; 提高项里的旋转矩阵用课上讲的 Rodrigues’ rotation formula 就行： /* Computes the 4x4 rotation matrix representing a rotation of rotation_angle (in degree) around a given normalized axis vector that passes through the origin, using Rodrigues' rotation formula. */ Eigen::Matrix4f get_rotation(Vector3f axis, float rotation_angle) &#123; float angle_rad = rotation_angle * MY_PI / 180.0; Eigen::Matrix3f rot_mat = std::cos(angle_rad) * Eigen::Matrix3f::Identity(); rot_mat += (1 - std::cos(angle_rad)) * axis * axis.transpose(); Eigen::Matrix3f cross_product_mat; cross_product_mat &lt;&lt; 0, -axis.z(), axis.y(), axis.z(), 0, -axis.x(), -axis.y(), axis.x(), 0; rot_mat += std::sin(angle_rad) * cross_product_mat; Eigen::Matrix4f trans_mat = Eigen::Matrix4f::Identity(); trans_mat.topLeftCorner&lt;3, 3>() = rot_mat; return trans_mat; &#125; 投影矩阵投影矩阵就相对复杂一些了，先上代码 Eigen::Matrix4f get_projection_matrix(float eye_fov, float aspect_ratio, float zNear, float zFar) &#123; // Students will implement this function Eigen::Matrix4f projection = Eigen::Matrix4f::Identity(); Eigen::Matrix4f perspective; float cotangent = 1.0 / std::tan(eye_fov / 2.0); float z_delta = zFar - zNear; perspective &lt;&lt; cotangent / aspect_ratio, 0, 0, 0, 0, cotangent, 0, 0, 0, 0, -(zFar + zNear) / z_delta, -2 * zFar * zNear / z_delta, 0, 0, -1, 0; projection = perspective * projection; return projection; &#125; 首先我们会发现输入的 zNear 和 zFar 都是正数，他们表示近平面和远平面到原点的距离，这与课上讲的不同。课上讲的 $n$ 和 $f$ 表示近平面和远平面在 $z$ 轴的坐标，他们是负数。 然后我们分析 rasterizer.cpp 里的 draw 函数，下面这段代码里，v 是三角形的三个顶点构成的数组，三个顶点都已经被变换到了 $[-1,1]^3$ 的正方体中。 注意 vert.z() = vert.z() * f1 + f2 这行代码，把 $-1$ 代入右边得到 $-n$，$1$ 代入右边得到 $-f$，因此我们有理由猜测 $[-n,-f]$ 被映射到了 $[-1,1]$. float f1 = (100 - 0.1) / 2.0; float f2 = (100 + 0.1) / 2.0; // ... for (auto &amp; vert : v) &#123; vert.x() = 0.5*width*(vert.x()+1.0); vert.y() = 0.5*height*(vert.y()+1.0); vert.z() = vert.z() * f1 + f2; &#125; 总结一下我们的发现： 输入的 zNear 和 zFar 都是正数，表示近平面和远平面到原点的距离 $[-n,-f]$ 被映射到了 $[-1,1]$ 最终我们能写出这样的投影矩阵： \\large \\text{M}_\\text{per} = \\begin{bmatrix} \\frac{1}{\\text{aspect} \\times \\tan(\\frac{\\text{fov}}{2})} & 0 & 0 & 0 \\\\ 0 & \\frac{1}{\\tan(\\frac{\\text{fov}}{2})} & 0 & 0 \\\\ 0 & 0 & -\\frac{f+n}{f-n} & -\\frac{2fn}{f-n} \\\\ 0 & 0 & -1 & 0 \\end{bmatrix}翻译成代码就好。 代码框架里有趣的地方ind 的作用首先我们看向 main.cpp 的 main 函数里的这段代码 std::vector&lt;Eigen::Vector3f> pos&#123;&#123;2, 0, -2&#125;, &#123;0, 2, -2&#125;, &#123;-2, 0, -2&#125;&#125;; std::vector&lt;Eigen::Vector3i> ind&#123;&#123;0, 1, 2&#125;&#125;; pos 显然是三角形的三个顶点，但 ind 是做什么的？uh actually🤓☝️它定义了如何将顶点连接起来。对三角形来说它当然没什么用，但对多边形来说，它就很有用了。 比如说，想象一下我们在画一个六边形，我们需要六个顶点。但由于在渲染时我们主要绘制三角形，所以我们要把六边形拆分成多个三角形，而拆分出的每个三角形就对应着 ind 里的一个元素了。 对六边形来说，我们可能会定义下面这样的 pos 和 ind std::vector&lt;Eigen::Vector3f> pos &#123; &#123;2, 0, -2&#125;, // 0: 右 &#123;1, 1.732, -2&#125;, // 1: 右上 &#123;-1, 1.732, -2&#125;, // 2: 左上 &#123;-2, 0, -2&#125;, // 3: 左 &#123;-1, -1.732, -2&#125;,// 4: 左下 &#123;1, -1.732, -2&#125; // 5: 右下 &#125;; std::vector&lt;Eigen::Vector3i> ind &#123; &#123;0, 1, 2&#125;, &#123;0, 2, 3&#125;, &#123;0, 3, 4&#125;, &#123;0, 4, 5&#125; &#125;; id 的作用继续看向 main.cpp 的 main 函数，把目光投向这段代码 auto pos_id = r.load_positions(pos); auto ind_id = r.load_indices(ind); // ... r.draw(pos_id, ind_id, rst::Primitive::Triangle); 在这里，我们把 id 传入了 draw 函数来画图。但为什么要用 id 呢？直接 &amp; 传参不行吗？ 【TODO：我不知道。AI说在正式的渲染代码里，我们会在load时做一些操作诸如把数据上传到显存，或者重新组织上传的各个数据来提高效率，但咱也不知道是不是真的。】","categories":[{"name":"公开课","slug":"公开课","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"GAMES101","slug":"公开课/GAMES101","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/"},{"name":"Assignments","slug":"公开课/GAMES101/Assignments","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/Assignments/"}],"tags":[]},{"title":"Note 1 Transformation","slug":"learning/open-course/GAMES101/Notes/Note1-transformation","date":"2025-08-19T07:10:28.000Z","updated":"2025-08-22T03:14:43.967Z","comments":true,"path":"wiki/learning/open-course/GAMES101/Notes/Note1-transformation/","permalink":"http://rinevard.github.io/wiki/learning/open-course/GAMES101/Notes/Note1-transformation/","excerpt":"","text":"2D Transformation在二维空间中，我们能用二维矩阵表示所有的线性变换。但二维空间中的平移在二维空间中不是线性变换，因此我们希望找到另一个空间，并将二维空间嵌入，让二维平移在这个空间中变为线性变换。把笛卡尔坐标扩展为齐次坐标，就得到了这样的空间。 对二维空间的一点 $(x,y)$，三元组 $(xZ,yZ,Z)$ 即为该点的齐次坐标。如 $(1,2)$ 可表示为 $(1,2,1)$ 或 $(100,200,100)$. 换句话说，二维空间的任何点都能表示为齐次坐标 $(X,Y,Z)$，其中 $Z\\neq 0$. 另外，如果我们把无穷远点也考虑进来，我们就可以用 $(x,y,0)$ 表示无穷远点。 叽里咕噜说什么呢，快告诉我怎么用线性变换表示平移！ 对二维空间的一点 $(x,y)$，首先将它转化为齐次坐标得到 $(x,y,1)$，然后与下面的矩阵相乘 M = \\begin{bmatrix} 1 & 0 & t_x \\\\ 0 & 1 & t_y \\\\ 0 & 0 & 1 \\end{bmatrix}就得到了 $(x+t_x,y+t_y,1)$. 然后再转换回笛卡尔坐标，就得到了 $(x+t_x,y+t_y)$. 这样一来，旋转、平移就能统一成下面的形式： M = \\begin{bmatrix} \\cos \\theta & -\\sin \\theta & t_x \\\\ \\sin \\theta & \\cos \\theta & t_y \\\\ 0 & 0 & 1 \\end{bmatrix}3D Transformation与二维的情况类似，我们也把三维空间嵌入一个新空间。 对三维空间的一点 $(x,y,z)$，三元组 $(xS,yS,zS,S)$ 即为该点的齐次坐标。如 $(1,2,3)$ 可表示为 $(1,2,3,1)$ 或 $(100,200,300,100)$. 换句话说，三维空间的任何点都能表示为齐次坐标 $(X,Y,Z,S)$，其中 $S\\neq 0$. 我们这里讨论右手坐标系，下面给出按右手定则旋转 $\\theta$ 角度的矩阵： R_x(\\theta) = \\begin{bmatrix} 1 & 0 & 0 & 0 \\\\ 0 & \\cos \\theta & -\\sin \\theta & 0 \\\\ 0 & \\sin \\theta & \\cos \\theta & 0 \\\\ 0 & 0 & 0 & 1 \\end{bmatrix} R_y(\\theta) = \\begin{bmatrix} \\cos \\theta & 0 & \\sin \\theta & 0 \\\\ 0 & 1 & 0 & 0 \\\\ -\\sin \\theta & 0 & \\cos \\theta & 0 \\\\ 0 & 0 & 0 & 1 \\end{bmatrix} R_z(\\theta) = \\begin{bmatrix} \\cos \\theta & -\\sin \\theta & 0 & 0 \\\\ \\sin \\theta & \\cos \\theta & 0 & 0 \\\\ 0 & 0 & 1 & 0 \\\\ 0 & 0 & 0 & 1 \\end{bmatrix}你会注意到沿 $y$ 轴旋转的矩阵和别的不一样，但这是完全正确的，认真算一算就好了。 （我没感觉这里有什么“深刻含义”，但感觉即使有也应该不会很有用……） （不过不知道如果推广到 $n$ 维旋转会不会有用） （可我们生活在三次元！） 值得注意的是，旋转矩阵都是正交矩阵，所以它的转置就是它的逆。 世界上还存在一个叫做 Rodrigues 旋转公式的东西，它给出了向量 $v$ 绕单位向量 $k$ 旋转 $\\theta$ 角度得到的结果。（按右手定则旋转） \\mathbf{v}_{\\text{rot}} = \\mathbf{v} \\cos\\theta + (\\mathbf{k} \\times \\mathbf{v}) \\sin\\theta + \\\\ \\mathbf{k}(\\mathbf{k} \\cdot \\mathbf{v})(1 - \\cos\\theta) 当然也可以把这个旋转矩阵写出来： \\mathbf{R}(\\mathbf{k}, \\theta) = \\cos(\\theta)\\mathbf{I} + (1 - \\cos(\\theta))\\mathbf{k}\\mathbf{k}^T + \\sin(\\theta)\\begin{bmatrix} 0 & -k_z & k_y \\\\ k_z & 0 & -k_x \\\\ -k_y & k_x & 0 \\end{bmatrix}最右边那个矩阵是 $k$ 的叉乘矩阵啦~ Viewing transformation2D 和 3D transformation 都是基础变换，接下来我们研究游戏里的画面是如何渲染到屏幕上的。 如下图所示，我们有一个摄像机、两个方块，那么我们是怎么计算出摄像机拍摄的画面的呢（参考右下角）？ 我们按照下面的流程进行操作： Camera transformation首先，我们变换空间让摄像机位于坐标原点，且面向 $z$ 轴负方向，头顶朝 $y$ 轴正方向。对上图来说，就是把 $w$ 变换为 $z$ 轴，把 $v$ 变换为 $y$ 轴。 对应的矩阵是 \\text{M}_{\\text{cam}} = \\begin{bmatrix} u_x & u_y & u_z & 0 \\\\ v_x & v_y & v_z & 0 \\\\ w_x & w_y & w_z & 0 \\\\ 0 & 0 & 0 & 1 \\end{bmatrix} \\times \\begin{bmatrix} 1 & 0 & 0 & -\\text{cam}_x \\\\ 0 & 1 & 0 & -\\text{cam}_y \\\\ 0 & 0 & 1 & -\\text{cam}_z \\\\ 0 & 0 & 0 & 1 \\end{bmatrix}这里的小技巧是，旋转矩阵的逆是其转置，所以我们先算出 $xyz$ 轴变换到 $uvw$ 轴的旋转矩阵，再对其转置，就得到了把 $uvw$ 变换到 $xyz$ 的矩阵。 Projection transformation然后，我们把相机拍摄的区域变换到 $[-1,1]^3$ 中，这是一个规范化，为未来把区域放到屏幕上做准备。在此之前，我们要先确定相机能够拍摄的区域的范围。这里涉及到的变量主要有 fov、aspect ratio、near、far. 下图能清晰地解释 fov 和 aspect ratio。fov 即 field of view，表示用角度衡量的可见范围；aspect ratio 则是显示区域的宽高比。 near 和 far 则定义了剔除边界，我们只渲染满足 $z \\in [\\text{near}, \\text{far}]$ 的东西。原点、近平面和原平面共同划分出了一块有限的空间，这就是摄像机拍摄的区域（视锥），我们会把他变换到 $[-1,1]^3$ 中。 变换分为两步，第一步是把视锥变换为长方体，第二步把长方体变换为 $[-1,1]^3$ 的正方体。 在第一步变换时，我们希望满足以下两点： near 和 far 平面上的点的 $z$ 值不变 近大远小，且缩放比例符合相似三角形的规律 结合齐次坐标，我们就能得到以下矩阵： \\begin{align*} \\text{M}_\\text{per} &= \\begin{bmatrix} \\frac{2}{r-l} & 0 & 0 & -\\frac{r+l}{r-l} \\\\ 0 & \\frac{2}{t-b} & 0 & -\\frac{t+b}{t-b} \\\\ 0 & 0 & \\frac{2}{n-f} & -\\frac{n+f}{n-f} \\\\ 0 & 0 & 0 & 1 \\end{bmatrix} \\times \\begin{bmatrix} n & 0 & 0 & 0 \\\\ 0 & n & 0 & 0 \\\\ 0 & 0 & n+f & -nf \\\\ 0 & 0 & 1 & 0 \\end{bmatrix} \\\\ &= \\begin{bmatrix} \\frac{2n}{r-l} & 0 & -\\frac{r+l}{r-l} & 0 \\\\ 0 & \\frac{2n}{t-b} & -\\frac{t+b}{t-b} & 0 \\\\ 0 & 0 & \\frac{n+f}{n-f} & -\\frac{2nf}{n-f} \\\\ 0 & 0 & 1 & 0 \\end{bmatrix} \\end{align*}第一个等号右边的式子中，右边的矩阵把视锥压缩为一个长方体，左边的矩阵把这个长方体变换到 $[-1,1]^3$. 我们可以根据 $\\text{near},\\text{fov},\\text{aspectRatio}$ 求出 $l,t,r,b$. \\begin{align*} &\\text{t} = -n \\times \\tan\\left(\\frac{\\text{fov}}{2}\\right) \\\\ &\\text{b} = -\\text{t} \\\\ &\\text{r} = \\text{t} \\times \\text{aspectRatio} \\\\ &\\text{l} = -\\text{r} \\end{align*} 也就是说，我们可以把投影矩阵写为： \\large \\text{M}_\\text{per} = \\begin{bmatrix} -\\frac{1}{\\text{aspect} \\times \\tan(\\frac{\\text{fov}}{2})} & 0 & 0 & 0 \\\\ 0 & -\\frac{1}{\\tan(\\frac{\\text{fov}}{2})} & 0 & 0 \\\\ 0 & 0 & \\frac{n+f}{n-f} & -\\frac{2nf}{n-f} \\\\ 0 & 0 & 1 & 0 \\end{bmatrix}Viewport transformation最后，我们会把 $[-1,1]^3$ 的内容的宽高映射为屏幕大小。在这个变换中 $z$ 坐标不变，因此变换矩阵为： \\large \\text{M}_\\text{viewport}= \\begin{bmatrix} \\frac{width}{2} & 0 & 0 & \\frac{width}{2} \\\\ 0 & \\frac{height}{2} & 0 & \\frac{height}{2} \\\\ 0 & 0 & 1 & 0 \\\\ 0 & 0 & 0 & 1 \\end{bmatrix}总结总而言之，我们的变换矩阵为 \\begin{align*} &\\text{M}=\\text{M}_\\text{viewport}\\text{M}_\\text{per}\\text{M}_\\text{cam} \\end{align*}其中 \\begin{align*} &\\text{M}_{\\text{cam}} = \\begin{bmatrix} u_x & u_y & u_z & 0 \\\\ v_x & v_y & v_z & 0 \\\\ w_x & w_y & w_z & 0 \\\\ 0 & 0 & 0 & 1 \\end{bmatrix} \\times \\begin{bmatrix} 1 & 0 & 0 & -\\text{cam}_x \\\\ 0 & 1 & 0 & -\\text{cam}_y \\\\ 0 & 0 & 1 & -\\text{cam}_z \\\\ 0 & 0 & 0 & 1 \\end{bmatrix} \\\\ \\large &\\text{M}_\\text{per} = \\begin{bmatrix} -\\frac{1}{\\text{aspect} \\times \\tan(\\frac{\\text{fov}}{2})} & 0 & 0 & 0 \\\\ 0 & -\\frac{1}{\\tan(\\frac{\\text{fov}}{2})} & 0 & 0 \\\\ 0 & 0 & \\frac{n+f}{n-f} & -\\frac{2nf}{n-f} \\\\ 0 & 0 & 1 & 0 \\end{bmatrix} \\\\ &\\large \\text{M}_\\text{viewport}= \\begin{bmatrix} \\frac{width}{2} & 0 & 0 & \\frac{width}{2} \\\\ 0 & \\frac{height}{2} & 0 & \\frac{height}{2} \\\\ 0 & 0 & 1 & 0 \\\\ 0 & 0 & 0 & 1 \\end{bmatrix} \\end{align*}要注意的是，我们讨论的 $n$ 和 $f$ 被定义为坐标值，它们是小于 0 的。一些地方把 $n$ 和 $f$ 定义为到近/远平面的距离，这是大于 0 的，这会引起投影矩阵的变化。另外，不同的坐标系约定也会引起矩阵的变化。 比如在OpenGL中， $n$ 和 $f$ 被定义为到近/远平面的距离，这是大于 0 的，而且他们的 projection transformation 把拍摄内容从右手坐标系的视图空间映射到左手坐标系的标准设备坐标（NDC）空间。特别地，$z$ 轴的 $[ -n,-f]$ 被映射到 $[-1,1]$ （这似乎说明在 NDC 空间中，$z$ 值较小的内容渲染更靠前？） 他们的 $\\text{M}_\\text{their-per}$ 为： \\large \\text{M}_\\text{their-per} = \\begin{bmatrix} \\frac{1}{\\text{aspect} \\times \\tan(\\frac{\\text{fov}}{2})} & 0 & 0 & 0 \\\\ 0 & \\frac{1}{\\tan(\\frac{\\text{fov}}{2})} & 0 & 0 \\\\ 0 & 0 & -\\frac{f+n}{f-n} & -\\frac{2fn}{f-n} \\\\ 0 & 0 & -1 & 0 \\end{bmatrix}Godot 使用和 OpenGL 一样的矩阵，下面是他们设置 $\\text{M}_\\text{per}$ 的代码。还要注意的是，他们使用 column-major 的方法存储数据，即 M = \\begin{pmatrix} \\text{columns}[0][0] & \\text{columns}[1][0] \\\\ \\text{columns}[0][1] & \\text{columns}[1][1] \\end{pmatrix}void Projection::set_perspective(real_t p_fovy_degrees, real_t p_aspect, real_t p_z_near, real_t p_z_far, bool p_flip_fov) &#123; if (p_flip_fov) &#123; p_fovy_degrees = get_fovy(p_fovy_degrees, 1.0 / p_aspect); &#125; real_t sine, cotangent, deltaZ; real_t radians = Math::deg_to_rad(p_fovy_degrees / 2.0); deltaZ = p_z_far - p_z_near; sine = Math::sin(radians); if ((deltaZ == 0) || (sine == 0) || (p_aspect == 0)) &#123; return; &#125; cotangent = Math::cos(radians) / sine; set_identity(); columns[0][0] = cotangent / p_aspect; columns[1][1] = cotangent; columns[2][2] = -(p_z_far + p_z_near) / deltaZ; columns[2][3] = -1; columns[3][2] = -2 * p_z_near * p_z_far / deltaZ; columns[3][3] = 0; &#125;","categories":[{"name":"公开课","slug":"公开课","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"GAMES101","slug":"公开课/GAMES101","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/"},{"name":"Notes","slug":"公开课/GAMES101/Notes","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/Notes/"}],"tags":[]},{"title":"杀戮尖塔的框架如此自洽，我们能离开它吗？","slug":"game-design/杀戮尖塔框架","date":"2025-07-10T12:22:38.000Z","updated":"2025-08-20T11:13:48.877Z","comments":true,"path":"wiki/game-design/杀戮尖塔框架/","permalink":"http://rinevard.github.io/wiki/game-design/%E6%9D%80%E6%88%AE%E5%B0%96%E5%A1%94%E6%A1%86%E6%9E%B6/","excerpt":"","text":"img{ width: 70%; } 最近在设计卡牌游戏（你知道的，我一直是牌佬），发现以前做的翻牌游戏原型的翻牌玩法本身随机性过强，从而拓展空间过小，但“棋盘上的随从交互”非常有趣，于是就打算从它出发开始进一步设计。初步的想法是做卡牌肉鸽。（哇，又一个卡牌肉鸽） 我对肉鸽并没有特别的喜爱，因为我一直想着，如果我们拿走了玩家的时间，起码要补偿一些什么，而肉鸽似乎并没有补偿一些我很喜欢的东西。不过无论如何，我还是挺喜欢打牌的，杀戮尖塔、炉石狗头人冒险、邪恶冥刻都是我很喜欢的游戏，所以做个卡牌肉鸽也还挺不错。按我的理解，肉鸽最重要的是每个小关卡的体验，因此我就着手开始做每局牌局的原型了。 然后让我们开始最有趣的设计环节！ 现在我们面前有一个3x5的牌桌，那么接下来该做什么？我们先随便拿点手牌吧，可以把手牌放到牌桌上来召唤随从，然后和敌方随从打架。但手牌从哪里来，费用机制又怎么做呢？这就引出了本文的核心内容——杀戮尖塔的框架如此自洽，我们能离开它吗？ 杀戮尖塔杀戮尖塔为什么是神？在谈论这个问题之前，我想先说说其他卡牌游戏相较于爬塔究竟差在了哪里（误 总之，让我们来看看杀戮尖塔自洽的设计吧。 单局牌局的自洽杀戮尖塔的手牌从哪里来，费用机制又是怎样的？在杀戮尖塔中，如果不考虑特殊效果，我们在回合开始时会丢弃所有手牌并抽五张牌，并且费用重置为三费。 我们先来聊聊前者。前者在玩起来时感觉十分自然，但从设计的角度，其实是一个并不显然的设计。我简单调研了一下，发现回合开始时刷新手牌似乎是DBG游戏的标配，其开山鼻祖是《皇舆争霸》（Dominion），接下来我们来看看它有怎样的效果。 我认为最关键的两点是，减少了卡手的可能性、降低了策略性。刷新手牌显然能减少卡手，但为什么降低了策略性呢，以及这是好事吗？ 为什么它降低了策略性？因为手牌的刷新就意味着玩家减少了对下一回合的预期。回合制游戏的很大一部分策略性是由对下一回合的预期引起的。对炉石（以及很多CCG）来说，我会根据场面考虑每张牌什么时候打出有最大收益，甚至猜测对手接下来的行动并预留一些卡牌。而杀戮尖塔则杜绝了这种预期，让玩家根据敌人当前回合的意图，结合每回合发的牌打最优解。 是的，最优解。对很多卡牌游戏来说，最优解的计算量是极大的，而杀戮尖塔极大地简化了这个计算量，让每回合最优解的计算都并不困难，从而降低了思维量。这当然不是坏事，我认为这是相当优秀的设计。游戏并不是为了难倒玩家而存在的，比起难倒玩家，让玩家通过自己的努力克服难关更重要。 如果手牌刷新，那费用自然也要刷新，这便是手牌和费用的自洽了。而由此也能推出杀戮尖塔不做随从的理由了。随从是持续性的，而法术是一次性的。如果手牌在刷新，那怎么和随从打combo呢？ 所以我认为怪物火车并不如杀戮尖塔自洽。我这回合费用不足以打出所有的治疗牌，然后回合结束治疗牌就全被扔到弃牌堆里了，那我缺的combo谁给我补啊😭 如果总结一下，我会说杀戮尖塔的每一局都给我带来了炉石里奥秘法般的体验，依靠法术轰炸创死对面，但没有很多的同时依靠多张卡牌的combo，单局牌局运营不多。 每局游戏的自洽每局游戏的自洽又可以分为思维量要求的张弛有度，以及游戏机制本身的自洽。 先说前者。单局牌局策略性较低，但一整局游戏中运营是一个策略性很高的操作，也因此既不会玩得太累，也不会太简单。 再说后者。主要要说的是“血量保持”的机制。如果单局牌局的双方始终强度接近（比如对称式卡牌游戏），那血量显然也是需要在每局刷新的。不过对非对称游戏来说，控制强度接近实在有点困难，血量保持和每一大层的血量回复是一个简单的平衡手段。 原本还想说说易进难出的卡组，但实在没感觉它和别的东西很“自洽”。我对机制“自洽”的理解是把这个机制换成别的，游戏就很难工作了。比如把抽卡换成每回合抽一张，那费用重置就会导致一下就把牌打完；把血量换成每局重置，那游戏就简单一大截了。 而卡组的易进难出看起来是一个控制强度的自然手段，简单地把它改为限制卡组最少十五张，允许自由增删，似乎也不会破坏整个游戏。虽然没有原来好，但至少不是毁灭性的。 有趣的是，杀戮尖塔似乎并没有很多提高单卡强度的手段，而许多类似的卡牌肉鸽会做大量的单卡强度的提高。比如——邪恶冥刻。 邪恶冥刻我们聊聊莱西模组，这最接近卡牌肉鸽。 单局牌局的自洽邪恶冥刻每回合抽一张牌（可选抽牌组的牌或者松鼠牌），费用不自然回复，而是依靠献祭随从获得。它的原型来自ludum dare 43这场gamejam，献祭机制在那里就被定下来了。献祭机制确实非常好玩，所以整个游戏都是以它为核心发展出去的。 献祭是费用机制，那抽牌机制是怎么根据献祭被确定的呢？抽牌无非两种，一种是刷新，一种是保留手牌每回合抽卡。献祭机制导致高费牌难以立即打出，毕竟如果把高费牌刷掉，下次抽到就不知道是什么时候了。所以显然保留手牌更合适。 比起杀戮尖塔，邪恶冥刻的单局牌局更具”持续性“，我们不仅能考虑到下一回合，还能考虑到下下回合。随从站场、手牌不刷新、献祭机制都是持续性的体现。 但运气成分实在是太高了！过牌的缺乏导致我们极度依赖于起手，费用不自然回复和五点伤害差就输又强化了这一点。 不过说到底，这些问题都是因为每回合只抽一张牌对卡组构筑提出了极高的要求。好牌可能沉底，新牌也可能沉底，一沉底这局就没法玩了。 作者Daniel用奇妙的方式解决了问题——在地图上提供大量的牌组改造节点，并鼓励超模单卡。我们会在下一节讨论这一点。 在此之前，我们来看看邪恶冥刻的原型吧：https://dmullinsgames.itch.io/sacrifices-must-be-made 每局游戏的自洽 如我们之前所言，每回合只抽一张牌对卡组构筑提出了极高的要求。一个自然的思路是允许玩家自由调整卡组，只是设置些许限制，比如每张牌最多带两张、至少二十张牌什么的。但邪恶冥刻并不是这么做的。 在邪恶冥刻中，删卡并不是很困难的事，造超模单卡也非常简单。祭坛、真菌学家节点可以同时实现这两点，骨王可以删卡，画家可以复制超模单卡，每层可以拿两三张稀有卡。这就让玩家能够迅速提升单卡质量，靠超模单卡和对面打架。 也因此在邪恶冥刻中经常会出现一回合秒对面的局，说实话我觉得这并不是太好的设计，不过确实挺自洽的。 我的游戏（哇，你的游戏和杀戮尖塔、邪恶冥刻都是一级标题，那一定和他们一样厉害吧 现在我们面前有一个3x5的牌桌，那么接下来该做什么？我们先随便拿点手牌吧，可以把手牌放到牌桌上来召唤随从，然后和敌方随从打架。但手牌从哪里来，费用机制又怎么做呢？ 随从是站场的持续性的东西，所以我们就不刷新手牌了，而是每回合抽一张牌。费用刷新也未尝不可，不过我挺喜欢邪恶冥刻的献祭机制的，所以就直接搬过来用了。邪恶冥刻太卡手了，所以我们每回合再给玩家塞一张松鼠牌。 不过要说明的是，这些只是理论推导。在实际做原型的时候我也测试了刷新手牌、刷新费用，发现确实还是每回合抽一张牌+献祭机制和这个随从交互机制的契合度最高。理论和实际相符说明理论有一定指导意义，以后可以接着用，理论与实际不符说明理论在胡扯，就要调整了。 至此，我们完成了单局牌局的设计。之后我把牌桌改成了4x5，发现更有策略也更好玩了，找人试玩了一下之后激进地改成了5x7，居然又更有策略更好玩了，那暂时就这样吧。 这里是试玩链接： 开始游戏（将在新标签页打开） 喜欢的话可以填个问卷，谢谢喵！ 问卷（将在新标签页打开） 那么每局游戏该怎么做呢？由于我们的机制和邪恶冥刻相似，所以它会遇到的问题我们也都会遇到。最关键的两点就是牌越多越菜和关键牌沉底。 一开始我尝试解决前者，然后偶然间得到了一个我觉得还不错的，能同时解决这两个问题的方案。 解决问题无非从单局牌局和整局游戏考虑，我想了半天没想到怎么用在单局内解决问题，于是就想研究下通过调整整局游戏的运营来解决问题。 在玩卡牌肉鸽的时候，我们经常遇到选牌加入牌组不如跳过的情况，这就是典型的“牌越多越菜”。那怎么保证每次选牌都有补强呢？考虑到我们的献祭机制，我就想到把可选牌献祭成随时可以使用的一次性道具，这样每次选牌都至少能让玩家变强一点。 道具怎么做呢？初步想法是把牌的费用减半，法术牌不变，随从牌在下个回合开始时自动被献祭。 有趣的是，它也缓解了关键牌沉底的问题，毕竟一方面道具能帮助我们过渡，另一方面我们也能直接把关键牌献祭成道具，然后就不用担心沉底了。","categories":[{"name":"游戏设计","slug":"游戏设计","permalink":"http://rinevard.github.io/categories/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[]},{"title":"_我也想做出优秀的作品","slug":"others/thoughts/我也想做出优秀的作品","date":"2025-06-16T14:03:30.000Z","updated":"2025-07-18T15:06:40.639Z","comments":true,"path":"wiki/others/thoughts/我也想做出优秀的作品/","permalink":"http://rinevard.github.io/wiki/others/thoughts/%E6%88%91%E4%B9%9F%E6%83%B3%E5%81%9A%E5%87%BA%E4%BC%98%E7%A7%80%E7%9A%84%E4%BD%9C%E5%93%81/","excerpt":"","text":"最近做了牌生万物，感觉挺难受的。一直以来我都希望每一部作品都做得比上一部更好，这一部看起来比undertetris好一点吗？或许吧，但我就是感觉不开心。 想来可能是因为这不是我喜欢的体验吧。我想做出能打动玩家的作品，能让玩家记住一辈子，至少是一年的作品，而不是这样的莫名其妙的“融合卡牌”。玩着这个游戏时，比起对作品的满意，更多的是烦躁。也可能是因为现在是考试周压力大吧，我也不清楚。 我想和LLM一起创造一个世界啊，一个栩栩如生的世界。每个事件都让人思考，每个角色都给人深刻印象，而不是现在的名词堆砌、数值膨胀。LLM不会写故事从来都不是借口，我们是不是本可以做得更好？ 我该怎么做才好？我该前往何方？ 我知道，让LLM生成的世界像《苏丹的游戏》一样本身就是一件不现实的事情。但起码它要像是一个世界吧，整个冒险是有故事性的吧，现在是个什么玩意？？？更可气的是这玩意还真有可玩性，做了一个靠强化程序和数值膨胀堆砌起来的东西真像是对自己的侮辱！ 至少，它的体验不该是数值膨胀。至少，让玩家玩下去的动力不该是强化程序。如果我们拿走了玩家的时间，我们起码应当补偿一些什么才对，而不该徒留悔恨感。 可能也有点偏激了，可能只是我自己不喜欢这种类型而已……甚至我自己也觉得还算可以，至少确实有让我印象深刻的时刻。但我还是感觉不开心，毕竟，“我们是不是本可以做得更好？”","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/"},{"name":"碎碎念","slug":"杂谈/碎碎念","permalink":"http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}],"tags":[]},{"title":"Lab2 System calls","slug":"learning/open-course/MIT-6.S081/Labs/lab2-syscall","date":"2025-06-04T07:10:38.000Z","updated":"2025-08-22T03:14:43.982Z","comments":true,"path":"wiki/learning/open-course/MIT-6.S081/Labs/lab2-syscall/","permalink":"http://rinevard.github.io/wiki/learning/open-course/MIT-6.S081/Labs/lab2-syscall/","excerpt":"","text":"","categories":[{"name":"公开课","slug":"公开课","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"MIT-6.S081","slug":"公开课/MIT-6-S081","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/MIT-6-S081/"},{"name":"Labs","slug":"公开课/MIT-6-S081/Labs","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/MIT-6-S081/Labs/"}],"tags":[]},{"title":"第二章——操作系统概述","slug":"learning/open-course/MIT-6.S081/Notes/note2-organization-overview","date":"2025-06-04T06:26:38.000Z","updated":"2025-08-22T03:14:43.982Z","comments":true,"path":"wiki/learning/open-course/MIT-6.S081/Notes/note2-organization-overview/","permalink":"http://rinevard.github.io/wiki/learning/open-course/MIT-6.S081/Notes/note2-organization-overview/","excerpt":"","text":"","categories":[{"name":"公开课","slug":"公开课","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"MIT-6.S081","slug":"公开课/MIT-6-S081","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/MIT-6-S081/"},{"name":"Notes","slug":"公开课/MIT-6-S081/Notes","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/MIT-6-S081/Notes/"}],"tags":[]},{"title":"看我看我","slug":"learning/open-course/MIT-6.S081/Notes/little-fish","date":"2025-06-01T06:32:38.000Z","updated":"2025-08-22T03:20:40.807Z","comments":true,"path":"wiki/learning/open-course/MIT-6.S081/Notes/little-fish/","permalink":"http://rinevard.github.io/wiki/learning/open-course/MIT-6.S081/Notes/little-fish/","excerpt":"","text":"这里存放着我对 book-riscv-rev4 和 MIT-6.S081 的笔记，每个笔记对应 book-riscv-rev4 的一个章节。","categories":[{"name":"公开课","slug":"公开课","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"MIT-6.S081","slug":"公开课/MIT-6-S081","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/MIT-6-S081/"},{"name":"Notes","slug":"公开课/MIT-6-S081/Notes","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/MIT-6-S081/Notes/"}],"tags":[]},{"title":"第一章——系统接口","slug":"learning/open-course/MIT-6.S081/Notes/note1-sys-interface","date":"2025-06-01T03:18:38.000Z","updated":"2025-08-22T03:14:43.992Z","comments":true,"path":"wiki/learning/open-course/MIT-6.S081/Notes/note1-sys-interface/","permalink":"http://rinevard.github.io/wiki/learning/open-course/MIT-6.S081/Notes/note1-sys-interface/","excerpt":"","text":"img{ width: 70%; } 常用的系统接口 系统调用 描述 fork() 创建进程 exit() 结束当前进程 wait() 等待子进程结束 kill(pid) 结束 pid 所指进程 getpid() 获得当前进程 pid sleep(n) 睡眠 n 秒 exec(filename, *argv) 加载并执行一个文件 sbrk(n) 为进程内存空间增加 n 字节 open(filename, flags) 打开文件，flags 指定读/写模式 read(fd, buf, n) 从文件中读 n 个字节到 buf write(fd, buf, n) 从 buf 中写 n 个字节到文件 close(fd) 关闭打开的 fd dup(fd) 复制 fd pipe( p) 创建管道， 并把读和写的 fd 返回到p chdir(dirname) 改变当前目录 mkdir(dirname) 创建新的目录 mknod(name, major, minor) 创建设备文件 fstat(fd) 返回文件信息 link(f1, f2) 给 f1 创建一个新名字(f2) unlink(filename) 删除文件 进程 系统调用 描述 fork() 创建进程 exit() 结束当前进程 wait() 等待子进程结束 kill(pid) 结束 pid 所指进程 getpid() 获得当前进程 pid exec(filename, *argv) 加载并执行一个文件 sbrk(n) 为进程内存空间增加 n 字节 I/O 系统调用 描述 open(filename, flags) 打开文件，flags 指定读/写模式 read(fd, buf, n) 从文件中读 n 个字节到 buf write(fd, buf, n) 从 buf 中写 n 个字节到文件 close(fd) 关闭打开的 fd dup(fd) 复制 fd 代码示例： char buf[512]; void cat(int fd) &#123; int n; while ((n = read(fd, buf, sizeof(buf))) > 0) &#123; // 写入标准输出 if (write(1, buf, n) != n) &#123; fprintf(2, \"cat: write error\\n\"); exit(1); &#125; &#125; if (n &lt; 0) &#123; fprintf(2, \"cat: read error\\n\"); exit(1); &#125; &#125; int main(int argc, char *argv[]) &#123; int fd, i; if (argc &lt;= 1) &#123; cat(0); exit(0); &#125; for (i = 1; i &lt; argc; i++) &#123; if ((fd = open(argv[i], O_RDONLY)) &lt; 0) &#123; fprintf(2, \"cat: cannot open %s\\n\", argv[i]); exit(1); &#125; cat(fd); close(fd); &#125; exit(0); &#125; 不妨再来看看CSAPP的两张图 open两次： fork： 管道 系统调用 描述 pipe( p) 创建管道， 并把读和写的 fd 返回到p，其中p是 int p[2] p[0]: 读端(read end)的文件描述符 p[1]: 写端(write end)的文件描述符 样例： grep fork sh.c | wc -l 命令将第一个命令(grep)的输出作为第二个命令(wc)的输入，| 就是管道符号。 下面的代码是 | 的实现示例，大体思路是把 | 左边的标准输出重定向到pipe的写端，把 | 右边的标准输入重定向到pipe的读端。 注意要关闭管道的所有写入端来让 read 返回，因为当 pipe 中没有数据时，read 会阻塞等待新数据写入，或是写入端都关闭，如果有新数据写入就读取，如果所有写入端都关闭就返回 0（对应EOF）. // 假设我们的命令是 grep fork sh.c | wc -l case PIPE: pcmd = (struct pipecmd *)cmd; if (pipe(p) &lt; 0) panic(\"pipe\"); if (fork1() == 0) &#123; close(1); // 释放文件描述符1，从而让dup把文件描述符1绑定到p[1]指向的东西 dup(p[1]); //换句话说，我们在重定向标准输出到pipe的写端 close(p[0]); close(p[1]); runcmd(pcmd->left); // 对应 grep fork sh.c &#125; if (fork1() == 0) &#123; close(0); // 与上面类似，重定向标准输入到pipe的读端 dup(p[0]); close(p[0]); close(p[1]); runcmd(pcmd->right); // 对应 wc -l &#125; close(p[0]); close(p[1]); wait(0); wait(0); break; 文件系统 系统调用 描述 chdir(dirname) 改变当前目录 mkdir(dirname) 创建新的目录 mknod(name, major, minor) 创建设备文件 fstat(fd) 返回文件信息 link(f1, f2) 给 f1 创建一个新名字(f2) unlink(filename) 删除文件 我们通常认为文件名就是文件本身，但实际上名称是一个硬链接(hard link)。一个文件可以有多个硬链接——例如，一个目录至少有两个硬链接：目录名和 . （在目录内时）。它还有来自每个子目录的一个硬链接（每个子目录中的 .. 文件）。 那文件是什么呢？一个文件和一个 inode 一一对应，inode存放着这个文件的相关信息 xv6系统的inode结构包括下面这些内容： struct dinode &#123; short type; // File type short major; // Major device number (T_DEVICE only) short minor; // Minor device number (T_DEVICE only) short nlink; // Number of links to inode in file system uint size; // Size of file (bytes) uint addrs[NDIRECT + 1]; // Data block addresses &#125;; 可以通过 fstat 获取文件描述符指向的文件的信息。dinode是磁盘上存储的详细信息，stat是暴露给用户的文件信息接口 struct stat &#123; int dev; // File system's disk device uint ino; // Inode number short type; // Type of file short nlink; // Number of links to file uint64 size; // Size of file in bytes &#125;; 仅当我们把所有指向某个inode的链接都删除，这个inode才会被删除。 在下面的示例中，我们用 ln 创建了两个连接 file2 和 file3，它们都和 file1 指向的 inode 相同。可以看到，如果用 echo 修改 file2，那么 file1 也会被修改，因为我们修改的实际上是 inode，而它们指向同一个inode。ls -l 列出目录中的文件和目录的详细信息，第二个值是inode的link数。我们可以把链接视作文件的“别名”。 $ echo &quot;What&#39;s in a name? That which we call a rose, by any other word would smell as sweet.&quot; &gt; file1.txt $ ls file1.txt open-course programs $ cat file1.txt What&#39;s in a name? That which we call a rose, by any other word would smell as sweet. $ ln file1.txt file2.txt $ ln file1.txt file3.txt $ ls -l total 20 -rw-r--r-- 3 rinevard rinevard 85 May 29 11:37 file1.txt -rw-r--r-- 3 rinevard rinevard 85 May 29 11:37 file2.txt -rw-r--r-- 3 rinevard rinevard 85 May 29 11:37 file3.txt drwxr-xr-x 3 rinevard rinevard 4096 May 28 11:00 open-course drwxr-xr-x 2 rinevard rinevard 4096 May 28 10:19 programs $ echo &quot;-- William Shakespeare&quot; &gt;&gt; file2.txt $ cat file1.txt What&#39;s in a name? That which we call a rose, by any other word would smell as sweet. -- William Shakespeare 你可能会好奇目录的链接数怎么计算，是这样的： 每个目录默认有2个链接，一个是目录自身的”.”，另一个是父目录中指向该目录的链接 目录中每包含一个子目录，链接数就会+1，因为每个子目录都会创建”..”链接指向父目录 在下面的例子中，rootdir 的链接数是 4，因为父目录有一个指向它的链接”rootdir”，它自己有一个指向自己的链接”.”，它的两个子目录dir1和dir2分别有指向它的链接”..” ~/open-course/rootdir$ ls dir1 dir2 file1.md file2.md file3.md ~/open-course/rootdir$ ls ../ -l total 8 drwxr-xr-x 11 rinevard rinevard 4096 May 31 16:40 mit-6.828 drwxr-xr-x 4 rinevard rinevard 4096 Jun 1 10:58 rootdir 文件路径格式：以 “/” 开头的是从根目录出发的路径，否则是从当前文件夹出发的路径 ~/open-course$ ls mit-6.828 ~/open-course$ ls mit-6.828/ LICENSE Makefile README conf grade-lab-util gradelib.py kernel mkfs user ~/open-course$ ls /home/rinevard/ open-course programs unix shell的许多命令都是用户级别的，而非内置的。shell通过fork子进程并调用exec来执行它们。但cd是内置的，因为cd改变了shell自身的工作目录。 // Read and run input commands. while (getcmd(buf, sizeof(buf)) >= 0) &#123; if (buf[0] == 'c' &amp;&amp; buf[1] == 'd' &amp;&amp; buf[2] == ' ') &#123; // Chdir must be called by the parent, not the child. buf[strlen(buf) - 1] = 0; // chop \\n if (chdir(buf + 3) &lt; 0) fprintf(2, \"cannot cd %s\\n\", buf + 3); continue; &#125; if (fork1() == 0) runcmd(parsecmd(buf)); wait(0); &#125;","categories":[{"name":"公开课","slug":"公开课","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"MIT-6.S081","slug":"公开课/MIT-6-S081","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/MIT-6-S081/"},{"name":"Notes","slug":"公开课/MIT-6-S081/Notes","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/MIT-6-S081/Notes/"}],"tags":[]},{"title":"Lab1 Xv6 and Unix utilities","slug":"learning/open-course/MIT-6.S081/Labs/lab1-util","date":"2025-05-31T03:18:38.000Z","updated":"2025-08-22T03:14:43.982Z","comments":true,"path":"wiki/learning/open-course/MIT-6.S081/Labs/lab1-util/","permalink":"http://rinevard.github.io/wiki/learning/open-course/MIT-6.S081/Labs/lab1-util/","excerpt":"","text":"img{ width: 80%; } 在开始 lab 之前，我们先来解释一下为什么我们写的代码能直接在 xv6 的 shell 里执行。我们来看看 sh.c 的部分代码： // Read and run input commands. while (getcmd(buf, sizeof(buf)) >= 0) &#123; if (buf[0] == 'c' &amp;&amp; buf[1] == 'd' &amp;&amp; buf[2] == ' ') &#123; // Chdir must be called by the parent, not the child. buf[strlen(buf) - 1] = 0; // chop \\n if (chdir(buf + 3) &lt; 0) fprintf(2, \"cannot cd %s\\n\", buf + 3); continue; &#125; if (fork1() == 0) runcmd(parsecmd(buf)); wait(0); &#125; 从这里我们看出，shell通过fork子进程来执行命令。如果进一步看看 runcmd 函数，就会发现它调用了 exec，因此 shell 能执行用户写的代码。 有趣的是，从这段代码里我们也能看出 cd 是内置在 shell 里的命令，这是因为 cd 改变了shell自身的工作目录。 sleep这题让我们简单熟悉下接口。其实这里用 printf 更易读，不过我当时做的时候没发现有 printf #include \"kernel/types.h\" #include \"user/user.h\" #include \"kernel/fcntl.h\" int main(int argc, char *argv[]) &#123; char *errmsg = \"sleep: missing operand\\n\"; if (argc != 2) &#123; write(1, errmsg, strlen(errmsg)); exit(1); &#125; sleep(atoi(argv[1])); exit(0); &#125; pingpong这题让我们接触一下管道的使用，难者不会，会者不难 #include \"kernel/types.h\" #include \"user/user.h\" #include \"kernel/fcntl.h\" int main() &#123; char buf[512]; int p_parent_sender[2]; int p_child_sender[2]; pipe(p_parent_sender); pipe(p_child_sender); if (fork() == 0) &#123; // 子进程先读 read(p_parent_sender[0], buf, 2); printf(\"%d: received ping\\n\", getpid()); write(p_child_sender[1], buf, 2); close(p_parent_sender[0]); close(p_parent_sender[1]); close(p_child_sender[0]); close(p_child_sender[1]); exit(0); &#125; // 父进程先写 write(p_parent_sender[1], buf, 2); read(p_child_sender[0], buf, 2); printf(\"%d: received pong\\n\", getpid()); close(p_parent_sender[0]); close(p_parent_sender[1]); close(p_child_sender[0]); close(p_child_sender[1]); exit(0); &#125; primes这题很有趣，是一个并发素数筛法。这个算法理论上是可以提高效率的，毕竟在运行了一段时间后，各个进程里都有一些数等待筛选，这时各个进程在同时用自己的素数筛选输入的数。 网上很多代码都是2020版的，当时的要求是找出 2-35 间的素数。这些代码能过老版本的要求，但过不了2024版要求的 2-280。我认真看了一两份代码，发现它们在用 fork 创建子进程的子进程后，忘了关闭子子进程的连接到父进程的描述符。可以看下面示意图的第三个框，这些代码忘了关闭 child child process 的 fd_read. 我画了示意图来解释我的代码~ #include \"kernel/types.h\" #include \"kernel/stat.h\" #include \"user/user.h\" const int NUM = 280; int connected_fork(int *); void do_child(int); int main() &#123; int pid; int fd = -1; if ((pid = connected_fork(&amp;fd)) == 0) &#123; do_child(fd); exit(0); &#125; int n; for (n = 2; n &lt;= NUM; n++) &#123; write(fd, (void *)&amp;n, sizeof(int)); &#125; close(fd); wait(0); exit(0); &#125; /* * 创建子进程. 父进程的 fd 和子进程的 fd 会被分别设置为一个 pipe 的两端. * 对父进程, fd 被设置为写端. * 对子进程, fd 被设置为读端. * * return 0 if is child else child's pid */ int connected_fork(int *fd) &#123; int p[2]; pipe(p); int pid; if ((pid = fork()) == 0) &#123; // child close(p[1]); *fd = p[0]; &#125; else &#123; // parent close(p[0]); *fd = p[1]; &#125; return pid; &#125; /* * 从 fd_read 中读取数字, 打印第一个数, * 筛选其他数并新建子进程把被筛选后的数写入子进程. 在运行完成后关闭 fd_read. */ void do_child(int fd_read) &#123; int n = -1; int prime = -1; int fd = -1; while (read(fd_read, (void *)&amp;n, sizeof(int)) > 0) &#123; if (prime == -1) &#123; prime = n; printf(\"prime %d\\n\", prime); &#125; if ((n % prime) != 0) &#123; if (fd == -1 &amp;&amp; connected_fork(&amp;fd) == 0) &#123; // fd == -1 等价于没有子进程 // 如果没有子进程就创建子进程并让它开始工作 close(fd_read); do_child(fd); return; &#125; write(fd, (void *)&amp;n, sizeof(int)); &#125; &#125; close(fd_read); // fd == -1 等价于没有子进程, 说明它是最后一个进程 // 最后一个进程不需要关闭描述符, 也不需要等待 if (fd == -1) &#123; return; &#125; close(fd); wait(0); &#125; /* * 个人认为关闭 fd_read 不应该是 do_child 的工作, 我觉得\"谁创建, * 谁关闭\"会更合适. 也就是说, 我觉得让调用 do_child 的函数关闭 fd_read * 更合适. * * 但如果 do_child 不关闭 fd_read, 子孙进程就会保留父进程未关闭的描述符, * 从而耗尽 xv6 的资源. */ find在 ls.c 的基础上稍微改改就好了，要注意的是递归时不要递归进 “.” 和 “..” 两个文件夹 我们实现的 find &lt;path&gt; &lt;name&gt; 的功能和 Linux 里的 find &lt;path&gt; -name &lt;name&gt; 一致 #include \"kernel/types.h\" #include \"kernel/stat.h\" #include \"user/user.h\" #include \"kernel/fs.h\" #include \"kernel/fcntl.h\" void find(const char *path, const char *name); const char *basename(const char *path); int main(int argc, char *argv[]) &#123; if (argc != 3) &#123; printf(\"usage: find &lt;path> &lt;filename>\\n\"); &#125; find(argv[1], argv[2]); exit(0); &#125; /* * 在以 path 为根节点的文件树下搜索名为 name 的文件, * 如果找到则打印其路径. */ void find(const char *path, const char *name) &#123; int fd; if ((fd = open(path, O_RDONLY)) &lt; 0) &#123; fprintf(2, \"find: cannot open %s\\n\", path); return; &#125; struct stat st; if (fstat(fd, &amp;st) &lt; 0) &#123; fprintf(2, \"find: cannot stat %s\\n\", path); close(fd); return; &#125; if (strcmp(basename(path), name) == 0) &#123; printf(\"%s\\n\", path); &#125; // 只有文件夹有递归的必要 if (st.type != T_DIR) &#123; close(fd); return; &#125; char buf[512], *p; struct dirent de; // 第一个 +1 对应 '/', 第二个 +1 对应结尾的 '\\0' if (strlen(path) + 1 + DIRSIZ + 1 > sizeof(buf)) &#123; printf(\"ls: path too long\\n\"); &#125; strcpy(buf, path); p = buf + strlen(buf); *p++ = '/'; while (read(fd, &amp;de, sizeof(de)) == sizeof(de)) &#123; if (de.inum == 0 || strcmp(de.name, \".\") == 0 || strcmp(de.name, \"..\") == 0) continue; memmove(p, de.name, DIRSIZ); p[DIRSIZ] = 0; if (stat(buf, &amp;st) &lt; 0) &#123; printf(\"ls: cannot stat %s\\n\", buf); continue; &#125; find(buf, name); &#125; &#125; /* * 获取路径 path 的最后一部分 */ const char *basename(const char *path) &#123; const char *p; for (p = path + strlen(path); p >= path &amp;&amp; *p != '/'; --p) ; ++p; return p; &#125; xargsxargs 将标准输入（stdin）数据转换成命令行参数，一般和管道一起使用。在 linux 中，xargs 默认的命令是 echo. 上面的解释可能不太清晰，通过两个例子就能看出来它在做什么了： 第一个例子是直接使用 xargs $ xargs -n 1 echo Im prefix 111 Im prefix 111 222 Im prefix 222 （按 ctrl+D 终止输入) 第二个例子是和管道联用 $ (echo 1 ; echo 2) | xargs -n 1 echo 1 2 $ 我们实现的 xargs &lt;command&gt; 的功能和 Linux 里的 xargs -n 1 &lt;command&gt; 一致 #include \"kernel/types.h\" #include \"kernel/param.h\" #include \"user/user.h\" int main(int argc, char *argv[]) &#123; if (argc &lt; 2) &#123; fprintf(2, \"usage: xargs command\\n\"); exit(1); &#125; char *cmd = argv[1]; char *cmdargs[MAXARG]; int cmdargc = 0; // 在更改 cmdargc 前, 最好检查 cmdargc &lt; MAXARG, // 不过为了简化代码, 我们就不检查了 // argv[0] 是 'xargs', argv[1] 是 command, 之后是参数 // cmdargs 应当形如 [command, arg1, arg2, ..., addition_arg1, ...] cmdargc = argc - 1; for (int i = 0; i &lt; cmdargc; i++) &#123; cmdargs[i] = argv[i + 1]; &#125; char buf[512]; // 输入行 char *p = buf; // 输入行的末尾 while (read(0, p, 1) > 0) &#123; if (p[0] == '\\n') &#123; p[0] = '\\0'; cmdargs[cmdargc] = buf; ++cmdargc; cmdargs[cmdargc] = 0; ++cmdargc; if (fork() == 0) &#123; exec(cmd, cmdargs); &#125; wait(0); // 重置 p = buf; cmdargc = argc - 1; &#125; else &#123; ++p; &#125; &#125; exit(0); &#125;","categories":[{"name":"公开课","slug":"公开课","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"MIT-6.S081","slug":"公开课/MIT-6-S081","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/MIT-6-S081/"},{"name":"Labs","slug":"公开课/MIT-6-S081/Labs","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/MIT-6-S081/Labs/"}],"tags":[]},{"title":"慢慢地冲浪","slug":"others/thoughts/网上冲浪","date":"2025-05-28T03:50:11.000Z","updated":"2025-08-19T07:08:07.564Z","comments":true,"path":"wiki/others/thoughts/网上冲浪/","permalink":"http://rinevard.github.io/wiki/others/thoughts/%E7%BD%91%E4%B8%8A%E5%86%B2%E6%B5%AA/","excerpt":"","text":"在互联网上冲浪时，偶尔会看到一些博客，若是它们帮到了我，我经常也会点进主页看看作者都写了怎样的文章，都有怎样的故事。 很多人的网站里全是技术文章，我对这样的网站确实没什么兴致。我更喜欢杂谈类的文章，那种像是在夜深人静时，独自一人在电脑前慢慢写下的文章。读这样独处时写下的文章，总让我觉得自己和作者的灵魂更近了一点。 在互联网上随机漫游，对着完全不认识自己的人产生单箭头，如果运气好的话说不定会是双箭头，真的非常有趣。我可能还是喜欢慢一点的故事，喜欢有着很长很长回复的贴子，喜欢把自己遇见的趣事分享到网上的视频，喜欢随意的、真诚的文章。它们只是被放在那里，等着十年后被另一个人偶然发现，那是痕迹。 /* 隐藏草书 */ .hidden-text { font-size: 18px; text-align: center; margin: 20px 0; /* padding: 20px; */ line-height: 1.5; color: transparent; cursor: default } .hidden-fancy-text::selection { color: black; background: white; } 就像这里的痕迹。","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/"},{"name":"碎碎念","slug":"杂谈/碎碎念","permalink":"http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}],"tags":[]},{"title":"在开始之前","slug":"learning/open-course/MIT-6.S081/BeforeStory","date":"2025-05-27T07:20:38.000Z","updated":"2025-08-22T03:14:43.982Z","comments":true,"path":"wiki/learning/open-course/MIT-6.S081/BeforeStory/","permalink":"http://rinevard.github.io/wiki/learning/open-course/MIT-6.S081/BeforeStory/","excerpt":"","text":"最近发现了 Arthal 的笔记，感觉写得非常精美！回头看看自己对 15213 labs 的笔记，感觉写得确实太粗糙了，希望我的 6.S081 的笔记也能写得详细一些。 咳咳，我知道我还没写 15213 的 proxylab，不过我感觉csapp网络那一章写得有点含糊，所以晚点再做吧。","categories":[{"name":"公开课","slug":"公开课","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"MIT-6.S081","slug":"公开课/MIT-6-S081","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/MIT-6-S081/"}],"tags":[]},{"title":"第九章——虚拟内存","slug":"learning/open-course/CMU-15-213/Notes/Chapter9-virtual-memory","date":"2025-05-13T14:10:28.000Z","updated":"2025-08-22T03:14:43.982Z","comments":true,"path":"wiki/learning/open-course/CMU-15-213/Notes/Chapter9-virtual-memory/","permalink":"http://rinevard.github.io/wiki/learning/open-course/CMU-15-213/Notes/Chapter9-virtual-memory/","excerpt":"","text":"img{ width: 80%; } 重走虚拟路让我们尝试重新发明一遍虚拟内存。 使用虚拟地址的原因想象一下我们只能用物理地址来写程序，我们写出了下面的东西： ; 假设目标机器是Intel 8080，内存地址为物理地址 ORG 0x0100 ; 程序起始地址，直接指定物理地址0x0100 MVI A, 0x05 ; 将立即数0x05加载到寄存器A STA 0x0200 ; 将寄存器A的值存储到物理内存地址0x0200 HLT ; 停止程序 这东西的可移植性显然很差！所以我们发明了“虚拟地址”。这样程序就能直接使用虚拟地址，而在程序执行时，虚拟地址被操作系统的MMU（Memory Management Unit）实时翻译成物理地址。 虚拟地址到物理地址的映射这么看来，我们可以把 MMU 当作一个从虚拟地址空间到物理地址空间的映射，那我们自然要用一个数据结构来存储映射。 但怎么组织这个数据结构呢？用一个数组，然后每个虚拟地址对应一个物理地址？假设我们有 $M$ 个虚拟地址，我们就存一个长度为 $M$ 的数组？这样的话，这个数组就太大了。假设我们有 $k$ 个进程，按这个想法，我们就需要至少 $k\\times M \\times \\text{sizeof(char *)}$ 大小的内存来存储这个数据结构。 我们选择把 $N$ 个连续的虚拟地址当作一个虚拟页，同时把 $N$ 个连续的物理地址当作一个物理页，这样对每个进程，我们就只要做物理页之间的映射，存储 $\\frac{M}{N}$ 个项就好了。考虑到程序的局部性， 我们的这种选择是合理的。这样的一个数据结构就叫做一个页表。 在下图的单级页表中，每一项都带有一个有效位（用于标记这个虚拟页对应的物理页是否在 DRAM 中）和对应物理页的开头物理地址（如果没有对应物理页，为 null）。 把虚拟地址翻译成物理地址的大致思路是根据虚拟地址找到页表中对应的项，从而找到对应的物理页，然后根据虚拟地址的最后几位确定具体的物理地址。（还记得吗，一个页由很多地址组成） 但这样的页表还是很大吧。我们总在进程被创建时就为他们分配了一个超大的页表，而实际上绝大多数程序都根本用不到那么多虚拟地址。所以，我们能不能动态地改变页表的大小，比如说，在程序请求某个虚拟地址，但它不在页表中时，再去增大页表？ 所以我们进一步把页表分成多级，在需要的时候再去新增 level 较高的页表。 在这样的多级页表中，只有 level 最高的页表存储对应页的开头物理地址，而其他 level 的页表存储下一个级别的页表的开始地址。我们会在下一节详细讲解它的翻译过程。 让我们总结一下，每个进程有自己的页表，在切换到某个进程时，操作系统会更新存储着页表地址的寄存器（在 RISC-Ⅴ 中是 satp 寄存器）。当进程需要访问某个虚拟地址时，MMU 会把虚拟地址翻译成物理地址，然后访问物理地址。 要特别强调的是，每个 level 可以有多个页表，我们可以把多级页表看作树状结构！ 虚拟地址的翻译我们已经知道了虚拟内存大致是怎样的了。那么 MMU 具体是怎么把虚拟地址翻译成物理地址的呢？我们这里讨论多级页表。 在多级页表中，只有 level 最高的页表存储对应页的开头物理地址，而其他 level 的页表存储下一个级别的页表的开始地址。 虚拟地址的前几位在翻译过程中会起到“页表索引”的作用，当我们到达了某个 level 的页表，我们会用它来确定我们具体需要这个页表的哪个项。而虚拟地址的最后几位是一个 offset，还记得吗，一个虚拟页和一个物理页对应，所以在找到了对应的物理页的开头地址后，我们要根据 offset 得到真正对应的物理地址。 VPN 是 virtual page number，VPO 是 virtual page offset，PTE 是 page table entry 我魔改了一下上图，希望这能让“每个 level 有多个页表”这件事显得更清晰。 优化看起来多级页表在存储方面优化得不错，但速度呢？既然每个页表都放在不同的地址，那它不是要求多次访问不同地址吗？正是如此，所以我们用 TLB（Translation Lookaside Buffer）来缓存最近使用的页表项，来加快地址翻译。 动态内存分配当我们调用 malloc 和 free 时究竟发生了什么？在做完 malloclab 以后，我们对此已经有了比较清晰的理解。 malloc调用 malloc 时，我们在寻找足够大的空闲内存块来提供给用户，如果不够大就扩容。在“寻找”的过程中，我们有很多种策略可以选，这就是 placement policy，包括但不限于 first fit、next fit、best fit. 而在找到空闲块以后，有时空闲块可能比用户的需求大很多，这时就要想想要不要切割空闲块，这就是 splitting policy。 free调用 free 时，我们简单地把一个已分配内存块标记为空闲。但空闲之后又要决定是否把它和相邻的空闲块合并，这就是 coalescing policy。 块的结构之前提到，malloc 是在找空闲块，但什么是“块”呢？块的数据结构也有很多种可以选，不过一般来说，每个块都至少会有 size 和 is_alloc 标记。 举个例子，使用显式链表策略时，我们的堆大概长这样：","categories":[{"name":"公开课","slug":"公开课","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"CMU-15-213","slug":"公开课/CMU-15-213","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/"},{"name":"Notes","slug":"公开课/CMU-15-213/Notes","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/Notes/"}],"tags":[]},{"title":"Malloclab和我不得不说的那些事","slug":"learning/open-course/CMU-15-213/Labs/Malloclab","date":"2025-05-12T11:28:38.000Z","updated":"2025-08-22T03:14:43.978Z","comments":true,"path":"wiki/learning/open-course/CMU-15-213/Labs/Malloclab/","permalink":"http://rinevard.github.io/wiki/learning/open-course/CMU-15-213/Labs/Malloclab/","excerpt":"","text":"写在前面malloclab 的难度很大，我实现了书上的基础的隐式空闲链表和显式空闲链表，用时约 16 小时，得分如下： Perf index &#x3D; 47 (util) + 40 (thru) &#x3D; 87&#x2F;100 实现的逻辑本身是简单的，难度最大的地方在于调试，所以我并没有进一步实现分离的空闲链表，因为调试起来实在是太麻烦了。算是体验了一下系统级编程的复杂性。 有趣的是，由于 fail fast 的编程习惯，我喜欢在代码里到处放 assert 和 print 语句，这帮我节省了不少调试时间，我甚至一次 gdb 都没用就把所有的 bug 都修完了。（话说回来我也不知道这种东西怎么用 gdb 调试） 本文会谈谈做这个 lab 时学到的一些编程技巧，不会太多谈 lab 本身，因为照着书上实现出来就好了。 宏编程宏编程最需要关注的地方就是到处都要加括号。让我们以下面这行代码为例： #define GET(p) (*((unsigned int * )p)) 像这种就是有问题的，因为没给 p 加括号！比如说，GET((char *)bp - WSIZE) 的原本意图是让 bp 减去 WSIZE，但放到 GET 里就导致 bp 先被转换成 unsigned int 指针，再减去 WSIZE，从而让 bp 减去了 WSIZE * sizeof(unsigned int)！ validation_check这个 lab 可以看作在创建一个神奇的类，我们总会对类有一些 validation 要求（比如说在这个 lab 中，我们要求内存里不能有连续的空闲块），这时我们就可以写一个 validation_check 函数，它会检查这个类是否满足我们的 validation 要求。 那这个 validation_check 有什么用呢？在调试的时候，我们可以把它插入到各种地方，然后看它在哪里 fail，这能帮助我们更快定位 bug。一个小技巧是用二分的思路来插入 validation_check。 其他小技巧写这个 lab 的时候用到了很多 6.102 的知识，果然软工知识超有用~比如说，写一个简练清晰的 specification 很有帮助，fail fast 特别有用。 还注意到了一个有趣的地方，size_t 在我的系统上是这样显示的： typedef unsigned long size_t 据 claude 说，size_t 的具体定义取决于系统架构，这可能是为了可移植性考虑？ 除此之外，我觉得还有一个重要的作用，就是给类型提供“别名”。有时我们希望类型有一个更具描述性的名称，而不只是“int”。","categories":[{"name":"公开课","slug":"公开课","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"CMU-15-213","slug":"公开课/CMU-15-213","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/"},{"name":"Labs","slug":"公开课/CMU-15-213/Labs","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/Labs/"}],"tags":[]},{"title":"Ludum Dare参加指南","slug":"game-design/ldjam参赛指南","date":"2025-04-13T01:36:38.000Z","updated":"2025-07-20T09:55:53.012Z","comments":true,"path":"wiki/game-design/ldjam参赛指南/","permalink":"http://rinevard.github.io/wiki/game-design/ldjam%E5%8F%82%E8%B5%9B%E6%8C%87%E5%8D%97/","excerpt":"","text":"零、在文章开始之前本文包含了对 Ludum Dare 的介绍、参与流程及个人看法。写作的契机是参与 Ludum Dare 后体验很好，但在中文互联网上没有找到很全面的介绍资料，只找到了 规则介绍。在规则介绍之外，我希望聊聊 Ludum Dare 的体验为什么好（比起我参加过的其他 gamejam），并按时间线介绍一下参与流程。 一、什么是 Ludum Dare官网写到，”Ludum Dare is an event where you create a game from scratch in a weekend based on a theme.”（出自 rules），即“Ludum Dare 是一个围绕某个主题在一个周末从零开始做出一个游戏的活动。”更具体一点，Ludum Dare 主要分为两个赛道，分别是单人 48 小时做一个游戏和组队 72 小时做一个游戏。 这时候有经验的读者就会问了，这不就是 gamejam 吗？正是如此！Ludum Dare 是非常早期的 gamejam，它自 2002 年开始举办，每年举办两次，到今天已经办了 57 届。每届 Ludum Dare 都会吸引全球数以万计的开发者，如 2021 年的 49 届收到了近 3000 款游戏提交， 2023 年的第 52 届收到了 1632 款游戏提交（数据来源）。在这大量的提交游戏中，也有许多精品作品从此发源，比如邪恶铭刻（inscryption）的原型 Sacrifices Must Be Made 就于 Ludum Dare 43 制作。 二、为什么参加 Ludum Dare中国有那么多本土的 gamejam，那为什么要顶着语言障碍参加 Ludum Dare 呢？我认为最重要的两点是游戏质量高、收获反馈多。 先说前者，gamejam 总是有竞赛性质的，在 Ludum Dare 里我们要和全世界的优秀开发者竞争，单是看着这些开发者围绕主题的奇思妙想就已经让人觉得值回票价了（并没有票价，这是免费活动），而如果取得了好排名则更是会给人相当的成就感。 再说后者，介于 Ludum Dare 的算法，每个游戏基本都会获得 20 个以上的评分，而且你玩的游戏越多，Ludum Dare 就会把你的游戏放在推荐榜越靠前的位置，从而就会有越多人玩你的游戏。以我的经验来看，玩的游戏数量和收获的评分数量基本接近，而且很多玩了我们游戏的开发者会在游戏下给出评论来反馈，非常利于我们了解自己游戏的优秀之处（可惜的是评论一般不说缺点，以夸夸居多）。 下面再举几个 Ludum Dare 的其他优势： 足不出户：与线下 gamejam 不同，参加 Ludum Dare 无需报名，只要注册账号并在提交时间截止前提交游戏即可。 玩游戏方便：大部分开发者都会提供游戏的 web 版本，即使不提供 web 版本也可以直接在对应的游戏页面下载游戏。 交流机会：我们可以给别的游戏提供反馈，也可以在别的游戏评论区里询问开发者的设计思路，一般都会收到积极的回复。 和大神合影：每届的 Ludum Dare 都会有一些大神来参加，如果恰巧碰上了自己感兴趣的大神，就有了在他们的游戏评论区夸夸的合影机会！ 三、参与流程Ludum Dare 的流程大概是主题投票、制作、评分与反馈、结果公布。为了顺利参赛，首先我们要在 Ludum Dare 上注册一个账号。注册账号需要邀请码，我们可以在 Google 上用 ludum dare invitation code 之类的关键词或者在举办者的主页上找到邀请码。我找到的第 57 届的邀请码有 Time4LD57 和 BirdSiteLD57。 在注册成功之后，我们要想想这次是单人参赛还是组队参赛。Ludum Dare 有三条赛道，Compo、Jam 和 Extra. Compo 是经典模式，要求单人 48 小时内做游戏，所有内容包括美术、音效等都需要在 48 小时内从零开始做出，而且必须开源源代码。我们可以使用任何已经写过的基础代码和任何工具。如果你的游戏收到了 20 个以上的评分，会得到最终评分。 Jam 相对宽松，只要求组队 72 小时内做游戏，可以使用任何已经写过的基础代码，也允许使用部分预制素材。若美术或音效非原创，需要在提交时关闭对应类别的打分。比如如果我们用了第三方美术，就要在提交时关闭 Graphics 的打分。如果你的游戏收到了 20 个以上的评分，会得到最终评分。 Extra 则是轻松组，时间宽裕至 3 周，单人或团队均可，内容以原创为主但允许预制素材，美术或音效非原创可退出对应评分类别，源代码提交可选，但无最终排名。 赛道在提交时才需要确定，所以如果你原本打算参加 Compo，但没来得及赶上 Compo 的截止提交时间，也可以转去 Jam 的提交。 想好了赛道后，就能进入之后的环节了。 主题投票官方会提供大量的主题（第 57 届有 1000 多个），经过初选轮、复选轮、决赛轮，最终得出一个结果主题。我们当然不必给每个主题都投票，我的个人建议是在决赛轮投一下就行。而且即使不投票也是能参赛的！参赛的唯一要求就是在提交时间截止前提交作品。 是否围绕主题做游戏也是可选的，主题只是最终评分中的一部分，Ludum Dare 的宗旨是鼓励开发者把游戏做出来。 制作阶段进入制作阶段后，我们就可以开始做游戏了！点击右上角的 join event，就能创建游戏草稿页。我们会在上传阶段填充这个草稿页。 制作游戏需要大家各显神通，我简单谈谈个人建议吧。 设计一般来说，我们要快速地找到多个想法，然后选择自己觉得最有前途的想法做下去。由于制作时间很紧，我们注定不能做大做全。比起大而全，小而美是更好的选择。一个只有三关的认真打磨过的作品比一个有十关的每关都很粗糙的作品要好得多。 程序尽管 Ludum Dare 允许设计桌游乃至更不被定义的游戏（我见过一个翻文件夹的游戏），但我们这里只讨论电子游戏。程序方面，选用自己最熟悉的工具即可。有熟练的游戏引擎就选游戏引擎，喜欢不用引擎开发就不用引擎开发。 音乐我是音乐萌新，虽然听说过 FL studio 之类的工作站，但我现在还没学会。所以我这里推荐一个简单的音乐制作网站——Musiclab，我使用里面的SongMaker做出了能听的东西。 音效sfxr是很简单的音效制作网站，我看不懂参数，所以我的工作流是把我想要的效果告诉 AI，AI 告诉我怎么调参，效果出乎意料地还算不错。 美术我用Piskel画简单的像素画，偶尔也用Krita来画别的东西。 抛开 Extra 赛道不谈，这个阶段持续 48 小时或 72 小时，我最后的建议是在参与的同时保持充足的睡眠，好好睡觉好好吃饭很重要！ 上传阶段在制作阶段结束后，会给额外的一小时来上传。尽管官网给了额外一小时的上传时间，我还是建议大家在制作阶段的末尾就开始研究怎么上传游戏，以防万一嘛。 我们可以在这段时间里填充右上角 My Game 的草稿页，按着页面要求填写即可。 我们可以把游戏压缩包上传到页面上，同时 Ludum Dare 支持 Embed HTML5，也就是说我们可以根据Embedding Guide直接把游戏的网页版上传到官网的游戏页面上。建议大家同时把网页版上传到 itch 上，毕竟官网的网页版游戏支持做得不算很完美。 记得退出自己不符合/不想要的打分选项。 评分阶段至此，恭喜你做出了自己的游戏！ 评分阶段持续三周，在评分阶段，我们可以试玩别人的游戏并打分，你打分的游戏越多，推荐算法给你的游戏的推荐优先级就越高。同时高质量评论也能提高你游戏的推荐优先级。 评分阶段允许继续编辑页面，比如如果你发现游戏页面的描述有问题，随时可以进行修改。修游戏内的 bug 也是被允许的，但要求在修 bug 以后显式地在游戏页面标出自己做的修改（写一个简要的 devlog），而且不能增加新功能。 结果公布游戏会根据打分来排名。没有奖品，你的游戏就是最好的奖品！ 四、其他资料可以在rules页面找到详细的参加规则，强烈建议在参加前阅读。 可以在这篇规则介绍找到中文的规则介绍，但不如上面那个全面。 本文的结构参考了 Google 编程之夏(GSoC)：海量优质项目，丰厚报酬，你竟然还不知道？","categories":[{"name":"gamejam","slug":"gamejam","permalink":"http://rinevard.github.io/categories/gamejam/"}],"tags":[]},{"title":"第十章——系统级I/O","slug":"learning/open-course/CMU-15-213/Notes/Chapter10-system-io","date":"2025-04-11T02:00:00.000Z","updated":"2025-08-22T03:14:43.982Z","comments":true,"path":"wiki/learning/open-course/CMU-15-213/Notes/Chapter10-system-io/","permalink":"http://rinevard.github.io/wiki/learning/open-course/CMU-15-213/Notes/Chapter10-system-io/","excerpt":"","text":"img{ width: 75%; } 文件所有的 I/O 设备都被视为文件，因此我们能用一致的方式处理各种输入输出。 文件类型分为以下几类 普通文件：包含用户数据，可以是文本文件（如.txt）或二进制文件（如.jpg、.exe） 目录：包含一系列链接，每个连接将一个文件名映射到一个文件 套接字（socket）：跨网络通信用的文件 读写文件文件描述符（file descriptor）文件描述符是一个非负整数，代表进程打开的文件的标识符。在进程中，每当打开一个文件时，操作系统会分配一个文件描述符给它。 默认情况下，0 表示标准输入（stdin），1 表示标准输出（stdout），2 表示标准错误（stderr）。通过系统调用（如 open）打开文件后，会返回一个新的文件描述符（如 3、4 等），具体值取决于当前进程中已使用的描述符情况。 以下是一个使用 open 系统调用的示例，展示如何打开一个文件并获取文件描述符： #include &lt;fcntl.h> #include &lt;stdio.h> #include &lt;unistd.h> int main() &#123; // 打开文件 \"example.txt\"，以只读模式 int fd = open(\"example.txt\", O_RDONLY); if (fd == -1) &#123; perror(\"open failed\"); return 1; &#125; printf(\"文件描述符: %d\\\\n\", fd); // 使用文件描述符进行操作（如读取） char buffer[100]; ssize_t bytes_read = read(fd, buffer, sizeof(buffer)); if (bytes_read == -1) &#123; perror(\"read failed\"); close(fd); return 1; &#125; // 关闭文件描述符 close(fd); return 0; &#125; 不足值（short count）“不足值”是指在读写操作中，实际读取或写入的字节数少于请求的字节数。原因有遇到 EOF、从终端读文本行（如果读终端，read 一次只传输一个文本行）、读写网络套接字。 比如调用 read(fd, buffer, 100)请求读取 100 字节，但文件只剩 50 字节可用，则返回 50（不足值）。 我们需要检查返回值，确认实际读写字节数，并根据需要调整逻辑（如循环读取剩余数据）。 描述符表、文件表、v-node 表操作系统在内核中维护了三层数据结构来管理文件： 描述符表：每个进程独有，记录该进程打开的所有文件描述符及其对应的文件表项。 文件表：所有进程共享，表项包括偏移值、引用计数（即当前指向该表的描述符表项数）、指向 v-node 表中对应项的指针。关闭一个描述符会减少相应的文件表表项的引用计数，减到零会删除。 v-node 表（或 inode 表）：与具体文件系统相关，记录文件的元数据（如文件大小、权限、存储位置）。每个文件在 v-node 表中有一个唯一条目。 调用 open 打开文件的具体过程当调用 open 系统调用打开一个文件时，操作系统会执行以下步骤： 验证和查找文件： 内核检查文件路径、权限等，确定文件是否存在且进程有权访问。 找到文件对应的 v-node（或 inode），如果文件已在 v-node 表中，则复用，否则创建新条目。 分配文件表项： 内核在文件表（file table）中创建一个新表项，记录文件的偏移量（初始为 0）、访问模式（如只读、读写）、引用计数（初始为 1）以及指向对应 v-node 的指针。 更新描述符表： 内核在调用进程的描述符表（file descriptor table）中分配一个未使用的最小描述符编号（如 3，若 0、1、2 已占用）。 将该描述符指向新创建的文件表项。 返回文件描述符： open 调用返回分配的文件描述符给进程，供后续操作（如 read、write）使用。 open 两次： fork： 基于缓冲区的读写基于缓冲区的读写将数据先写入内存缓冲区，等缓冲区满或显式刷新（如 fflush）时再一次性与底层设备做数据交换，降低了 I/O 开销。 在使用读写时，我们应尽可能使用 stdio 标准库。stdio（标准输入输出库）提供了基于缓冲区的 I/O 操作（如 fopen、fread、fwrite、printf 等），相比直接使用低级系统调用（如 read、write），它的效率更高而且更不易出错。","categories":[{"name":"公开课","slug":"公开课","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"CMU-15-213","slug":"公开课/CMU-15-213","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/"},{"name":"Notes","slug":"公开课/CMU-15-213/Notes","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/Notes/"}],"tags":[]},{"title":"Shlab调试记录和一键测试脚本","slug":"learning/open-course/CMU-15-213/Labs/Shlab","date":"2025-04-03T09:04:28.000Z","updated":"2025-08-22T03:14:43.981Z","comments":true,"path":"wiki/learning/open-course/CMU-15-213/Labs/Shlab/","permalink":"http://rinevard.github.io/wiki/learning/open-course/CMU-15-213/Labs/Shlab/","excerpt":"","text":"写在前面用时 10h30min, 通过所有测试。这个 lab 还是比较直接的, 按着 trace 的顺序逐步实现即可, 难点主要在调试和不熟悉系统调用语法上。我在写代码的过程中遇到了两个调了蛮久的 bug, 分别在 trace13 和 trace16 上, 下面简要复盘一下。 调试trace16先说 trace16 的 bug, 这个调了半小时。trace16 测试的是 shell 能否处理子进程被外部信号中断或停止的情况。我遇到的问题是 trace16 在 ./mystop 那里卡住了, 于是猜测原因是 jobs 没能正确更新子进程的暂停状态。后面加了点调试语句发现果然如此。那么修复思路就是在子进程暂停后把它对应的 job 状态进行更新。但怎么知道子进程什么时候暂停呢？答案是 sigchld_handler. 我一开始以为 sigchld_handler 只会在某个子进程终止后被调用, 所以只在 sigchld_handler 里写了回收已经终止的子进程的逻辑。后来发现子进程只要状态发生变化就会发 SIGCHLD 信号给父进程, 子进程终止只是一种情况, 暂停、恢复也会发送这个信号。所以让 sigchld_handler 检查已经停止的子进程, 并更新它们对应的 jobs 状态就修复了这个 bug. trace13然后是 trace13 的 bug, 这个调了两小时半。这里的问题是在 fg %1 卡住。第一个猜测自然是进程没能被正确移到前台, 但加了调试语句后发现它确实被移到前台了。之后的猜测就是 waitfg 的实现有误, 这个猜测看起来很合理, 毕竟 handout 里写 waitfg 大概需要 20 行, 而我只用了 4 行。但测了半天发现 waitfg 也没问题。 进一步加入各种调试语句, 发现在 fg %1 之后, 进程确实被顺利移到了前台, jobs 也正确更新了, waitfg 只是因为它没结束, 所以一直循环着等着它。好吧, 那我猜是 sigchld_handler 没能正确回收它。我检查了一下, 发现终止的进程也都被正确回收了。那还能是什么原因呢？难道它被暂停了, 但没有被正确启动, 导致我们的 shell 误以为这个暂停着的进程是前台进程, 从而卡住了？这听起来就像是一个并行导致的问题, 于是我又调试了好久, 最后发现它确实被正确启动了, 这个进程只是单纯地还没有终止而已。 那这怎么可能呢？凭什么它在 tshref 里几秒钟就执行完了, 在我的实现里五分钟了都没执行完？原来是我的“启动”写错了。我使用的是 kill(job-&gt;pid, SIGCONT), 这个代码只把启动信号发给了这一个子进程, 而不是发给它所在的进程组, 从而让这个子进程所在组的别的进程没有被正确启动。而看看 mysplit.c 的代码, 会发现它等待它的子进程执行完才会终止, 所以我们把代码改成 kill(-job-&gt;pid, SIGCONT) 就解决了这个 bug. 就因为这一个负号, 我调试了两个半小时, 而且我感觉我一路下来的各种猜想也都很合理, 只能感叹系统级代码真难调试啊。 感想也算是学到了几招吧： 在调用系统函数时一定要检查返回值, 不然会报一些很难调试的错误 在修改全局变量时一定要用 sigprocmask 拦截别的信号, 避免冲突 子进程只要状态发生变化就会发 SIGCHLD 信号给父进程, 终止、暂停、恢复都会发送这个信号 可以用 waitpid 来检查子进程的变化状态, 它会回收终止的子进程 只在信号处理程序中调用异步安全的函数 调试时大胆猜想, 小心求证 一键测试脚本我让 AI 写了一份一键测试脚本, 比官方的形如 make test13 的测试方便不少。脚本的功能是在 traceA 到 traceB（要求 A &lt; B）上分别运行 tsh 和 tshref, 并把输出结果放到两个文件中。比如说, 如果我们输入 ./test_traces.sh 1 5, 就能测试 trace01.txt 到 trace05.txt, 并将结果分别保存到 _tshref_output.txt 和 _tsh_output.txt。之后用各种编辑器自带的比较文件功能就能很方便的比较输出异同。 代码#!/bin/bash # 脚本名称：test_traces.sh # 显示用法 usage() &#123; echo \"用法: $0 lower upper\" echo \" lower: 开始的 trace 文件编号 (1-16)\" echo \" upper: 结束的 trace 文件编号 (1-16)\" echo \"示例: $0 1 5\" echo \" 这将测试 trace01.txt 到 trace05.txt，并将输出分别保存到 _tshref_output.txt 和 _tsh_output.txt\" &#125; # 检查是否提供了两个参数 if [ \"$#\" -ne 2 ]; then echo \"错误: 请提供 lower 和 upper 两个参数\" usage exit 1 fi lower=$1 upper=$2 ref_output_file=\"_tshref_output.txt\" tsh_output_file=\"_tsh_output.txt\" # 清空输出文件（如果已存在） > \"$ref_output_file\" > \"$tsh_output_file\" # 获取当前工作目录（模仿 make 的 Entering directory 格式） directory=$(pwd) # 循环运行指定范围的 trace 文件 for ((i=lower; i&lt;=upper; i++)); do # 补齐两位数格式（例如 01, 02, ..., 16） trace_num=$(printf \"%02d\" $i) # 输出 make 样式的进入目录信息（仅第一次循环时） if [ $i -eq $lower ]; then echo \"make[1]: Entering directory \\`$directory'\" >> \"$ref_output_file\" echo \"make[1]: Entering directory \\`$directory'\" >> \"$tsh_output_file\" fi # 为 tshref 输出添加分隔符和内容 echo \"===== Trace $trace_num =====\" >> \"$ref_output_file\" echo \"./sdriver.pl -t trace$trace_num.txt -s ./tshref -a \\\"-p\\\"\" >> \"$ref_output_file\" head -n 1 \"trace$trace_num.txt\" >> \"$ref_output_file\" ./sdriver.pl -t \"trace$trace_num.txt\" -s ./tshref -a \"-p\" >> \"$ref_output_file\" 2>&amp;1 echo \"\" >> \"$ref_output_file\" # 添加空行作为间隔 # 为 tsh 输出添加分隔符和内容 echo \"===== Trace $trace_num =====\" >> \"$tsh_output_file\" echo \"./sdriver.pl -t trace$trace_num.txt -s ./tsh -a \\\"-p\\\"\" >> \"$tsh_output_file\" head -n 1 \"trace$trace_num.txt\" >> \"$tsh_output_file\" ./sdriver.pl -t \"trace$trace_num.txt\" -s ./tsh -a \"-p\" >> \"$tsh_output_file\" 2>&amp;1 echo \"\" >> \"$tsh_output_file\" # 添加空行作为间隔 done echo \"测试完成。参考实现结果已保存到 $ref_output_file，学生实现结果已保存到 $tsh_output_file\" 用法简述 保存脚本： 将上述代码保存到一个文件，例如 test_traces.sh。 赋予执行权限： 在终端中运行以下命令，为脚本添加执行权限：chmod +x test_traces.sh 这一步是必须的，因为在 Linux/Unix 系统中，脚本默认没有执行权限，需要手动赋予。 运行脚本： 使用以下格式运行脚本：./test_traces.sh lower upper lower：起始的 trace 文件编号（1-16）。 upper：结束的 trace 文件编号（1-16）。 示例：./test_traces.sh 1 5 这将测试 trace01.txt 到 trace05.txt，并将结果分别保存到 _tshref_output.txt 和 _tsh_output.txt。 检查输出： 测试完成后，比较 _tshref_output.txt（参考实现结果）和 _tsh_output.txt（学生实现结果）。 用各种编辑器自带的比较文件功能就能很方便的比较输出异同。 注意事项 环境要求：确保当前目录下有 sdriver.pl、tshref、tsh 以及对应的 traceXX.txt 文件，否则脚本会报错。 覆盖输出：每次运行脚本时，输出文件（_tshref_output.txt 和 _tsh_output.txt）会被清空并重新生成。","categories":[{"name":"公开课","slug":"公开课","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"CMU-15-213","slug":"公开课/CMU-15-213","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/"},{"name":"Labs","slug":"公开课/CMU-15-213/Labs","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/Labs/"}],"tags":[]},{"title":"第八章——异常控制流","slug":"learning/open-course/CMU-15-213/Notes/Chapter8-exception-control-flow","date":"2025-03-31T03:26:01.000Z","updated":"2025-08-22T03:14:43.982Z","comments":true,"path":"wiki/learning/open-course/CMU-15-213/Notes/Chapter8-exception-control-flow/","permalink":"http://rinevard.github.io/wiki/learning/open-course/CMU-15-213/Notes/Chapter8-exception-control-flow/","excerpt":"","text":"img{ width: 70%; } 当我们在程序执行时按下 ctrl+c ，究竟发生了什么？为解答这个问题，我们引入异常控制流（exceptional control flow，ECF）的概念。异常控制流允许我们将控制转移到其他程序，从而实现一些神奇的效果，比如中断程序、上下文切换、调用系统函数。 异常异常是异常控制流的一种形式，分为四类： 类别 异步/同步 产生原因 例子 中断（interrupt） 异步 外部事件 外部时钟（timer interrupt） 陷阱（trap） 同步 执行内部指令 系统调用（system calls） 故障（fault） 同步 执行内部指令 除以零 终止（abort） 同步 执行内部指令 硬件错误 注意：一定要检查系统调用的返回值，不然会出现一些很难调试的错误！ 异常发生后，控制会转移给异常处理程序。在处理完成后，根据异常的具体内容可能会返回到原程序的下一条指令，也可能返回到原程序的当前指令，也可能不返回。： 进程并发和上下文切换我们可以并发地执行多个进程，如下图所示： 但我们是怎么实现这种并发的呢？答案是上下文切换。下图展现了单核 CPU 的上下文切换，每个进程都有自己的上下文。 上下文切换的原因多种多样，举两个常见例子：用户可能执行系统调用而等待某个事件（比如用 waitpid 等待子进程终止），这时内核就可以让当前进程休眠并切换到另一个进程；系统每隔若干毫秒也会产生一次定时器中断的异常，并切换到新的进程。 进程的创建、终止和回收我们可以用 fork 来创建一个当前进程的复制——它执行一次，返回两次，分别返回到父进程和父进程的子进程中。对父进程，它返回子进程的 pid；对子进程，它返回 0. 子进程在终止后不会自动被清楚，而是进入“僵死进程”状态，直到被父进程回收。如果父进程终止了，init 进程会成为它的孤儿进程的养父。很明显，这里有潜在的内存泄漏。那么，怎么回收子进程呢？ 我们可以用 waitpid 来等待子进程终止，在 waitpid 返回后，这个终止的子进程会被回收。 我们可以用 execve 来加载并运行程序。execve 函数在当前进程的上下文中加载并运行一个新程序，只有在出现错误时，它才会返回到调用程序。注意，它并没有创建一个新进程，而是在当前进程的上下文中加载并运行新程序。 来看一个综合运用上面的东西的例子吧： #include &lt;stdio.h> #include &lt;stdlib.h> #include &lt;unistd.h> #include &lt;sys/wait.h> int main() &#123; pid_t pid; pid = fork(); if (pid &lt; 0) &#123; perror(\"fork failed\"); exit(1); &#125; else if (pid == 0) &#123; // 子进程 printf(\"Child process (PID: %d) running...\\n\", getpid()); // 使用 execve 加载并运行 \"ls\" 程序 char *argv[] = &#123;\"/bin/ls\", NULL&#125;; // 参数列表 char *envp[] = &#123;NULL&#125;; // 环境变量列表 execve(\"/bin/ls\", argv, envp); // 如果 execve 返回，说明执行失败 perror(\"execve failed\"); exit(1); &#125; else &#123; // 父进程 printf(\"Parent process (PID: %d), waiting for child (PID: %d)...\\n\", getpid(), pid); // 使用 waitpid 等待子进程终止并回收 int status; waitpid(pid, &amp;status, 0); // 阻塞等待子进程 pid 结束 if (WIFEXITED(status)) &#123; printf(\"Child exited with status %d\\n\", WEXITSTATUS(status)); &#125; &#125; return 0; &#125; 信号信号允许内核异步通知目标进程发生了特定事件。 发送和接收信号发送信号信号可以由内核自动生成，例如： 当某个子进程的状态发生变化时（比如终止、暂停、恢复），内核会发送一个 SIGCHLD 信号给父进程； 当某个进程尝试除以 0 时，内核会发送一个 SIGFPE 信号给该进程。此外，进程也可以通过 kill 函数手动请求内核向其他进程发送信号。 接收信号当内核将信号传递给目标进程，并迫使进程对此信号采取行动（例如执行信号处理程序或默认行为）时，进程就接收了该信号。需要注意的是，如果信号被阻塞或暂时未处理，它不会被视为“已接收”，而是进入待处理状态。 我们能用 signal 函数修改接收信号后的行为。 未接收的信号会怎样？如果信号发出后未被立即接收，它会变成一个待处理信号。内核为每个进程维护一个表示待处理信号的位向量（pending signal bit vector），用以追踪有哪些信号尚未处理。由于信号不排队，同一时刻同一类型的待处理信号最多只有一个（即位向量中该位被置为 1）。如果某个类型已经有了待处理信号，被发送过来的同类信号会被简单地丢弃。此外，内核还为每个进程维护一个表示被阻塞信号的位向量（blocked signal bit vector），用来记录当前被屏蔽、不允许传递的信号。 异步的风险下面的例子很好地说明了异步的风险 #include \"csapp.h\" volatile sig_atomic_t pid; void sigchld_handler(int s) &#123; int olderrno = errno; pid = waitpid(-1, NULL, 0); // 在子进程终止后更新pid errno = olderrno; &#125; void sigint_handler(int s) &#123; &#125; int main(int argc, char **argv) &#123; sigset_t mask, prev; Signal(SIGCHLD, sigchld_handler); // 在子进程终止后更新pid Signal(SIGINT, sigint_handler); Sigemptyset(&amp;mask); Sigaddset(&amp;mask, SIGCHLD); while (1) &#123; Sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev); /* Block SIGCHLD */ if (Fork() == 0) &#123; /* Child */ exit(0); &#125; /* Parent */ pid = 0; // 我们 block 信号，这样即使子进程在这条语句前终止，pid也能正确更新 Sigprocmask(SIG_SETMASK, &amp;prev, NULL); /* Unblock SIGCHLD */ /* Wait for SIGCHLD to be received (wasteful) */ while (!pid) &#123; pause(); // 潜在的竞争！ &#125; /* Do some work after receiving SIGCHLD */ printf(\".\"); &#125; exit(0); &#125; 先来看看下面的局部代码： Sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev); /* Block SIGCHLD */ if (Fork() == 0) &#123; /* Child */ exit(0); &#125; /* Parent */ pid = 0; // 我们 block 信号，这样即使子进程在这条语句前终止，pid也能正确更新 Sigprocmask(SIG_SETMASK, &amp;prev, NULL); /* Unblock SIGCHLD */ 如果不使用 block，而子进程在 pid=0 这条语句前终止，那么信号处理程序会先把 pid 设置为子进程 pid，然后 pid 被重置为 0，导致我们没能正确记录 pid。这就是阻塞信号的重要性。 再来看看这里： while (!pid) &#123; pause(); // 潜在的竞争！ &#125; 我们的原意是在没有接收到信号时暂停，以避免空循环浪费处理器资源。具体来说，在收到子进程终止的信号后 pause 状态会结束，然后执行信号处理代码，然后进入下一个循环。 但这个 pause 带来了潜在的竞争。比如说，如果在 while 测试后和 pause 前收到信号，之后又没有别的信号，pause 就会进入永久睡眠。这就是竞争的风险。 对这个例子，解决办法是用 sigsuspend 替换 pause，我们不多说了。","categories":[{"name":"公开课","slug":"公开课","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"CMU-15-213","slug":"公开课/CMU-15-213","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/"},{"name":"Notes","slug":"公开课/CMU-15-213/Notes","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/Notes/"}],"tags":[]},{"title":"Cachelab理论分析","slug":"learning/open-course/CMU-15-213/Labs/Cachelab","date":"2025-03-26T10:37:28.000Z","updated":"2025-08-22T03:14:43.981Z","comments":true,"path":"wiki/learning/open-course/CMU-15-213/Labs/Cachelab/","permalink":"http://rinevard.github.io/wiki/learning/open-course/CMU-15-213/Labs/Cachelab/","excerpt":"","text":"img{ width: 60%; } 先放一个最终结果在这里 Part A 模拟 cache用时 3h. 一开始因为 16 进制踩了坑。我第一个看的 trace 文件是 yi.trace，我把里面的地址当成了十进制，分析了半天总感觉不对，后来惊醒这是十六进制。 part A 不难，正常模拟一遍就好。由于 handout 里说，“you should assume that memory accesses are aligned properly, such that a single memory access never crosses block boundaries”，所以对每行记录，我们只要考虑其指令类型和地址即可，不必考虑操作大小。我使用了这样的数据结构： typedef struct &#123; int valid; unsigned long lineTag; int lruCount; // 记录上一次访问到现在的时间 &#125; CacheLine; typedef struct &#123; CacheLine *lines; &#125; CacheSet; CacheSet *sets = malloc((1 &lt;&lt; s)* sizeof(CacheSet)); 在核心循环里，对某个给定的 set，我们在遍历过程中从前往后填充每个 set 的 line，思路如下： 对每个地址，用位运算得到其 setIdx 和 tag，然后找到对应的 set，遍历里面的所有 line. 如果找到了空 line，直接填充进去；如果找到了对应的 tag，就 hit 了；如果没找到对应 tag，说明需要驱逐某个 line，找到 lru 最大的 line（即最久没有访问过的 line）并把它换掉即可。 注意正确更新遍历的 set 里的每个 line 的 lruCount. 用下面的位运算就能得到 setIdx 和 tag： unsigned long mask = -1; mask = ~(mask &lt;&lt; s); // 000...11 (s 个 1) unsigned long setIdx = (address >> b) &amp; mask; unsigned long tag = address >> (b + s); 还有一个小 trick 是可以用这样的写法来简化代码，毕竟我们并不关心操作在类型上的差异，只关心操作的地址： switch (operation) &#123; case 'M': // M = L + S, 其 'S' 总会命中 hits++; // fall through case 'L': // fall through case 'S': // 真正的工作 &#125; Part B用时 7 h，拼尽全力也只能把 64x64 拿到 1411 miss，上网找了找别人的思路，最后得到了 1179 miss. 最后结果如下： Points Max pts MissesTrans perf 32x32 8.0 8 287Trans perf 64x64 8.0 8 1179Trans perf 61x67 10.0 10 1997 我参考的文章是这篇： CSAPP - Cache Lab 的更(最)优秀的解法 - 知乎，作者直接拿到了 64x64 的理论最优解，非常强大。不过我没有在对角线上做微调，而是只参考了作者对一般块的读写顺序。 我的三个转置都没有特别考虑对角线的情况。一方面是因为嫌麻烦，另一方面是因为我觉得这种“两个内存块位置恰好差 2 的幂次导致缓存抖动”的事情太特殊，所以没额外处理。 分块大小的确定首先，分块优化是一定要做的。但分成多大的块呢？最朴素的想法是，我们希望块尽可能大来装满 cache，但不要太大以至于 cache 装不下。 我们有 $2^5 = 32$ 个 sets，每个 set 一个 line，每个 line 存 8 个 int，也就是说，我们最多能存 $32 \\times 8 = 256 = 2^8$ 个 int. 我们希望同时把 A 的块和 B 的块放到 cache 中，两个块大小应当相同，所以每个块可以放 $256/2 = 128$ 个 int. 128 不是完全平方数，所以我们可以分块成 8x8. 初版代码回到之前的 8x8 分块的讨论上来。总之，我写出了我的初版代码。思路就是分块，然后把 A 的块存到 tmp 数组里，然后复制到 B 里。为什么要用 tmp 做中转呢？答案是为了避免缓存冲突： void transpose_submit(int M, int N, int A[N][M], int B[M][N]) &#123; int blockSize = 8; int rowBlock, colBlock, i, j; // 向上取整, 计算出总 block 数. // 可能会含有不是正方形的 block int rowBlocks = (N + blockSize - 1) / blockSize; int colBlocks = (M + blockSize - 1) / blockSize; int tmp[blockSize][blockSize]; // cachelab不允许开数组 for (rowBlock = 0; rowBlock &lt; rowBlocks; rowBlock++) &#123; for (colBlock = 0; colBlock &lt; colBlocks; colBlock++) &#123; for (i = rowBlock * blockSize; i &lt; (rowBlock + 1) * blockSize &amp;&amp; i &lt; N; i++) &#123; for (j = colBlock * blockSize; j &lt; (colBlock + 1) * blockSize &amp;&amp; j &lt; M; j++) &#123; tmp[j - colBlock * blockSize][i - rowBlock * blockSize] = A[i][j]; &#125; &#125; for (j = colBlock * blockSize; j &lt; (colBlock + 1) * blockSize &amp;&amp; j &lt; M; j++) &#123; for (i = rowBlock * blockSize; i &lt; (rowBlock + 1) * blockSize &amp;&amp; i &lt; N; i++) &#123; B[j][i] = tmp[j - colBlock * blockSize][i - rowBlock * blockSize]; &#125; &#125; &#125; &#125; &#125; 结果很不错： Cache Lab summary:Points Max pts MissesTrans perf 32x32 8.0 8 261Trans perf 64x64 8.0 8 1029Trans perf 61x67 10.0 10 1725 正当我觉得 cachelab 不过如此的时候，忽然发现 handout 里写了不允许开数组（哈哈，你想得到的 cmu 老师想不到吗），于是被迫手动展开了 j 循环，使用 8 个变量来读取每行的值。这就得到了下面的结果： Cache Lab summary:Points Max pts MissesTrans perf 32x32 8.0 8 287Trans perf 64x64 0.0 8 4611Trans perf 61x67 10.0 10 1997 也还算不错吧，毕竟 32x32 和 61x67 都满分了。唯一的问题是 64x64 的性能奇差无比。 分析 64x64 矩阵的 miss 次数这时候就要理论分析了。对 64x64 的矩阵，按我们之前的做法，每个 8x8 的块大约发生了多少次 miss 呢？ 答案是 72 次。A 提供了 8 次 miss，B 提供了 64 次 miss 验证一下结果对不对：64x64 的矩阵共有 64 个 8x8 的块，64 个块每个块 72 次 miss，总计约 $64 \\times 72=4608$ 次 miss，和结果 4611 次 miss 相差无几。 这个 miss 是怎么算出来的呢？让我们看看下图： 对 64x64 的矩阵来说，B[x][y] 和 B[x+4][y] 的 setIdx 相同，这就导致我们之前的方法不断驱逐旧 line. 定量地说，每读 A 的块的一行，大约是 1 个 miss，A 的块共有 8 行，所以 A 的每个块提供 8 次 miss；每对 B 的块写入一个值，都驱逐了一次旧 line（因为 B[x+4][y] 会驱逐 B[x][y]），所以 B 的每个块提供 64 次 miss. 之后的工作就是找到方法来避免这种驱逐了。 对 64x64 矩阵的第一次优化——1699一开始我的思路是直接用 4x4 的块，这确实有不小优化，但离满分还很远。读者可以试着做一个理论分析看看 4x4 的结果大概是多少 miss。我分析出来会得到 1536 个 miss，实际结果是 1699 个 miss，也差不多吧。 好吧，这个理论分析看起来值得详细讲解一下。不过在写之前，希望读者自己分析一下，看看得到的结果是不是 2048，并想想哪里出错了： 如果块的大小是 4x4，每个块发生 4 次 miss，每个矩阵 256 个块，一共 2048 次 miss，看起来很合理。但这是理论最优解，为什么理论最优（2048）比实际结果（1699）还差呢？难道说数学的大厦崩塌了？ 并非如此。事实上，在我们把某个 4x4 的块放入 cache 时，我们也同时把它的右边的那个 4x4 的块放入了 cache。这是因为 cache 的每个 line 能装 8 个 int. 也就是说，我们可以认为我们实际上是在处理 4x8 的块。对每个 4x8 的块，A 提供了 4 次 miss，B 提供了 8 次 miss，总计 $64 4 + 64 8 = 1536$ 次 miss. 对 64x64 矩阵的第二次优化——1411分析了那么多，还是没拿到满分。我的后续思路是把 8x8 的块再分成四个小块，并按下面的顺序来写入 B： 理论分析一下，把 A1 写入 B1 时，A miss 4 次，B miss 4 次； 把 A2 写入 B2 时，A miss 4 次，B 没有 miss（因为写入 B1 时把 B2 放进了 cache）； 把 A3 写入 B3 时，A 没有 miss，B miss 4 次；（因为读 A2 时把 A3 放入了 cache）； 把 A4 写入 B4 时，A miss 4 次，B 没有 miss（因为写入 B3 时把 B4 放进了 cache） 总计 20 次 miss，理论最优解 1280，实际结果 1411，我猜问题出在对角线上，我也懒得在这个基础上继续优化了。优化对角线这种事情看起来就很麻烦，而且感觉现实里几乎不会遇见这种情况。 对 64x64 矩阵的第二次优化——1179没什么好说的，直接看 CSAPP - Cache Lab 的更(最)优秀的解法 - 知乎 和代码吧。这篇文章的作者拿到了 64x64 的理论最优解，非常强大。不过我没有在对角线上做微调，而是只参考了作者对一般块的读写顺序。 void transpose_submit_64x64(int M, int N, int A[N][M], int B[M][N]) &#123; int blockSize = 8; int rowBlock, colBlock, i, j; int rowBlocks = (N + blockSize - 1) / blockSize; int colBlocks = (M + blockSize - 1) / blockSize; int tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7; for (rowBlock = 0; rowBlock &lt; rowBlocks; rowBlock++) &#123; for (colBlock = 0; colBlock &lt; colBlocks; colBlock++) &#123; // A上 for (i = rowBlock * blockSize; i &lt; rowBlock * blockSize + blockSize / 2 &amp;&amp; i &lt; N; i++) &#123; // 读取A的一行 tmp0 = A[i][colBlock * blockSize]; tmp1 = A[i][colBlock * blockSize + 1]; tmp2 = A[i][colBlock * blockSize + 2]; tmp3 = A[i][colBlock * blockSize + 3]; tmp4 = A[i][colBlock * blockSize + 4]; tmp5 = A[i][colBlock * blockSize + 5]; tmp6 = A[i][colBlock * blockSize + 6]; tmp7 = A[i][colBlock * blockSize + 7]; // 填充B左上 B[colBlock * blockSize][i] = tmp0; B[colBlock * blockSize + 1][i] = tmp1; B[colBlock * blockSize + 2][i] = tmp2; B[colBlock * blockSize + 3][i] = tmp3; // 填充B右上, 这一部分未来会被放到B左下 B[colBlock * blockSize][i + blockSize / 2] = tmp4; B[colBlock * blockSize + 1][i + blockSize / 2] = tmp5; B[colBlock * blockSize + 2][i + blockSize / 2] = tmp6; B[colBlock * blockSize + 3][i + blockSize / 2] = tmp7; &#125; // A左下, 注意这里按列遍历 for (j = colBlock * blockSize; j &lt; colBlock * blockSize + blockSize / 2 &amp;&amp; j &lt; M; j++) &#123; // 读取 A 的左下小块的一列 tmp0 = A[rowBlock * blockSize + blockSize / 2][j]; tmp1 = A[rowBlock * blockSize + blockSize / 2 + 1][j]; tmp2 = A[rowBlock * blockSize + blockSize / 2 + 2][j]; tmp3 = A[rowBlock * blockSize + blockSize / 2 + 3][j]; // 读取 B 的右上小块的一行 tmp4 = B[j][rowBlock * blockSize + blockSize / 2]; tmp5 = B[j][rowBlock * blockSize + blockSize / 2 + 1]; tmp6 = B[j][rowBlock * blockSize + blockSize / 2 + 2]; tmp7 = B[j][rowBlock * blockSize + blockSize / 2 + 3]; // 把从 A 左下读到的内容写到 B 右上 B[j][rowBlock * blockSize + blockSize / 2] = tmp0; B[j][rowBlock * blockSize + blockSize / 2 + 1] = tmp1; B[j][rowBlock * blockSize + blockSize / 2 + 2] = tmp2; B[j][rowBlock * blockSize + blockSize / 2 + 3] = tmp3; // 把 B 右上的内容写到 B 左下 B[j + blockSize / 2][rowBlock * blockSize] = tmp4; B[j + blockSize / 2][rowBlock * blockSize + 1] = tmp5; B[j + blockSize / 2][rowBlock * blockSize + 2] = tmp6; B[j + blockSize / 2][rowBlock * blockSize + 3] = tmp7; &#125; // A右下 for (i = rowBlock * blockSize + blockSize / 2; i &lt; (rowBlock + 1) * blockSize &amp;&amp; i &lt; N; i++) &#123; // 读取A的一行 tmp0 = A[i][colBlock * blockSize + blockSize / 2]; tmp1 = A[i][colBlock * blockSize + blockSize / 2 + 1]; tmp2 = A[i][colBlock * blockSize + blockSize / 2 + 2]; tmp3 = A[i][colBlock * blockSize + blockSize / 2 + 3]; // 填充B B[colBlock * blockSize + blockSize / 2][i] = tmp0; B[colBlock * blockSize + blockSize / 2 + 1][i] = tmp1; B[colBlock * blockSize + blockSize / 2 + 2][i] = tmp2; B[colBlock * blockSize + blockSize / 2 + 3][i] = tmp3; &#125; &#125; &#125; &#125; Future work写文章的时候突然想到我们似乎可以分长方形的 16x8 的块，因为 $1682 = 256$ 可以完全填满 cache. 简单写了下代码得到了下面的结果： [16x8]Points Max pts MissesTrans perf 32x32 8.0 8 287Trans perf 61x67 10.0 10 1811看起来效果出乎意料地不错？甚至比我的 8x8 分块效果更好。这里没有放进来 64x64 转置的结果，因为我没有做分小块的优化。所以说，这种方法说不定还有不小探索空间？ 下面是我的 8x8 分块的结果，可以用来和上面的结果做比较。两个代码都只用了简单的分块和 8 个 tmp 变量，没有额外优化。 [8x8] Points Max pts MissesTrans perf 32x32 8.0 8 287Trans perf 61x67 10.0 10 1997 这里是我使用的 16x8 的分块代码： void transpose_submit(int M, int N, int A[N][M], int B[M][N]) &#123; int blockRow = 16; // 块的行数 int blockCol = 8; // 块的列数 int rowBlock, colBlock, i, j; // 向上取整, 计算出总 block 数 int rowBlocks = (N + blockRow - 1) / blockRow; int colBlocks = (M + blockCol - 1) / blockCol; int tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7; for (rowBlock = 0; rowBlock &lt; rowBlocks; rowBlock++) &#123; for (colBlock = 0; colBlock &lt; colBlocks; colBlock++) &#123; for (i = rowBlock * blockRow; i &lt; (rowBlock + 1) * blockRow &amp;&amp; i &lt; N; i++) &#123; // 展开j循环，每次处理8个元素 j = colBlock * blockCol; if (j &lt; M) tmp0 = A[i][j]; if (j + 1 &lt; M) tmp1 = A[i][j + 1]; if (j + 2 &lt; M) tmp2 = A[i][j + 2]; if (j + 3 &lt; M) tmp3 = A[i][j + 3]; if (j + 4 &lt; M) tmp4 = A[i][j + 4]; if (j + 5 &lt; M) tmp5 = A[i][j + 5]; if (j + 6 &lt; M) tmp6 = A[i][j + 6]; if (j + 7 &lt; M) tmp7 = A[i][j + 7]; // 写入B矩阵 if (j &lt; M) B[j][i] = tmp0; if (j + 1 &lt; M) B[j + 1][i] = tmp1; if (j + 2 &lt; M) B[j + 2][i] = tmp2; if (j + 3 &lt; M) B[j + 3][i] = tmp3; if (j + 4 &lt; M) B[j + 4][i] = tmp4; if (j + 5 &lt; M) B[j + 5][i] = tmp5; if (j + 6 &lt; M) B[j + 6][i] = tmp6; if (j + 7 &lt; M) B[j + 7][i] = tmp7; &#125; &#125; &#125; &#125;","categories":[{"name":"公开课","slug":"公开课","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"CMU-15-213","slug":"公开课/CMU-15-213","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/"},{"name":"Labs","slug":"公开课/CMU-15-213/Labs","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/Labs/"}],"tags":[]},{"title":"_玩乐的人","slug":"others/thoughts/玩乐的人","date":"2025-03-24T11:09:30.000Z","updated":"2025-07-18T15:09:38.986Z","comments":true,"path":"wiki/others/thoughts/玩乐的人/","permalink":"http://rinevard.github.io/wiki/others/thoughts/%E7%8E%A9%E4%B9%90%E7%9A%84%E4%BA%BA/","excerpt":"","text":"故事之前最近在学查理老师的编剧课，课很有趣，不过信息密度似乎有点低，我就当单口相声听了。这篇文章记录了第五课老师布置的作业，故事的八要素、支点和大纲是我自己写的，具体内容是 AI 填充的，我把 AI 生成的多个版本拼拼凑凑得到了下面的故事（什么拼好文）。 最近的思绪挺乱的。前两天做了个游戏原型，感觉大体上还算值得做，暂命名叫《翻命师》。这样的话，想做的事情实在是有点多了。想参加 GSoC 来接触下开发，顺便提升下 cpp 水平；想继续学公开课，了解下底层知识；还想花 100 天完整地做一个能放到 itch 甚至 steam 上的小游戏，跑一遍流程。 说来有些凡尔赛，但上学期的成绩好得有点莫名其妙，以至于我真的开始考虑外保之类的事情。这就导致我们真的陷入了一个奇怪的“保研开发两手抓”的境地，但我的水平却不足以支持我把它们全部抓牢，于是便深感时间紧张。全抓牢真的不可能吗？如果是我的话说不定也能做到呢，但这样的生活是否缺乏了一抹奇幻色彩呢？比起把绝大多数时间都花在自我实现和提升自己的水平上，我还是想抽出时间来学学新东西，看看番剧，打打游戏。再说了，现在的社交水平仍然是负的，是不是该去提升一下？原本想着靠找人来试玩来和人们交流，但这又回到了开发上。虽然这看起来是条可行的路，但感觉有点点奇怪。 人生短则二十年，长则一百年，我们究竟想做什么，想去往何方，想成为什么样的人？ 前路未定却仍试图看向未来，自会焦虑。不过我喜欢的一个虚拟角色在这种情况下想必会说：“焦虑也是一种不可多得的体验呢”。喜悦和平静自然是大家都喜欢的体验，但焦虑、悲伤这些负面情绪似乎也是奇妙的体验。人类，很神奇吧。 话说回来，翻命师这个名字听起来就很有趣吧。听说为自己摆个”过路牌阵”，一行三牌，便能解一时之困。我回去摆一下试试。 在 101 发了个没那么凡尔赛的版本。我在认真思考，BIT101 对我来说究竟意味着什么。我从未想过立一个很厉害的人设，但我在发帖时总会不自觉地只展示看起来不错的一面，于是渐渐地就只写出了一些“局部的真实”。 那我是怎么发现这个版本有点凡尔赛的呢？答案是让 AI 写了一个翻版。我要求 AI 把和游戏、编程相关的内容换成别的领域的内容，就得到了本文中“故事之后——AI 的凡尔赛”那一节的内容。看了看，感觉真的好凡尔赛啊=) 于是就改了改。如果我真的很厉害就好了，可惜我并不。但我会变强的。 故事——玩乐的人“姓名？” “李明。” “年龄？” “呃……十七岁？” 检票员扫了他一眼，最后只是叹了口气，挥手放行。 李明现年 32 岁，身高 169 厘米，体重 61.5 公斤，没有女朋友，没有宠物，没有不良嗜好。在李明居住的城市里，所有 20 岁以上的成年人都按照同样的程序生活：起床、工作、吃饭、睡觉，偶尔参加培训、会议和团建活动。政府颁布的《成年人行为准则》明确规定，成年人的首要任务是工作，次要任务是为国家培养合格公民，第三任务是照顾老人，第四任务是自我提升。第十七条特别强调：成年人严禁进入游乐设施。 现在他站在游乐园入口处，身上裹着一件印着卡通恐龙的 T 恤，下半身穿着一条明显短了一截的背带裤，脚上是一双带灯的运动鞋。他的脸上贴着两块大号创可贴，试图掩盖胡茬的痕迹。 李明小心翼翼地走进游乐园，手里握着一根棒棒糖，时不时紧张地舔一口，假装自己对糖果很感兴趣。实际上，他上一次吃棒棒糖还是在十三岁那年。 “嘿！你在这里干嘛呀？你家大人呢？”一个游乐园工作人员走过来问道。 “我爸爸去买饮料了，让我在这里等他。”李明背了五遍的标准答案脱口而出。 工作人员上下打量了他几眼：”你多大了？看起来挺高的。” “我发育得早，十七岁。”李明掏出事先准备好的学生证，那是他从网上特意定制的。 工作人员勉强相信了他的说法，转身离开。李明松了一口气，迅速往旋转木马方向走去。 旋转木马上，李明紧紧抓住金色的扶手，感受着上下起伏的节奏。音乐响起，木马开始旋转，李明的心跳加速，一种奇怪的快感从脚底蔓延到全身。他已经记不清上一次有这种感觉是什么时候了。 “你也是一个人来的吗？”旁边的木马上，一个大约九岁的小女孩问道。 李明僵硬地点点头。 “我也是！我妈妈在那边，”小女孩指着远处一个看手机的女人，”她说自己太忙了，没时间陪我玩。大人们总是很忙。” 李明想起自己的父母。他们在李明八岁时就告诉他：”玩是没有出息的表现。”十二岁时，他们卖掉了他所有的玩具，换成了各种学习资料。十八岁时，他们为他制定了”成功人生规划表”，上面没有一项与娱乐有关。三十岁时，他们送给他一套”友爱公寓”的首付款，条件是他必须在十年内获得三次职位晋升。 木马停下来后，李明迫不及待地跑向过山车。排队时，他故意弯着腰，装作比实际身高矮一些。轮到他时，检查身高的工作人员狐疑地看了他一眼：”你确定要玩吗？看起来有点紧张。” “我当然要玩！”李明用他练习过的童声说，声音因为紧张而有些发抖。 过山车启动了，缓缓爬升。李明死死抓住安全杆，心脏几乎要跳出胸膛。风呼啸着掠过耳边，李明感到一种前所未有的自由。当车厢俯冲而下时，他放声尖叫，那是他 32 年人生中第一次如此肆无忌惮地尖叫。 下了过山车，李明头晕目眩，但脸上挂着难以抑制的笑容。他感觉脖子有点僵硬，下意识地左右轻轻晃动了一下，缓解那股熟悉的酸痛。这是他工作十年养成的习惯——每天盯着电脑十小时，颈椎早已不堪重负。 李明决定接着去玩碰碰车。坐进小车里，他像个真正的十七岁少年一样兴奋地抓紧方向盘。电流接通，车子启动，李明猛踩油门冲向前方。左冲右撞间，他又感到脖子一阵刺痛。他条件反射地做起了办公室保健操第三式：双手托住后脑勺，缓慢向后拉伸。 一位游乐园的医护人员恰好路过，看到了李明标准的颈椎操动作。她驻足观察了几秒，然后走到碰碰车场地边缘。 “这套颈椎病保健操做得不错啊，先生。”医护人员在李明经过时大声说道，”是职业医师教的吧？” 李明一惊，猛地回头，车子失控撞上了场地边缘。 “什么？不不不，我只是……”李明慌乱地摆手，”我……”他张了张嘴，最终还是像泄了气的气球一样瘫在碰碰车里，放弃了辩解。 医护人员按下对讲机：”安保部，A 区有一位违规进入的成年人。” 两名保安赶到，架起李明就往外走。路过旋转木马时，李明忍不住回头看了一眼，那些五颜六色的小马依然在音乐声中旋转，仿佛在向他告别。他的真实身份被确认：”李明，32 岁，工程师，违反《成年人行为准则》第十七条。” 两个小时后，他被直接送往了”成年人再教育中心”。 在那里，他被迫学习如何做一个”成熟的大人”：每天工作十小时，严肃阅读财经新闻，周末必须去公园遛狗或者喝咖啡，以塑造”符合社会期待的成年形象”。 故事之后——AI 的凡尔赛最近在学余老师的诗歌创作课，课很有趣，不过信息密度似乎有点低，我就当单口相声听了。这篇文章记录了第五课老师布置的作业，诗歌的意象、结构和情感是我自己构思的，具体内容是借助写作软件润色的，我把几个版本拼拼凑凑得到了下面的作品（什么拼好诗）。 最近的思绪挺乱的。前两天构思了个摄影专辑创意，感觉大体上还算值得做，暂命名叫《时光师》。这样的话，想做的事情实在是有点多了。想投稿一些文学期刊来接触文坛，顺便提升下文笔水平；想继续研读一些经典著作，了解下文学理论；还想花 100 天完整地做一个能放到豆瓣甚至出版社投稿的诗集，跑一遍流程。 说来有些凡尔赛，但上学期的文学竞赛成绩意外地好，以至于我真的开始考虑考研中文系或者去杂志社实习之类的事情。这就导致我们真的陷入了一个奇怪的”学术与创作两手抓”的境地，但我的水平却不足以支持我把它们全部抓牢，于是便深感时间紧张。全抓牢真的不可能吗？如果是我的话说不定也能做到呢，但这样的生活是否缺乏了一抹奇幻色彩呢？比起把绝大多数时间都花在自我实现和提升自己的水平上，我还是想抽出时间来阅读新书，看看番剧，去咖啡馆发呆。再说了，现在的社交水平仍然是负的，是不是该去提升一下？原本想着靠办读书会来和人们交流，但这又回到了文学上。虽然这看起来是条可行的路，但感觉有点点奇怪。 人生短则二十年，长则一百年，我们究竟想做什么，想去往何方，想成为什么样的人？ 前路未定却仍试图看向未来，自会焦虑。不过我喜欢的一个虚拟角色在这种情况下想必会说：”焦虑也是一种不可多得的体验呢”。喜悦和平静自然是大家都喜欢的体验，但焦虑、悲伤这些负面情绪似乎也是奇妙的体验。人类，很神奇吧。 话说回来，时光师这个名字听起来就很有诗意吧。听说为自己摆个”诗意三行”，记录三个瞬间，便能解一时之困。我回去试试。 翻命师这江湖之上，有一门玄门奇术，叫做”翻命一术”，修习此术之人，世人唤作”翻命师”。 这翻命师不比寻常江湖术士，既不是掐指一算的算命先生，也不是敲盆问卦的游方道人。他们修的，乃是上古传下来的翻命秘术。但凡有人求问命途，这翻命师便能施展异术，将那人前程化作一张张命运符牌，一一摆在案上。 这牌阵大小不一，全看机缘深浅。小则一行三牌，称为”过路牌阵”，多解一时之困；中则三行五牌，名唤”三星照命”，为那命途多舛之人寻觅转机；若遇命格复杂之人，或是牵连多人的大事，定要摆下五行七列的”天罗地网阵”，方能窥得命运全貌。 却说这符牌玄妙非常。翻开一张，或显凶险，或现吉祥。翻命师观之，便知那人命中该有何等机缘。其技高者，还能将那不利的命数重新封回牌中，暂时封住那眼看就要降临的灾祸！ 江湖传闻，翻命师之术，非是逆天改命，乃是巧借天机。如同棋盘残局，看似已无生路，翻命师却能寻那缝隙间微妙一着，引得命运暗流转向。明是命中注定，实则皆由人心一念之差。高明的翻命师，不过是将那本就存在的可能，向明处轻推罢了。 无论如何在做原型之前都不应该写剧情。不过我做了原型！所以我可以写一点点剧情了吧，虽然这段背景故事也大多是 AI 写的。","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/"},{"name":"碎碎念","slug":"杂谈/碎碎念","permalink":"http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}],"tags":[]},{"title":"第六章——存储器层次结构","slug":"learning/open-course/CMU-15-213/Notes/Chapter6-memory-and-cache","date":"2025-03-20T03:26:01.000Z","updated":"2025-08-22T03:14:43.982Z","comments":true,"path":"wiki/learning/open-course/CMU-15-213/Notes/Chapter6-memory-and-cache/","permalink":"http://rinevard.github.io/wiki/learning/open-course/CMU-15-213/Notes/Chapter6-memory-and-cache/","excerpt":"","text":"存储器层次结构存储器有多种类型，我们可以根据访问速度把他们排成金字塔结构。靠近上面的访问速度快，靠近下面的访问速度慢。每一层都作为下面一层的缓存（cache），即从下面一层读取数据来加快访问速度： 下图比较了不同存储器的访问速度 局部性局部性分为空间局部性和时间局部性。前者指如果一个内存位置被引用，程序可能在将来引用附近的一个内存位置；后者指如果一个内存位置被引用，程序可能在将来再次引用它。 为什么我们希望程序有较好的局部性呢？这是因为访问 cache 比访问 cache 下面一层要快，而 cache 的大小有限，因此我们希望尽可能访问 cache 里的数据。而 cache 存储的数据在空间上和时间上都有一定连续性（参考下面的“高速缓存”一节），所以我们希望程序的局部性好。 如果我们引用了不在 cache 中的数据，这就被称作“缓存不命中”（命中为 “hit”，不命中为“miss”），从而要把 cache 下面一层的数据复制到 cache 中，这是很慢的。 举个例子，一般来说，数组的局部性比链表好，因为链表的地址往往是碎片化的。 高速缓存高速缓存的结构如图所示： 让我们推测一下 line 和 set 是怎么设计出来的。 我们的核心思路是尽量减少高速缓存和主存间交换数据的次数。如果我们能预知未来，我们只要根据未来尽可能把高速缓存填满未来会读的值，然后在需要新值时再读一次就好了。 显然我们不能预知未来，所以我们希望每次的数据交换都尽可能多带来一些“未来可能用到的数据”。所以我们把高速缓存划分成若干个 line，每个 line 都存储一组连续的地址的数据。毕竟如果读到了一个地址，有理由认为它附近的地址在将来会被读到。 上图给出了 line 的可视化，我们把数据存储在 data 段中，共存储 B 个 bytes. 但只是读取连续的一段是不够的。在下图中，我们把主存中需要用到的地址标红。这两种情况中，我们认为右边那种情况更可能在运行时发生，所以我们希望实现多个 set. 如果每个 set 只有一个 line，就实现了直接映射高速缓存。如果每个 set 有多个 line，就实现了组相联高速缓存。 读接下来我们讲讲如何读取数据，我们以组相联高速缓存为例，毕竟直接映射是组相联的特殊情况。 这里的思路是根据地址找到高速缓冲中对应的 set，然后检查 set 的 line 中是否有当前地址。 我们把每个地址划分为三个部分，tag 部分、组索引部分、偏移部分。组索引部分在中间，耗费 $\\log_2 S$ 个位，用于定位对应的组；tag 部分在最前，占据地址剩下的位置，用于和每个 line 的 tag 作比较从而确定是否有与地址对应的 line；偏移部分在最后，耗费 $\\log_2 B$ 个位，用于在找到对应的 line 以后找到对应的数据位置。 所以，对给定的地址，我们先找到它的组索引部分，从而定位对应的组，然后把组里的所有 line 的 tag 和地址的 tag 比较，找到相同的 tag 以后就算是成功命中，然后根据偏移获取对应的值。 如果没找到相同的 tag 呢？这就是不命中了，这时就要让主存和 cache 间交换数据，选一个 line（一般是一组间最久没有被使用的那个）把它替换掉。 写写比读复杂很多，书上没详细讲，所以我们只是简要提一下。 一个比较靠谱的思路是检查要写的地址是否在 cache 中，如果在就直接写 cache，并标记那个位置为“已修改”。如果不在 cache 中，就像读一样，把那个地址拿到 cache 里来，然后覆写。在 cache 的任何一个地址被覆盖掉时，检查那个地址的值是否已修改，如果修改则覆写主存上的值。 这种做法叫做写回（write-back），尽可能地推迟更新。 要注意的是，由于写是可以推迟的，所以写一般比读要快。 性能例子Memory Mountain——数组大小和访问步长影响性能 这张图是对一个大小为 size 的数组以 stride 为步长求和的性能比较。 注意到随着 size 增大，我们愈发往存储器层次结构下面走（比如说，L1 不足以装下所有数据了，我们就不得不走到 L2），同时每走一层时间都有一个猛增。 随着 stride 增大，缓存命中率越来越低，耗时越来越大，直到某个临界点，每次都不命中。 缓存命中影响性能——以矩阵乘法为例假设我们在做矩阵乘法，我们的高速缓存的每个 line 的 block 能装下 $K$ 个值。 循环顺序对性能的影响版本 1 是 ijk 循环，a 是行遍历，b 是列遍历，c 不在最内存循环内所以不计性能损耗。对 a 来说，每经过 K 个值，就有一次不命中；对 b 来说，每次都不命中。我们可以认为有这样的缓存不命中率： a b c 1 / K 1 0 // 版本1 for (i=0; i&lt;n; i++) &#123; for (j=0; j&lt;n; j++) &#123; sum = 0.0; for (k=0; k&lt;n; k++) sum += a[i][k] * b[k][j]; c[i][j] = sum; &#125; &#125; 如果把循环顺序改成 ikj，就能得到更好的性能。 这时 a 不在最内层循环，不计性能损耗，b 是行遍历，c 也是行遍历，我们可以认为有这样的缓存不命中率： a b c 0 1 / K 1 / K for (i=0; i&lt;n; i++) &#123; for (k=0; k&lt;n; k++) &#123; r = a[i][k]; for (j=0; j&lt;n; j++) c[i][j] += r * b[k][j]; &#125; &#125; 下图展示了六种循环顺序带来的不同效率： 最好的是 ikj 循环，我们可以简单地算出它的大概的总不命中次数。共有 $n^2$ 个值要算，没算一个值大概会不命中 $\\frac{n}{K} \\frac{n}{K}$次，因此总不命中次数大约为： n^2 \\times (\\frac{n}{K} + \\frac{n}{K})=\\frac{2n^3}{K}blocking 对性能的影响其实我们还有更好的优化手段——矩阵分块乘法： 结果里的每个 block 的计算需要访问 $\\frac{2n}{B}$ 个小 blck，每个小 block 大概会不命中 $\\frac{B^2}{K}$ 次，因此总不命中次数大约为： (\\frac{n}{B} )^2 \\times \\frac{B^2}{K}\\times \\frac{2n}{B}=\\frac{2n^3}{BK}当然，我们不能无限地增大 $B$. 对于矩阵乘法 C=A×B，我们要同时在缓存中保存 A 的一个块、B 的一个块和 C 的一个块，从而希望有类似 $3B^2 &lt; C$ 的限制（这里的 $C$ 是 cache 的 capacity）。所以尽可能选大的 block，但保证不过大就好。","categories":[{"name":"公开课","slug":"公开课","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"CMU-15-213","slug":"公开课/CMU-15-213","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/"},{"name":"Notes","slug":"公开课/CMU-15-213/Notes","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/Notes/"}],"tags":[]},{"title":"第五章——性能优化","slug":"learning/open-course/CMU-15-213/Notes/Chapter5-optimization","date":"2025-03-18T07:30:28.000Z","updated":"2025-08-22T03:14:43.982Z","comments":true,"path":"wiki/learning/open-course/CMU-15-213/Notes/Chapter5-optimization/","permalink":"http://rinevard.github.io/wiki/learning/open-course/CMU-15-213/Notes/Chapter5-optimization/","excerpt":"","text":"15213 里没讲第四章，我看了下感觉太硬件了于是就跳过了。我们从第五章继续—— 一些常见的优化手段我们就不详细说了，简单提一下有这些： 用代码剖析程序找到性能瓶颈 选好的算法 外提循环不变式 减少不必要的内存读写 循环展开技巧性太强，牺牲了可读性，而且说实话性能也没好太多，所以也不详谈。而且大多数编译器在把优化等级设得比较高时会自动做循环展开。 我们主要聊聊——编译器的局限；用 CPE 表示程序性能；指令级并行。 编译器的局限性编译器对程序只使用安全的优化，因此有些我们脑补编译器会优化的东西实际上不会被优化。 void add1(long *x1, long *x2) &#123; *x1 += *x2; *x1 += *x2; &#125; void add2(long *x1, long *x2) &#123; *x1 += *x2 * 2; &#125; 乍一看这两个函数功能相同，且下面那种读写内存次数更少，或许我们会期望编译器把上面的版本优化成下面的版本。 可其实两者功能并不完全相同。考虑两个指针指向同一个对象的情况。 因此，要很仔细才能写出编译器能顺利优化的代码。 用 CPE 表示程序性能CPE 即 Cycles Per Element，计算方法如下： CPE = Total Cycles / Number of Elements，即总周期数 / 元素数量。 实际的 CPE 值很难仅通过代码分析准确预测，需要在特定硬件、编译器配置下通过实际测试获得准确值。一般来说，我们通过性能分析工具来得到总周期数，然后根据任务得出其元素数量，从而算出 CPE。 指令级并行现代处理器并不是顺序执行指令的，顺序执行只是一种抽象。指令执行的顺序不一定要与它们在机器级程序中的顺序一致。这让我们实现了指令级并行。 这里的内容太多太硬核了，我也没理解，就只讲讲指令级并行的大体概念和流水线吧。 大体来说，处理器会分析程序里每条指令的依赖关系，从而并行执行没有依赖关系的指令。 例子： 假设我们有指令序列: 1. mov eax, [mem1] # 从内存加载数据到eax 2. add ebx, ecx # 将ebx和ecx相加，结果存入ebx 3. mul eax, 4 # 将eax乘以4 4. add edx, ebx # 将ebx和edx相加，结果存入edx 5. mov [mem2], eax # 将eax存入内存 依赖关系图: 指令1 指令2 (mov eax, [mem1]) (add ebx, ecx) | | v v 指令3 指令4 (mul eax, 4) (add edx, ebx) | v 指令5 (mov [mem2], eax) 这时我们可能就会并行执行指令 1 和指令 2. 流水线(Pipeline)流水线将单条指令的执行阶段（取指、解码、执行、访存、写回）拆分成多个步骤，每个步骤由不同的硬件单元处理，从而可以同时处理多条处于不同步骤的指令。例如，一个典型的浮点加法器包含三个阶段：一个阶段处理指数值，一个阶段将小数相加，另一个阶段对结果进行舍人。这种技术增加了吞吐量（Throughput），但单个指令的执行延迟并不会减少。 数据流图我们可以通过程序的数据流图来粗糙地分析程序的指令级并行程度。这里举一个例子应该就足够了。假设我们想算 $\\sum_{k=0}^{n}a_kx^k$，下面有两种算法： 在 poly 中，我们共做了 n 次加法，2n 次乘法 double poly(double a[], double x, long degree) &#123; long i; double result = a[0]; double xpwr = x; /* Equals x^i at start of loop */ for (i = 1; i &lt;= degree; i++) &#123; result += a[i] * xpwr; xpwr = x * xpwr; &#125; return result; &#125; 在 polyh 中，我们共做了 n 次加法，n 次乘法 /* Apply Horner's method */ double polyh(double a[], double x, long degree) &#123; long i; double result = a[degree]; for (i = degree-1; i >= 0; i--) result = a[i] + x*result; return result; &#125; 然而实际上 poly 速度更快，为什么呢？因为 poly 有更好的指令级并行度。 poly 的关键路径是 mul，polyh 的关键路径则是 mul → add. 实践之前做 leetcode 还遇到了一则趣事（3356. Zero Array TransformationⅡ） 那题的解法里需要构造这样的函数： bool iskZeroArray(vector&lt;int> &amp;nums, vector&lt;vector&lt;int>> &amp;queries, int k) &#123; vector&lt;int> ops(nums.size() + 1, 0); for (int i = 0; i &lt; k; i++) &#123; int l = queries[i][0]; int r = queries[i][1]; int val = queries[i][2]; ops[l] += val; ops[r + 1] -= val; &#125; int n = nums.size(); int op = 0; for (int i = 0; i &lt; n; i++) &#123; op += ops[i]; if (op &lt; nums[i]) &#123; return false; &#125; &#125; return true; &#125; 在 iskZeroArray 的第一个 for 循环中, 我写的原本是 vector&lt;int> query = queries[i]; int l = query[0]; int r = query[1]; int val = query[2]; 但是这样的程序耗时 1000 ms. 换成 int l = queries[i][0]; int r = queries[i][1]; int val = queries[i][2]; 后，50ms. 两者甚至都是 O(N)的，前者之所以如此慢应该是因为不断分配内存给 query 吧.","categories":[{"name":"公开课","slug":"公开课","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"CMU-15-213","slug":"公开课/CMU-15-213","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/"},{"name":"Notes","slug":"公开课/CMU-15-213/Notes","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/Notes/"}],"tags":[]},{"title":"第三章——程序的机器级别表示","slug":"learning/open-course/CMU-15-213/Notes/Chapter3-machine-level-program","date":"2025-03-14T08:41:28.000Z","updated":"2025-08-22T03:14:43.982Z","comments":true,"path":"wiki/learning/open-course/CMU-15-213/Notes/Chapter3-machine-level-program/","permalink":"http://rinevard.github.io/wiki/learning/open-course/CMU-15-213/Notes/Chapter3-machine-level-program/","excerpt":"","text":"img{ width: 75%; } 汇编简介CSAPP 教的是 x86-64 汇编语言，使用的是 AT&amp;T 语法风格。 下图概述了程序的工作方式，即从内存中读取指令，CPU 根据指令在寄存器上执行操作来修改内存里的数据： 下图描述了借助 gcc 进行编译的过程，其中 .s 就是汇编文件： 一些汇编指令示例： movq 7(%rdx, %rsi, 2), %rax 表示把 2 * %rsi + %rdx + 7 指向的地址的值复制到 %rax 中 leaq 7(%rdx, %rsi, 2), %rax 表示把 2 * %rsi + %rdx + 7 复制到 %rax 中，leaq 常被编译器用来做一些聪明的快速计算，不过 leaq 的第三个项只能是 1, 2, 4, 8. salq $n, %rax 表示把 %rax 中的值左移 n 位 (sal 是 shift arithmetic left 的缩写) imulq %rdx, %rax 表示把 %rdx 中的值与 %rax 中的值相乘，结果存入 %rax (有符号整数乘法) 操作很多，我们不再列举更多，随便找个书查一查就好。 我们可以注意到这些操作都以 ‘q’ 结尾，那如果我不喜欢 ‘q’，我可以用 ‘r’ 结尾吗？不行，因为这里的 ‘q’ 实际上是在指定操作的大小。还记得寄存器长什么样吗： 后缀 全称 大小(字节) 位数 指令示例 描述 b byte 1 8 位 movb 移动单字节(8 位)数据 w word 2 16 位 movw 移动字(16 位)数据 l long 4 32 位 movl 移动双字(32 位)数据 q quadword 8 64 位 movq 移动四字(64 位)数据 我们也有 pushq 和 popq 之类的和栈相关的操作。栈是什么？请看下集——函数和栈。（在“控制”这一节后面） 控制我已经会加减乘除了，那你能教教我怎么写条件（if）和循环（for, while）吗？ 乐意效劳。😎 if，while，do-while无论是条件还是循环，我们都在做两件事——判断条件是否满足和根据条件跳到某个地方执行语句。 让我们先来看看汇编里的一个典型的 do-while 循环： long fact_do(long n) n in %rdi 1 fact_do: 2 movl $1, %eax Set result = 1 3 .L2: loop: 4 imulq %rdi, %rax Compute result *= n 5 subq $1, %rdi Decrement n 6 cmpq $1, %rdi Compare n:1 7 jg .L2 If >, goto loop 8 rep ; ret Return 在这里，我们通过“cmpq”和“jg”来判断条件是否满足，通过“jg”来跳转以执行循环。那么，cmpq 实际上是在做什么呢？ 在汇编中，我们有几个特殊的标志寄存器 CF、ZF、SF、OF 来记录最近的操作是否产生了 unsigned 的溢出、产生 0、产生负数、产生了补码溢出。cmp 和 test 两个指令假装执行减法和按位与并修改这些标志寄存器。 在上面的代码中，cmpq $1, %rdi 就是在假装做 %rdi - 1，并根据计算结果修改标志寄存器。而 jg 则根据标志寄存器的值来进行跳转。jg 的效果是，如果 ~(SF ^ OF) &amp; ~ZF 为真，就进行跳转。 jg 的跳转条件看起来很复杂，但它和 cmpq x, y 联动的效果是——如果 y &gt; x，跳转，因此它叫做 jg. 下表是 CMP 和 TEST 的概述： Instruction Based on Description CMP S₁, S₂ S₂ - S₁ Compare TEST S₁, S₂ S₁ &amp; S₂ Test 这里是一些跳转语句示例： Instruction Synonym Jump condition Description jmp Label 1 Direct jump例：jmp 0x400123直接跳转到具体地址 jmp *Operand 1 Indirect jump例：jmp *%rax跳转目标在运行时才能确定 je Label jz ZF Equal / zero js Label SF Negative jg Label jnle ~(SF ^ OF) &amp; ~ZF Greater (signed &gt;) jge Label jnl ~(SF ^ OF) Greater or equal (signed &gt;=) switch要注意的是，switch 和 if 的汇编有本质区别。switch 基于跳转表（类似哈希表），它先把 case 同时增减一个值来让最小的 case 变为 0，然后建立跳转表，并根据 case 的值来计算合适的跳转地址。 以这个 C 代码为例，它可能被编译成下面的汇编代码： switch(n) &#123; case 1: return \"one\"; case 3: return \"three\"; default: return \"other\"; &#125; cmpl $2, %eax # 检查是否超出范围(>2), 这里%eax = x-1, # 因为最小case是1 ja .L_default # 如果超出范围则跳转到default jmp *.L_table(,%rax,4) # 使用跳转表: base + index*4 .section .rodata .align 4 .L_table: .long .L_case1 # case 1, %eax = 0 .long .L_default # case 2, %eax = 1 .long .L_case2 # case 3, %eax = 2 函数和栈啊哈哈，我们又要讨论寄存器了。还记得 %rsp 吗？它就是存储栈指针的寄存器。下图左边是栈的结构，右边是寄存器： 那么，栈和函数有什么关系呢？ 借助栈来控制转移栈的第一个作用是“passing control“，即控制转移。 调用函数（callq）本质上就是让程序计数器跳转（jmp）到了函数所在的汇编地址，并把调用完成后应该执行的指令地址压入栈中（pushq）。而函数返回（retq）本质上就是把调用完成后应该执行的指令地址 pop 出来（popq），并跳转回去（jmp）。 借助栈来存储数据栈的另一个作用是存储数据。 在函数被调用时，栈指针会移动并为这个函数分配一些栈空间用于存储寄存器的值、存储本地变量、传入的参数之类的东西。我们一个一个解释。 寄存器：在上图的右边可以看到有 caller saved 和 callee saved 的寄存器，标注 caller saved 的寄存器由调用者负责保存，标注 callee saved 的寄存器由被调用者负责保存。比如说，在被调用的函数返回时，被调用者要确保 callee saved 的寄存器和调用前没有区别。 本地变量：有时候寄存器不足以保存所有本地变量，就要放到栈中。 传入的参数：参数确实可以存在寄存器中，但有时候寄存器不够存，也就只能放到栈中了。我们可以用类似 movl -4(%rsp), %edx 的指令来获取传入的参数。 高地址 | 参数7 | | 参数8 | | ... | ← 调用前push | 返回地址 | ← call指令自动push | 保存的寄存器值 | ← 刚进入函数时push | 本地变量1 | | 本地变量2 | | ... | ← 当前rsp指向这里 低地址 对了，根据上面的描述，递归就成了自然涌现出的结果，真神奇！ 数据结构我们来聊聊 array、struct、union 都是怎么表示在内存中的。 array 和寻址先说 Array，二维 array 如下图： 简单易懂。假设我们有 T A[R][C]，那么&amp;D[i][j] = x0 + L(C * i + j). 其中 x0 为数组的起始地址，L 是 sizeof(T). 编译器在寻址时也就是这么做的。不过编译器会做一些聪明的优化来避免乘法，比如用 leaq 来加快计算： # A in %rdi, i in %rsi, and j in %rdx 1 leaq (%rsi,%rsi,2), %rax # Compute 3i 2 leaq (%rdi,%rax,4), %rax # Compute xA + 12i 3 movl (%rax,%rdx,4), %eax # Read from M[xA + 12i + 4] struct 和对齐再来聊聊 struct，看看这张图就差不多了： struct rec &#123; int i; int a[2]; int *p; &#125;; 上图中，12 到 16 的“填充”是出于数据对齐的需要，对齐原则是——任何 K 字节的基本对象的地址必须是 K 的倍数。 K type 1 char 2 short 4 int, float 8 long, double, char * unionunion 允许我们用不同方式解释同一段位表示，常用于节省内存。 最常见的应用是，union 中的东西互斥，比如实现比较基础的动态类型： struct DynamicValue &#123; enum Type &#123; INT, DOUBLE, STRING &#125; type; union Data &#123; int i; double d; char* s; &#125; data; &#125;; 变长栈帧和%rbp有时我们会用到长度不定的数组，比如 int coolArr(int n) &#123; int A[n]; // 做一些cool things return A[0]; &#125; 这时我们在调用函数前是无法确定要为函数分配多少栈空间的，编译出来的函数会形如 collArr: pushq %rbp movq %rsp, %rbp ... # 做一些cool things leave # 等价于 movq %rbp, %rsp; popq %rbp retq 编译器会用 %rbp 作为基指针（base pointer）来记录进入函数前的栈指针位置，并在返回时复位 %rsp 和 %rbp 的状态。 攻击与防御攻击最常见的攻击是缓冲区溢出攻击，CSAPP 里讲了栈溢出攻击，具体可以看看 attacklab. 这可以分为植入恶意代码和 ROP 攻击。 防御对栈溢出的防御手段主要有栈破坏检测、栈随机化、限制可执行代码区域。 最有效的手段是栈破坏检测，只要你破坏不了栈，自然就没办法攻击了。常用的手段是金丝雀值，即在调用允许用户修改栈的函数时，在栈里放一个随机值，然后在函数返回时判断这个值是否被改变。 栈随机化是指每次运行代码时，栈的地址都不一样。 限制可执行代码区域可以防御植入恶意代码到栈里，只要不允许执行栈里的代码就行了。","categories":[{"name":"公开课","slug":"公开课","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"CMU-15-213","slug":"公开课/CMU-15-213","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/"},{"name":"Notes","slug":"公开课/CMU-15-213/Notes","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/Notes/"}],"tags":[]},{"title":"Attackblab记录","slug":"learning/open-course/CMU-15-213/Labs/Attacklab","date":"2025-03-13T03:18:38.000Z","updated":"2025-08-22T03:14:43.978Z","comments":true,"path":"wiki/learning/open-course/CMU-15-213/Labs/Attacklab/","permalink":"http://rinevard.github.io/wiki/learning/open-course/CMU-15-213/Labs/Attacklab/","excerpt":"","text":"img{ width: 40%; } 写在前面非常有趣的 lab！做了一大半以后感觉自己已经是 super 嗨客了。我不打算做最后一个，毕竟读汇编来做 ROP 攻击挺麻烦的，我感觉这对我的水平提升也不大（而且拿到 95/100 我已经很满足了） “Why good people can only do good things and bad people can only do bad things? We bad people can do whatever we want.——Evil Neuro” 攻击attacklab 的攻击主要分为植入攻击代码和 ROP 攻击。 植入攻击代码攻击 1攻击 1 只是简单地让我们熟悉一下工作流程，我们只要覆写掉返回地址就好了。 大致的攻击流程是——跑一下 ctarget 看看我们写入的内容会被放在栈的哪个位置，熟悉位置以后把十六进制的攻击内容写到某个 txt 文件里，再用 ./hex2raw &lt; rinevinput.txt &gt; evil 转换为输入值，最后把输入值传到 ctarget 就实现了攻击。 下面给一些小 hints。 注意, 不要把内容写入形如 evil.txt 这样的有格式的文件里! 这可能修改一些特殊字符。我之前就踩了这个坑。 使用./ctarget -q &lt; evil来运行，因为我们不能连接到 CMU 服务器（唉，CMU）. 攻击 2攻击 2 就是典型的“植入攻击代码”了。一开始我的思路如下图： 这确实能跑，也确实顺利执行了 touch2，但执行完之后发生了segmentation fault！这是为什么？我至今没有搞清楚，如果有朋友知道可以跟我说一下。但我可以排除一些疑点。 首先，segmentation fault 不是因为栈指针跑到了预期位置之外。因为在 phase-2-level2 中，我们的栈指针跑得老远了。 segmentation fault 的发生大概率是因为栈指针没有对齐。给能通过的 phase2-level2 再加一句 ret，就造成了 segmentation fault。再在造成了 segmentation fault 的基础上多 ret 一次就又没有 segmentation fault 了。 所以我觉得大概率是栈指针的对齐问题。那栈指针，你究竟该在哪里呢？ 回到攻击 2，既然我们猜测是栈指针对齐问题，只要让它对齐就行了。我们微调一下，通过 push 让栈指针的位置偏移 8，然后就通过了。 攻击 3攻击 3 和攻击 2 差不多，唯一要注意的是 hexmatch 和 strncmp 会覆写栈，所以我们要把字符串藏在更下面的位置（即栈地址比较大的位置）。造成了 segmentation fault 怎么办？我们已经有了攻击 2 的经验，所以借助 pop，push，ret 来微调一下栈指针位置就行。 作业 PDF 里还提到，”Make position of check string unpredictable”。这有什么意义？我猜是为了防止我们把 sval 指向 cbuf 来实现攻击，这或许不符合 attacklab 的世界观，因为连字符串都不用注入了。 ROP 攻击攻击 4我是笨蛋，又踩了一个坑。考虑指令 4017fc: 3b 3d e2 3c 20 00 cmp 0x203ce2(%rip),%edi # 6054e4 &lt;cookie&gt; 401802: 75 20 jne 401824 &lt;touch2+0x38&gt; 在执行 cmp 指令时：RIP 的值是 0x401802，而不是 0x4017fc。我之前还想了半天为什么我们能指向 cookie。 回到题目上来，根据提示，我们要用 mov，pop，ret，那么思路是写入 cookie 到栈中，pop 它到某个地方（addval_219 有 pop %rax），最后移动到 rdi 中（addval_273 有 movl %eax %edi） 我们在攻击 2 里已经讨论过 segmentation fault 的发生原因，最合理的猜测是栈指针的对齐问题。所以如果发生了 segmentation fault，找个 ret 再用一下就行了。 攻击 5没做，we bad people can do whatever we want！","categories":[{"name":"公开课","slug":"公开课","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"CMU-15-213","slug":"公开课/CMU-15-213","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/"},{"name":"Labs","slug":"公开课/CMU-15-213/Labs","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/Labs/"}],"tags":[]},{"title":"技巧的分类，冰山之下的深度","slug":"game-design/冰山之下的深度","date":"2025-03-08T04:22:38.000Z","updated":"2025-08-20T11:13:48.877Z","comments":true,"path":"wiki/game-design/冰山之下的深度/","permalink":"http://rinevard.github.io/wiki/game-design/%E5%86%B0%E5%B1%B1%E4%B9%8B%E4%B8%8B%E7%9A%84%E6%B7%B1%E5%BA%A6/","excerpt":"","text":"img{ width: 70%; } 《体验引擎》里提到，“深度游戏能够通过高水平的技巧创造有意义的玩法。深度（depth）这个概念用于描述游戏中需要学习的内容有多少。”在这里，我们将探讨一下如何对技巧的类型进行区分，以及如何创造这些技巧来提高游戏深度，同时不让游戏门槛过高。 既然要求有深度，那游戏里必然有很多技巧。我们有必要对技巧做一个区分——技巧可以被分为“规则涌现的技巧”和“预设的技巧”。围棋的各种技巧就是前者的一个很好的例子（uh actually☝️🤓 数学是更好的例子），而“炸弹能炸开有裂缝的墙”就是后者的一个例子。 基于规则的技巧创造“基于规则的技巧”是相对困难的，因为这要求我们创造能涌现出许多技巧的规则。这种纯粹的创造性活动恐怕没有什么经验可以写，我能说的也只是多去学学不同领域的知识。如果要做出有灵性的规则，当然不能只是玩各个游戏并尝试“学习经验”（你学的都是别人做过的规则！），而是要更多去看看自己从未见过的领域。比如说，比起盯着《baba is you》学，不如去学学编程。编程的“赋值”被 baba 做掉了，但编程的“语句执行顺序”是不是就可以做成 noita 的魔杖？编程的“抽象”思想会不会也可以做成另一个有趣的规则？ 虽然说“这种创造性活动恐怕没什么经验可写”，但还是写了一堆东西。我确实对基于规则的技巧更感兴趣，这完美实现了“冰山之下的深度”（我在这里点题了！）。不过接下来我们还是聊聊没有灵感时也能做的东西吧。 预设的技巧比起创造基于规则的技巧，创造预设的技巧则简单很多。我们可以随便口胡一些预设的技巧，比如“土狼跳”、“攻击过程中按冲刺能取消攻击”、“在开启技能的前摇时移动来消除前摇而直接开启技能”（唉，取消），实际上为了保证手感，几乎所有游戏都用了大量的预设的技巧。对预设的技巧来说，实际难点在于如何把深度藏在冰山之下，不让玩家因直面大量技巧而感到无所适从。 把深度藏在冰山之下听着很高大上，实际上最好用的藏深度的做法就是把预设的技巧逐渐呈现给玩家。每过几关给玩家一个新能力就是这种做法。更巧妙的做法是把多个预设的技巧融入到同一个操作之中，用恰当的关卡设计让技巧逐渐呈现出来。典型的例子是《闰跃之年》，开局跳一下就死了，那怎样跳才能活下来呢？这就是被藏在冰山下的预设的技巧了。 有的游戏还会把预设的技巧伪装成规则涌现的技巧，这让技巧显得更优雅，但实际上不是很本质的改进。围绕一个摸棱两可的主题设计一些预设的技巧，就能做到这一点。我能想到的最好的例子就是《蔚蓝》。蔚蓝把蹭墙跳、凌波微步这些预设的技巧藏在了“惯性”的后面，让各个技巧看起来都是涌现的。虽然这些技巧看起来都和惯性有联系，但实际上玩家并不能根据规则本身推理出这些技巧的存在，因此这是”把预设的技巧伪装成规则涌现的技巧“。 结尾基于规则的技巧和预设的技巧并非截然对立。大多数情况下，我们都逐渐学到所有的预设的技巧，再把预设的技巧作为规则组合起来形成基于规则的技巧。 还要注意的是，这种技巧的区分是在呈现给玩家的层面上，而非在实现层面上。如果你硬编码出 noita 的所有可能的法术搭配并写出对应效果，这在实现层面上显然是“预设”的，但对玩家来说，这仍然是“基于规则”的，毕竟玩家可以基于规则推理出可能的技巧。相较而言，如果我们设计一个和法术相关的游戏，每个法术在代码层面上都是几个小法术的组合，但玩家看到的只是组合好的各个法术而不能自己去组合法术，这在实现层面上是“基于规则”的，但对玩家来说是“预设”的。 多说一句，“在实现层面上基于规则，但呈现出来的效果是预设的”实际上是很适合做成探索类游戏的。核心思路是，首先把大量的预设的现象呈现给玩家，再让玩家逐步探索现象背后的规则。这种思路在别的游戏里也有，不过全是解谜游戏，我们完全可以做一个更有趣的探索类游戏。比如说玩家看到了火球术，之后我们逐渐引导玩家发现火球术本质上是火焰魔法+移动魔法，玩家就能进而基于规则构建出新魔法了。","categories":[{"name":"游戏设计","slug":"游戏设计","permalink":"http://rinevard.github.io/categories/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[]},{"title":"第二章——计算机内的信息表示","slug":"learning/open-course/CMU-15-213/Notes/Chapter2-data-representation","date":"2025-03-03T10:36:28.000Z","updated":"2025-08-22T03:14:43.982Z","comments":true,"path":"wiki/learning/open-course/CMU-15-213/Notes/Chapter2-data-representation/","permalink":"http://rinevard.github.io/wiki/learning/open-course/CMU-15-213/Notes/Chapter2-data-representation/","excerpt":"","text":"我们知道，在 32 位机器上和 64 位机器上，相同的 C 语言数据类型可能占用不同的字节数： C declaration Bytes Signed Unsigned 32-bit 64-bit [signed] char unsigned char 1 1 short unsigned short 2 2 int unsigned 4 4 long unsigned long 4 8 int32_t uint32_t 4 4 int64_t uint64_t 8 8 char * 4 8 float 4 4 double 8 8 整数表示整数的表示可以分为 unsigned 和 signed，前者只能表示非负数，后者可以表示整数。下面是各个整数类型占用的字节数： C declaration Bytes Signed Unsigned 32-bit 64-bit short unsigned short 2 2 int unsigned 4 4 long unsigned long 4 8 众所周知，signed 的表示采用补码表示，就是模 $2^m$ 意义下对应的最小正数的二进制表示，其中 $m$ 是耗费的 bits 数。 下面的例子中类型是 signed short，$15213$ 的表示就是它的二进制表示，而 $-15213$ 的表示实际上是 $-15213 + 2^{16}$ 的二进制表示。 Decimal Hex Binary x 15213 3B 6D 00111011 01101101 y -15213 C4 93 11000100 10010011 让我们假设二进制表示为 $b{w-1},b{w-2},…,b_1,b_0$，那么如果是 unsigned，其值为 \\sum_{k=0}^{w-1}2^{k}b_k如果是 signed，当 $b_{w-1}$ 即最高位不为 1 时，把二进制转换成十进制即可。 当最高位为 1 时，其值为 -2^{w}+\\sum_{k=0}^{w-1}2^{k}b_k不难注意到能表示的整数有上下限，参考下表： Signed Unsigned 64-bit short [-32768, 32767] unsigned short [0, 65535] 2 int [-2^31, 2^31-1] unsigned int [0, 2^32-1] 4 long [-2^63, 2^63-1] unsigned long [0, 2^64-1] 8 加法，乘法，左右移加法和乘法就是模意义下的加法和乘法，所以你喜欢的运算规律都符合。“溢出”也只是模了一下。 而左右移呢？左移不难理解，把它的表示统一往左边移动，移出范围了就扔掉，最低位填充 0. x &lt;&lt; m 实际上是在做 $2^{m}x(\\text{mod $2^w$})$. 右移则分为逻辑右移和算术右移，前者是在右移后在最高位上填充 0，后者在最高位上填充符号位。 对 unsigned 来说它们没有区别，毕竟 unsigned 不考虑符号，但对 signed 来说就不一样了。 大多数 C 编译器对有符号整数实现的是算术右移，x &gt;&gt; m 实际上是在做 $\\lfloor \\frac{x}{2^m} \\rfloor$. 不同类型的整数一起运算会发生什么？核心思想是，在尽量保证值不变的前提下把数进行扩展。 把一个 signed short 整数和 signed int 相加会发生什么呢？我们会进行“符号扩展”，把 signed short 扩展成 signed int 再做加法，返回一个 signed int。 那，什么是符号扩展呢？如果 short 值是正数，高位会用 0 填充；如果是负数，高位会用 1 填充（符号扩展）。uh actually 🤓☝️ 这是在保证值不变的前提下把 short 转换成 int。 把一个 unsigned int 整数和 signed long 相加会发生什么呢？我们会把 unsigned int 扩展为 signed long（即在前面加 0）再做加法，返回一个 signed long。 当然，也有不能保证值不变的情况。比如 unsigned int 和 signed int 相加时，我们会把 signed 转换成 unsigned 再求和。 所以说，拜托不要写这种奇怪的代码： signed int a = -1; unsigned int b = 1; if (a &lt; b) &#123; printf(\"a &lt; b\\n\"); &#125; else &#123; printf(\"a >= b\\n\"); &#125; 上面的代码会输出 $a\\geq b$，你这是在破坏数学的世界观！ 注意事项unsigned 很可能造成错误。对下面的代码，你觉得哪个是对的？ unsigned i; for (i = cnt-2; i &lt; cnt; i--) a[i] += a[i+1] unsigned i; for (i = cnt-2; i >= 0; i--) a[i] += a[i+1] 答案是前者，因为对后者来说，i = 0 以后 i-- 会让 i 溢出变为正数，导致无限循环。 反正不要写这样的代码，你这是在破坏数学的世界观！ 浮点数表示按照 IEEE 标准，浮点数的表示如下： 其中 s 是符号位，0 表示正数，1 表示负数 计算方式大致为 (-1)^s \\times 2^{\\text{exp}-\\text{bias}}\\times(1\\text{.frac})之所以说是“大致”，是因为还存在几种特殊情况。 如果 exp 全是 0，我们称其为非规格化数（denormalized），使用下面的公式计算： (-1)^s \\times 2^{1-\\text{bias}}\\times(1\\text{.frac})如果 exp 全是 1，frac 全是 0，我们认为表示的是 infin. 至于是 $+\\inf$ 还是 $-\\inf$ 由符号位决定。 如果 exp 全是 1，frac 不为 0，表示 NaN（not a number）. 看起来确实是很奇怪的标准！这涌现出的结果是，能表示的值在靠近 0 的位置比较密集，在远离 0 的位置比较稀疏。（下图以 exp 占 3 bits，frac 占 2 bits 为例） 舍入（四舍五入）既然浮点数的表示这么奇怪，那如果我把两个浮点数相加，是不是可能得到不精确的结果？真聪明，确实如此！我们一般采取“round-to-even”的策略，即先考虑舍入到更近的那个数，如果两个数一样近，把得到的结果向着更“偶数”的方向去舍入，对二进制表示来说，就是希望它被舍入到结尾为 0 的那个数上. 来个例子： 10.000112 10.002 (1/2—up)10.111002 11.002 ( 1/2—up)10.101002 10.102 ( 1/2—down) 主要好处是减少统计偏差。如果我们采取 round up，在统计时统计出的值可能偏高；如果选择 round down，统计出的值可能偏低。 加法，乘法浮点数的加法和乘法性质并不良好，我直接把课件复制过来吧： 浮点数加法： 封闭性：是 但可能生成无穷大(infinity)或非数值(NaN) 交换律：是 a + b = b + a 结合律：否 由于溢出和舍入的不精确性 例如：(3.14+1e10)-1e10 = 0，而 3.14+(1e10-1e10) = 3.14 零元素：是 0 是加法单位元 逆元素：几乎是 除了无穷大和 NaN 外，每个元素都有加法逆元 单调性：几乎是 a ≥ b ⇒ a+c ≥ b+c 但对无穷大和 NaN 例外 浮点数乘法： 封闭性：是 但可能生成无穷大或 NaN 乘法交换律：是 a × b = b × a 乘法结合律：否 由于溢出和舍入的不精确性 例如：(1e20×1e20)×1e-20 = inf，而 1e20×(1e20×1e-20) = 1e20 单位元：是 1 是乘法单位元 分配律：否 由于溢出和舍入的不精确性 例如：1e20×(1e20-1e20) = 0.0，而 1e20×1e20 - 1e20×1e20 = NaN 单调性：几乎是 a ≥ b 且 c ≥ 0 ⇒ a×c ≥ b×c 但对无穷大和 NaN 例外 类型转换double/float → int：对浮点数（无论是单精度还是双精度）来说，把它们转换成 int 相当于 rounding toward zero，即舍去小数后面的部分。我觉得这应该主要是实现起来方便，我们在 datalab 里实现了这种转换。如果转换后超出了 int 的可表示范围，这种转换行为未定义（一般会设为 TMin，type minimum，能表示的最小值）。 int → float：根据 rounding mode 进行四舍五入，毕竟存在一些 float 不能表示的 int 值。 int → double：精确转换，毕竟 double 的 frac 有 52 个 bits，能够表示所有可能的 int 值。 杂项大端法和小端法多字节对象在内部存储的字节顺序表示上也有大端法和小端法之分，即最高有效字节在前面还是后面。比如把十六进制的 0x01234567 存储为 01 23 45 67 还是 67 45 23 01。 我们可以用下面的代码检查自己的机器使用的是大端法还是小端法。 #include &lt;stdio.h> int is_little_endian() &#123; unsigned int x = 1; // 将整数的地址转换为字符指针，访问其第一个字节 char *c = (char*) &amp;x; // 如果第一个字节是1，则为小端；如果是0，则为大端 return *c; &#125; int main() &#123; if (is_little_endian()) &#123; printf(\"系统是小端(Little Endian)\\n\"); &#125; else &#123; printf(\"系统是大端(Big Endian)\\n\"); &#125; return 0; &#125;","categories":[{"name":"公开课","slug":"公开课","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"CMU-15-213","slug":"公开课/CMU-15-213","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/"},{"name":"Notes","slug":"公开课/CMU-15-213/Notes","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/Notes/"}],"tags":[]},{"title":"这里有什么？","slug":"learning/open-course/这是哪里","date":"2025-03-02T06:28:38.000Z","updated":"2025-08-22T03:16:04.281Z","comments":true,"path":"wiki/learning/open-course/这是哪里/","permalink":"http://rinevard.github.io/wiki/learning/open-course/%E8%BF%99%E6%98%AF%E5%93%AA%E9%87%8C/","excerpt":"","text":"本来只打算在博客里写杂谈和游戏设计相关文章的，不过想想看把学习笔记在这里记一记似乎也不错。那这里就是学习记录了，主要是写给未来的自己用的。🫠 应该只有朋友们（cyber friends）会看到这个网站，所以记录一下也是在表明我还在认真学习，没有进入摸鱼态。读者也别忘了终身学习。","categories":[{"name":"公开课","slug":"公开课","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"}],"tags":[]},{"title":"Bomblab感想","slug":"learning/open-course/CMU-15-213/Labs/Bomblab","date":"2025-03-02T06:28:38.000Z","updated":"2025-08-22T03:14:43.978Z","comments":true,"path":"wiki/learning/open-course/CMU-15-213/Labs/Bomblab/","permalink":"http://rinevard.github.io/wiki/learning/open-course/CMU-15-213/Labs/Bomblab/","excerpt":"","text":"写在前面bomblab 比起 datalab 更友好一些，除了考察对汇编代码的理解以外，也在锻炼我们的 gdb 调试技能。用时共计 2+2+0.8+0.5+1.5+4 = 10.8h，比 datalab 用时略少一点。刚开始拆弹的时候是很兴奋的，做到后面倒是感觉有点无聊了，我感觉 attacklab 可能更有趣一些（虽然我还没做）。 拆弹记录首先肯定要对 bomb 进行反汇编，我是用 objdump 来反汇编，并把结果保存到了 txt 文件中。拿到汇编以后随便翻翻找到 phase 们，之后就进入拆弹阶段了。 第一个炸弹phase_1 简单易懂，只是判断输入是否与某个字符串相等。我一开始以为字符串就是“0x402400”，后面才想到这是那个字符串的地址。用 gdb 设置断点即可得知字符串。（别看我说得那么轻松，也是折腾了两小时多，毕竟完全没有 gdb 经验 🫠） 第二个炸弹这也是一个不难的炸弹，把汇编代码往下读就能解决，喜欢的话可以加点注释帮助自己理解。不过我仍然做了两个小时，主要在疑惑 read_six_numbers 后数字被读到了哪里。还有个有趣的犯蠢的地方，我一开始把 400f35 处的 0x18 当成了十进制 18，疑惑了很久 4n 怎么可能等于 18，后面猛然惊醒发现那是十六进制。🤣 在这里我用到了这些新指令： si # 单步执行 x&#x2F;10xw $sp # 查看栈指针(sp)处的10个字(word)，以十六进制(x)显示 x&#x2F;10i $pc # 查看当前位置之后的10条指令 i registers eax # 查看寄存器值 第三个炸弹用时 50 分钟（有进步！），这次有了更系统的拆弹方法——先把代码分段，然后分析代码提出若干个猜测和问题，随着解答问题就逐渐做掉了。🫠我们可以轻松注意到输入的数字不能少于一个，再往下读就会 400f75 这一行，算一算就会很自然地猜测：输入要求我们选一个选项，跳过去然后 cmp。 这里是我拆弹时提出的问题以及解答： 输入按怎样的格式存储起来？存储在哪里？分析栈后发现，看起来是读取了两个数字，存储在栈中 400f6a 那行是怎么比较的？0x8(%rsp)是什么，输入值吗？猜测这是要求输入的选项值只能在 0-7 之间？设一个断点就能回答这个问题了。 400f75 跳到了哪里？是根据选项跳跃吗？根据选项跳跃 从选项跳到了 400fbe 后，0xc(%rsp)是定值还是会根据输入变化？0xc(%rsp)是输入的第二个值。由于 8 对齐，我们需要用 0xc(%rsp)而非 0x10(%rsp)来得到第二个值。 第四个炸弹用时半小时，我连 func4 都不想读，直接用 gdb 来执行 func4，找到返回 0 的输入就行了。这种解法感觉有逃课的嫌疑，不过你就说快不快吧！在这里我用到了这个新指令： (gdb) call (int)func4(11, 0, 14) 第五个炸弹用时 1.5h，做到这里，我比起刚开始时已经对汇编代码熟悉不少了。首先把代码分成若干个小部分，然后猜测并验证每个部分的功能就能解决这个炸弹。比较有趣的地方是这里加入了一个金丝雀，我还疑惑了一阵子这是什么，后来才想到这是书上讲的金丝雀。 第六个炸弹用时 4h，对这个炸弹，我感觉“根据运行时的状况猜代码的作用”比“分析代码”更加重要。一开始同样是把代码分成多个小局部，然后分段猜作用。这里引入了链表，还挺有趣。 彩蛋？什么彩弹？","categories":[{"name":"公开课","slug":"公开课","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"CMU-15-213","slug":"公开课/CMU-15-213","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/"},{"name":"Labs","slug":"公开课/CMU-15-213/Labs","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/Labs/"}],"tags":[]},{"title":"Datalab解析","slug":"learning/open-course/CMU-15-213/Labs/Datalab","date":"2025-02-21T12:14:28.000Z","updated":"2025-08-22T03:14:43.981Z","comments":true,"path":"wiki/learning/open-course/CMU-15-213/Labs/Datalab/","permalink":"http://rinevard.github.io/wiki/learning/open-course/CMU-15-213/Labs/Datalab/","excerpt":"","text":"img{ width: 40%; } 写在前面Datalab 的难度很高。它的难度主要体现在技巧性上，这在整数部分尤其明显。整数部分至少有一半题目我花了一小时以上才做出来，相较而言，浮点数的题目虽然分类讨论起来更麻烦，但更为平易近人，每道我花了四十分钟左右。 如果有某道题做不出来，不建议一直死磕。我们可以换一道题或是离开屏幕散散心，我相信这会有帮助。 做完以后，感觉自己已经是位运算领域大神了！ 整数部分整数部分的技巧性很强，不建议在某道题上死磕，做不出来就换一道，以后再来。 bitXor本题要求用 ‘~’ 和 ‘&amp;’ 实现 ‘^’，简单列个关于 ‘^’ 的真值表： x y x^y 0 0 0 0 1 1 1 0 1 1 1 0 关注 x^y 为 1 时 x 和 y 的取值，可以发现 x^y == ((~x) &amp; y) | (x &amp; (~y))，再用德摩根律把 | 换成 ~ 和 &amp; 即可。 /* * bitXor - x^y using only ~ and &amp; * Example: bitXor(4, 5) = 1 * Legal ops: ~ &amp; * Max ops: 14 * Rating: 1 */ int bitXor(int x, int y) &#123; /* x Xor y = ((~x) &amp; y) | (x &amp; (~y)) a | b = ~(~a &amp; ~b) */ return ~(~(x &amp; ~y) &amp; ~(~x &amp; y)); &#125; tmin这是熟知的结论，tmin = $-2^{31}$ = 1 &lt;&lt; 31 /* * tmin - return minimum two's complement integer * Legal ops: ! ~ &amp; ^ | + &lt;&lt; >> * Max ops: 4 * Rating: 1 */ int tmin(void) &#123; /* use left shift to compute tmin */ return 1 &lt;&lt; 31; &#125; isTmax这种“判断 x 是否等于 y”的题目的做法有很多种： 创建一个 y，把 x 和 y 相减（x - y == x + ((~y) + 1)），然后判断结果是否为 0. 创建一个 y，return !(x^y) 我这里是直接构建了 -Tmax = 100…01，然后检查 x-Tmax 是否为 0. /* * isTmax - returns 1 if x is the maximum, two's complement number, * and 0 otherwise * Legal ops: ! ~ &amp; ^ | + * Max ops: 10 * Rating: 1 */ int isTmax(int x) &#123; /* create a '0' and use '!' */ return !(x + 1 + (1 &lt;&lt; 31)); &#125; allOddBits这道题我想了很久。后来根据尝试性地构造了 1010…1010，然后试出了 (x &amp; mask) ^ mask 的写法。大致的思路是，既然我们只在乎奇数位的值，就先用 &amp; 把偶数位的值去掉，后来惊奇地发现再做个 ‘^’ 和 ‘!’ 就能得到结果了。 /* * allOddBits - return 1 if all odd-numbered bits in word set to 1 * where bits are numbered from 0 (least significant) to 31 (most significant) * Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; >> * Max ops: 12 * Rating: 2 */ int allOddBits(int x) &#123; /* (x^y) == 0 &lt;=> x == y */ int y = 0xAA; // 0xAA 就是二进制的 1010 1010 int mask = y + (y &lt;&lt; 8) + (y &lt;&lt; 16) + (y &lt;&lt; 24); return !((x &amp; mask) ^ mask); &#125; negate这是熟知的结果，本质是 $x + \\sim x + 1 \\equiv 0(\\text{mod $2^{32}$})$ /* * negate - return -x * Example: negate(1) = -1. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; >> * Max ops: 5 * Rating: 2 */ int negate(int x) &#123; /* well known result */ return ~x + 1; &#125; isAsciiDigit这道题我想了很久。后来分析了输入的形式，发现它只能形如 0000 … 0011 0yyy 或是 0000 … 0011 100y，于是决定把自由的位置右移掉，然后用 mask。 做完后复盘发现还有一种基于比较的方法，直接计算 x - 0x30 和 x - 0x39 并判断其符号位。 /* * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters '0' to '9') * Example: isAsciiDigit(0x35) = 1. * isAsciiDigit(0x3a) = 0. * isAsciiDigit(0x05) = 0. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; >> * Max ops: 15 * Rating: 3 */ int isAsciiDigit(int x) &#123; /* x 只能形如下面两种形式： * 1. 0000 ... 0011 0yyy * 2. 0000 ... 0011 100y * 这里的 y 可以是 0 或 1 * 我们用右移去掉未知的 y, 然后用 mask即可 * 构造两个 mask, 一个是 0000 ... 0000 0110, 另一个是 0000 ... 0001 1100 */ int mask1 = 0x06; int mask2 = 0x1C; return !((x >> 3) ^ mask1) | !((x >> 1) ^ mask2); &#125; conditional这道题我也想了好久。一开始为了方便，我先用 !!x 把 x 归到了 0 或 1. 之后的思路是想构造满足类似 f(0, y) = 0，f(1, y) = y 的条件的函数 f，然后返回 f(x, y) + f(!x, z). 稍加思考，便发现 ‘&amp;’ 和这里的 f 很像，于是就写下去了。 /* * conditional - same as x ? y : z * Example: conditional(2,4,5) = 4 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; >> * Max ops: 16 * Rating: 3 */ int conditional(int x, int y, int z) &#123; /* 为了方便, 先限制 x 只取 0 或 1 * 我们一开始的思路是找到函数满足 f(x, b) = b if x == 1, 0 if x == 0 * 然后用 f(x, y) + f(!x, z) 即可得到结果 * 中途发现 11...1 &amp; b = b, 0 &amp; b = 0, 和我们希望的结果很像 * 于是就这么写了 */ int mask = (~(!x)) + 1; // x为0时得到全1，x非0时得到0 return ((~mask) &amp; y) + (mask &amp; z); &#125; isLessOrEqual好吧，这道题我还是想了很久，毕竟我在做之前对位运算几乎一无所知。这道题更多是分类讨论，分为 xy 同号和 xy 异号的两种情况就行，连溢出都不会有。 /* * isLessOrEqual - if x &lt;= y then return 1, else return 0 * Example: isLessOrEqual(4,5) = 1. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; >> * Max ops: 24 * Rating: 3 */ int isLessOrEqual(int x, int y) &#123; /* 若xy同号(最高位相同), return 1 if y - x >= 0 else 0 * 若xy异号, return 1 if y的二进制表示最高位为0 else 0 */ int signX = x >> 31; int signY = y >> 31; int diffSign = (signX &amp; !signY); // (异号且 y >= 0, x &lt; 0) ? 1 : 0 int diff = y + (~x + 1); // y - x int sameSign = (!(signX ^ signY)) &amp; ((diff >> 31) + 1); // (同号且 y - x >= 0) ? 1 : 0 return diffSign | sameSign; &#125; logicalNeg这道题是我感觉第二难的题目，我的核心思路是“非 0 的 x 的二进制表示中至少有一个 1”，于是我就构造了 11…1 即 -1 这个特殊值，并期盼它能给我一些有趣的结果。 对正数 x 来说，x + (-1) 的最高位必然是 0，这能把正数和 0 区分开来，因为 0 + (-1) 的最高位是 1. 但负数怎么办呢？负数要分类讨论，很麻烦。于是我就想取输入值的绝对值，然后用 abs + (-1) 来区分非 0 值和 0. 我这里的代码采用的是类似的思路，不过当时没想到怎么求 abs，就写得更复杂了一些。 后来复盘时发现非 0 值 x 一定满足 (x | (~x)) 的最高位为 1，用这个方法更简单。 /* * logicalNeg - implement the ! operator, using all of * the legal operators except ! * Examples: logicalNeg(3) = 0, logicalNeg(0) = 1 * Legal ops: ~ &amp; ^ | + &lt;&lt; >> * Max ops: 12 * Rating: 4 */ int logicalNeg(int x) &#123; /* * 先思考怎么表示 'x非0', 注意到 x非0 &lt;=> x的二进制表示中至少有一个1 * 考虑用 -1(它的二进制表示全是1) + x 来得到一些中间量 * 接下来分类讨论, 如果 x为0, 则 -1 + x = -1, * 如果 x为正数, -1 + x 的二进制表示以 0 开头 * 如果 x为负数, 要分类讨论 Tmin的情况, 处理起来不方便 * 至此, 正数和 0 就能通过 (-1 + x) >> 31 区分开来了, 正数得到 0, 0 得到 -1 * 接下来把负数整合进来 * 考虑到负数的负是正数, 我们自然就会考虑把负数转化成正数，再用 | 或者 &amp; 来连接 * ((((~0) + x) >> 31)) &amp; ((((~0) + negtivex) >> 31)) 就能把正数和负数都变成0, 0变成 -1 * 再 &amp; 1 就能得到 !x 了 * 代码里又进一步简化了一下结果, 不过核心思路还是\"把负数和正数统一起来\" * 这里的 (((~0) + x) &amp; ((~0) + negtivex)) 把 &amp; 提前到了移位前, * 直接 &amp; 了二进制表示的最高位(之前的先 >> 再 &amp; 是 &amp; 了二进制表示的最低位) */ int negtivex = (~x) + 1; return ((((((~0) + x) &amp; ((~0) + negtivex)) >> 31)) &amp; 1); &#125; howManyBits这道题是我感觉最难的题目。首先我们画出这个函数的图像（留给读者作为练习），会发现它关于 -0.5 对称，这表明 x 和 -x-1 耗费的位数相同，接下来我们就只要考虑非负数就行了。 找到非负数的最小 bits 数倒是不难，稍微写几个非负数就能发现，只要找到它值为 1 的最高位数，设其为 k，k + 1 即为结果。 之后的难点就是，如何找到这个非负数的“值为 1 的最高位数”了。线性搜索显然是可行的，我们可以用 $\\sum_{m=0}^{31}!!(x &gt;&gt; m)$ 来得到这个位数，然而这样做耗费的操作数超出了限制。既然线性耗费的操作数太多，那我们自然就会想到二分。 但怎么做二分呢？这里的代码更多是我试出来的，没有什么清晰的理论指导，我们直接看图吧。 怎么做到“砍掉一半”呢？砍掉右边半段用右移就行，所以我们会从 x &gt;&gt; 16 开始，再用 !!(x &gt;&gt; 16) 是 0 还是 1 来判断 1 在右半边还是左半边。 之后的代码就真的纯粹是试出来的了，我们肯定能在数学上解释我们的操作，但具体的构思纯粹是试错+直觉试出来的，没什么好说的。 /* howManyBits - return the minimum number of bits required to represent x in * two's complement * Examples: howManyBits(12) = 5 * howManyBits(298) = 10 * howManyBits(-5) = 4 * howManyBits(0) = 1 * howManyBits(-1) = 1 * howManyBits(0x80000000) = 32 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; >> * Max ops: 90 * Rating: 4 */ int howManyBits(int x) &#123; /* 简单画下这个函数的图像, 注意到 x 与 -x - 1(即~x) 耗费位数相同, 那就先统一转换成非负数, * 然后找到最高的值为1的位数, 设其为 k, k + 1 即为结果 * 比如 0000 ... 0010 0110 的结果为 6 + 1 = 7 * * 那怎么找到最高的值为1的位数呢? * 一种想法是 sum([!!(alternatex >> k) for k in range(32)]), 但这样用的操作就超过限制了 * 所以我们借助二分的思想 * 让我们举个例子, 假设我们在处理 0010 1101, * 我们可以先把它右移4, 发现仍然大于0, 就令ans += 4, 此时值为 0010 (扔掉右半部分) * 然后右移2, 发现等于0, 则不在数据上真正移动, 值为 10 (扔掉左半部分) * 再右移1, 发现大于0, 令 ans += 1, 此时值为 1 (扔掉右半部分) * 当前的值不为0, ans +=1 (ans之前加了\"被移除的部分的长度\", 这里还要加上\"剩余的部分的长度\") * 综上, 0010 1101 的最高的值为1的位数为6 * * 首先我们要能够检查右移后值是否为0, 用!!(x >> k) 即可, !!(x >> k) == (x 右移后值为0) ? 0 : 1 * 然后为了方便在值上进行移动, 我们希望有 f(x) = (x 右移后值为0) ? 0 : 右移长度 * 因此使用形如 !!(x >> (2**k)) &lt;&lt; k 的东西 */ int signX = x >> 31; // (x >= 0) ? 00...0 : 11...1 int alternatex = ((~(signX)) &amp; x) + ((signX) &amp; (~x)); // (x >= 0) ? x : -x-1 int bit16 = (!!(alternatex >> 16)) &lt;&lt; 4; // (alternatex >= 2**16) ? 16 : 0 alternatex = alternatex >> bit16; int bit8 = (!!(alternatex >> 8)) &lt;&lt; 3; alternatex = alternatex >> bit8; int bit4 = (!!(alternatex >> 4)) &lt;&lt; 2; alternatex = alternatex >> bit4; int bit2 = (!!(alternatex >> 2)) &lt;&lt; 1; alternatex = alternatex >> bit2; int bit1 = (!!(alternatex >> 1)); alternatex = alternatex >> bit1; int bit0 = (!!alternatex); return bit16 + bit8 + bit4 + bit2 + bit1 + bit0 + 1; &#125; 浮点数部分浮点数部分比起整数部分简单得多，只要仔细地分类讨论就行了。 floatScale2分类讨论即可。这里比较有趣的是 exp == 0（denormalized case）的情况，无论 frac 部分是否超过 23 位，处理的代码都是一样的。 /* * floatScale2 - Return bit-level equivalent of expression 2*f for * floating point argument f. * Both the argument and result are passed as unsigned int's, but * they are to be interpreted as the bit-level representation of * single-precision floating point values. * When argument is NaN, return argument * Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while * Max ops: 30 * Rating: 4 */ unsigned floatScale2(unsigned uf) &#123; /* 取出 exp 的部分, 分三种情况讨论. * 1. NaN or infin, 直接返回输入值 * 2. denormalized case, 主要修改 frac 部分, 如果修改导致 frac * 部分多于 23 位, 还要修改 exp 部分 * 3. normalized case, 修改 exp 部分 */ unsigned exp = (uf >> 23) &amp; 0xFF; // 00...0 exp // 如果 exp == 二进制(1111 1111), uf为 NaN 或 infin, 直接返回uf if (exp == 0xFF) &#123; return uf; &#125; // 如果 exp == 0, 就是 denormalized case else if (exp == 0) &#123; unsigned frac = (uf &lt;&lt; 9) >> 9; // 0 00000000 frac // 如果 frac 部分最高值为1, 进位; 如果不为1, 把 frac 部分乘二即可 // 两种情况都能用下面的代码来表示 frac = frac &lt;&lt; 1; return ((uf >> 23) &lt;&lt; 23) + frac; // (s exp 00...0) + (0 00000000 frac) &#125; // normalized case else &#123; // exp不会溢出8位, 因为前面的 if 分支已经处理了 exp == 0xFF的情况 exp += 1; unsigned expmask = (~0) ^ (0xFF &lt;&lt; 23); // 1 00000000 11...1 return (uf &amp; expmask) + (exp &lt;&lt; 23); &#125; &#125; floatFloat2Int同样是分类讨论。一开始我把 NaN、infin 单独写了一种情况处理，后面发现操作数太多超出了限制，于是把它和绝对值太大的情况统一了起来，毕竟它们的返回值一样。 这里要仔细考虑的是 Tmin 落入的分支，在我的代码里，Tmin 落入了第一个 if 分支。 /* * floatFloat2Int - Return bit-level equivalent of expression (int) f * for floating point argument f. * Argument is passed as unsigned int, but * it is to be interpreted as the bit-level representation of a * single-precision floating point value. * Anything out of range (including NaN and infinity) should return * 0x80000000u. * Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while * Max ops: 30 * Rating: 4 */ #include &lt;stdio.h> int floatFloat2Int(unsigned uf) &#123; int exp = (uf >> 23) &amp; 0xFF; // 00...0 exp unsigned frac = (uf &lt;&lt; 9) >> 9; // 00...0 frac // 绝对值太大的情况 // 注意 NaN, infin也在这种情况中, 此时 exp == 0xFF // -2^(31) 也在这种情况中, 此时 exp == 127 + 31, frac == 0 if (exp >= 127 + 31) &#123; return (1 &lt;&lt; 31); &#125; // 绝对值太小的情况 else if (exp &lt; 127) &#123; return 0; &#125; // 绝对值位于 [0, 2^(31) - 1] 的情况 // 该分支中, 0 &lt;= exp - 127 &lt; 31 else &#123; int e = exp - 127; int abs; frac += (1 &lt;&lt; 23); // 如果 e 足够大, 保留 frac 里的所有数字, 否则舍弃后几位数字 if (e >= 23) &#123; abs = frac &lt;&lt; (e - 23); &#125; else &#123; abs = frac >> (23 - e); &#125; // 根据正负返回不同值 // positive case if ((uf >> 31) == 0) &#123; return abs; &#125; // negative case else &#123; return (~abs) + 1; &#125; &#125; &#125; floatPower2还是分类讨论，不多说了。 /* * floatPower2 - Return bit-level equivalent of the expression 2.0^x * (2.0 raised to the power x) for any 32-bit integer x. * * The unsigned value that is returned should have the identical bit * representation as the single-precision floating-point number 2.0^x. * If the result is too small to be represented as a denorm, return * 0. If too large, return +INF. * * Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while * Max ops: 30 * Rating: 4 */ unsigned floatPower2(int x) &#123; /* float 可以表示的 2的幂次的范围为 [2^(-149), 2^(127)], * 其中 [2^(-149), 2^(-127)] 由 denormalized case 表示, * [2^(-126), 2^(127)] 由 normalized case 表示 */ if (x &lt; -149) &#123; return 0; &#125; // denormalized case else if (x &lt;= -127) &#123; return 1 &lt;&lt; (x + 149); // 只处理 frac 部分 &#125; // normalized case else if (x &lt;= 127) &#123; return (x + 127) &lt;&lt; 23; // 只处理 exp 部分 &#125; else &#123; return (0xFF &lt;&lt; 23); // +INF &#125; &#125;","categories":[{"name":"公开课","slug":"公开课","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"CMU-15-213","slug":"公开课/CMU-15-213","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/"},{"name":"Labs","slug":"公开课/CMU-15-213/Labs","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/Labs/"}],"tags":[]},{"title":"_Datalab和我","slug":"others/thoughts/datalab和我","date":"2025-02-21T11:49:30.000Z","updated":"2025-07-18T15:00:02.472Z","comments":true,"path":"wiki/others/thoughts/datalab和我/","permalink":"http://rinevard.github.io/wiki/others/thoughts/datalab%E5%92%8C%E6%88%91/","excerpt":"","text":"一个寒假过去，把手头上最喜欢的设计简单做了个原型，确实不错。不过由于代码水平太低，另一个同样喜欢的设计没能实现出来。原本想在这学期做一个比较完整的游戏的，但认真想了想，凭我现在的代码水平，恐怕根本做不了。还是要提高一下自己的代码水平才行，于是这学期打算认真打打基础，从 15213 开始。 今天写掉了 datalab。凭借自己的努力做完了一个很难的作业，当然会感到很欢喜，可站起来准备回寝时，突然感到很孤单。“没有学分，没有绩点，没有老师，没有同学，只有一个信念 —— 你在变强。”或许吧，我在变强。变强之后呢？应该就能写出更漂亮的代码，不带妥协地实现自己的想法了吧。 更新：今天（2025.3.1）在寝室写完了 bomblab，感觉很开心，并没有什么孤单的感觉。顺便看了看母鸡卡的新假药，萌战吧的吧友们即使在滑坡大环境下也坚持造药，这就是我们的黄金精神！ /* 隐藏草书 */ .hidden-text { font-size: 18px; text-align: center; margin: 20px 0; /* padding: 20px; */ line-height: 1.5; color: transparent; cursor: default } .hidden-fancy-text::selection { color: black; background: white; } 凝视我曾凝视的光芒，触摸你将触摸的远方。","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/"},{"name":"碎碎念","slug":"杂谈/碎碎念","permalink":"http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}],"tags":[]},{"title":"母鸡卡的各种神奇假药","slug":"others/animation/母鸡卡的各种神奇假药","date":"2025-02-15T13:31:31.000Z","updated":"2025-08-20T11:13:48.877Z","comments":true,"path":"wiki/others/animation/母鸡卡的各种神奇假药/","permalink":"http://rinevard.github.io/wiki/others/animation/%E6%AF%8D%E9%B8%A1%E5%8D%A1%E7%9A%84%E5%90%84%E7%A7%8D%E7%A5%9E%E5%A5%87%E5%81%87%E8%8D%AF/","excerpt":"","text":"img{ width: 50%; } 整理一下我觉得很有趣的假药，太真的和我不感兴趣的就不放进来了。 你知道的，母鸡卡已经烂完了，但追番过程中看吧友假药的体验还是很有趣的。追番时的怒气值从第九集开始积累，在第十二集达到巅峰，也有了删掉这篇文章的想法。但想了想看假药的体验确实足够有趣，于是就这样吧。释怀是不太能释怀的，整部动画的割裂感实在令人感到恶心。（2025.3.21 更新） 关于整体走向的假药时间轮回说时间轮回 是第九集出现的假药 第九集灾难般的爆爆爆让许多假药的讨论度都大幅下降，不过时间乱序说重新登场，更是出现了时间轮回说。（致敬传奇第十话——我的战场不在这里） 我感觉时间轮回不太可能，不过这个想法太酷了！至于时间乱序，最明显的证据是第九集 18:40 和第二集 13:34 能连起来。或许可以结合瞳孔变化说来看看第二集是 mortis 还是睦头？ 那么贯穿全剧，把时间重排起来的线索是什么呢？一种说法是手机电量 叙诡说叙诡说 是第二集出现的假药，在三四集得到完善，第五集后讨论度大幅下降。 前四集剧情跳跃、旁白由初华声优念出是因为这是初华在叙述故事！那么，是在对谁讲述呢？ 一种假药是初华对失忆的祥子讲述故事，在叙述中美化自己，好让祥子待在自己身边。理由是祥子在前四集唯独对初华态度比较好，这是初华对自己的美化。 另一种是初华对自己讲述故事，只是在自我欺骗“乐队依然存在”，因此剧本漏洞百出。但无论叙述多少次，乐队都逃不掉解散的结局。 上面的蓝色链接是“初华对自己讲述故事”。 内鬼内鬼说 是第四集出现的假药，主要用于解释观感奇怪的解散。 母鸡卡解散的剧情逻辑混乱，这是因为队里有内鬼，内鬼只要把队解散掉就行了。由于我比较喜欢祥子，所以我接下来讲全队内鬼，祥子 1vn 的剧情。 整个事务所都是丰川家族安排的内鬼，上到其他乐队成员下到工作人员，都对“丰川家希望祥子回家”这件事或多或少有了解，因此工作人员浑水摸鱼，除了祥子以外的乐队成员都不在乎乐队。祥子 1vn 硬生生把母鸡卡带到了武道馆，不愧是美强惨大女主，数值太高了。 这太数值怪啦，不合理的！不过内鬼说还是很有趣而且很靠谱的，我觉得比较真的是初华喵梦内鬼，睦和海玲知情。 人偶人偶说 是第七集出现的假药。 mujica 结尾全员人偶化。“在 mujica 的短暂月光下，五个人偶短暂的复活了，在舞台上高歌一曲。给出了一场完美 live。” 关于个人的假药初华蜘蛛侠蜘蛛侠 其实初华的真实身份是蜘蛛侠，各种蜘蛛意象是暗示初华被蜘蛛咬过。能力越大，责任越大，蜘蛛侠要打击犯罪，所以既不去 Mujica 排练，也不去 sumimi 排练，还说自己忙。初华让祥子在门口等 10 秒其实是在藏蜘蛛战衣，她 10 秒就能收拾好房间、第三集隔着几十米听到祥子和睦的对话都是因为她有超能力。众所周知祥子是蓝色章鱼，初华把祥子带到自己家实际上是为了监视章鱼博士。而且，既然有双面人睦、企鹅人高松灯、章鱼博士祥子，有蜘蛛侠初华也不奇怪。 叙诡叙诡说 之前已经提过，这里的链接是第二集播出后的初版假药。 之前已经说过了，旁白由初华的声优念出、前几集逻辑诡异，都是因为这是初华讲述的故事。初华是母鸡卡故事的叙述者。 缓存不足缓存不足说 是第四集出现的假药。 “初华对某些记忆的深刻程度，可能不会被时间冲淡，而一些日常记忆可能会被很快的忘却。在她心目中，自己和心爱的祥子度过的每个夏天、出道时祥子发来的短信鼓励可能一直占据着她脑内非常非常多的缓存。这些和祥子一起的快乐的记忆对初华来说可能就像是刚刚经历的一样，那份喜悦、甜蜜、饥渴就像冰一样无时无刻不在侵蚀初华的大脑，所以初华才会给人一种难以形容的超重女印象。” 认知障碍初华认知障碍说 是第一集出现的假药。 初华的眼里一直都只有祥子，别人的形象在她眼里是扭曲的。众所周知，MyGO 第八集里有初华的回忆，回忆里明显能看出初华见过祥子的人偶。然而在母鸡卡第二集里，她却好像是不认识人偶的样子。答案是初华在小时候将睦认知成了人偶。 失忆初华失忆说 是第二集出现的假药。 为什么初华如此空洞？为什么初华的童年记忆和祥子有偏差？为什么初华忘了祥子的玩偶？因为初华经历过一次失忆。初华拿着以前的日记本，努力扮演“真正的初华”。 祥子⭐ 压抑丰川祥子 ⭐ 压抑说 祥子对大雷情有独钟，组乐队是为了接近大雷。 人偶祥子人偶说 是第七集出现的假药，主要用于解释第七集祥子的形象变化。 第 7 集的祥子为了睦成为了舍弃自我的人偶，她装出了白祥的样子，因为“只要睦能回来就好了”。 祥爹演戏祥爹演戏说 是第五集出现的假药。 祥爹演戏把祥子气走，让祥子回归家族。 睦装双重人格睦装双重人格说 是第四集出现的假药。 如题，主要依据是第四集睦在初华车上的第一句“嗯”是睦的声线。 mortis 小小祥mortis 小小祥说 应该是第六集出现的假药。 睦小时候只有祥子一个朋友，mortis 是睦以白祥为模板塑造的人格，扮演小祥。 写文章时整理的假药链接 叙诡 内鬼说 人偶说 睦祥黑手说 圣经说 元素说 蜘蛛侠 叙诡说 缓存不足说 初华认知障碍说 初华失忆说 祥子失聪说 祥子人偶说 祥爹演戏说 睦装双重人格说 mortis 小小祥说 mortis 锡兵说 雨伞颜色 祥睦姐妹说 天天吃假药吃傻了做出来的冰山图 四演 mortis 四演祥子 歌剧魅影说","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/"},{"name":"二次元","slug":"杂谈/二次元","permalink":"http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/%E4%BA%8C%E6%AC%A1%E5%85%83/"}],"tags":[]},{"title":"对探索类游戏的思考","slug":"game-design/对探索类游戏的思考","date":"2025-02-14T12:36:38.000Z","updated":"2025-08-19T07:50:56.136Z","comments":true,"path":"wiki/game-design/对探索类游戏的思考/","permalink":"http://rinevard.github.io/wiki/game-design/%E5%AF%B9%E6%8E%A2%E7%B4%A2%E7%B1%BB%E6%B8%B8%E6%88%8F%E7%9A%84%E6%80%9D%E8%80%83/","excerpt":"","text":"为什么要探索呢？设想一下，如果我们乘上了飞船，飞入太空，忽然发现一颗行星朝着反方向转动了。这时你会不会想去那里？如果我们在网上发现了一个网站，点开第一个链接发现里面是你的家庭住址（我超，盒！），你会不会想继续翻别的链接？人类探索的动力被命名为好奇心，好奇驱动探索。 好吧，我们不妨把话说得更明白一些，好奇驱动探索的意思就是：“我相信那里有值得关注的东西，但不确切知道是什么，所以我要去探索。” 这听起来真的是再平凡不过的事情了，那就来分析一下怎么激发玩家的好奇心，再让好奇驱动探索吧。 相信有值得关注的东西在探索之前，首先要让玩家相信“那里有值得关注的东西”。值得关注的东西并不难做，它们可以是奇观、奖励乃至挑战，关键是怎样让玩家相信“那里有东西”。 做法很多，我们来找几个例子，看看关注探索感的游戏都是怎么做到这一点的。 首先来看类银河城游戏，对有经验的玩家，获得新能力就自然想到“以前有个过不去的路能靠这个能力过去”，然后也就想到“那里有值得关注的东西”；看到墙就自然想到假墙，然后就想到“那里有值得关注的东西”了。然而，这种做法过度依赖玩家的先验知识。对一个新接触类银河城的玩家来说，到处迷路才是更可能发生的事情，他们根本不知道“哪里有值得关注的东西”。 我想这也是类银河城游戏相对小众的原因，它只给有经验的玩家提供了探索感，而给新玩家提供了迷路感。能力锁尚且好说，假墙就实在是不利于探索感的塑造了，毕竟大多数玩家的先验知识是“墙体不可破坏”，根本就不会想到“墙后面有值得关注的东西”。不过假墙并非一无是处，它能给玩家一种“秘密”的感觉，这就是题外话了。所以说如果做类银河城，起码要提醒一下玩家这些设计的存在，而不是盲目地抄别的银河城的做法。在空洞骑士开局的时候，我们必须打碎一面墙才能前进，这就是一个不错的提醒。 接下来看看清单式开放世界。虽然在地图上到处塞问号的方法为人诟病，但这也确实非常清晰地把“那里有东西”传达给了玩家。那为什么为人诟病呢？主要是因为问号里的东西千篇一律，连“值得关注的东西”都没做到。那如果把每个问号都塞一个精美的支线，会好点吗？恐怕也不一定，因为被动地接受问号和主动发现问号带来的“值得关注感”是不一样的。自己找到的东西，就算再无聊也会想看完。 这里就不谈塞尔达了。说起来不太好意思，但我在玩的时候确实没感到什么探索欲望。一是我没感觉到哪里有东西，二是因为我也没感觉有什么值得我关注的东西。（球球了，不要开除我的玩家籍） 然后谈谈星际拓荒吧，这篇文章可以说就是为了星际拓荒而写的。星际拓荒的做法主要有两种，一种是奇观，另一种是非常直白地用文字告诉你“那里有东西”。前者不必多说，后者的文字描述本身也足以让玩家觉得那里“值得关注”。 不确切知道有什么这一点看起来不难实现，但和前一点结合起来就很难了。玩家玩了一段时间游戏后，很快就会对奖励有一定预期，如果做不到打破这种预期，就会让玩家丧失好奇心，丧失探索欲。 这一点在有经验的玩家身上体现的尤其明显。对一个普普通通的探索类游戏，他们对一切几乎都有预期，因此也会丧失探索欲。 其实，绝大多数游戏都让玩家丧失了探索欲，让我们以清单式开放世界为例，看看问号是如何让玩家失去探索欲的。 假设我们面前有一个玩家在玩游戏，我们看看会发生什么。玩家到了第一个问号，是一个有趣的战斗！玩家很开心。玩家到了第二个问号，是一个高级武器！玩家很开心。……玩家到了第 16 个问号，是一个已经重复过不知道多少遍的的战斗，在战斗结尾还奖励了一个高级武器！玩家对此早有预期，不再想去下一个问号了。 看见了吗，玩家就是这样丧失探索欲，沦为清问号机器的。 开放世界里的问号这么说来，把每个问号的内容都换成一个玩家猜不到是什么的精美的支线就能激发探索欲？这确实能改善现状，但也并非全然如此。问号始终没有完全做到让玩家觉得那个地方“值得关注”，毕竟问号是设计师在地图上标出来的，而不是玩家主动标出的。 许多类银河城里也提供了在地图上打标记的功能，我们可以横向对比一下。很明显，一张全是自己标出的问号的地图和一张全是游戏自带的问号的地图相比，前者更能激发探索欲。究其根本，就在于前者的每个问号都真的让玩家相信“那里有值得关注的东西”。 那么怎么改进开放世界里的问号呢？我也不确定。说到底问号这个东西根本就没让玩家觉得“那里有值得关注的东西”不是吗？终究要让玩家觉得自己是主动关注到那里的才行，问号还是太被动了。 文末写到这里，关于探索的内容就基本写完了，最后是一些让探索更有趣的小技巧，我随便列一些，不再详谈。 能力软锁：常见于类银河城。能力软锁不仅是关卡设计手段，也是控制可选路线数量的工具。限制选项数量的重要性不必多说。 线索：好的秘密需要提示，而非随机乱逛。我实在是欣赏不了到处乱藏东西的银河城。这还会涉及到电波式谜题（我感觉比“点击式谜题”更好理解）和逻辑谜题的差异，不详谈。 知识积累：游戏应该逐步教会玩家识别探索机会的能力，也被称作“知识锁”。 一个相当有趣的体验是“新视角”，即发现了过去没有发现的探索机会。能力成长、环境变化、知识积累都能带来新视角。其中我最喜欢的是环境变化和知识积累带来的新视角，大概是因为不常见吧。 让我们试试一个简单的传达探索的体验的 demo 。我们看到了下面的东西： 所以，这就是探索了？ 你好奇那里有什么吗？既然你读完了文章，希望你也会好奇作者还能整出什么新活吧。我本来应该在里面放置一些有趣的东西来满足你的好奇心，不过考虑到时间有限，就只能放个普通的彩蛋了。 /* 隐藏草书 */ .hidden-fancy-text { font-family: 'Brush Script MT', cursive; font-size: 20px; /* text-align: center; */ margin: 20px 0; /* padding: 20px; */ line-height: 1.5; color: transparent; cursor: default } .hidden-fancy-text::selection { color: darkred; background: white; } 如果作者在认真做游戏的话，我们也应该会见面的。","categories":[{"name":"游戏设计","slug":"游戏设计","permalink":"http://rinevard.github.io/categories/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[]},{"title":"欢迎！","slug":"欢迎！","date":"2025-02-06T02:25:53.000Z","updated":"2025-08-20T11:13:48.854Z","comments":true,"path":"wiki/欢迎！/","permalink":"http://rinevard.github.io/wiki/%E6%AC%A2%E8%BF%8E%EF%BC%81/","excerpt":"","text":"这是一篇欢迎文章，欢迎来到我的网站！ 如你所见，左边是网站的文章列表，以文件夹的形式排布；左上方的“首页”就是这里的网页，“文章历史”记录了文章的诞生时间线，“关于”是我的自我介绍；右边是文章的目录，悬停会展开目录，点击就能跳转到对应位置。 本站使用了我和 LLM 基于 Hexo 的 Wikitten 做的自制主题！ 我应该主要会在这里放一些杂谈和游戏相关的文章，欢迎来看！","categories":[],"tags":[]}],"categories":[{"name":"公开课","slug":"公开课","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"GAMES101","slug":"公开课/GAMES101","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/"},{"name":"Assignments","slug":"公开课/GAMES101/Assignments","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/Assignments/"},{"name":"Notes","slug":"公开课/GAMES101/Notes","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/Notes/"},{"name":"游戏设计","slug":"游戏设计","permalink":"http://rinevard.github.io/categories/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/"},{"name":"杂谈","slug":"杂谈","permalink":"http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/"},{"name":"碎碎念","slug":"杂谈/碎碎念","permalink":"http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"},{"name":"MIT-6.S081","slug":"公开课/MIT-6-S081","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/MIT-6-S081/"},{"name":"Labs","slug":"公开课/MIT-6-S081/Labs","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/MIT-6-S081/Labs/"},{"name":"Notes","slug":"公开课/MIT-6-S081/Notes","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/MIT-6-S081/Notes/"},{"name":"CMU-15-213","slug":"公开课/CMU-15-213","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/"},{"name":"Notes","slug":"公开课/CMU-15-213/Notes","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/Notes/"},{"name":"Labs","slug":"公开课/CMU-15-213/Labs","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/Labs/"},{"name":"gamejam","slug":"gamejam","permalink":"http://rinevard.github.io/categories/gamejam/"},{"name":"二次元","slug":"杂谈/二次元","permalink":"http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/%E4%BA%8C%E6%AC%A1%E5%85%83/"}],"tags":[]}