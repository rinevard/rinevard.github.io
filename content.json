{"meta":{"title":"Rinevard","subtitle":"","description":"","author":"Rinevard","url":"http://rinevard.github.io","root":"/"},"pages":[{"content":"<p>这里是一些有趣的人们，我的生活因他们而增添了一抹奇幻色彩。你知道的，我并没有很多社交技能点，所以便用这种方法来告诉未来的自己——我曾遇见过一些有趣的人。</p>\n<h1 id=\"北理工\"><a href=\"#北理工\" class=\"headerlink\" title=\"北理工\"></a>北理工</h1><p>先是一些算是同辈的人吧</p>\n<ul>\n<li><a href=\"https://example1.com\">示例链接 1</a> - 描述文字</li>\n<li><a href=\"https://example2.com\">示例链接 2</a> - 描述文字</li>\n<li><a href=\"https://example3.com\">示例链接 3</a> - 描述文字</li>\n</ul>\n<p>然后是一些前辈，虽然年龄也差不太多就是了</p>\n<ul>\n<li><a href=\"https://blog.flwfdd.xyz/\">范滇东的博客</a> - 如果没有前辈开发的 bit101，我的北理生活想必不会那么有趣。</li>\n<li><a href=\"https://zhouyifan.net/\">周弈帆的博客</a> - 一个有趣的前辈，写的博客对我有启发。</li>\n</ul>\n<p>这个页面是突发奇想做出来的，如果它让我和人们有了更多的联系，那实在很有趣！抱着对这份奇幻色彩的期待，便觉得这些文字值得写了。</p>\n"},{"content":"<p>一个寒假过去，把手头上最喜欢的设计简单做了个原型，确实不错。不过由于代码水平太低，另一个同样喜欢的设计没能实现出来。原本想在这学期做一个比较完整的游戏的，但认真想了想，凭我现在的代码水平，恐怕根本做不了。还是要提高一下自己的代码水平才行，于是这学期打算认真打打基础，从 15213 开始。</p>\n<p>今天写掉了 datalab。凭借自己的努力做完了一个很难的作业，当然会感到很欢喜，可站起来准备回寝时，突然感到很孤单。“没有学分，没有绩点，没有老师，没有同学，只有一个信念 —— 你在变强。”或许吧，我在变强。变强之后呢？应该就能写出更漂亮的代码，不带妥协地实现自己的想法了吧。</p>\n<p>更新：今天（2025.3.1）在寝室写完了 bomblab，感觉很开心，并没有什么孤单的感觉。顺便看了看母鸡卡的新假药，萌战吧的吧友们即使在滑坡大环境下也坚持造药，这就是我们的黄金精神！</p>\n<style>\n/* 隐藏草书 */\n.hidden-text {\n    font-size: 18px;\n    text-align: center;\n    margin: 20px 0;\n    /* padding: 20px; */\n    line-height: 1.5;\n    color: transparent;\n    cursor: default\n}\n\n.hidden-fancy-text::selection {\n    color: black;\n    background: white;\n}\n</style>\n\n<div class=\"hidden-text\"><br>凝视我曾凝视的光芒，触摸你将触摸的远方。<br></div>\n"},{"content":"<p>这里什么也没有哦~<br>文件夹已经很方便了，为什么还要用分类呢？</p>\n"},{"content":"<p>这里是 Rinevard. 喜欢独立游戏之类的新鲜事物。我应该主要会在站里放一些杂谈和游戏相关的文章，欢迎来看！</p>\n<p><img src=\"/images/fishhhhhhhhh.svg\" alt=\"\"></p>\n<p>偶尔会出现的爱好是取名，我还用过 Lyraine、鲤鱼、江知鹤（读起来和 rinevard 蛮像的）之类的名字。</p>\n<p>如果想和我联系，欢迎发邮件到 <a href=\"mailto:rinevard@outlook.com\">rinevard@outlook.com</a>！（不过不一定会看）</p>\n<p>我的 Github 账号: <a href=\"https://github.com/rinevard\">Rinevard</a>.</p>\n<p>另外，欢迎到<a href=\"https://rinevard.itch.io/\">我的 itch 主页</a>上玩我的游戏！</p>\n"},{"content":"<style>\n/* 草书效果相关样式 */\n.center-cursive-text {\n    font-family: 'Brush Script MT', cursive;\n    font-size: 24px;\n    color: darkred;\n    text-align: center;\n    margin: 20px 0;\n    /* padding: 20px; */\n    line-height: 1.5;\n    cursor: default;\n}\n\n/* 隐藏草书 */\n.hidden-fancy-text {\n    font-family: 'Brush Script MT', cursive;\n    font-size: 24px;\n    text-align: center;\n    margin: 20px 0;\n    /* padding: 20px; */\n    line-height: 1.5;\n    color: transparent;\n}\n\n.hidden-fancy-text::selection {\n    color: darkred;\n    background: white;\n}\n\n/* 人迹罕至的路 */\n.secret-message {\n    color: transparent;\n    cursor: default;\n    font-family: 'Brush Script MT', cursive;  /* 使用草书字体 */\n    font-size: 24px;\n    text-align: center;\n    margin: 20px 0;\n    line-height: 1.5;\n}\n\n.secret-message:hover {\n    color: darkred;\n    transition: color 0.5s ease;  /* 稍微延长过渡时间 */\n}\n</style>\n\n<div class=\"center-cursive-text\"><br>一片树林里分出两条路——<br></div>\n\n<div class=\"secret-message\"><br>而我选择了人迹更少的一条，<br></div>\n\n<div class=\"hidden-fancy-text\"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>从此决定了我一生的道路。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br></div>\n"},{"content":"<p>最近做了<a href=\"https://rinevard.itch.io/myriad-by-cards\">牌生万物</a>，感觉挺难受的。一直以来我都希望每一部作品都做得比上一部更好，这一部看起来比<a href=\"https://rinevard.itch.io/undertetris\">undertetris</a>好一点吗？或许吧，但我就是感觉不开心。</p>\n<p>想来可能是因为这不是我喜欢的体验吧。我想做出能打动玩家的作品，能让玩家记住一辈子，至少是一年的作品，而不是这样的莫名其妙的“融合卡牌”。玩着这个游戏时，比起对作品的满意，更多的是烦躁。也可能是因为现在是考试周压力大吧，我也不清楚。</p>\n<p>我想和LLM一起创造一个世界啊，一个栩栩如生的世界。每个事件都让人思考，每个角色都给人深刻印象，而不是现在的名词堆砌、数值膨胀。LLM不会写故事从来都不是借口，我们是不是本可以做得更好？</p>\n<p>我该怎么做才好？我该前往何方？</p>\n<p>我知道，让LLM生成的世界像《苏丹的游戏》一样本身就是一件不现实的事情。但起码它要像是一个世界吧，整个冒险是有故事性的吧，现在是个什么玩意？？？更可气的是这玩意还真有可玩性，做了一个靠强化程序和数值膨胀堆砌起来的东西真像是对自己的侮辱！</p>\n<p>至少，它的体验不该是数值膨胀。至少，让玩家玩下去的动力不该是强化程序。如果我们拿走了玩家的时间，我们起码应当补偿一些什么才对，而不该徒留悔恨感。</p>\n<p>可能也有点偏激了，可能只是我自己不喜欢这种类型而已……甚至我自己也觉得还算可以，至少确实有让我印象深刻的时刻。但我还是感觉不开心，毕竟，“我们是不是本可以做得更好？”</p>\n"},{"content":"<style>\n/* 草书效果相关样式 */\n.center-cursive-text {\n    font-family: 'Brush Script MT', cursive;\n    font-size: 24px;\n    color: black;\n    text-align: center;\n    margin: 20px 0;\n    line-height: 1.5;\n    cursor: default;\n}\n\n/* 重叠文字效果 */\n.text-overlay-container {\n    position: relative;\n    height: 100px;\n    margin: 20px 0;\n}\n\n.overlapping-text {\n    position: absolute;\n    width: 100%;\n    font-family: 'Brush Script MT', cursive;\n    font-size: 24px;\n    text-align: center;\n    color: black;\n    opacity: 0.15;\n    cursor: default;\n}\n\n/* 为每行文字设置不同的位置和透明度 */\n.text-1 { top: 0; opacity: 0.8; }\n.text-2 { top: 12px; opacity: 0.6; }\n.text-3 { top: 24px; opacity: 0.4; }\n.text-4 { top: 36px; opacity: 0.2; }\n.text-5 { top: 48px; opacity: 0.1; }\n.text-6 { top: 60px; color: transparent; }\n</style>\n\n<div class=\"center-cursive-text\"><br>一片树林里分出两条路——<br></div>\n\n<div class=\"center-cursive-text\"><br>而我选择了人来人往的一条，<br></div>\n\n<div class=\"center-cursive-text\"><br>只看到了六道印迹。<br></div>\n\n<div class=\"text-overlay-container\"><br>    <div class=\"overlapping-text text-1\">脚印</div><br>    <div class=\"overlapping-text text-2\">脚印</div><br>    <div class=\"overlapping-text text-3\">脚印</div><br>    <div class=\"overlapping-text text-4\">脚印</div><br>    <div class=\"overlapping-text text-5\">脚印</div><br>    <div class=\"overlapping-text text-6\">脚印</div><br></div>\n"},{"content":"<p>这里什么也没有哦~<br>文件夹已经很方便了，为什么还要用标签呢？</p>\n"},{"content":"<style>\n/* 隐藏文本相关样式 */\n.secret-text::selection {\n    color: white;\n    background: black;\n}\n.secret-text {\n    background: transparent;\n    cursor: default;    /* 鼠标样式保持默认 */\n}\n#output {\n    white-space: pre;\n    font-family: monospace;\n    font-size: 12px;\n    line-height: 12px;\n    letter-spacing: unset;\n    transform: unset;\n    overflow-y: hidden;\n    background: transparent;\n    cursor: default;    /* 鼠标样式保持默认 */\n}\n\n/* 草书效果相关样式 */\n.cursive-text {\n    font-family: 'Brush Script MT', cursive;\n    font-size: 20px;\n    color: darkred;\n    /* text-align: center; */\n    margin: 20px 0;\n    /* padding: 20px; */\n    line-height: 1.5;\n    cursor: default;    \n}\n\n/* 草书效果相关样式 */\n.center-cursive-text {\n    font-family: 'Brush Script MT', cursive;\n    font-size: 20px;\n    color: darkred;\n    text-align: center;\n    margin: 20px 0;\n    /* padding: 20px; */\n    line-height: 1.5;\n    cursor: default;\n}\n\n/* 隐藏草书 */\n.hidden-fancy-text {\n    font-family: 'Brush Script MT', cursive;\n    font-size: 22px;\n    /* text-align: center; */\n    margin: 20px 0;\n    /* padding: 20px; */\n    line-height: 1.5;\n    color: transparent;\n    cursor: default;\n}\n\n.hidden-fancy-text::selection {\n    color: darkred;\n    background: white;\n}\n\n/* 人迹罕至的路 */\n.paths-container {\n    display: flex;\n    justify-content: center;\n    margin: 20px 0;\n    font-family: 'Brush Script MT', cursive;\n    font-size: 20px;\n}\n\n/* 修改链接样式 */\n.paths-container a.path {\n    padding: 15px;\n    text-decoration: none !important;\n    border: none;  /* 移除可能的边框 */\n    background: none;  /* 移除可能的背景 */\n}\n\n/* 有人的路径样式 */\n.paths-container a.path-visible {\n    color: #5a3921 !important;  /* 使用 !important 来确保优先级 */\n}\n\n/* 隐藏的路径样式 */\n.paths-container a.path-hidden {\n    color: transparent !important;  /* 使用 !important 来确保优先级 */\n}\n\n/* 悬停效果 */\n.paths-container a.path-hidden:hover {\n    color: #5a3921 !important;\n    transition: color 0.3s ease;\n}\n\n/* visited状态 */\n.paths-container a.path-visible:visited {\n    color: #5a3921 !important;\n}\n\n.paths-container a.path-hidden:visited {\n    color: transparent !important;\n}\n\n.paths-container a.path-hidden:hover:visited {\n    color: #5a3921 !important;\n}\n</style>\n\n<p>对不起骗了大家这么久，其实我是一条鲤鱼。<br><img src=\"../images/secret/index/secret-fish.png\"></p>\n<pre id=\"output\" style=\"color: transparent;\" class=\"secret-text\">\n\n\n                                                             ..-*=.    \n                            ......:::.......               .:=*****:.  \n                        ..:=++*++=---------=++**+=:..    .:+********-. \n                ...+*+:..                   ..:=*+:.-***************-. \n                ..:-*+..                            .=***************: \n            .:=+*=**:                              .:***************+. \n        ..-=-     +*:                              .:****************: \n    ..:+          +*:                              .:****************- \n    .+*    **      +*:                              .:****************-\n    .-**          +*:                              .:****************: \n        +...+     +*:                              .:****************. \n            :.:=****-.                             .:***************-  \n                ..:-++-..                       ..-++-*************=.  \n                    ..:=**+=:.....     .....:-+**+:....-**********=..  \n                        ...:-===++++++==-:...           .-*******=.    \n                                                          ..=***+.     \n                                                           ..-*:.      \n\n\n</pre>\n\n<div class=\"cursive-text\"><br>嗯，实在是太敷衍了，所以我稍微加了点东西。<br></div>\n\n<div class=\"cursive-text\"><br>祝你好运，也祝你玩得开心。<br></div>\n\n<!-- 烛言加的东西 -->\n<div class=\"center-cursive-text\"><br>    黄昏的树林里分出两条路，<br>    所幸在此我能同时去涉足<br></div>\n\n<div class=\"paths-container\"><br>    <a href=\"many-people-path.html\" class=\"path path-visible\"><br>        人来人往的路<br>    </a><br>    <a href=\"jurora-path.html\" class=\"path path-hidden\"><br>        人迹罕至的路<br>    </a><br></div>\n\n<div class=\"hidden-fancy-text\"><br>    或许哪天还会再来看看这里的变化？启程了，再见啦。<br></div>\n"},{"content":"<h1 id=\"故事之前\"><a href=\"#故事之前\" class=\"headerlink\" title=\"故事之前\"></a>故事之前</h1><p>最近在学<a href=\"https://www.bilibili.com/video/BV1eE411F73t\">查理老师的编剧课</a>，课很有趣，不过信息密度似乎有点低，我就当单口相声听了。这篇文章记录了第五课老师布置的作业，故事的八要素、支点和大纲是我自己写的，具体内容是 AI 填充的，我把 AI 生成的多个版本拼拼凑凑得到了下面的故事（什么拼好文）。</p>\n<p>最近的思绪挺乱的。前两天做了个游戏原型，感觉大体上还算值得做，暂命名叫《翻命师》。这样的话，想做的事情实在是有点多了。想参加 GSoC 来接触下开发，顺便提升下 cpp 水平；想继续学公开课，了解下底层知识；还想花 100 天完整地做一个能放到 itch 甚至 steam 上的小游戏，跑一遍流程。</p>\n<p>说来有些凡尔赛，但上学期的成绩好得有点莫名其妙，以至于我真的开始考虑外保之类的事情。这就导致我们真的陷入了一个奇怪的“保研开发两手抓”的境地，但我的水平却不足以支持我把它们全部抓牢，于是便深感时间紧张。全抓牢真的不可能吗？如果是我的话说不定也能做到呢，但这样的生活是否缺乏了一抹奇幻色彩呢？比起把绝大多数时间都花在自我实现和提升自己的水平上，我还是想抽出时间来学学新东西，看看番剧，打打游戏。再说了，现在的社交水平仍然是负的，是不是该去提升一下？原本想着靠找人来试玩来和人们交流，但这又回到了开发上。虽然这看起来是条可行的路，但感觉有点点奇怪。</p>\n<p>人生短则二十年，长则一百年，我们究竟想做什么，想去往何方，想成为什么样的人？</p>\n<p>前路未定却仍试图看向未来，自会焦虑。不过我喜欢的一个虚拟角色在这种情况下想必会说：“焦虑也是一种不可多得的体验呢”。喜悦和平静自然是大家都喜欢的体验，但焦虑、悲伤这些负面情绪似乎也是奇妙的体验。人类，很神奇吧。</p>\n<p>话说回来，翻命师这个名字听起来就很有趣吧。听说为自己摆个”过路牌阵”，一行三牌，便能解一时之困。我回去摆一下试试。</p>\n<p>在 101 发了个没那么凡尔赛的版本。我在认真思考，BIT101 对我来说究竟意味着什么。我从未想过立一个很厉害的人设，但我在发帖时总会不自觉地只展示看起来不错的一面，于是渐渐地就只写出了一些“局部的真实”。</p>\n<p>那我是怎么发现这个版本有点凡尔赛的呢？答案是让 AI 写了一个翻版。我要求 AI 把和游戏、编程相关的内容换成别的领域的内容，就得到了本文中“故事之后——AI 的凡尔赛”那一节的内容。看了看，感觉真的好凡尔赛啊=) 于是就改了改。如果我真的很厉害就好了，可惜我并不。但我会变强的。</p>\n<h1 id=\"故事——玩乐的人\"><a href=\"#故事——玩乐的人\" class=\"headerlink\" title=\"故事——玩乐的人\"></a>故事——玩乐的人</h1><p>“姓名？”</p>\n<p>“李明。”</p>\n<p>“年龄？”</p>\n<p>“呃……十七岁？”</p>\n<p>检票员扫了他一眼，最后只是叹了口气，挥手放行。</p>\n<p>李明现年 32 岁，身高 169 厘米，体重 61.5 公斤，没有女朋友，没有宠物，没有不良嗜好。在李明居住的城市里，所有 20 岁以上的成年人都按照同样的程序生活：起床、工作、吃饭、睡觉，偶尔参加培训、会议和团建活动。政府颁布的《成年人行为准则》明确规定，成年人的首要任务是工作，次要任务是为国家培养合格公民，第三任务是照顾老人，第四任务是自我提升。第十七条特别强调：成年人严禁进入游乐设施。</p>\n<p>现在他站在游乐园入口处，身上裹着一件印着卡通恐龙的 T 恤，下半身穿着一条明显短了一截的背带裤，脚上是一双带灯的运动鞋。他的脸上贴着两块大号创可贴，试图掩盖胡茬的痕迹。</p>\n<p>李明小心翼翼地走进游乐园，手里握着一根棒棒糖，时不时紧张地舔一口，假装自己对糖果很感兴趣。实际上，他上一次吃棒棒糖还是在十三岁那年。</p>\n<p>“嘿！你在这里干嘛呀？你家大人呢？”一个游乐园工作人员走过来问道。</p>\n<p>“我爸爸去买饮料了，让我在这里等他。”李明背了五遍的标准答案脱口而出。</p>\n<p>工作人员上下打量了他几眼：”你多大了？看起来挺高的。”</p>\n<p>“我发育得早，十七岁。”李明掏出事先准备好的学生证，那是他从网上特意定制的。</p>\n<p>工作人员勉强相信了他的说法，转身离开。李明松了一口气，迅速往旋转木马方向走去。</p>\n<p>旋转木马上，李明紧紧抓住金色的扶手，感受着上下起伏的节奏。音乐响起，木马开始旋转，李明的心跳加速，一种奇怪的快感从脚底蔓延到全身。他已经记不清上一次有这种感觉是什么时候了。</p>\n<p>“你也是一个人来的吗？”旁边的木马上，一个大约九岁的小女孩问道。</p>\n<p>李明僵硬地点点头。</p>\n<p>“我也是！我妈妈在那边，”小女孩指着远处一个看手机的女人，”她说自己太忙了，没时间陪我玩。大人们总是很忙。”</p>\n<p>李明想起自己的父母。他们在李明八岁时就告诉他：”玩是没有出息的表现。”十二岁时，他们卖掉了他所有的玩具，换成了各种学习资料。十八岁时，他们为他制定了”成功人生规划表”，上面没有一项与娱乐有关。三十岁时，他们送给他一套”友爱公寓”的首付款，条件是他必须在十年内获得三次职位晋升。</p>\n<p>木马停下来后，李明迫不及待地跑向过山车。排队时，他故意弯着腰，装作比实际身高矮一些。轮到他时，检查身高的工作人员狐疑地看了他一眼：”你确定要玩吗？看起来有点紧张。”</p>\n<p>“我当然要玩！”李明用他练习过的童声说，声音因为紧张而有些发抖。</p>\n<p>过山车启动了，缓缓爬升。李明死死抓住安全杆，心脏几乎要跳出胸膛。风呼啸着掠过耳边，李明感到一种前所未有的自由。当车厢俯冲而下时，他放声尖叫，那是他 32 年人生中第一次如此肆无忌惮地尖叫。</p>\n<p>下了过山车，李明头晕目眩，但脸上挂着难以抑制的笑容。他感觉脖子有点僵硬，下意识地左右轻轻晃动了一下，缓解那股熟悉的酸痛。这是他工作十年养成的习惯——每天盯着电脑十小时，颈椎早已不堪重负。</p>\n<p>李明决定接着去玩碰碰车。坐进小车里，他像个真正的十七岁少年一样兴奋地抓紧方向盘。电流接通，车子启动，李明猛踩油门冲向前方。左冲右撞间，他又感到脖子一阵刺痛。他条件反射地做起了办公室保健操第三式：双手托住后脑勺，缓慢向后拉伸。</p>\n<p>一位游乐园的医护人员恰好路过，看到了李明标准的颈椎操动作。她驻足观察了几秒，然后走到碰碰车场地边缘。</p>\n<p>“这套颈椎病保健操做得不错啊，先生。”医护人员在李明经过时大声说道，”是职业医师教的吧？”</p>\n<p>李明一惊，猛地回头，车子失控撞上了场地边缘。</p>\n<p>“什么？不不不，我只是……”李明慌乱地摆手，”我……”他张了张嘴，最终还是像泄了气的气球一样瘫在碰碰车里，放弃了辩解。</p>\n<p>医护人员按下对讲机：”安保部，A 区有一位违规进入的成年人。”</p>\n<p>两名保安赶到，架起李明就往外走。路过旋转木马时，李明忍不住回头看了一眼，那些五颜六色的小马依然在音乐声中旋转，仿佛在向他告别。他的真实身份被确认：”李明，32 岁，工程师，违反《成年人行为准则》第十七条。”</p>\n<p>两个小时后，他被直接送往了”成年人再教育中心”。</p>\n<p>在那里，他被迫学习如何做一个”成熟的大人”：每天工作十小时，严肃阅读财经新闻，周末必须去公园遛狗或者喝咖啡，以塑造”符合社会期待的成年形象”。</p>\n<h1 id=\"故事之后——AI-的凡尔赛\"><a href=\"#故事之后——AI-的凡尔赛\" class=\"headerlink\" title=\"故事之后——AI 的凡尔赛\"></a>故事之后——AI 的凡尔赛</h1><p>最近在学<a href=\"https://www.bilibili.com/video/BV1eE411F73t\">余老师的诗歌创作课</a>，课很有趣，不过信息密度似乎有点低，我就当单口相声听了。这篇文章记录了第五课老师布置的作业，诗歌的意象、结构和情感是我自己构思的，具体内容是借助写作软件润色的，我把几个版本拼拼凑凑得到了下面的作品（什么拼好诗）。</p>\n<p>最近的思绪挺乱的。前两天构思了个摄影专辑创意，感觉大体上还算值得做，暂命名叫《时光师》。这样的话，想做的事情实在是有点多了。想投稿一些文学期刊来接触文坛，顺便提升下文笔水平；想继续研读一些经典著作，了解下文学理论；还想花 100 天完整地做一个能放到豆瓣甚至出版社投稿的诗集，跑一遍流程。</p>\n<p>说来有些凡尔赛，但上学期的文学竞赛成绩意外地好，以至于我真的开始考虑考研中文系或者去杂志社实习之类的事情。这就导致我们真的陷入了一个奇怪的”学术与创作两手抓”的境地，但我的水平却不足以支持我把它们全部抓牢，于是便深感时间紧张。全抓牢真的不可能吗？如果是我的话说不定也能做到呢，但这样的生活是否缺乏了一抹奇幻色彩呢？比起把绝大多数时间都花在自我实现和提升自己的水平上，我还是想抽出时间来阅读新书，看看番剧，去咖啡馆发呆。再说了，现在的社交水平仍然是负的，是不是该去提升一下？原本想着靠办读书会来和人们交流，但这又回到了文学上。虽然这看起来是条可行的路，但感觉有点点奇怪。</p>\n<p>人生短则二十年，长则一百年，我们究竟想做什么，想去往何方，想成为什么样的人？</p>\n<p>前路未定却仍试图看向未来，自会焦虑。不过我喜欢的一个虚拟角色在这种情况下想必会说：”焦虑也是一种不可多得的体验呢”。喜悦和平静自然是大家都喜欢的体验，但焦虑、悲伤这些负面情绪似乎也是奇妙的体验。人类，很神奇吧。</p>\n<p>话说回来，时光师这个名字听起来就很有诗意吧。听说为自己摆个”诗意三行”，记录三个瞬间，便能解一时之困。我回去试试。</p>\n<h1 id=\"翻命师\"><a href=\"#翻命师\" class=\"headerlink\" title=\"翻命师\"></a>翻命师</h1><p>这江湖之上，有一门玄门奇术，叫做”翻命一术”，修习此术之人，世人唤作”翻命师”。</p>\n<p>这翻命师不比寻常江湖术士，既不是掐指一算的算命先生，也不是敲盆问卦的游方道人。他们修的，乃是上古传下来的翻命秘术。但凡有人求问命途，这翻命师便能施展异术，将那人前程化作一张张命运符牌，一一摆在案上。</p>\n<p>这牌阵大小不一，全看机缘深浅。小则一行三牌，称为”过路牌阵”，多解一时之困；中则三行五牌，名唤”三星照命”，为那命途多舛之人寻觅转机；若遇命格复杂之人，或是牵连多人的大事，定要摆下五行七列的”天罗地网阵”，方能窥得命运全貌。</p>\n<p>却说这符牌玄妙非常。翻开一张，或显凶险，或现吉祥。翻命师观之，便知那人命中该有何等机缘。其技高者，还能将那不利的命数重新封回牌中，暂时封住那眼看就要降临的灾祸！</p>\n<p>江湖传闻，翻命师之术，非是逆天改命，乃是巧借天机。如同棋盘残局，看似已无生路，翻命师却能寻那缝隙间微妙一着，引得命运暗流转向。明是命中注定，实则皆由人心一念之差。高明的翻命师，不过是将那本就存在的可能，向明处轻推罢了。</p>\n<p>无论如何在做原型之前都不应该写剧情。不过我做了原型！所以我可以写一点点剧情了吧，虽然这段背景故事也大多是 AI 写的。</p>\n"}],"posts":[{"title":"多级页面测试","slug":"others/thoughts/多级页面测试","date":"2026-01-02T03:09:00.000Z","updated":"2026-01-02T03:09:39.340Z","comments":true,"path":"wiki/others/thoughts/多级页面测试/","permalink":"http://rinevard.github.io/wiki/others/thoughts/%E5%A4%9A%E7%BA%A7%E9%A1%B5%E9%9D%A2%E6%B5%8B%E8%AF%95/","excerpt":"","text":".hidden-link, .hidden-link span { color: transparent; cursor: default; } .hidden-link span::selection { color: blue; background: #e0e0ff; } 你好世界！ 玩乐的人 |我也想做出优秀的作品 |datalab和我","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/"},{"name":"碎碎念","slug":"杂谈/碎碎念","permalink":"http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}],"tags":[]},{"title":"树上的黄蜂","slug":"others/thoughts/大黄蜂","date":"2026-01-02T01:58:30.000Z","updated":"2026-01-02T02:40:55.512Z","comments":true,"path":"wiki/others/thoughts/大黄蜂/","permalink":"http://rinevard.github.io/wiki/others/thoughts/%E5%A4%A7%E9%BB%84%E8%9C%82/","excerpt":"","text":"打算在新年第一天鼓捣一些有趣的东西。稍微想了想感觉把大黄蜂挂树上会挺有趣，于是就开工了！ 我有一个硬币大小的大黄蜂，但我没有线啊😔 不过只要思想不滑坡，办法总比困难多。我们发挥主观能动性来想想手头上有什么能利用起来的东西吧。一个正常的大学生手头上有什么可以当线的东西呢？答案当然是『石之自由』！只要将自己的身体分散成线，就能把大黄蜂挂起来！ 开玩笑的，这超出射程范围了。不过我翻出了一根废弃数据线，用小刀把它割开就能拿出里面的细铜线了。这个东西太细而且弯弯绕绕以至于想打结都挺难的，但经过不懈努力我还是把它绑在了大黄蜂身上。我们先把它挂到灯线上打个结试试效果吧！ 效果不错，但我突然意识到好像拿不下来了…折腾半天终于解开了结，接下来我们前往树林吧——然后把她挂上去！ 再来点特写 我们成功了喵🫠🫠 晚上再来看看，大黄蜂成功存活！ 第二天早上再来看看，大黄蜂成功存活一天！","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/"},{"name":"碎碎念","slug":"杂谈/碎碎念","permalink":"http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}],"tags":[]},{"title":"Lab 6 Building an IP router","slug":"learning/open-course/CS144/labs/lab6-ip-router","date":"2025-12-31T04:38:28.000Z","updated":"2025-12-31T05:10:40.188Z","comments":true,"path":"wiki/learning/open-course/CS144/labs/lab6-ip-router/","permalink":"http://rinevard.github.io/wiki/learning/open-course/CS144/labs/lab6-ip-router/","excerpt":"","text":"在这个 Lab 里我们要实现按转发表转发数据报的方法。我们不需要实现构造转发表的算法，也不需要用前缀树来快速查询转发表，所以实现起来不算难。 转发表需要对给定的 IP 给出下一跳的 IP 和对应的出接口/端口号，我们先来看看头文件和相应的新增转发表条目的方法： class Router &#123; public: // ... private: std::pair&lt;size_t, std::optional&lt;Address>> find_best_route( const IPv4Datagram&amp; dgram ) const; // The router's collection of network interfaces std::vector&lt;std::shared_ptr&lt;NetworkInterface>> interfaces_ &#123;&#125;; struct ForwardEntry &#123; uint32_t route_prefix &#123;&#125;; uint8_t prefix_length &#123;&#125;; std::optional&lt;Address> next_hop = std::nullopt; size_t interface_num &#123;&#125;; &#125;; std::vector&lt;ForwardEntry> forward_table_ &#123;&#125;; &#125;; void Router::add_route( const uint32_t route_prefix, const uint8_t prefix_length, const optional&lt;Address> next_hop, const size_t interface_num ) &#123; forward_table_.push_back( &#123; route_prefix, prefix_length, next_hop, interface_num &#125; ); &#125; 然后我们要实现按转发表转发数据的方法。一个路由器有多个端口，每个端口通常对应一个子网。这里的 NetworkInterface 是对端口的抽象，路由器则通过端口之间的数据交换实现了多个子网之间的数据交换。 我们可以用前缀树把查表速度优化为常数级，但 Lab 文档说 $O(N)$ 的查表速度是可以接受的，所以我这里就不优化了。 void Router::route() &#123; for ( auto&amp; interface : interfaces_ ) &#123; auto&amp; datagram_received = interface->datagrams_received(); while ( not datagram_received.empty() ) &#123; auto dgram = std::move( datagram_received.front() ); datagram_received.pop(); const auto [interface_num, next_hop] = find_best_route( dgram ); if ( dgram.header.ttl != 0 &amp;&amp; --dgram.header.ttl != 0 &amp;&amp; next_hop.has_value() ) &#123; dgram.header.compute_checksum(); interfaces_[interface_num]->send_datagram( std::move( dgram ), next_hop.value() ); &#125; &#125; &#125; &#125; 要注意左移 32 位是未定义行为，所以我们要特殊处理 prefix_length == 0 即默认路由的情况。 std::pair&lt;size_t, std::optional&lt;Address>> Router::find_best_route( const IPv4Datagram&amp; dgram ) const &#123; size_t interface_num = 0; std::optional&lt;Address> next_hop = std::nullopt; uint8_t longest_prefix_match = 0; for ( const auto&amp; entry : forward_table_ ) &#123; if ( entry.prefix_length &lt; longest_prefix_match ) &#123; continue; &#125; const uint32_t mask = ( entry.prefix_length == 0 ) ? 0 : ( UINT32_MAX &lt;&lt; ( 32 - entry.prefix_length ) ); if ( ( entry.prefix_length == 0 ) || ( ( dgram.header.dst &amp; mask ) == ( entry.route_prefix &amp; mask ) ) ) &#123; // The range of left shift counts is limited in 0-31, so `mask` is not reliable when // entry.prefix_length == 0, which means the entry is the default route, so we do not use `mask` when // prefix_length == 0 interface_num = entry.interface_num; longest_prefix_match = entry.prefix_length; next_hop = entry.next_hop.value_or( Address::from_ipv4_numeric( dgram.header.dst ) ); &#125; &#125; return &#123; interface_num, next_hop &#125;; &#125;","categories":[{"name":"公开课","slug":"公开课","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"CS144","slug":"公开课/CS144","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/CS144/"},{"name":"Labs","slug":"公开课/CS144/Labs","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/CS144/Labs/"}],"tags":[]},{"title":"Lab 4 Measuring the real world","slug":"learning/open-course/CS144/labs/lab4-real-world","date":"2025-12-30T03:16:28.000Z","updated":"2025-12-30T03:24:03.007Z","comments":true,"path":"wiki/learning/open-course/CS144/labs/lab4-real-world/","permalink":"http://rinevard.github.io/wiki/learning/open-course/CS144/labs/lab4-real-world/","excerpt":"","text":"这个 Lab 让我们 ping 一小时远程主机来收集数据画图。我在校园网环境下 ping 了 github、mit.edu，还在手机热点下 ping 了 mit.edu。 可以看出手机热点延迟波动大，但总体延迟优于校园网。 比较有趣的是在我运行 traceroute mit.edu 时，校园网环境下解析出的 IP 是 23.75.122.29（位于美国），而手机热点环境解析出的 IP 是 184.87.104.30（位于香港）。这是因为 DNS 返回的 IP 和供应商有关（大概吧🫠🫠）","categories":[{"name":"公开课","slug":"公开课","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"CS144","slug":"公开课/CS144","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/CS144/"},{"name":"Labs","slug":"公开课/CS144/Labs","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/CS144/Labs/"}],"tags":[]},{"title":"Lab 5 Down the stack (the network interface)","slug":"learning/open-course/CS144/labs/lab5-network-interface","date":"2025-12-30T03:01:28.000Z","updated":"2025-12-31T02:54:36.231Z","comments":true,"path":"wiki/learning/open-course/CS144/labs/lab5-network-interface/","permalink":"http://rinevard.github.io/wiki/learning/open-course/CS144/labs/lab5-network-interface/","excerpt":"","text":"在这个 lab 里，我们要把第二层链路层和第三层网络层连接起来，实现一个能让同一子网下的主机通信的接口。在出站方向，我们的代码将 IP 包封装为 ETH 帧，并视情况发起 ARP 请求以维护 IP 到 MAC 的映射表；在入站方向，我们把 ETH 帧解析为 IP 包并向上传递，或解析为 ARP 协议包并更新 ARP 表。 我们要维护 ARP 表和“想要发送但尚不知道目标 MAC 地址的包”列表，并在一定时间后让它们过期。所以我们在头文件里新增以下字段： class NetworkInterface &#123; public: // ... private: // ... static constexpr size_t ARP_TTL = 30000; static constexpr size_t ARP_SAME_REQUEST_CD = 5000; // Datagrams to send. We store datagrams whose next hop's MAC is still unknown here. struct PendingArpRequest &#123; std::vector&lt;InternetDatagram> buffered_datagrams &#123;&#125;; size_t ms_since_last_request &#123; SIZE_MAX &#125;; // Init to max so the first request is not limited by ARP_SAME_REQUEST_CD. &#125;; // Mapping ip to pending arp request std::unordered_map&lt;uint32_t, PendingArpRequest> pending_arp_requests_ &#123;&#125;; struct ArpEntry &#123; EthernetAddress eth_addr &#123;&#125;; size_t living_ms &#123; 0 &#125;; &#125;; // Table mapping IP to MAC and living time std::unordered_map&lt;uint32_t, ArpEntry> arp_table_ &#123;&#125;; &#125;; 在出站方向，如果已经知道下一跳对应的 MAC 地址，直接发送就行；如果不知道就要把想要出站的数据存储起来并广播 ARP 请求。注意对同一个 IP 的 ARP 请求不应太频繁，如实验文档所说我们可以设置一个五秒的 CD. 这里的 serialize 函数是一个辅助函数，用于把数据转换成二进制序列。在 InternetDatagram 这些类内部内存不一定连续（比如 std::vector&lt;Refstd::string&gt; payload &#123;&#125;），也可能有大小端问题，serialize 则处理这些问题把它们转化成连续的、网络序的字节流。 这里的 transmit 则是对主机的物理发信能力的抽象。 void NetworkInterface::send_datagram( InternetDatagram dgram, const Address&amp; next_hop ) &#123; EthernetFrame eth_frame &#123;&#125;; eth_frame.header.src = ethernet_address_; if ( arp_table_.contains( next_hop.ipv4_numeric() ) &amp;&amp; arp_table_[next_hop.ipv4_numeric()].living_ms &lt; ARP_TTL ) &#123; // Send datagram right away if the dst eth address is already known eth_frame.header.dst = arp_table_[next_hop.ipv4_numeric()].eth_addr; eth_frame.header.type = EthernetHeader::TYPE_IPv4; eth_frame.payload = serialize( dgram ); &#125; else &#123; pending_arp_requests_[next_hop.ipv4_numeric()].buffered_datagrams.push_back( std::move( dgram ) ); // Send ARP request if last ARP request with same IP was more than ARP_SAME_REQUEST_CD ago if ( pending_arp_requests_[next_hop.ipv4_numeric()].ms_since_last_request &lt; ARP_SAME_REQUEST_CD ) &#123; return; &#125; eth_frame.header.dst = ETHERNET_BROADCAST; eth_frame.header.type = EthernetHeader::TYPE_ARP; ARPMessage arpmsg; arpmsg.opcode = ARPMessage::OPCODE_REQUEST; arpmsg.sender_ethernet_address = ethernet_address_; arpmsg.sender_ip_address = ip_address_.ipv4_numeric(); arpmsg.target_ethernet_address = ETHERNET_ZERO; arpmsg.target_ip_address = next_hop.ipv4_numeric(); eth_frame.payload = serialize( arpmsg ); pending_arp_requests_[next_hop.ipv4_numeric()].ms_since_last_request = 0; &#125; transmit( eth_frame ); &#125; 在入站方向，接收到 ETH 帧时做个 Multiplexing 分成 IPV4 和 ARP 两个分支，遇到 IPV4 就放进 datagrams_received_ 给上层应用；遇到 ARP 先结合其 sender 的 IP 和 MAC 信息更新 ARP 表、发缓存的包（如果有），再根据类型判断是否回复。 void NetworkInterface::recv_frame( const EthernetFrame&amp; frame ) &#123; if ( frame.header.dst != ethernet_address_ &amp;&amp; frame.header.dst != ETHERNET_BROADCAST ) &#123; return; &#125; if ( frame.header.type == EthernetHeader::TYPE_IPv4 ) &#123; InternetDatagram dgram; if ( parse( dgram, frame.payload ) ) &#123; datagrams_received_.push( dgram ); &#125; else &#123; debug( \"recv_frame: Parse failed!\" ); &#125; &#125; else if ( frame.header.type == EthernetHeader::TYPE_ARP ) &#123; ARPMessage arpmsg; if ( parse( arpmsg, frame.payload ) ) &#123; arp_table_[arpmsg.sender_ip_address] = &#123; arpmsg.sender_ethernet_address, 0 &#125;; // Send datagrams whose next hop's MAC was unknown but is known now. if ( pending_arp_requests_.contains( arpmsg.sender_ip_address ) ) &#123; for ( const auto&amp; dgram : pending_arp_requests_[arpmsg.sender_ip_address].buffered_datagrams ) &#123; EthernetFrame eth_frame; eth_frame.header.src = ethernet_address_; eth_frame.header.dst = arp_table_[arpmsg.sender_ip_address].eth_addr; eth_frame.header.type = EthernetHeader::TYPE_IPv4; eth_frame.payload = serialize( dgram ); transmit( eth_frame ); &#125; &#125; pending_arp_requests_.erase( arpmsg.sender_ip_address ); // Send ARP reply if it is an ARP request asking for our IP address if ( arpmsg.opcode == ARPMessage::OPCODE_REQUEST &amp;&amp; arpmsg.target_ip_address == ip_address_.ipv4_numeric() ) &#123; EthernetFrame eth_frame &#123;&#125;; eth_frame.header.src = ethernet_address_; eth_frame.header.dst = arpmsg.sender_ethernet_address; eth_frame.header.type = EthernetHeader::TYPE_ARP; ARPMessage arpreply; arpreply.opcode = ARPMessage::OPCODE_REPLY; arpreply.sender_ethernet_address = ethernet_address_; arpreply.sender_ip_address = ip_address_.ipv4_numeric(); arpreply.target_ethernet_address = arpmsg.sender_ethernet_address; arpreply.target_ip_address = arpmsg.sender_ip_address; eth_frame.payload = serialize( arpreply ); transmit( eth_frame ); &#125; &#125; else &#123; debug( \"recv_frame: Parse failed!\" ); &#125; &#125; &#125; 最后是 tick 函数，它更新大家的计时器然后在到期时 erase 就行。注意别把边遍历边 erase 的逻辑写错了。 void NetworkInterface::tick( const size_t ms_since_last_tick ) &#123; for ( auto it = pending_arp_requests_.begin(); it != pending_arp_requests_.end(); ) &#123; auto&amp; [ip, pending_arp_request] = *it; pending_arp_request.ms_since_last_request += ms_since_last_tick; if ( pending_arp_request.ms_since_last_request > ARP_SAME_REQUEST_CD ) &#123; it = pending_arp_requests_.erase( it ); &#125; else &#123; ++it; &#125; &#125; for ( auto it = arp_table_.begin(); it != arp_table_.end(); ) &#123; auto&amp; [ip, arp_entry] = *it; arp_entry.living_ms += ms_since_last_tick; if ( arp_entry.living_ms > ARP_TTL ) &#123; it = arp_table_.erase( it ); &#125; else &#123; ++it; &#125; &#125; &#125;","categories":[{"name":"公开课","slug":"公开课","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"CS144","slug":"公开课/CS144","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/CS144/"},{"name":"Labs","slug":"公开课/CS144/Labs","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/CS144/Labs/"}],"tags":[]},{"title":"Lab 2 The TCP receiver","slug":"learning/open-course/CS144/labs/lab2-receiver","date":"2025-12-15T12:40:28.000Z","updated":"2025-12-15T13:43:09.896Z","comments":true,"path":"wiki/learning/open-course/CS144/labs/lab2-receiver/","permalink":"http://rinevard.github.io/wiki/learning/open-course/CS144/labs/lab2-receiver/","excerpt":"","text":"在这个 Lab 里我们要写 TCP 协议的接收方收到数据时的处理函数，以及构造接收方的回信的函数。 在 TCP 协议中我们要和三种索引打交道： seqno: 在 TCP 头部中空间很宝贵，所以只用 32 位来存储序列号，这就是 seqno. 考虑到安全性，seqno 不从 0 开始，而是从一个随机数 ISN 开始。 absolute seqno: 每个 TCP 连接中的字节流以 SYN 为开头，FIN 为结尾。用 64 位给每个字节编号就得到了 absolute deqno. stream index: 用 64 位给 TCP 连接中除 SYN 和 FIN 以外的实际数据编码就得到了 stream index. Sequence Numbers Absolute Sequence Numbers Stream Indices 标识 “seqno” “absolute seqno” “stream index” 起始点 从 ISN 开始 从 0 开始 从 0 开始 内容范围 包括 SYN/FIN 包括 SYN/FIN 不包含 SYN/FIN 性质 32 bits, 回绕 64 bits, 不回绕 64 bits, 不回绕 这里是示例数据，假设 ISN 为 $2^{32} - 2$，传输的内容为 “cat”，则有： element SYN c a t FIN seqno $2^{32} - 2$ $2^{32} - 1$ 0 1 2 absolute seqno 0 1 2 3 4 stream index 0 1 2 Translating between 64-bit indexes and 32-bit seqnos在 Lab 的开始我们要写 seqno 和 absolute seqno 间相互转换的两个函数，我的实现如下： Wrap32 Wrap32::wrap( uint64_t n, Wrap32 zero_point ) &#123; return zero_point + static_cast&lt;uint32_t>( n ); &#125; uint64_t Wrap32::unwrap( Wrap32 zero_point, uint64_t checkpoint ) const &#123; auto dist = [checkpoint]( uint64_t x ) &#123; return x > checkpoint ? ( x - checkpoint ) : ( checkpoint - x ); &#125;; const uint64_t k = checkpoint >> 32; const uint64_t val1 = raw_value_ - zero_point.raw_value_ + k * ( 1ULL &lt;&lt; 32 ); const uint64_t val2 = raw_value_ - zero_point.raw_value_ + ( k + 1 ) * ( 1ULL &lt;&lt; 32 ); const uint64_t val3 = raw_value_ - zero_point.raw_value_ + ( k - 1 ) * ( 1ULL &lt;&lt; 32 ); return std::min( &#123; val1, val2, val3 &#125;, [dist]( uint64_t x, uint64_t y ) &#123; return dist( x ) &lt; dist( y ); &#125; ); &#125; Implementing the TCP receiver然后我们要给 TCP 接收方写收到数据的处理函数和构造回信的函数了。这里主要有三个难点，我们分析一下： 怎么根据 message 里的 RST、SYN、FIN 改变收信方的状态？ 我们可以把 TCP receiver 分成 LISTEN、SYN_RCVD、CLOSE_WAIT 三种状态， LISTEN 是还没收到 SYN 的状态，SYN_RCVD 是收到 SYN 后正常接收数据的状态，CLOSE_WAIT 则是收到 FIN 后的状态。 另外，RST 表示发生了不可挽回的错误，因此在收到 RST 后应该立即抛出异常。在我们的代码里就表现为关闭 ByteStream. 每个 TCP 连接和一个 ByteStream 唯一绑定，是该连接向用户交付数据的唯一渠道。 怎么计算 ackno？ ackno 是我们需要的下一个 byte 的 32 位索引，也就是尚未被写入 ByteStream 的最小索引。ByteStream 存的是 stream index，所以我们要先根据它算出 absolute seqno，再用我们之前实现的 Wrap32 的各种方法得到 32 位的 ackno： const uint64_t abs_ackno = reassembler_.writer().bytes_pushed() + seen_syn_ + reassembler_.writer().is_closed(); const std::optional&lt;Wrap32> ackno = seen_syn_ ? std::optional&lt;Wrap32>( Wrap32::wrap( abs_ackno, zero_point_ ) ) : std::nullopt; 这里的 reassembler_.writer().is_closed() 不能换成 seen_fin_，因为收到 FIN 并不代表数据已经被填入了 ByteStream. 怎么计算 stream index？ 对带 SYN 的 message，stream index 就是 0. 对不带 SYN 的 message，stream index 是 absolute seqno - 1. 最后我们放代码： class TCPReceiver &#123; public: // ... private: Reassembler reassembler_; Wrap32 zero_point_ &#123; 0 &#125;; bool seen_syn_ &#123; false &#125;; &#125;; void TCPReceiver::receive( TCPSenderMessage message ) &#123; if ( message.RST ) &#123; reassembler_.reader().set_error(); return; &#125; if ( !seen_syn_ &amp;&amp; !message.SYN ) &#123; return; &#125; if ( !seen_syn_ &amp;&amp; message.SYN ) &#123; zero_point_ = message.seqno; seen_syn_ = true; &#125; const uint64_t abs_ackno = reassembler_.writer().bytes_pushed() + seen_syn_ + reassembler_.writer().is_closed(); const uint64_t stream_idx = message.seqno.unwrap( zero_point_, abs_ackno ) - !message.SYN; reassembler_.insert( stream_idx, std::move( message.payload ), message.FIN ); &#125; TCPReceiverMessage TCPReceiver::send() const &#123; const uint64_t abs_ackno = reassembler_.writer().bytes_pushed() + seen_syn_ + reassembler_.writer().is_closed(); const std::optional&lt;Wrap32> ackno = seen_syn_ ? std::optional&lt;Wrap32>( Wrap32::wrap( abs_ackno, zero_point_ ) ) : std::nullopt; const uint16_t window_size = ( reassembler_.writer().available_capacity() > UINT16_MAX ) ? UINT16_MAX : static_cast&lt;uint16_t>( reassembler_.writer().available_capacity() ); return &#123; ackno, window_size, reassembler_.reader().has_error() &#125;; &#125;","categories":[{"name":"公开课","slug":"公开课","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"CS144","slug":"公开课/CS144","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/CS144/"},{"name":"Labs","slug":"公开课/CS144/Labs","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/CS144/Labs/"}],"tags":[]},{"title":"Lab 1 Stitching substrings into a byte stream","slug":"learning/open-course/CS144/labs/lab1-reassembler","date":"2025-12-13T08:55:28.000Z","updated":"2025-12-15T12:19:14.727Z","comments":true,"path":"wiki/learning/open-course/CS144/labs/lab1-reassembler/","permalink":"http://rinevard.github.io/wiki/learning/open-course/CS144/labs/lab1-reassembler/","excerpt":"","text":"这个 Lab 里我们要手动构造一个 IP 请求，然后写一个把无序数据变成有序数据的 Reassembler. Send an Internet datagram by handReliability from unreliability 那节课的 notes（Lecture notes - Week 1 Day 2）里记录了一段示例代码，我们把它复制到 ip_raw.cc 然后改改就能发包了： #include \"address.hh\" #include \"socket.hh\" using namespace std; int main(int argc, char* argv[]) &#123; auto args = span( argv, argc ); string datagram; datagram += static_cast&lt;char>(0b0100'0101); // version and IHL datagram += string( 7, 0 ); // rest of first two lines datagram += static_cast&lt;char>(64); // TTL datagram += static_cast&lt;char>(5); // proto // checksum datagram += static_cast&lt;char>(0); datagram += static_cast&lt;char>(0); // sender ip datagram += static_cast&lt;char>(10); datagram += static_cast&lt;char>(194); datagram += static_cast&lt;char>(218); datagram += static_cast&lt;char>(138); // target ip datagram += static_cast&lt;char>(10); datagram += static_cast&lt;char>(195); datagram += static_cast&lt;char>(159); datagram += static_cast&lt;char>(100); string art; art += \" \"; art += \" /\\\\_____/\\\\ \"; art += \" / o o \\\\ \"; art += \" ( == ^ == ) \"; art += \" ) ( \"; art += \" ( ) \"; art += \"( ( ) ( ) ) \"; art += \"(__(__)___(__)_)\"; art += \" Lyraine Cat! \"; art += \" \"; datagram += art; RawSocket &#123;&#125;.send(datagram, Address(args[1], args[2])); return 0; &#125; 我在 WSL 上可以用上面的代码给室友的电脑发包，他能用 wireshark 监听到包，下图是 wireshark 截图： 接下来我们分析一下这段代码在做什么。我们被要求使用 Rawsocket 而非原始 socket 来发包，Raw Socket 一般工作在第三层网络层，所以我们要手动构造 IP 数据包。 我们回顾一下 IP header 的结构： struct ip &#123; uint8 ip_vhl; // version &lt;&lt; 4 | header length >> 2 uint8 ip_tos; // type of service uint16 ip_len; // total length, including this IP header uint16 ip_id; // identification uint16 ip_off; // fragment offset field uint8 ip_ttl; // time to live uint8 ip_p; // protocol uint16 ip_sum; // checksum, covers just IP header uint32 ip_src, ip_dst; &#125;; 然后按格式填入数据就行。 Reassembler接下来我们要实现一个重组器。重组器接受一个乱序的数据流，把他们组织成顺序并 push 到 ByteStream 中，这样读者就能读取顺序数据了，如下图所示： 我们用环存储到达的数据，并维护一个 valid_ 数组以记录环的哪些位置是有效数据。对到达的新数据，一个朴素的处理思路如下，可以对照代码下面的图片来理解： // 把数据存到环中 auto dst = ( head_ + first_index - first_unassembled_idx_ ) % ring_.size(); for ( uint64_t i = 0; i &lt; data.size(); i++ ) &#123; ring_[( dst + i ) % ring_.size()] = data[i]; valid_[( dst + i ) % ring_.size()] = 1; &#125; // 如果新数据填充了开头从而有了可以写入的连续数据, 写入 ByteStream if ( first_index == first_unassembled_idx_ ) &#123; // 计算 written_len, 写入 ByteStream // 更新 valid_, first_unassembled_idx, head_ &#125; 上面的思路只能处理新数据的两端（first_index 和 first_indx + data.size）都在环内的情况，然而新数据的某一端可能在环外，这时我们就要裁剪数据，只把和环重叠的部分存入环中。 接下来我们给出完整代码，先放头文件： class Reassembler &#123; public: explicit Reassembler( ByteStream&amp;&amp; output ) : output_( std::move( output ) ) , ring_( output_.writer().available_capacity() + 1 ) , valid_( output_.writer().available_capacity() + 1 ) &#123;&#125; // ... private: ByteStream output_; uint64_t head_ &#123;&#125;, first_unassembled_idx_ &#123;&#125;, eof_idx_ &#123; UINT64_MAX &#125;; std::vector&lt;char> ring_; std::vector&lt;char> valid_; // use vector&lt;char> instead of &lt;bool> to improve performance 然后是 insert 和 count_bytes_pending 的实现： #include \"reassembler.hh\" #include \"debug.hh\" #include &lt;algorithm> using namespace std; void Reassembler::insert( uint64_t first_index, string data, bool is_last_substring ) &#123; if ( output_.writer().is_closed() ) &#123; return; &#125; if ( is_last_substring ) &#123; eof_idx_ = first_index + data.size(); &#125; // Cut overlap data if ( first_index &lt; first_unassembled_idx_ ) &#123; const uint64_t offset = first_unassembled_idx_ - first_index; if ( offset >= data.size() ) &#123; return; &#125; data = data.substr( offset ); first_index = first_unassembled_idx_; &#125; // Copy data into ring const uint64_t capacity = output_.writer().available_capacity(); if ( first_index >= first_unassembled_idx_ + capacity ) &#123; return; &#125; const uint64_t cplen = std::min( data.size(), capacity - ( first_index - first_unassembled_idx_ ) ); const uint64_t dst = ( head_ + first_index - first_unassembled_idx_ ) % ring_.size(); const uint64_t len1 = std::min( cplen, ring_.size() - dst ); const uint64_t len2 = cplen - len1; std::copy( data.begin(), data.begin() + static_cast&lt;int64_t>( len1 ), ring_.begin() + static_cast&lt;int64_t>( dst ) ); std::copy( data.begin() + static_cast&lt;int64_t>( len1 ), data.begin() + static_cast&lt;int64_t>( cplen ), ring_.begin() ); std::fill( valid_.begin() + static_cast&lt;int64_t>( dst ), valid_.begin() + static_cast&lt;int64_t>( dst + len1 ), 1 ); std::fill( valid_.begin(), valid_.begin() + static_cast&lt;int64_t>( len2 ), 1 ); // Write into stream if possible if ( first_index == first_unassembled_idx_ ) &#123; uint64_t written_len &#123;&#125;; for ( written_len = 0; written_len &lt; capacity &amp;&amp; valid_[( head_ + written_len ) % ring_.size()]; written_len++ ) &#123; valid_[( head_ + written_len ) % ring_.size()] = 0; &#125; const uint64_t last = ( head_ + written_len ) % ring_.size(); // push [head_, last) or [head, size) + [0, last) into writer if ( head_ &lt;= last ) &#123; output_.writer().push( std::string( ring_.begin() + static_cast&lt;int64_t>( head_ ), ring_.begin() + static_cast&lt;int64_t>( last ) ) ); &#125; else &#123; output_.writer().push( std::string( ring_.begin() + static_cast&lt;int64_t>( head_ ), ring_.end() ) ); output_.writer().push( std::string( ring_.begin(), ring_.begin() + static_cast&lt;int64_t>( last ) ) ); &#125; first_unassembled_idx_ += written_len; head_ = last; // Close writer if all data have been writen into stream if ( first_unassembled_idx_ == eof_idx_ ) &#123; output_.writer().close(); &#125; &#125; &#125; // How many bytes are stored in the Reassembler itself? // This function is for testing only; don't add extra state to support it. uint64_t Reassembler::count_bytes_pending() const &#123; return std::ranges::count( valid_, 1 ); &#125; 最后跑出了 25Gbit/s 的结果，是文档说的“top-of-the-line”的两倍多🫠🫠 最后谈谈我优化性能的方法。我在优化时主要从少取模、少写 for 循环和少分支三方面考虑。 少取模和少写 for 循环是密切相关的。我们在用 for 循环遍历环时经常会对环的长度取模，典型例子就比如下面的代码： for ( uint64_t i = 0; i &lt; cplen; i++ ) &#123; ring_[( dst + i ) % ring_.size()] = data[i]; &#125; 取模的速度很慢，手搓 for 循环来逐字节拷贝也比 std::copy 慢，所以我们可以用 std::copy 来代替这里的循环，得到： const uint64_t len1 = std::min( cplen, ring_.size() - dst ); std::copy( data.begin(), data.begin() + len1, ring_.begin() + dst ); if (len1 &lt; data.size()) &#123; std::copy(data.begin() + len1, data.end(), ring_.begin()); &#125; 这能把 no overlap 的速度从 30Gbit/s 提升到 40Gbit/s，把 10x overlap 从 5Gbit/s 提升到 20Gbit/s 上面的效果已经很不错了，我们还能通过减少分支预测的开销来进一步优化性能： const uint64_t len1 = std::min( cplen, ring_.size() - dst ); std::copy( data.begin(), data.begin() + len1, ring_.begin() + dst ); std::copy( data.begin() + len1, data.begin() + cplen, ring_.begin() ); 这能把 no overlap 的速度从 40Gbit/s 提升到 70Gbit/s，把 10x overlap 从 20Gbit/s 提升到 25Gbit/s","categories":[{"name":"公开课","slug":"公开课","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"CS144","slug":"公开课/CS144","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/CS144/"},{"name":"Labs","slug":"公开课/CS144/Labs","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/CS144/Labs/"}],"tags":[]},{"title":"Lab 0 Networking Warmup","slug":"learning/open-course/CS144/labs/lab0-network-warmup","date":"2025-12-10T10:03:28.000Z","updated":"2025-12-12T08:26:04.875Z","comments":true,"path":"wiki/learning/open-course/CS144/labs/lab0-network-warmup/","permalink":"http://rinevard.github.io/wiki/learning/open-course/CS144/labs/lab0-network-warmup/","excerpt":"","text":"在这个 Lab 里我们要实现一个发 GET 请求的函数和一个“内存字节流”，我们开始吧。 webget首先我们回顾一下 CSAPP 里客户端使用 socket 接口的方法：getaddrinfo -&gt; socket -&gt; connect -&gt; read/write -&gt; close 然后对照 socket.hh 和 file_descriptor.hh 写出 C++ 版本的代码就行： void get_URL( const string&amp; host, const string&amp; path ) &#123; TCPSocket socket; socket.connect( Address( host, \"http\" ) ); socket.write( \"GET \" + path + \" HTTP/1.1\\r\\nHost: \" + host + \"\\r\\nConnection: close\\r\\n\\r\\n\" ); std::string buf; while ( !socket.eof() ) &#123; socket.read( buf ); std::cout &lt;&lt; buf; buf.clear(); &#125; &#125; 这里不需要手动调用 close，因为 file_descriptor.cc 的析构函数 ~FDWrapper() 自己会调用 close. 这是遵循了 C++ 的 RAII 规范。 测试代码的原理是 webget_t.sh 用管道重定向程序输出，然后对比正确值。 byte stream我们需要实现一个内存字节流，写者可以往里面写东西，读者可以读，字节流有最大容量。Lab 文档说无需考虑并发，所以我们简单做个环形队列然后设置读写头就行（死去的 6S081 记忆突然攻击我！） 首先设置几个成员变量，这里的 head_ 始终指向第一个有效数据，tail_ 始终指向空位置： class ByteStream &#123; public: explicit ByteStream( uint64_t capacity ); // Helper functions (provided) to access the ByteStream's Reader and Writer interfaces Reader&amp; reader(); const Reader&amp; reader() const; Writer&amp; writer(); const Writer&amp; writer() const; void set_error() &#123; error_ = true; &#125;; // Signal that the stream suffered an error. bool has_error() const &#123; return error_; &#125;; // Has the stream had an error? protected: // Please add any additional state to the ByteStream here, and not to the Writer and Reader interfaces. uint64_t capacity_; uint64_t tot_pushed_ &#123;&#125;; uint64_t head_ &#123;&#125;, tail_ &#123;&#125;; std::vector&lt;char> ring_; bool closed_ &#123;&#125;; bool error_ &#123;&#125;; &#125;; 这里成员变量命名结尾带下划线是 Google C++ Style，利于区分成员变量和局部变量 / 函数参数。 然后这里的 Reader 和 Writer 方法有什么用呢？Reader 和 Writer 继承自 ByteStream，允许用户用不同视角看同一个对象。这么说有点抽象，可以看向 byte_stream_helpers.cc，它只是做了类型转换。 Reader&amp; ByteStream::reader() &#123; static_assert( sizeof( Reader ) == sizeof( ByteStream ), \"Please add member variables to the ByteStream base, not the ByteStream Reader.\" ); return static_cast&lt;Reader&amp;>( *this ); // NOLINT(*-downcast) &#125; 读者和写者操控的是同一个 ByteStream 对象，我们则提供了两种不同的视角，每种视角有不同的操作数据的方法。 然后实现两种视角各自的接口： #include \"byte_stream.hh\" #include \"debug.hh\" using namespace std; // Leave one space to distinguish between a full ring and an empty ring. ByteStream::ByteStream( uint64_t capacity ) : capacity_( capacity ), ring_( capacity + 1 ) &#123;&#125; // Push data to stream, but only as much as available capacity allows. void Writer::push( const string&amp; data ) &#123; const auto written_len = std::min( available_capacity(), data.size() ); if ( written_len == 0 ) &#123; return; &#125; for ( uint64_t i = 0; i &lt; written_len; i++ ) &#123; ring_[tail_] = data[i]; tail_ = ( tail_ + 1 ) % ring_.size(); &#125; tot_pushed_ += written_len; &#125; // Signal that the stream has reached its ending. Nothing more will be written. void Writer::close() &#123; closed_ = true; &#125; // Has the stream been closed? bool Writer::is_closed() const &#123; return closed_; // Your code here. &#125; // How many bytes can be pushed to the stream right now? uint64_t Writer::available_capacity() const &#123; return ( head_ + ring_.size() - tail_ - 1 ) % ring_.size(); &#125; // Total number of bytes cumulatively pushed to the stream uint64_t Writer::bytes_pushed() const &#123; return tot_pushed_; &#125; // Peek at the next bytes in the buffer -- ideally as many as possible. // It's not required to return a string_view of the *whole* buffer, but // if the peeked string_view is only one byte at a time, it will probably force // the caller to do a lot of extra work. string_view Reader::peek() const &#123; if ( head_ == tail_ ) &#123; return &#123;&#125;; &#125; if ( head_ &lt; tail_ ) &#123; return &#123; ring_.begin() + static_cast&lt;int64_t>( head_ ), ring_.begin() + static_cast&lt;int64_t>( tail_ ) &#125;; &#125; return &#123; ring_.begin() + static_cast&lt;int64_t>( head_ ), ring_.end() &#125;; &#125; // Remove `len` bytes from the buffer. void Reader::pop( uint64_t len ) &#123; head_ = ( head_ + len ) % ring_.size(); &#125; // Is the stream finished (closed and fully popped)? bool Reader::is_finished() const &#123; return closed_ &amp;&amp; ( head_ == tail_ ); &#125; // Number of bytes currently buffered (pushed and not popped) uint64_t Reader::bytes_buffered() const &#123; return ( tail_ + ring_.size() - head_ ) % ring_.size(); &#125; // Total number of bytes cumulatively popped from stream uint64_t Reader::bytes_popped() const &#123; return tot_pushed_ - bytes_buffered(); &#125; 这里的 Reader::peek 无需返回整个环，只需尽力而为，所以我们在 head &gt; tail 时只返回 head 到 ring.size 部分的内容而没带上 0 到 tail 的内容；这里的 Writer::push 或许可以用 std::copy 来优化，但我就不写了吧。 然后放下测试结果：","categories":[{"name":"公开课","slug":"公开课","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"CS144","slug":"公开课/CS144","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/CS144/"},{"name":"Labs","slug":"公开课/CS144/Labs","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/CS144/Labs/"}],"tags":[]},{"title":"Lab 9 mmap","slug":"learning/open-course/MIT-6.S081/Labs/lab9-mmap","date":"2025-12-07T07:24:28.000Z","updated":"2025-12-07T07:30:24.305Z","comments":true,"path":"wiki/learning/open-course/MIT-6.S081/Labs/lab9-mmap/","permalink":"http://rinevard.github.io/wiki/learning/open-course/MIT-6.S081/Labs/lab9-mmap/","excerpt":"","text":"这个 Lab 要求我们要实现简单版的 mmap，它把文件映射到内存中以提高访问效率。mmap 的定义可以参考 man 2 mmap，总之它的参数如下： void *mmap(void *addr, size_t len, int prot, int flags, int fd, off_t offset); int munmap(void *addr, size_t length); 我们跳过系统调用的配置，因为想必大家已经品鉴的够多了。 sys_mmap 和 vmfaultLab 要求 lazy allocation，因此我们需要把 mmap 被调用时传入的参数记录在一个结构体中以便后续在 page fault 时按需分配，我设计的结构体如下： struct &#123; int valid; // Is this idx being used? uint64 st; // Start of the mmap, page aligned int len; // Number of bytes to map int prot; // PROT_READ or PROT_WRITE or both int flags; // MAP_SHARED or MAP_PRIVATE struct file *f; // Mapped file int off; &#125; mmap[NMMAP]; 其中 NMMAP 被定义在 param.h 中。这里定义成 16 是因为 Lab 文档说用长度为 16 的定长数组来记录 mmap 信息就够了。 #define NMMAP 16 这里简单聊下我是怎么设计结构体的。我在设计结构体时习惯快速写一个初版，然后在写后续代码的过程中迭代。像这里的初版就是把 mmap 的参数全塞进去再加个 valid 位，然后写 sys_mmap 时发现 offset 默认是 0 于是就删掉了 off，后来在写 sys_munmap 时又发现 off 是有用的就加了回来。 有了结构体以后我们就能实现 sys_mmap 了。在这个函数里简单地保存数据即可，无需复制文件内容到物理内存中，毕竟我们是 lazy allocation. uint64 sys_mmap(void) &#123; int len, prot, flags; struct file *f; struct proc *p; int i; // Ignore args[0], `addr`, which is always zero argint(1, &amp;len); argint(2, &amp;prot); argint(3, &amp;flags); if (argfd(4, 0, &amp;f) &lt; 0) &#123; return -1; &#125; // Ignore arg[5], `offset`, which is always zero if (!f->writable &amp;&amp; (flags &amp; MAP_SHARED) &amp;&amp; (prot &amp; PROT_WRITE)) &#123; return -1; &#125; p = myproc(); for (i = 0; i &lt; NMMAP; i++) &#123; if (!p->mmap[i].valid) &#123; p->mmap[i].valid = 1; p->mmap[i].st = PGROUNDUP(p->sz); p->mmap[i].len = len; p->mmap[i].prot = prot; p->mmap[i].flags = flags; p->mmap[i].f = f; p->mmap[i].off = 0; filedup(f); break; &#125; &#125; if (i == NMMAP) &#123; // No space to save metadata for this mmap return -1; &#125; p->sz = PGROUNDUP(p->sz) + PGROUNDUP(len); return p->mmap[i].st; &#125; 然后我们需要实现 page fault 来把传入 mmap 的文件复制到物理内存中。和 cow lab 类似，要修改 trap.c 的 usertrap 函数： if (r_scause() == 8) &#123; // system call // ... &#125; else if ((which_dev = devintr()) != 0) &#123; // ok &#125; else if ((r_scause() == 15 || r_scause() == 13) &amp;&amp; vmfault(p->pagetable, r_stval(), (r_scause() == 13) ? 1 : 0) != 0) &#123; // page fault on mmap page &#125; else &#123; // kill process // ... &#125; 然后这里是我对 vmfault 的实现： int ismapped(pagetable_t pagetable, uint64 va) &#123; pte_t *pte = walk(pagetable, va, 0); if (pte == 0) &#123; return 0; &#125; if (*pte &amp; PTE_V) &#123; return 1; &#125; return 0; &#125; uint64 vmfault(pagetable_t pagetable, uint64 va, int read) &#123; printf(\"vmfault\\n\"); printf(\"va: %lu, related page: %lu\\n\", va, PGROUNDDOWN(va)); uint64 mem; int perm, i; uint off; struct file *f = 0; struct proc *p = myproc(); if (va >= p->sz) return 0; if (ismapped(pagetable, va)) &#123; return 0; &#125; // Find mmap metadata corresponding to va for (i = 0; i &lt; NMMAP; i++) &#123; if (p->mmap[i].valid &amp;&amp; p->mmap[i].st &lt;= va &amp;&amp; va &lt; p->mmap[i].st + p->mmap[i].len) &#123; f = p->mmap[i].f; break; &#125; &#125; if (!f) return 0; // Alloc new page and fill with file data mem = (uint64)kalloc(); if (mem == 0) return 0; memset((void *)mem, 0, PGSIZE); ilock(f->ip); off = PGROUNDDOWN(va) - p->mmap[i].st + p->mmap[i].off; if (off > f->ip->size) return 0; readi(f->ip, 0, mem, off, PGSIZE); iunlock(f->ip); // Map page perm = PTE_U; if (p->mmap[i].prot &amp; PROT_READ) perm |= PTE_R; if (p->mmap[i].prot &amp; PROT_WRITE) perm |= PTE_W; if (mappages(p->pagetable, PGROUNDDOWN(va), PGSIZE, mem, perm) != 0) &#123; kfree((void *)mem); return 0; &#125; return mem; &#125; 至此我们就能通过第一个 munmap 之前的所有测试了。我们可能会疑惑，如果传入 mmap 的 len 比 f-&gt;ip-&gt;size 大很多怎么办？对照 man 文档可以发现我们应该在访问非文件区域时（超出文件大小的区域）应该发 SIGBUS 信号，但所幸测试代码没有测这一点，因此我们只要按需分页并复制就行了。如实验文档所言，“If mmaptest doesn’t use a mmap feature, you don’t need to implement that feature.” sys_munmap接下来我们实现一个便宜版本的 sys_munmap. 感觉在这个 Lab 里要不断回顾 ”If mmaptest doesn’t use a mmap feature, you don’t need to implement that feature”，不然实现起来就没完没了了🫠🫠 在 Lab 中，munmap 总是在尝试 unmap 一块形如 [start of a map, mid of this map] 或 [mid of a map, end of this map] 或 [start of a map, end of this map] 的区域。总之就是它只在一个 map 区域内 unmap，且不会挖洞。 自然而然地我们会想问，如果传入的参数覆盖了多个 mmap 区域呢？如果覆盖了普通内存呢？如果挖了个洞呢？ 我只能说，不要多想🫠🫠🫠🫠 但提出了问题总归是要给解答的，虽然我没有实现这些功能，而且不实现它们也能通过测试。根据 man 手册推测这几种情况的行为如下： 如果传入的参数覆盖了多个 mmap 区域，把它们都 unmap 掉（潜在的风险是每个区域的 flags 可能不同） 如果覆盖了普通内存，把那块内存释放掉 如果挖了个洞，把这块 mmap 区域分割成两块 mmap 区域 回到我们的 Lab. 在实现 sys_munmap 前有两点要注意，第一点是在 unmap 时要检查 map 区域是否被设为 MAP_SHARED，如果是要把内容写回文件；第二点是我们现在使用 lazy allocation，所以虚拟内存空间可能有未映射的虚拟页，因此要修改 uvmunmap 让它在遇到未映射的虚拟页时跳过而非 panic. 先来看看第一点，写回文件的实现如下，如 hint 所言参考 filewrite 就行： // Write parts of a shared mmap[i] back to file // theses parts must in mappepd pages and addr must be page-aligned int mmap_wbk(int i, uint64 addr, int len) &#123; struct file *f; uint64 fileend, src; struct proc *p; int pg; if (addr % PGSIZE != 0) &#123; return -1; &#125; p = myproc(); if (i >= NMMAP || !(p->mmap[i].flags &amp; MAP_SHARED) || addr &lt; p->mmap[i].st || addr + len > p->mmap[i].st + p->mmap[i].len) &#123; return -1; &#125; f = p->mmap[i].f; ilock(f->ip); fileend = p->mmap[i].st - p->mmap[i].off + f->ip->size; iunlock(f->ip); // Write valid pages back to file for (pg = 0; pg * PGSIZE &lt; len; pg++) &#123; if (walkaddr(p->pagetable, addr + pg * PGSIZE)) &#123; int max = ((MAXOPBLOCKS - 1 - 1 - 2) / 2) * BSIZE; int tot = min(PGSIZE, fileend - (addr + pg * PGSIZE)); int r, written = 0; while (written &lt; tot) &#123; int n = tot - written; if (n > max) n = max; begin_op(); ilock(f->ip); src = addr + pg * PGSIZE + written; r = writei(f->ip, 1, src, src - p->mmap[i].st + p->mmap[i].off, n); iunlock(f->ip); end_op(); if (r != n) &#123; return -1; &#125; written += r; &#125; &#125; &#125; return 0; &#125; 这里以页为单位写回文件是因为 lazy allocation 导致可能存在未被映射的虚拟页，我们不希望把未映射的页写回文件。另外要注意写回的长度不能超过文件本身长度，也就是说对每一个尝试写回的页，实际写入的长度为： int tot = min(PGSIZE, fileend - (addr + pg * PGSIZE)); 我把这个 mmap_wbk 函数放在 proc.c 中，因为后续在 exit 函数里也要用到它。 然后是第二点，让 uvmunmap 在遇到未映射的虚拟页时跳过而非 panic，我们简单改了一下 uvmunmap： void uvmunmap(pagetable_t pagetable, uint64 va, uint64 npages, int do_free) &#123; uint64 a; pte_t *pte; if ((va % PGSIZE) != 0) panic(\"uvmunmap: not aligned\"); for (a = va; a &lt; va + npages * PGSIZE; a += PGSIZE) &#123; if ((pte = walk(pagetable, a, 0)) == 0) &#123; continue; // panic(\"uvmunmap: walk\"); &#125; if ((*pte &amp; PTE_V) == 0) &#123; continue; // panic(\"uvmunmap: not mapped\"); &#125; if (PTE_FLAGS(*pte) == PTE_V) panic(\"uvmunmap: not a leaf\"); if (do_free) &#123; uint64 pa = PTE2PA(*pte); kfree((void *)pa); &#125; *pte = 0; &#125; &#125; 最后让我们来看看 sys_munmap： #define min(a, b) ((a) &lt; (b) ? (a) : (b)) uint64 sys_munmap(void) &#123; struct file *f; uint64 addr; int len; struct proc *p; int i; argaddr(0, &amp;addr); argint(1, &amp;len); if (addr % PGSIZE != 0) &#123; return -1; &#125; p = myproc(); // Find mmap corresponding to addr for (i = 0; i &lt; NMMAP; i++) &#123; if (p->mmap[i].valid &amp;&amp; p->mmap[i].st &lt;= addr &amp;&amp; addr &lt; p->mmap[i].st + p->mmap[i].len) &#123; f = p->mmap[i].f; break; &#125; &#125; if (i == NMMAP) &#123; // No mmap corresponding to addr uvmunmap(p->pagetable, addr, PGROUNDUP(len) / PGSIZE, 1); return 0; &#125; if (p->mmap[i].flags &amp; MAP_SHARED) &#123; if (mmap_wbk(i, addr, min(len, p->mmap[i].st + p->mmap[i].len - addr)) &lt; 0) &#123; return -1; &#125;; &#125; uvmunmap(p->pagetable, addr, PGROUNDUP(len) / PGSIZE, 1); if (addr == p->mmap[i].st &amp;&amp; addr + len == p->mmap[i].st + p->mmap[i].len) &#123; p->mmap[i].valid = 0; fileclose(f); return 0; &#125; else if (addr == p->mmap[i].st) &#123; p->mmap[i].st += PGROUNDUP(len); p->mmap[i].len -= PGROUNDUP(len); p->mmap[i].off += PGROUNDUP(len); return 0; &#125; else if (addr + len == p->mmap[i].st + p->mmap[i].len) &#123; p->mmap[i].len -= PGROUNDUP(len); return 0; &#125; else &#123; // No need to consider hole punching case in this lab &#125; return -1; &#125; 它能通过测试代码，也算是够用了吧🫠🫠 exit 和 fork有了 munmap 的经验，exit 函数的修改就很简单了。我把关闭 mmap 的代码放在了关闭文件后面： void exit(int status) &#123; // ... // Close all open files. // ... // Close all mmaps for (int i = 0; i &lt; NMMAP; i++) &#123; if (p->mmap[i].valid) &#123; struct file *f; uint64 addr; f = p->mmap[i].f; addr = p->mmap[i].st; if (p->mmap[i].flags &amp; MAP_SHARED) &#123; if (mmap_wbk(i, addr, p->mmap[i].len) &lt; 0) &#123; panic(\"mmap wbk failed\"); &#125;; &#125; for (int pg = 0; pg * PGSIZE &lt; p->mmap[i].len; pg++) &#123; if (walkaddr(p->pagetable, addr + pg * PGSIZE)) &#123; uvmunmap(p->pagetable, addr + pg * PGSIZE, 1, 1); &#125; &#125; p->mmap[i].valid = 0; fileclose(f); &#125; &#125; // ... &#125; 而 fork 的修改也不难： int fork(void) &#123; // ... // increment reference counts on open file descriptors. // ... // Copy mmap for (i = 0; i &lt; NMMAP; i++) &#123; if (p->mmap[i].valid) &#123; np->mmap[i] = p->mmap[i]; filedup(np->mmap[i].f); &#125; &#125; safestrcpy(np->name, p->name, sizeof(p->name)); // ... &#125; 再见了，所有的 6S081 完结撒花，感谢陪伴！Bilibili 干杯 - ( ゜- ゜)つロ[","categories":[{"name":"公开课","slug":"公开课","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"MIT-6.S081","slug":"公开课/MIT-6-S081","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/MIT-6-S081/"},{"name":"Labs","slug":"公开课/MIT-6-S081/Labs","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/MIT-6-S081/Labs/"}],"tags":[]},{"title":"Lab 8 File System","slug":"learning/open-course/MIT-6.S081/Labs/lab8-fs","date":"2025-12-03T15:01:11.000Z","updated":"2025-12-03T15:03:40.522Z","comments":true,"path":"wiki/learning/open-course/MIT-6.S081/Labs/lab8-fs/","permalink":"http://rinevard.github.io/wiki/learning/open-course/MIT-6.S081/Labs/lab8-fs/","excerpt":"","text":"感觉 xv6 的文件系统还是挺有深度的。这个 lab 带我们简单复习了下 inode 如何指向 blocks，以及通过路径名查找文件的方法。 Large files这道题让我们增大 xv6 最大文件的大小。原本的 xv6 的每个 inode 支持 12 个普通块和一个间接块，那么原本的最大文件占据 12 + 256 = 268 个块。我们需要把 inode 修改为支持 11 个普通块、一个间接块、一个双重间接块，这样最大文件就能占据 11 + 256 + 256 * 256 = 65803 个块。 首先我们要去 fs.h 里修改 dinode 和一些常量的定义，再去 file.h 里修改 inode 的定义，主要是修改 addrs： #define NDIRECT 11 #define NINDIRECT (BSIZE / sizeof(uint)) #define NDOUBLYINDIRECT (NINDIRECT * NINDIRECT) #define MAXFILE (NDIRECT + NINDIRECT + NDOUBLYINDIRECT) struct dinode &#123; // 其他内容保持不变 uint addrs[NDIRECT + 2]; &#125;; struct inode &#123; // 其他内容保持不变 uint addrs[NDIRECT + 2]; &#125;; 然后我们可以画一画 ip-&gt;addrs 的结构，如下图所示： 对给定的 bn，如果它在 $[0,11)$ 之间，就查找普通块；如果在 $[11,11+256)$ 之间，就查找间接块；如果在 $[11+256,256+256\\times256)$ 之间，就查找双重间接块。再参考 bmap 原有的代码就能完成修改了： static uint bmap(struct inode *ip, uint bn) &#123; uint addr, *a; struct buf *bp; if (bn &lt; NDIRECT) &#123; if ((addr = ip->addrs[bn]) == 0) &#123; addr = balloc(ip->dev); if (addr == 0) return 0; ip->addrs[bn] = addr; &#125; return addr; &#125; bn -= NDIRECT; if (bn &lt; NINDIRECT) &#123; // Load indirect block, allocating if necessary. if ((addr = ip->addrs[NDIRECT]) == 0) &#123; addr = balloc(ip->dev); if (addr == 0) return 0; ip->addrs[NDIRECT] = addr; &#125; bp = bread(ip->dev, addr); a = (uint *)bp->data; if ((addr = a[bn]) == 0) &#123; addr = balloc(ip->dev); if (addr) &#123; a[bn] = addr; log_write(bp); &#125; &#125; brelse(bp); return addr; &#125; bn -= NINDIRECT; if (bn &lt; NDOUBLYINDIRECT) &#123; // Load doubly indirect block, allocating if necessary. if ((addr = ip->addrs[NDIRECT + 1]) == 0) &#123; addr = balloc(ip->dev); if (addr == 0) return 0; ip->addrs[NDIRECT + 1] = addr; &#125; // Load indirect block, allocating if necessary. bp = bread(ip->dev, addr); a = (uint *)bp->data; if ((addr = a[(bn / NINDIRECT)]) == 0) &#123; addr = balloc(ip->dev); if (addr) &#123; a[(bn / NINDIRECT)] = addr; log_write(bp); &#125; &#125; brelse(bp); if (addr == 0) &#123; return 0; &#125; // Find addr in block bp = bread(ip->dev, addr); a = (uint *)bp->data; if ((addr = a[bn % NINDIRECT]) == 0) &#123; addr = balloc(ip->dev); if (addr) &#123; a[bn % NINDIRECT] = addr; log_write(bp); &#125; &#125; brelse(bp); return addr; &#125; panic(\"bmap: out of range\"); &#125; 我们还需要修改 itrunc，它释放传入的 inode 占用的所有数据块。仿照 itrunc 原有的代码加入释放双重间接块的代码就行： void itrunc(struct inode *ip) &#123; int i, j, k; struct buf *bp, *bbp; uint *a, *aa; for (i = 0; i &lt; NDIRECT; i++) &#123; if (ip->addrs[i]) &#123; bfree(ip->dev, ip->addrs[i]); ip->addrs[i] = 0; &#125; &#125; if (ip->addrs[NDIRECT]) &#123; bp = bread(ip->dev, ip->addrs[NDIRECT]); a = (uint *)bp->data; for (j = 0; j &lt; NINDIRECT; j++) &#123; if (a[j]) bfree(ip->dev, a[j]); &#125; brelse(bp); bfree(ip->dev, ip->addrs[NDIRECT]); ip->addrs[NDIRECT] = 0; &#125; if (ip->addrs[NDIRECT + 1]) &#123; // Free doubly indirect block bp = bread(ip->dev, ip->addrs[NDIRECT + 1]); a = (uint *)bp->data; for (j = 0; j &lt; NINDIRECT; j++) &#123; if (a[j]) &#123; // Free indirect block j bbp = bread(ip->dev, a[j]); aa = (uint *)bbp->data; for (k = 0; k &lt; NINDIRECT; k++) &#123; if (aa[k]) bfree(ip->dev, aa[k]); &#125; brelse(bbp); bfree(ip->dev, a[j]); &#125; &#125; brelse(bp); bfree(ip->dev, ip->addrs[NDIRECT + 1]); ip->addrs[NDIRECT + 1] = 0; &#125; ip->size = 0; iupdate(ip); &#125; Symbolic links这道题让我们给 xv6 加入符号链接，不过这里的符号链接是青春版。符号链接正统版应该能指向目录，我们的只能指向文件。 这里就不放配置系统调用的代码了（大家都已经品鉴过无数次了），我们先看看 man 手册是怎么介绍 symlink 的。这里我们主要看 man 2 symlink 和 man 7 symlink，前者是给使用者看的函数说明，后者是函数原理。 symlink(2): make new name for file - Linux man page symlink(7): symbolic link handling - Linux man page symlink 的签名是 int symlink(const char *oldpath, const char *newpath);，它创建一个名为 newpath 的指向 oldpath 的符号链接文件，这个文件里存储着 oldpath 这个字符串。 对照 hint，我们知道要去 stat.h 里新增一种叫作 T_SYMLINK 的文件类型，这就是符号链接类型。至此我们就能新增 sys_symlink 函数了。 uint64 sys_symlink(void) &#123; char old[MAXPATH], new[MAXPATH]; struct inode *ip; int len; begin_op(); if (argstr(0, old, MAXPATH) &lt; 0 || argstr(1, new, MAXPATH) &lt; 0 || (ip = create(new, T_SYMLINK, 0, 0)) == 0) &#123; end_op(); return -1; &#125; len = strlen(old); writei(ip, 0, (uint64)&amp;len, 0, sizeof(len)); writei(ip, 0, (uint64)old, sizeof(len), len + 1); iunlockput(ip); end_op(); return 0; &#125; 我一开始对 iunlock、iunlockput 很疑惑，主要是不知道 iput 有什么用。其实 iput 和 inode 的工作方式密切相关，我们接下来简要分析一下。这里涉及到的文件是 fs.c。 考虑到我们只能直接和内存交互，而磁盘上又有很多 inode，我们会把有人在用的的 inode 保存在 itable.inode 中，并用 inode.ref 来记录有多少人在用。用完的人要调用 iput 说自己用完了，这样 ref 就会减少。未来我们在把磁盘 inode 放到内存中时会找到 ref == 0 的东西来替换。 举个例子，dirlookup 找路径对应的 inode，这种“找”最终总会调用 iget，iget 会检查想找的 inode 在不在内存中的 itable.inode 中，如果不在就在 itable.inode 里找个 ref == 0 的元素，把它替换成想找的 inode 并设置其 ref。相应地，调用者在用完 inode 后要负责调用 iput 说自己用完了，不然 itable.inode 的空间被占满后就不能加载新的 inode 了。 所以在 sys_symlink 的末尾我们要调用 iunlockput 而不是只调用 iunlock，毕竟我们在 sys_symlink 里不再使用这个 inode 了。 接下来我们看看 open 函数。首先照着 hint 在 fcntl.h 里加入 O_NOFOLLOW，然后对符号链接类型的文件，读取其 path 然后顺藤摸瓜就行： uint64 sys_open(void) &#123; char path[MAXPATH]; int fd, omode; struct file *f; struct inode *ip; int n, symcnt, len; argint(1, &amp;omode); if ((n = argstr(0, path, MAXPATH)) &lt; 0) return -1; begin_op(); if (omode &amp; O_CREATE) &#123; ip = create(path, T_FILE, 0, 0); if (ip == 0) &#123; end_op(); return -1; &#125; &#125; else if (omode &amp; O_NOFOLLOW) &#123; if ((ip = namei(path)) == 0) &#123; end_op(); return -1; &#125; ilock(ip); if (ip->type == T_DIR &amp;&amp; omode != O_RDONLY) &#123; iunlockput(ip); end_op(); return -1; &#125; &#125; else &#123; symcnt = 0; if ((ip = namei(path)) == 0) &#123; end_op(); return -1; &#125; ilock(ip); while (ip->type == T_SYMLINK) &#123; symcnt++; if (symcnt >= 10) &#123; iunlockput(ip); end_op(); return -1; &#125; readi(ip, 0, (uint64)&amp;len, 0, sizeof(len)); readi(ip, 0, (uint64)path, sizeof(len), len + 1); iunlockput(ip); if ((ip = namei(path)) == 0) &#123; end_op(); return -1; &#125; ilock(ip); &#125; if (ip->type == T_DIR &amp;&amp; omode != O_RDONLY) &#123; iunlockput(ip); end_op(); return -1; &#125; &#125; if (ip->type == T_DEVICE &amp;&amp; (ip->major &lt; 0 || ip->major >= NDEV)) &#123; iunlockput(ip); end_op(); return -1; &#125; if ((f = filealloc()) == 0 || (fd = fdalloc(f)) &lt; 0) &#123; if (f) fileclose(f); iunlockput(ip); end_op(); return -1; &#125; if (ip->type == T_DEVICE) &#123; f->type = FD_DEVICE; f->major = ip->major; &#125; else &#123; f->type = FD_INODE; f->off = 0; &#125; f->ip = ip; f->readable = !(omode &amp; O_WRONLY); f->writable = (omode &amp; O_WRONLY) || (omode &amp; O_RDWR); if ((omode &amp; O_TRUNC) &amp;&amp; ip->type == T_FILE) &#123; itrunc(ip); &#125; iunlock(ip); end_op(); return fd; &#125; 顺提一句，make grade 显示 Timeout FAIL 可能是因为后台的进程太多了导致 CPU 没有全力以赴。尽量把别的进程（比如浏览器）关掉只保留一个在跑 make grade 的终端。","categories":[{"name":"公开课","slug":"公开课","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"MIT-6.S081","slug":"公开课/MIT-6-S081","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/MIT-6-S081/"},{"name":"Labs","slug":"公开课/MIT-6-S081/Labs","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/MIT-6-S081/Labs/"}],"tags":[]},{"title":"Lab 7 Lock","slug":"learning/open-course/MIT-6.S081/Labs/lab7-lock","date":"2025-12-02T04:15:29.000Z","updated":"2025-12-02T04:15:32.298Z","comments":true,"path":"wiki/learning/open-course/MIT-6.S081/Labs/lab7-lock/","permalink":"http://rinevard.github.io/wiki/learning/open-course/MIT-6.S081/Labs/lab7-lock/","excerpt":"","text":"这个 lab 让我们熟悉对锁的使用。除了 2024 的题外我还顺便做了下 2025 新增的读写锁（2025 年用 Read-write lock 换掉了 Buffer cache），让我们依次来看看这几道题。 Memory allocator在 xv6 里，多个进程同时尝试新增 / 释放内存时会在 kalloc.c 的 kmem 上产生激烈的锁竞争，这道题让我们给每个 CPU 设置一个自己的空闲块链表来缓解竞争问题。比较 tricky 的地方是当一个 CPU 的空闲块链表为空时，它要去别的 CPU 那里偷空闲块。 我们先来看看测试代码在做什么吧，先来看看 test2： void test2() &#123; int free0 = countfree(); int free1; int n = (PHYSTOP - KERNBASE) / PGSIZE; printf(\"start test2\\n\"); printf(\"total free number of pages: %d (out of %d)\\n\", free0, n); if (n - free0 > 1000) &#123; printf(\"test2 FAILED: cannot allocate enough memory\"); exit(1); &#125; for (int i = 0; i &lt; 50; i++) &#123; free1 = countfree(); if (i % 10 == 9) printf(\".\"); if (free1 != free0) &#123; printf(\"test2 FAIL: losing pages %d %d\\n\", free0, free1); exit(1); &#125; &#125; printf(\"\\ntest2 OK\\n\"); &#125; 这里的 countfree 函数在 sbrk 尽可能多的内存，计算一共新增了多少页，然后返回新增的页数。可以看出 test2 就是在检查分配 / 释放内存时有没有丢页。 test1 则更复杂一些。它把多进程 sbrk 前后锁自旋的总次数存在 m 和 n 中并计算 n - m。如果我们的实现较好，锁就会自旋较少，就能通过 if (n - m &lt; 10) 然后通过测试： void test1(void) &#123; int n, m; printf(\"start test1\\n\"); m = ntas(0); // 创建 NCHILD 个子进程并让他们不断 sbrk for (int i = 0; i &lt; NCHILD; i++) &#123; // ... &#125; int status = 0; for (int i = 0; i &lt; NCHILD; i++) &#123; wait(&amp;status); &#125; n = ntas(1); if (n - m &lt; 10) printf(\"test1 OK\\n\"); else printf(\"test1 FAIL\\n\"); &#125; 这里的 ntas 很神奇，我花了蛮长时间才弄明白它是怎么获取锁的自旋次数的。感兴趣的话可以看看，不感兴趣的话记住它最终借助了 spinlock.c 的 statslock 来获取锁的自旋总次数就行。 首先 ntas 调用了 statistics，看向 statistics.c，它在读取 statistics 文件： int statistics(void *buf, int sz) &#123; int fd, i, n; fd = open(\"statistics\", O_RDONLY); if (fd &lt; 0) &#123; fprintf(2, \"stats: open failed\\n\"); exit(1); &#125; for (i = 0; i &lt; sz;) &#123; if ((n = read(fd, buf + i, sz - i)) &lt; 0) &#123; break; &#125; i += n; &#125; close(fd); return i; &#125; 那 statistics 文件在哪呢？statistics 文件在 init.c 里被初始化。我们在内核的 stats.c 的 statsinit 里初始化了 STATS，把对它的读设置为调用 statsread，并在 statsread 里调用 spinlock.c 里的 statslock. 注意这里有内核的 stats.c 和用户的 stats.c，我们说的是前者。 总之 statistics 函数会读取 statistics，对 statistics 的读会调用 statsread，statsread 在 statistics 被读完后会调用 statslock 来更新内容。 我们当然会问为什么要绕这么大一圈，直接读spinlock.c里的东西不行吗？这是因为用户和内核有隔离。statistics 是用户态的函数，不能也不应该直接读内核的 spinlock.c 里的数据。 test3 则是 test1 和 test2 的整合高清重制豪华加强版。我的代码能通过 2023 年和 2025 年版本的完整测试，但不能稳定通过 2024 版本的 test3（大部分时间过不了，运气好能过）。 2023 年的版本没有这种整合测试，2025 年的版本写的是 n-m &lt; (NCHILD4-1)*10000，感觉 2025 比 2024 的测试更合理，那就认为我的代码已经满足要求了吧。 然后我们上代码。先放在初始化的部分和 kfree： struct &#123; struct spinlock lock; struct run *freelist; &#125; kmems[NCPU]; static char kmemlockname[NCPU][16]; const int STOLEN_NUM = 8; void kinit() &#123; for (int i = 0; i &lt; ncpu; i++) &#123; snprintf(kmemlockname[i], sizeof(kmemlockname[i]), \"kmem_%d\", i); initlock(&amp;kmems[i].lock, kmemlockname[i]); &#125; freerange(end, (void *)PHYSTOP); &#125; void freerange(void *pa_start, void *pa_end) &#123; char *p; p = (char *)PGROUNDUP((uint64)pa_start); for (; p + PGSIZE &lt;= (char *)pa_end; p += PGSIZE) kfree(p); &#125; void kfree(void *pa) &#123; struct run *r; if (((uint64)pa % PGSIZE) != 0 || (char *)pa &lt; end || (uint64)pa >= PHYSTOP) panic(\"kfree\"); // Fill with junk to catch dangling refs. memset(pa, 1, PGSIZE); r = (struct run *)pa; push_off(); int id = cpuid(); acquire(&amp;kmems[id].lock); r->next = kmems[id].freelist; kmems[id].freelist = r; release(&amp;kmems[id].lock); pop_off(); &#125; 代码思路很清晰，每个 CPU 一个自己的空闲链表，kfree 把释放掉的块加到当前 CPU 的链表上。 我还试了下在 kinit 结尾打印出每个 CPU 的空闲块链表长度，然后发现所有的空闲块都在一个 CPU 那里。原本我还以为 freerange 的过程中每个 CPU 都会跑一跑 kfree，然后让空闲块均匀分布在各个 CPU 上呢。 然后我们看看 kalloc： void *kalloc(void) &#123; // We can consistently pass the 2025 tests, but occasionally fail the 2024 // test3. I think this is good enough, so we won't continue further. struct run *r; push_off(); int id = cpuid(); acquire(&amp;kmems[id].lock); r = kmems[id].freelist; if (r) &#123; kmems[id].freelist = r->next; release(&amp;kmems[id].lock); &#125; else &#123; // There isn't a fixed acquire order for CPU locks // so release the lock before acquiring other locks to avoid deadlock release(&amp;kmems[id].lock); struct run *stolen_head = 0; struct run *stolen_end = 0; // Steal STOLEN_NUM pages from another CPU's free list for (int i = (id - 1 + ncpu) % ncpu; i != id; i = (i - 1 + ncpu) % ncpu) &#123; acquire(&amp;kmems[i].lock); if (!kmems[i].freelist) &#123; release(&amp;kmems[i].lock); continue; &#125; stolen_head = kmems[i].freelist; for (int cnt = 0; (kmems[i].freelist) &amp;&amp; (cnt &lt; STOLEN_NUM); cnt++) &#123; stolen_end = kmems[i].freelist; kmems[i].freelist = stolen_end->next; &#125; stolen_end->next = 0; release(&amp;kmems[i].lock); break; &#125; if (stolen_head) &#123; acquire(&amp;kmems[id].lock); stolen_end->next = kmems[id].freelist; kmems[id].freelist = stolen_head; r = kmems[id].freelist; kmems[id].freelist = r->next; release(&amp;kmems[id].lock); &#125; &#125; pop_off(); if (r) memset((char *)r, 5, PGSIZE); // fill with junk return (void *)r; &#125; 这里比较 trickky 的就是 else 里窃取别的 CPU 的块的部分。首先如我的注释所言，各个 CPU 的 kmem lock 没有固定的获取顺序，所以我们要先释放自己的 kmem lock 再开偷，保证同一时间只拿着一个 CPU 的 kmem lock，不然有死锁风险。 然后我们从当前 CPU 开始往后遍历，找到合适的 CPU 以后就抓它的锁然后偷 STOLEN_NUM 个块暂存在 stolen_head 这个链表里，偷完以后释放它的锁并抓自己的锁再把链表接到自己头上。 这样一来窃取和新增块都是原子性的，不会有并发问题。 我测出来设置 STOLEN_NUM 为 1 或 8 时效果最好，更大反而效果欠佳，挺神奇的。 Buffer cache文件系统的缓存层也有一个较激烈的锁竞争，我们可以通过把缓存链表拆分成若干个小的链表，给每个链表设置单独的锁来缓解竞争。 那么怎么拆分链表呢？我们知道每个 block 有 blockno，因此我们可以把 block 放到编号为 hash(blockno) 的链表中。基本思路就是这样，接下来看代码吧，首先是初始化部分： #define BUCKET_SIZE 13 struct &#123; struct spinlock steal_lock; // steal lock, only one process is stealing at a time struct buf buf[NBUF]; struct buf head; &#125; bcache; struct &#123; struct spinlock lock; struct buf head; &#125; buckets[BUCKET_SIZE]; uint hash(uint blockno) &#123; return blockno % BUCKET_SIZE; &#125; void binit(void) &#123; struct buf *b; initlock(&amp;bcache.steal_lock, \"bcache\"); for (int i = 0; i &lt; BUCKET_SIZE; i++) &#123; initlock(&amp;buckets[i].lock, \"bcache.bucket\"); &#125; // Put all buffers into bucket[0] initially struct buf *cur; cur = &amp;buckets[0].head; for (b = bcache.buf; b &lt; bcache.buf + NBUF; b++) &#123; cur->next = b; b->prev = cur; initsleeplock(&amp;b->lock, \"buffer\"); cur = b; &#125; &#125; 这里主要是对链表做了下拆分。这里的 steal_lock 和接下来的 bget 相关，主要是为了防止下面这种情况： 进程 A 和进程 B 都在请求 blockno，我们令 dest = hash(blockno) 进程 A 和 B 都没在 buckets[dest] 找到块，开始窃取。 进程 B 比 A 先窃取到了一个空闲块，把它放进了 buckets[dest] 并填入了数据。 进程 A 也找到了一个空闲块并把它放入 buckets[dest] 并填入数据。 这会导致两个 buf 有相同的 blockno，这不是我们想要的。 这里的 steal_lock 保证同一时间只有一个进程在试图窃取别的 bucket 的 buf. 配合在窃取前再次检查一遍 bucket[dest] 就能避免上述情况的发生。 我们现在来看看 bget： static struct buf *bget(uint dev, uint blockno) &#123; struct buf *b; uint dest = hash(blockno); acquire(&amp;buckets[dest].lock); // Is the block already cached? for (b = buckets[dest].head.next; b; b = b->next) &#123; if (b->dev == dev &amp;&amp; b->blockno == blockno) &#123; b->refcnt++; release(&amp;buckets[dest].lock); acquiresleep(&amp;b->lock); return b; &#125; &#125; // --------------------下面是窃取代码-------------------- // Not cached. release(&amp;buckets[dest].lock); acquire(&amp;bcache.steal_lock); acquire(&amp;buckets[dest].lock); // double check, other process might have stolen before we steal for (b = buckets[dest].head.next; b; b = b->next) &#123; if (b->dev == dev &amp;&amp; b->blockno == blockno) &#123; b->refcnt++; release(&amp;buckets[dest].lock); release(&amp;bcache.steal_lock); acquiresleep(&amp;b->lock); return b; &#125; &#125; release(&amp;buckets[dest].lock); // steal from another bucket for (int i = 0; i &lt; BUCKET_SIZE; i++) &#123; acquire(&amp;buckets[i].lock); // iterate through bucket to find a free buf for (b = buckets[i].head.next; b; b = b->next) &#123; if (b->refcnt == 0) &#123; // remove b from orig bucket b->prev->next = b->next; if (b->next) &#123; b->next->prev = b->prev; &#125; b->prev = 0; b->next = 0; release(&amp;buckets[i].lock); // put b into dest bucket acquire(&amp;buckets[dest].lock); b->prev = &amp;buckets[dest].head; b->next = buckets[dest].head.next; b->prev->next = b; if (b->next) &#123; b->next->prev = b; &#125; b->dev = dev; b->blockno = blockno; b->valid = 0; b->refcnt = 1; acquiresleep(&amp;b->lock); release(&amp;buckets[dest].lock); release(&amp;bcache.steal_lock); return b; &#125; &#125; release(&amp;buckets[i].lock); &#125; panic(\"bget: no buffers\"); &#125; 也有不加 steal_lock 的写法，可以在填入数据前检查 buckets[dest] 中是否有 blockno 对应的 buf，如果有就不填数据而是把空块加入 buckets[dest]，如果没有再填数据，如下所示： static struct buf *bget(uint dev, uint blockno) &#123; struct buf *b; uint dest = hash(blockno); acquire(&amp;buckets[dest].lock); // Is the block already cached? for (b = buckets[dest].head.next; b; b = b->next) &#123; if (b->dev == dev &amp;&amp; b->blockno == blockno) &#123; b->refcnt++; release(&amp;buckets[dest].lock); acquiresleep(&amp;b->lock); return b; &#125; &#125; // Not cached. release(&amp;buckets[dest].lock); // steal from another bucket for (int i = 0; i &lt; BUCKET_SIZE; i++) &#123; acquire(&amp;buckets[i].lock); // iterate through bucket to find a free buf for (b = buckets[i].head.next; b; b = b->next) &#123; if (b->refcnt == 0) &#123; // remove b from orig bucket b->prev->next = b->next; if (b->next) &#123; b->next->prev = b->prev; &#125; b->prev = 0; b->next = 0; release(&amp;buckets[i].lock); // put b into dest bucket acquire(&amp;buckets[dest].lock); b->prev = &amp;buckets[dest].head; b->next = buckets[dest].head.next; b->prev->next = b; if (b->next) &#123; b->next->prev = b; &#125; // double check, other process might have stolen before we steal for (struct buf *check = buckets[dest].head.next; check; check = check->next) &#123; if (check->dev == dev &amp;&amp; check->blockno == blockno) &#123; check->refcnt++; release(&amp;buckets[dest].lock); acquiresleep(&amp;check->lock); return check; &#125; &#125; b->dev = dev; b->blockno = blockno; b->valid = 0; b->refcnt = 1; release(&amp;buckets[dest].lock); acquiresleep(&amp;b->lock); return b; &#125; &#125; release(&amp;buckets[i].lock); &#125; panic(\"bget: no buffers\"); &#125; 最后几个要改的函数把原本的锁换成 bucket 的锁就可以了。 void brelse(struct buf *b) &#123; if (!holdingsleep(&amp;b->lock)) panic(\"brelse\"); releasesleep(&amp;b->lock); uint idx = hash(b->blockno); acquire(&amp;buckets[idx].lock); b->refcnt--; release(&amp;buckets[idx].lock); &#125; void bpin(struct buf *b) &#123; uint idx = hash(b->blockno); acquire(&amp;buckets[idx].lock); b->refcnt++; release(&amp;buckets[idx].lock); &#125; void bunpin(struct buf *b) &#123; uint idx = hash(b->blockno); acquire(&amp;buckets[idx].lock); b->refcnt--; release(&amp;buckets[idx].lock); &#125; Read-write lock我还抽空做了下 2025 版本新增的 Read-write lock，这要求我们实现一个读写锁。读写锁把用户分为读者和写者，同一时间可以有多个读者或一个写者持有读写锁。另外在这道题里，如果读者和写者同时在等待，写者优先持锁。 我的实现思路还是比较朴素的，我们先看数据结构吧： struct rwspinlock &#123; struct spinlock l; int readers; int writer_active; // 0 or 1 int waiting_writers; &#125;; 读者仅在没有写者持锁且没有写者在等待时才能持锁，所以我们需要 writer_active 和 waiting_writers 两个字段；写者仅在没有别的写者持锁且没有读者持锁时才能持锁，所以我们也需要 readers 字段。这里的 spinlock 则是为了保护这些共享数据。 其实也可以不用 spinlock 而全用原子语句写，但我感觉太难了就没这么做。 函数的实现思路也比较朴素，可以直接看代码。要注意我们被要求实现自旋版本的读写锁，所以在 acquire 的条件不满足时我们不能 sleep，而应释放锁然后不断循环。 现实里也存在睡眠版本的读写锁，不过这和我们的 lab 没关系。 static void read_acquire_inner(struct rwspinlock *rwlk) &#123; while (1) &#123; acquire(&amp;rwlk->l); if (rwlk->writer_active || rwlk->waiting_writers > 0) &#123; release(&amp;rwlk->l); continue; &#125; rwlk->readers++; release(&amp;rwlk->l); return; &#125; &#125; static void read_release_inner(struct rwspinlock *rwlk) &#123; acquire(&amp;rwlk->l); rwlk->readers--; release(&amp;rwlk->l); &#125; static void write_acquire_inner(struct rwspinlock *rwlk) &#123; acquire(&amp;rwlk->l); rwlk->waiting_writers++; release(&amp;rwlk->l); while (1) &#123; acquire(&amp;rwlk->l); if (rwlk->readers > 0 || rwlk->writer_active) &#123; release(&amp;rwlk->l); continue; &#125; rwlk->waiting_writers--; rwlk->writer_active = 1; release(&amp;rwlk->l); return; &#125; &#125; static void write_release_inner(struct rwspinlock *rwlk) &#123; acquire(&amp;rwlk->l); rwlk->writer_active = 0; release(&amp;rwlk->l); &#125; 这里是 initrwlock 的代码 void initrwlock(struct rwspinlock *rwlk) &#123; // Replace this with your implementation. initlock(&amp;rwlk->l, \"rwlk\"); rwlk->readers = 0; rwlk->waiting_writers = 0; rwlk->writer_active = 0; &#125; 测试时我们遇到了一个神奇的现象，在 make qemu 后第一次运行 rwlktest 总是能通过的，而之后运行总是不能通过的。重新 make qemu 以后还是第一次运行能通过，后续运行无法通过。 经过漫长的 debug 时光，我们发现问题出在下面的测试函数上： static void rwspinlock_test_step(uint step, const char *msg) &#123; static uint barrier; const uint ncpu = 4; __atomic_fetch_add(&amp;barrier, 1, __ATOMIC_ACQ_REL); while (__atomic_load_n(&amp;barrier, __ATOMIC_RELAXED) &lt; ncpu * step) &#123; // spin &#125; if (cpuid() == 0) &#123; printf(\"rwspinlock_test: step %d: %s\\n\", step, msg); &#125; &#125; 这个函数的设计原意应该是起这两个作用： 同步 CPU，保证四个 CPU 都到达了这里再继续往下运行 打印当前运行到的测试编号（step） 这个函数通过下面的代码实现 CPU 同步。它让 barrier 原子性地加一，表示一个 CPU 跑到了这里，然后如果四个 CPU 中还有人没来就自旋等待。 __atomic_fetch_add(&amp;barrier, 1, __ATOMIC_ACQ_REL); while (__atomic_load_n(&amp;barrier, __ATOMIC_RELAXED) &lt; ncpu * step) &#123; // spin &#125; 为了保证 barrier 被四个 CPU 共享，barrier 被设置为静态变量 static uint barrier. 但测试代码又没在测试开始时把它重置为 0，所以就出现了这种第一次测试能通过，之后的测试不能通过的情况。 第一次测试时，barrier 是初始值 0，所以一切正常；之后的测试里 barrier 保留了之前的值，while 的条件始终为假，于是这种同步功能也就完全失效了。在同步功能失效后，跑得快的 CPU 都跑完 30 个 steps 了，跑得慢的 CPU 可能还在第 8 个 step 挣扎，这就让 rwlktest 也跟着失效了。 气氛都到这儿了，不给个修复也不好意思🫠🫠用下面的代码就行了 static void rwspinlock_test_step(uint step, const char *msg) &#123; static uint count; static uint sense; const uint ncpu = 4; int local_sense = __atomic_load_n(&amp;sense, __ATOMIC_RELAXED); if (__atomic_fetch_add(&amp;count, 1, __ATOMIC_ACQ_REL) == ncpu - 1) &#123; // Let the last reached CPU reset values and print message printf(\"rwspinlock_test: step %d: %s\\n\", step, msg); __atomic_store_n(&amp;count, 0, __ATOMIC_RELAXED); __atomic_store_n(&amp;sense, !local_sense, __ATOMIC_RELEASE); &#125; else &#123; while (__atomic_load_n(&amp;sense, __ATOMIC_ACQUIRE) == local_sense) &#123; // spin &#125; &#125; &#125; count 和 sense 是共享的变量，所以要用原子语句读写。__ATOMIC_RELAXED 之类的东西是对内存顺序（memory orders）的限制，这能防止指令重排，具体可以看 https://gcc.gnu.org/onlinedocs/gcc/_005f_005fatomic-Builtins.html. 发现这个 bug 以后我也给 6S081 的官方发了邮件，没想到还真收到回复了！他们说加入了一个类似的修复，会在 2026 年的版本更新。感觉自己对 MIT 的滤镜更厚了（）","categories":[{"name":"公开课","slug":"公开课","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"MIT-6.S081","slug":"公开课/MIT-6-S081","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/MIT-6-S081/"},{"name":"Labs","slug":"公开课/MIT-6-S081/Labs","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/MIT-6-S081/Labs/"}],"tags":[]},{"title":"Lab 6 Networking","slug":"learning/open-course/MIT-6.S081/Labs/lab6-net","date":"2025-11-08T23:41:29.000Z","updated":"2025-11-08T23:58:14.625Z","comments":true,"path":"wiki/learning/open-course/MIT-6.S081/Labs/lab6-net/","permalink":"http://rinevard.github.io/wiki/learning/open-course/MIT-6.S081/Labs/lab6-net/","excerpt":"","text":"这个 lab 分两个部分，第一部分是补全 E1000 网卡驱动的数据包收发相关代码，第二部分是添加代码完成 UDP 包的接收。在开始之前，我们应该先去把讲网络的 lecture 看掉，因为里面涉及了很多相关内容。你可能会疑惑为什么课程把 lab 安排在 lec 前面，我在本文的文末吐槽里写了可能的原因。 让我们进入正题。 E1000 网卡驱动我们在编写代码时要回答两个问题——我们如何借助网卡接收数据，又如何发送数据？我们对照文档第三章来分析一下，然后在分析的结尾分别给出 e1000_recv 和 e1000_transmit 的代码： 我们如何借助网卡接收数据？ 我们在初始化里设置了 RDTR，这让网卡在收到包时发出中断，这一部分和文档的 3.2.8 Receive Interrupts 有关： // ask e1000 for receive interrupts. regs[E1000_RDTR] = 0; // interrupt after every received packet (no timer) 我们还在初始化里设置了 RDBAL，这让网卡在收到包时把数据放到 rx_ring 中： // [E1000 14.4] Receive initialization memset(rx_ring, 0, sizeof(rx_ring)); for (i = 0; i &lt; RX_RING_SIZE; i++) &#123; rx_bufs[i] = kalloc(); if (!rx_bufs[i]) panic(\"e1000\"); rx_ring[i].addr = (uint64)rx_bufs[i]; &#125; regs[E1000_RDBAL] = (uint64)rx_ring; 具体来说，它会把包放到 rx_ring[RDH] 里，我们则用 RDT 来读取。 下图是 rx_ring 的示意图，硬件可向 [HEAD, TAIL) 中写入内容， TAIL 处留空以区分空环和满环。 网卡传来的数据格式在 e1000_dev.h 里定义，可参考文档 3.2.3 Receive Descriptor Format： struct rx_desc &#123; uint64 addr; /* Address of the descriptor's data buffer */ uint16 length; /* Length of data DMAed into data buffer */ uint16 csum; /* Packet checksum */ uint8 status; /* Descriptor status */ uint8 errors; /* Descriptor Errors */ uint16 special; &#125;; 网卡发出中断后，内核会调用 e1000_intr，e1000_intr 又会进一步调用 e1000_recv. 对照 rx_ring 的示意图，我们就知道 e1000_recv 应该去 rx_ring[RDT + 1] 处读取数据，直到读到无效数据为止。参考文档的 3.2.3.1 Receive Descriptor Status Field，我们可以根据 rx_desc 的 status 的 DD 位得知数据是否有效。 总之代码如下所示： static void e1000_recv(void) &#123; // // Your code here. // // Check for packets that have arrived from the e1000 // Create and deliver a buf for each packet (using net_rx()). // acquire(&amp;e1000_lock); uint32 idx = (regs[E1000_RDT] + 1) % RX_RING_SIZE; while (rx_ring[idx].status &amp; E1000_RXD_STAT_DD) &#123; char *recv_buf = rx_bufs[idx]; int buflen = rx_ring[idx].length; rx_bufs[idx] = kalloc(); if (!rx_bufs[idx]) &#123; panic(\"e1000\"); &#125; rx_ring[idx].addr = (uint64)rx_bufs[idx]; rx_ring[idx].status = 0; idx = (idx + 1) % RX_RING_SIZE; // net_rx could call e1000_transmit, so release lock before calling it release(&amp;e1000_lock); net_rx(recv_buf, buflen); acquire(&amp;e1000_lock); &#125; // set RDT to the last processed index regs[E1000_RDT] = (idx + RX_RING_SIZE - 1) % RX_RING_SIZE; release(&amp;e1000_lock); &#125; 这里的 regs[E1000_RDT] = (idx + RX_RING_SIZE - 1) % RX_RING_SIZE 可能比较 tricky，总之就是 RDT 应该指在最后一个被取出的描述符处以实现留空。 我们如何借助网卡发送数据？ 如文档 3.4.3 Transmit Interrupts 所写，我们也可以设置网卡在传输完成时发生中断，不过在 xv6 里我们没有这么设置，所以发送成功不会中断。 与读取数据要把 rx_ring 的位置告诉网卡类似，我们要把 tx_ring 的位置在初始化里告诉网卡： // [E1000 14.5] Transmit initialization memset(tx_ring, 0, sizeof(tx_ring)); for (i = 0; i &lt; TX_RING_SIZE; i++) &#123; tx_ring[i].status = E1000_TXD_STAT_DD; tx_bufs[i] = 0; &#125; regs[E1000_TDBAL] = (uint64)tx_ring; 我们会把数据放到 tx_ring[TDT] 里，网卡会自动走动 TDH 直到追上 TDT. 下图是 rx_ring 的示意图，TAIL 指向硬件能够处理的最后一个描述符之后的位置，这也是软件写入第一个新描述符的位置。与 rx_ring 不同，tx_ring 无留空。 传给网卡的数据结构也在 e1000_dev.h 里定义，可参考文档 3.3.2 Transmit Descriptors： struct tx_desc &#123; uint64 addr; uint16 length; uint8 cso; uint8 cmd; uint8 status; uint8 css; uint16 special; &#125;; 对照 tx_ring 的示意图，我们要把数据存在 tx_ring[TDT] 里。要注意如果 TDT 指向的内容已经被网卡成功发送了（可以通过 status 的 DD 位来判断），我们要释放 TDT 指向的内存以避免内存泄漏；另外我们还要更新 cmd 位，具体可以参考 3.3.3.1 Transmit Descriptor Command Field Format. 总之下面是代码： int e1000_transmit(char *buf, int len) &#123; // // Your code here. // // buf contains an ethernet frame; program it into // the TX descriptor ring so that the e1000 sends it. Stash // a pointer so that it can be freed after send completes. // acquire(&amp;e1000_lock); uint32 idx = regs[E1000_TDT]; if (!(tx_ring[idx].status &amp; E1000_TXD_STAT_DD)) &#123; release(&amp;e1000_lock); return -1; &#125; // free old buf that has been sent away if (tx_ring[idx].addr) &#123; kfree(tx_bufs[idx]); &#125; tx_bufs[idx] = buf; tx_ring[idx].addr = (uint64)tx_bufs[idx]; tx_ring[idx].length = len; tx_ring[idx].cmd = E1000_TXD_CMD_EOP | E1000_TXD_CMD_RS; tx_ring[idx].status = 0; regs[E1000_TDT] = (idx + 1) % TX_RING_SIZE; release(&amp;e1000_lock); return 0; &#125; UDP 包的接收我们先来梳理一下整个收信流程是怎样的：外部会发 packet 给网卡，网卡在收到后会引发中断，内核发现中断由网卡引发就会调用 e1000_intr，之后 packet 会被发给 net_rx 来让内核做进一步处理。如果 net_rx 发现这是一个 IP packet 就会进一步调用 ip_rx，然后就到我们的工作了。 我们只需要处理 ETH-IP-UDP 嵌套的 packet，让我们回顾一下它的结构： 具体的 packet header 的定义在 net.h 里。 总之我们要实现 recv、bind、ip_rx 这三个函数。应用会调用 bind 来监听一个端口，当端口被监听时我们需要保存到达这个端口的数据包，所以要在 net.h 中定义如下的数据结构： #define MAX_LISTEN_PORTS 128 #define PACKET_RING_SIZE 16 // for any given port, no more than 16 packets should be saved struct listener &#123; int used; int port; char *packet_ring[PACKET_RING_SIZE]; int head; // used by writer int tail; // used by reader &#125;; 这里的 used 字段可能有点奇怪，我来解释一下：我们希望每当一个应用调用 bind，我们就新增一个 listener，但由于 C 语言实现动态数组很麻烦，所以我们选择创建静态大小的 listeners 数组。那为什么不用链表呢？因为我们新增内存的手段只有 kalloc，而一整个页对一个 listener 来说太大了。 struct listener 里的 used 字段就是为了判断 listeners 数组里的某个 listener 是否已经被使用。 我们要在 net.c 里初始化 listeners 数组： static struct listener listeners[MAX_LISTEN_PORTS]; void netinit(void) &#123; initlock(&amp;netlock, \"netlock\"); for (int i = 0; i &lt; MAX_LISTEN_PORTS; i++) &#123; listeners[i].used = 0; for (int j = 0; j &lt; PACKET_RING_SIZE; j++) &#123; listeners[i].packet_ring[j] = 0; &#125; &#125; &#125; 接下来我们分析一下每个函数要做什么，再给出代码： recv(int dport, int *src, short *sport, char *buf, int maxlen) 接收到达 dport 端口的 UDP packet. 如果到达了多个，取出第一个 packet；如果没有东西到达，等待直到有东西到达。 本函数把取出的 packet 里 32 位的源 IP 地址复制到 *src，UDP 源端口号复制到 *sport，payload 的至多 maxlen 个字节复制到 buf. 成功则返回复制的 payload 字节数，失败返回 -1. 注意网络字节序和系统字节序不同，要用 ntohs 和 ntohl 来逆转字节序。 另外，这里的各个指针是用户空间的虚拟地址，我们要用 copyout 把 packet 里的内容（它们在内核空间）复制到用户空间。 uint64 sys_recv(void) &#123; // // Your code here. // struct proc *p; int dport; uint64 src; uint64 sport; uint64 buf; int maxlen; struct listener *listener = 0; p = myproc(); argint(0, &amp;dport); argaddr(1, &amp;src); argaddr(2, &amp;sport); argaddr(3, &amp;buf); argint(4, &amp;maxlen); // find listener related to dport acquire(&amp;netlock); for (int i = 0; i &lt; MAX_LISTEN_PORTS; i++) &#123; listener = &amp;listeners[i]; if (listener->used &amp;&amp; listener->port == dport) &#123; break; &#125; listener = 0; &#125; if (!listener) &#123; goto bad; &#125; // return the earliest waiting packet or wait until a packet arrives while (1) &#123; if (listener->packet_ring[listener->tail]) &#123; // extract a packet from the ring char *packet = listener->packet_ring[listener->tail]; listener->packet_ring[listener->tail] = 0; listener->tail = (listener->tail + 1) % PACKET_RING_SIZE; // extract data from the packet struct ip *ip_packet = (struct ip *)(packet + sizeof(struct eth)); struct udp *udp_packet = (struct udp *)(packet + sizeof(struct eth) + sizeof(struct ip)); void *payload = ((char *)udp_packet) + sizeof(struct udp); // re-arrange the bytes uint32 src_ip = ntohl(ip_packet->ip_src); uint16 src_port = ntohs(udp_packet->sport); if (copyout(p->pagetable, src, (char *)&amp;src_ip, sizeof(src_ip)) &lt; 0) &#123; kfree(packet); goto bad; &#125; if (copyout(p->pagetable, sport, (char *)&amp;src_port, sizeof(src_port)) &lt; 0) &#123; kfree(packet); goto bad; &#125; // copy at most maxlen bytes of the payload and free the packet uint16 buflen = ntohs(udp_packet->ulen) - sizeof(struct udp); uint64 cplen = (buflen > maxlen) ? maxlen : buflen; if (copyout(p->pagetable, buf, payload, cplen) &lt; 0) &#123; kfree(packet); goto bad; &#125; kfree(packet); release(&amp;netlock); return cplen; &#125; else &#123; // wait until a packet arrives sleep(listener->packet_ring, &amp;netlock); &#125; &#125; goto bad; bad: release(&amp;netlock); return -1; &#125; bind(int port) 进程在调用 recv 前应当先调用 bind 来监听特定端口，bind 被调用时应该要初始化 port 对应的待处理区。 uint64 sys_bind(void) &#123; // // Your code here. // int port; argint(0, &amp;port); acquire(&amp;netlock); // return error if repeated binding for (int i = 0; i &lt; MAX_LISTEN_PORTS; i++) &#123; if (listeners[i].used &amp;&amp; listeners[i].port == port) &#123; goto bad; &#125; &#125; for (int i = 0; i &lt; MAX_LISTEN_PORTS; i++) &#123; if (!listeners[i].used) &#123; // use the first unused listener for port listeners[i].used = 1; listeners[i].port = port; listeners[i].head = 0; listeners[i].tail = 0; release(&amp;netlock); return 0; &#125; &#125; goto bad; bad: release(&amp;netlock); return -1; &#125; ip_rx(char *buf, int len) e1000_recv 会把 packet 转发给 net_rx，net_rx 在发现收到的 packet 是 IP packet 时会把 packet 转发给 ip_rx. 我们需要检查 destination port 是否在正在被监听，如果未监听或待处理区已满就丢弃包，否则存到待处理区。 void ip_rx(char *buf, int len) &#123; // don't delete this printf; make grade depends on it. static int seen_ip = 0; if (seen_ip == 0) printf(\"ip_rx: received an IP packet\\n\"); seen_ip = 1; // // Your code here. // struct udp *udp_packet; struct listener *listener = 0; udp_packet = (struct udp *)(buf + sizeof(struct eth) + sizeof(struct ip)); acquire(&amp;netlock); for (int i = 0; i &lt; MAX_LISTEN_PORTS; i++) &#123; listener = &amp;listeners[i]; // try best to save packet in listener related to dport if (listener->used &amp;&amp; listener->port == ntohs(udp_packet->dport)) &#123; int head = listener->head; // if ring is full, drop the incoming packet if (listener->packet_ring[head] != 0) &#123; kfree(buf); release(&amp;netlock); return; &#125; // save packet in listener listener->packet_ring[head] = buf; listener->head = (head + 1) % PACKET_RING_SIZE; wakeup(listener->packet_ring); release(&amp;netlock); return; &#125; &#125; kfree(buf); release(&amp;netlock); return; &#125; 然后我们就下班了！ 杂七杂八小知识所有权转移看一眼 e1000_recv 的代码，我们会发现它调用了 kalloc，却没有在内部显式释放新建的内存，这是内存泄漏吗？ static void e1000_recv(void) &#123; // // Your code here. // // Check for packets that have arrived from the e1000 // Create and deliver a buf for each packet (using net_rx()). // acquire(&amp;e1000_lock); uint32 idx = (regs[E1000_RDT] + 1) % RX_RING_SIZE; while (rx_ring[idx].status &amp; E1000_RXD_STAT_DD) &#123; char *recv_buf = rx_bufs[idx]; // 在这里取出 int buflen = rx_ring[idx].length; rx_bufs[idx] = kalloc(); // 在这里分配新内存 if (!rx_bufs[idx]) &#123; panic(\"e1000\"); &#125; rx_ring[idx].addr = (uint64)rx_bufs[idx]; rx_ring[idx].status = 0; idx = (idx + 1) % RX_RING_SIZE; // net_rx could call e1000_transmit, so release lock before calling it release(&amp;e1000_lock); net_rx(recv_buf, buflen); // 在这里转移所有权 acquire(&amp;e1000_lock); &#125; // set RDT to the last processed index regs[E1000_RDT] = (idx + RX_RING_SIZE - 1) % RX_RING_SIZE; release(&amp;e1000_lock); &#125; 这并不是内存泄漏，而是一种所有权转移。对每个新建的 rx_bufs[idx] = kalloc()，我们都会在未来通过 recv_buf = rx_bufs[idx] 把它取出，并把其所有权通过 net_rx(recv_buf, buflen) 转移给 net_rx. 也就是说，net_rx 负责释放传入的 buf. 而 net_rx 也可能把 buf 的所有权转移给 app_rx 或 ip_rx. void net_rx(char *buf, int len) &#123; struct eth *eth = (struct eth *)buf; if (len >= sizeof(struct eth) + sizeof(struct arp) &amp;&amp; ntohs(eth->type) == ETHTYPE_ARP) &#123; arp_rx(buf); &#125; else if (len >= sizeof(struct eth) + sizeof(struct ip) &amp;&amp; ntohs(eth->type) == ETHTYPE_IP) &#123; ip_rx(buf, len); &#125; else &#123; kfree(buf); &#125; &#125; 这和 C++ 里的 move 语义类似，都是“转移所有权”。 什么是 attribute((packed))net.h 里有 packet header 的定义，这里 struct eth 里的 __attribute((packed))__ 是在告知编译器取消内存对齐优化，让结构体成员紧凑排列。 struct eth &#123; uint8 dhost[ETHADDR_LEN]; uint8 shost[ETHADDR_LEN]; uint16 type; &#125; __attribute__((packed)); 还记得对齐优化是什么吗？为了提高 CPU 访问内存的效率，结构体中的每个成员的起始地址相对于结构体起始地址的偏移量需要是该成员自身大小的整数倍。如果不是，编译器会在前一个成员后面填充一些空白字节。 比如对下面的结构体，sizeof(struct Test) 是 12 字节，而不是成员大小之和的 1 + 4 + 1 = 6 字节。 struct Test &#123; char c1; int i; char c2; &#125;; 文末吐槽Lab Net 经历了不少变迁，在 2019 和 2020 年它还是课程的最后一个 lab，而从 2021 年开始它就被移到了课程中期，而网络 lec 则一直在课程后期，所以就造成了 lab 和 lec 的错位。 2023 年版本的 Net Lab 只要求实现 Part One 而且标注的难度还是 hard，2024 年就变成了 moderate 还新加了一个 Part Two，果然课程难度也是会通货膨胀的🫠🫠","categories":[{"name":"公开课","slug":"公开课","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"MIT-6.S081","slug":"公开课/MIT-6-S081","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/MIT-6-S081/"},{"name":"Labs","slug":"公开课/MIT-6-S081/Labs","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/MIT-6-S081/Labs/"}],"tags":[]},{"title":"透过望远镜给月亮拍照","slug":"others/thoughts/moon","date":"2025-11-05T14:10:15.000Z","updated":"2025-11-05T15:01:12.376Z","comments":true,"path":"wiki/others/thoughts/moon/","permalink":"http://rinevard.github.io/wiki/others/thoughts/moon/","excerpt":"","text":"今天拿出了我耗费 200 元巨资买的森林人望远镜试着看月亮！ 在拿起望远镜看向月亮之前真的很难想象，一个两百元的望远镜就能让我看清月海、月陆、第谷环形山。不过如果我只是在这里高谈阔论的话，读者（这篇文章真的存在读者吗）一定感受不到这种奇妙的体验的，那我就上图吧！ 我们会注意到它是黑一块白一块的。黑的就是月海，它们是古代火山喷发后玄武岩形成的平原，玄武岩颜色较深，反射阳光的能力弱，所以看起来是暗灰色的。而白的则是月陆，主要由一种叫做斜长岩的浅色岩石构成，看起来更明亮。 而图片五点半方向上的那个辐射状的东西就是第谷坑！（看起来有点像星际拓荒的宇宙之眼呢） 不过这是 PS 调整后的图，主要是拉高了曝光、拉低了高光、拉高了纹理和清晰度，下面是直接拍出来的图（当然不是原图，原图 20mb 感觉放这里就太大了）： 接下来看看我是怎么拍出来的吧！直接拿着手机对着望远镜拍只能拍出来一个小光球，正确的做法是调到专业模式然后调整参数，我的K80至尊版有这些参数可调： S - 快门速度（Shutter Speed） ISO - 感光度 WB - 白平衡 F - 对焦（Focus） 直接拍只能拍出小光球是因为手机拍照默认是自动模式，自动模式看到整个画面都是黑色的（众所周知夜空是黑的）就会努力调节自动曝光，最后导致过曝。 为了避免过曝，我们要在专业模式里把 S 提高、ISO 降低。总之我最后的参数设置是这样的：S: 1/160, ISO: 100, WB: 没调, F: 拉到最右边。然后就能愉快地拍照了！","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/"},{"name":"碎碎念","slug":"杂谈/碎碎念","permalink":"http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}],"tags":[]},{"title":"Lab 5 Copy-on-Write Fork","slug":"learning/open-course/MIT-6.S081/Labs/lab5-cow","date":"2025-11-03T13:56:22.000Z","updated":"2025-11-03T13:57:01.187Z","comments":true,"path":"wiki/learning/open-course/MIT-6.S081/Labs/lab5-cow/","permalink":"http://rinevard.github.io/wiki/learning/open-course/MIT-6.S081/Labs/lab5-cow/","excerpt":"","text":"这个 Lab 要求我们实现 cow fork，这是一个常见的节省内存的手段。 总而言之，就是在 fork 时把父子的虚拟内存都映射到原本的父进程的物理内存上，并将其设为“仅读”。当有进程尝试写它会触发 page fault，这时我们才新建物理页，然后调整尝试写的进程的页表，将对应虚拟页映射到新建的物理页上。 这个 Lab 似乎没有太 tricky 的地方，接下来我会自问自答一下，只要能把这里的答案想明白基本就能写对代码了： 怎么让只读页正确只读，而不能被写？ 我们通过给 PTE 设置一个 COW 位来判断是否是只读. COW 为 1 表示这个 PTE 原本应该是可写的，但现在被临时标记为只读，因为对应的物理页正在被多个进程共享。 什么时候新建物理页？我们会不会多建了不必要的物理页？ 我们维护对每个物理页的引用计数，当引用计数为 1 时就把 COW 重设为 0（因为这个物理页不再被多个进程共享），把 W 位重新设为 1. 什么时候释放物理页？ 调用 kfree 时，如果引用计数大于 1，将引用计数 -1 然后不动；如果引用计数 == 1，释放物理页。 然后就上代码吧。 物理内存层的基建代码首先在 kalloc.c 里新建一个数据结构： struct &#123; struct spinlock lock; int refcnt[PHYSTOP / PGSIZE]; &#125; kref; 这里有锁是因为我们不希望多个进程同时读写 refcnt. 我们要在 kinit 里初始化锁： void kinit() &#123; initlock(&amp;kmem.lock, \"kmem\"); initlock(&amp;kref.lock, \"kref\"); freerange(end, (void *)PHYSTOP); &#125; 然后我们提供三个接口： void kaddref(uint64 pa) &#123; acquire(&amp;kref.lock); kref.refcnt[pa / PGSIZE] += 1; release(&amp;kref.lock); &#125; void kdecref(uint64 pa) &#123; acquire(&amp;kref.lock); if (kref.refcnt[pa / PGSIZE] > 0) &#123; kref.refcnt[pa / PGSIZE] -= 1; &#125; release(&amp;kref.lock); &#125; int kgetref(uint64 pa) &#123; int ref; acquire(&amp;kref.lock); ref = kref.refcnt[pa / PGSIZE]; release(&amp;kref.lock); return ref; &#125; 之后就能修改 kfree 和 kalloc 了，这里我提供的 kfree 是有并发风险的，具体可以看注释： void kfree(void *pa) &#123; struct run *r; if (((uint64)pa % PGSIZE) != 0 || (char *)pa &lt; end || (uint64)pa >= PHYSTOP) panic(\"kfree\"); // 这里有潜在的并发风险, 如果多个共享了物理页的进程同时 kfree 这个物理页, // 那么 if (kgetref((uint64)pa) == 0) 下的语句就有可能被多个进程进入. // 想修正也不难, 不调用函数而是手动请求锁, 在和 refcnt 交互完后释放锁就行. // 不过介于测试代码已经过了, 我们就不改动了 kdecref((uint64)pa); // Free physical memory only when no other reference exists if (kgetref((uint64)pa) == 0) &#123; // Fill with junk to catch dangling refs. memset(pa, 1, PGSIZE); r = (struct run *)pa; acquire(&amp;kmem.lock); r->next = kmem.freelist; kmem.freelist = r; release(&amp;kmem.lock); &#125; &#125; void *kalloc(void) &#123; struct run *r; acquire(&amp;kmem.lock); r = kmem.freelist; if (r) kmem.freelist = r->next; release(&amp;kmem.lock); if (r) kaddref((uint64)r); if (r) memset((char *)r, 5, PGSIZE); // fill with junk return (void *)r; &#125; COW 策略实现然后我们看向 trap.c，在 usertrap 里加入页错误的分支： if (r_scause() == 8) &#123; // ... &#125; else if ((which_dev = devintr()) != 0) &#123; // ... &#125; // 这里是加入的分支 else if ((r_scause() == 15) &amp;&amp; writefault(p->pagetable, r_stval()) != 0) &#123; // copy on write &#125; else &#123; // ... &#125; 接着我们到 vm.c 里实现 writefault： // return 0 if error, and physical address if successful. uint64 writefault(pagetable_t pagetable, uint64 va) &#123; pte_t *pte; uint64 pa; uint flags; int refcnt; struct proc *p = myproc(); if (va >= p->sz) &#123; return 0; &#125; va = PGROUNDDOWN(va); pte = walk(pagetable, va, 0); if (pte == 0) return 0; flags = PTE_FLAGS(*pte); if (!(flags &amp; PTE_COW)) &#123; // read-only page return 0; &#125; pa = PTE2PA(*pte); if ((refcnt = kgetref(pa)) == 0) &#123; // no process ref this page return 0; &#125; else if (refcnt == 1) &#123; // only one process ref this page, change it to a regular writeable page *pte &amp;= (~PTE_COW); *pte |= (PTE_W); return pa; &#125; else &#123; // copy on write char *mem; if ((mem = kalloc()) == 0) &#123; return 0; &#125; memmove(mem, (char *)pa, PGSIZE); *pte &amp;= (~PTE_V); // make mappages work if (mappages(pagetable, va, PGSIZE, (uint64)mem, flags) != 0) &#123; kfree(mem); return 0; &#125; *pte &amp;= (~PTE_COW); *pte |= (PTE_W); kdecref(pa); return pa; &#125; &#125; 然后在 uvmcopy 里加入把多个虚拟内存映射到相同物理内存的机制： int uvmcopy(pagetable_t old, pagetable_t new, uint64 sz) &#123; pte_t *pte; uint64 pa, i; uint flags; for (i = 0; i &lt; sz; i += PGSIZE) &#123; if ((pte = walk(old, i, 0)) == 0) panic(\"uvmcopy: pte should exist\"); if ((*pte &amp; PTE_V) == 0) panic(\"uvmcopy: page not present\"); pa = PTE2PA(*pte); flags = PTE_FLAGS(*pte); if (mappages(new, i, PGSIZE, (uint64)pa, flags) != 0) &#123; goto err; &#125; if (flags &amp; PTE_W) &#123; pte_t *new_pte = walk(new, i, 0); *pte &amp;= (~PTE_W); *new_pte &amp;= (~PTE_W); *pte |= (PTE_COW); *new_pte |= (PTE_COW); &#125; kaddref(pa); &#125; return 0; err: uvmunmap(new, 0, i / PGSIZE, 1); return -1; &#125; 最后改改 copyout 就可以下班了： int copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len) &#123; uint64 n, va0, pa0; pte_t *pte; while (len > 0) &#123; va0 = PGROUNDDOWN(dstva); if (va0 >= MAXVA) return -1; pte = walk(pagetable, va0, 0); if (pte == 0 || (*pte &amp; PTE_V) == 0 || (*pte &amp; PTE_U) == 0) return -1; if ((*pte &amp; PTE_W) == 0) &#123; if ((*pte &amp; PTE_COW) &amp;&amp; writefault(pagetable, va0) != 0) &#123; // copy on write &#125; else &#123; return -1; &#125; &#125; pa0 = PTE2PA(*pte); n = PGSIZE - (dstva - va0); if (n > len) n = len; memmove((void *)(pa0 + (dstva - va0)), src, n); len -= n; src += n; dstva = va0 + PGSIZE; &#125; return 0; &#125; 等等，先别急着下班，copyout 是做什么的？为什么它看起来独树一帜，要我们手动调用处理写故障的函数，而不是自动触发写故障然后自动被处理？ 看看代码可以发现，它没有通过用户页表来“写”内存，而是通过用户页表拿到物理地址，再通过内核页表写内存。在这里，硬件只检查内核页表的权限，而不检查用户页表 PTE 的 PTE_W/COW，因此自然不会触发写故障。 总之就下班了，然后放张图图吧","categories":[{"name":"公开课","slug":"公开课","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"MIT-6.S081","slug":"公开课/MIT-6-S081","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/MIT-6-S081/"},{"name":"Labs","slug":"公开课/MIT-6-S081/Labs","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/MIT-6-S081/Labs/"}],"tags":[]},{"title":"Lab 4 Traps","slug":"learning/open-course/MIT-6.S081/Labs/lab4-traps","date":"2025-10-30T14:28:22.000Z","updated":"2025-10-30T14:38:20.127Z","comments":true,"path":"wiki/learning/open-course/MIT-6.S081/Labs/lab4-traps/","permalink":"http://rinevard.github.io/wiki/learning/open-course/MIT-6.S081/Labs/lab4-traps/","excerpt":"","text":"RISC-V assembly在 lab 开始时，我们要简单回答一些问题。这里只简单聊聊最后两道： 下面的代码会打印什么？ unsigned int i = 0x00646c72; printf(\"H%x Wo%s\", 57616, (char *) &amp;i); 57616 转换到十六进制是 E110，所以空格前打印的是 HE110. RISC-V 使用小端法，所以 i 在内存中的存储是 72 6c 64 00，所以空格后打印的是 rld. 总之我们打印了 HE110, World!（以后咱就用这个去水贴 下面的代码在 “y=” 后会打印什么？ printf(\"x=%d y=%d\", 3); 我们没有传入第三个参数，所以我们会把寄存器 a2 里的东西当作 int 来打印。 Backtrace这里要求我们实现一个 backtrace 函数，打印出当前调用栈。 解法我们先来回顾一下 xv6 的栈结构： . . +-&gt; . | +-----------------+ | | | return address | | | | previous fp ------+ | | saved registers | | | local variables | | | ... | &lt;-+ | +-----------------+ | | | return address | | +------ previous fp | | | saved registers | | | local variables | | +-&gt; | ... | | | +-----------------+ | | | return address | | | | previous fp ------+ | | saved registers | | | local variables | | | ... | &lt;-+ | +-----------------+ | | | return address | | +------ previous fp | | | saved registers | | | local variables | | $fp --&gt; | ... | | +-----------------+ | | return address | | | previous fp ------+ | saved registers | $sp --&gt; | local variables | +-----------------+ 可以概括算法流程如下： 找到当前 stack frame 的 fp，这在初始化时就是找到寄存器 s0 里存储的指针。 找到当前 stack frame 的 previous fp，判断 previous fp 和当前 fp 是否在一个 page 内 如果在，用 %p 打印这个 frame 存储的跳转值，然后继续循环 如果不在就结束循环 总之代码如下： void backtrace(void) &#123; uint64 fp = r_fp(); printf(\"backtrace:\\n\"); for (uint64 cur_fp = fp; PGROUNDDOWN(cur_fp) == PGROUNDDOWN(fp); cur_fp = *(uint64 *)(cur_fp - 16)) &#123; uint64 ret_addr = *(uint64 *)(cur_fp - 8); printf(\"%p\\n\", (void *)ret_addr); &#125; &#125; 和 CSAPP 介绍的栈结构的对比我们会注意到 xv6 的栈结构和 CSAPP 里介绍的略有差异，主要是 CSAPP 的栈帧不包含 previous fp。下面的是 CSAPP 介绍的栈结构 高地址 | 参数7 | | 参数8 | | ... | ← 调用前push | 返回地址 | ← call指令自动push | 保存的寄存器值 | ← 刚进入函数时push | 本地变量1 | | 本地变量2 | | ... | ← 当前rsp指向这里 低地址 下面我们来编译 CSAPP 书中的一段代码： long caller() &#123; long arg1 = 534; long arg2 = 1057; long sum = swap_add(&amp;arg1, &amp;arg2); long diff = arg1 - arg2; return sum * diff; &#125; 这里是 CSAPP 书上给出的编译结果： caller: subq $16, %rsp ; Allocate 16 bytes for stack frame movq $534, (%rsp) ; Store 534 in arg1 movq $1057, 8(%rsp) ; Store 1057 in arg2 leaq 8(%rsp), %rsi ; Compute &amp;arg2 as second argument movq %rsp, %rdi ; Compute &amp;arg1 as first argument call swap_add ; Call swap_add(&amp;arg1, &amp;arg2) movq (%rsp), %rdx ; Get arg1 subq 8(%rsp), %rdx ; Compute diff = arg1 - arg2 imulq %rdx, %rax ; Compute sum * diff addq $16, %rsp ; Deallocate stack frame ret ; Return 这里则是在 xv6 里得到的编译结果： 0000000000000034 &lt;caller&gt;: long caller() 34: 1141 addi sp,sp,-16 36: e422 sd s0,8(sp) 38: 0800 addi s0,sp,16 3a: 000cb537 lui a0,0xcb 3e: 25d50513 addi a0,a0,605 # cb25d &lt;base+0xca24d&gt; 42: 6422 ld s0,8(sp) 44: 0141 addi sp,sp,16 46: 8082 ret 可以注意到 CSAPP 只是把局部变量 arg1 和 arg2 存储在了栈中，而 xv6 的 sd s0,8(sp) 把调用者的栈帧指针压入了栈中。 产生这种差异的原因是编译器的优化，CSAPP 里的编译器认为通过 subq $16, %rsp 和 addq $16, %rsp 就能完成这个函数的工作，所以没有存储栈帧指针；xv6 则为了方便教学，包含了栈帧指针。 Alarm这里我们要实现一个叫做 sigalarm(interval, handler) 的系统调用，它会每隔 interval 个 ticks 调用一次 handler. 每个 tick 都会产生一个中断，我们要做的就是每中断若干次调用一下 handler. 我们还需要实现 sigreturn，它是一个辅助 sigalarm 正确工作的系统调用。我们有这样的 promise——用户在调用 sigalram 时提供的 handler 函数必须在结尾调用 sigreturn。总之，sigreturn 的工作主要是把用户进程状态恢复到被中断时的状态。 开工！我们可以按下面的流程完成任务： 在开始之前： 在 usys.pl 等地方做一些基建来把两个系统调用加入到系统里 每隔若干 ticks 调用一次 handler： 在 proc.h 里加入存储 interval、handler 以及距离上一次调用 handler 过去的 ticks 的字段 在 sysproc.c 里实现 sys_sigalarm，它记录并存储用户传进来的 interval 和 handler 在 trap.c 的 usertrap 里加入对 handler 的调用。还记得吗，当执行 SERT 时，程序计数器 pc 被设置为存储在 sepc 寄存器中的值，所以我们要修改 p-&gt;trapframe-&gt;epc. 把用户进程状态恢复到被中断时的状态： 我们需要保存的是用户中断时的 struct trapframe. 所以我们需要在 proc.h 里新增 struct trapframe alarm_tf 字段，在 handler 被调用时把 p-&gt;trapframe 复制到 alarm_tf，并在 sys_sigreturn 被调用时把 alarm_tf 复制回 p-&gt;trapframe. 我们就直接放最终代码了。 首先在 proc.h 的 struct proc 里新增这些字段： int alarm_freq; // How many ticks to call alarm_handler once uint64 alarm_handler; // Handler's user virtual address int tick_from_last; // How many ticks have passed since the last call int is_alarming; struct trapframe alarm_tf; 然后在 sys_proc.c 里把用户传入的 interval 和 handler 保存下来，并初始化一些和调用 handler 相关的变量： uint64 sys_sigalarm(void) &#123; int ticks; uint64 handler; argint(0, &amp;ticks); argaddr(1, &amp;handler); myproc()->alarm_freq = ticks; myproc()->alarm_handler = handler; myproc()->tick_from_last = 0; myproc()->is_alarming = 0; return 0; &#125; 之后修改 trap.c 完成对 handler 的调用以及对用户进程状态的保存： if (which_dev == 2) &#123; if (p->alarm_freq != 0) &#123; if (!p->is_alarming &amp;&amp; p->tick_from_last >= p->alarm_freq &amp;&amp; p->tick_from_last % p->alarm_freq == 0) &#123; p->is_alarming = 1; memmove(&amp;p->alarm_tf, p->trapframe, sizeof(*p->trapframe)); p->trapframe->epc = p->alarm_handler; p->tick_from_last = 0; &#125; else &#123; p->tick_from_last += 1; &#125; &#125; yield(); &#125; 最后在返回时重置用户进程状态： uint64 sys_sigreturn(void) &#123; struct proc *p = myproc(); memmove(p->trapframe, &amp;p->alarm_tf, sizeof(*p->trapframe)); p->is_alarming = 0; return p->alarm_tf.a0; &#125; 一些小想法为什么说“Prevent re-entrant calls to the handler—-if a handler hasn’t returned yet, the kernel shouldn’t call it again. test2 tests this.”，即不能在上次对 handler 的调用完成前进行下次调用？我猜是因为我们会保存调用前的用户进程状态，而在上次 handler 完成前再次调用 handler 就会保存上次 handler 正在执行时的用户进程状态，这会覆盖最开始的用户进程状态。 再说句题外话，感觉 Page Tables 的 hard 的难度比这个难不少……果然 All hards are hard, but some hards are harder than others🫠🫠","categories":[{"name":"公开课","slug":"公开课","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"MIT-6.S081","slug":"公开课/MIT-6-S081","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/MIT-6-S081/"},{"name":"Labs","slug":"公开课/MIT-6-S081/Labs","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/MIT-6-S081/Labs/"}],"tags":[]},{"title":"Lab 3 Page Tables","slug":"learning/open-course/MIT-6.S081/Labs/lab3-pagetable","date":"2025-10-28T08:28:22.000Z","updated":"2025-10-28T08:29:01.912Z","comments":true,"path":"wiki/learning/open-course/MIT-6.S081/Labs/lab3-pagetable/","permalink":"http://rinevard.github.io/wiki/learning/open-course/MIT-6.S081/Labs/lab3-pagetable/","excerpt":"","text":"Inspect a user-process page table这道题让我们解释一下 print_pgtbl 的打印结果，首先让我们来看看它打印了什么： print_pgtbl starting va 0x0 pte 0x21FCD85B pa 0x87F36000 perm 0x5B va 0x1000 pte 0x21FD141B pa 0x87F45000 perm 0x1B va 0x2000 pte 0x21FD1017 pa 0x87F44000 perm 0x17 va 0x3000 pte 0x21FD4007 pa 0x87F50000 perm 0x7 va 0x4000 pte 0x21FC70D7 pa 0x87F1C000 perm 0xD7 va 0x5000 pte 0x0 pa 0x0 perm 0x0 va 0x6000 pte 0x0 pa 0x0 perm 0x0 va 0x7000 pte 0x0 pa 0x0 perm 0x0 va 0x8000 pte 0x0 pa 0x0 perm 0x0 va 0x9000 pte 0x0 pa 0x0 perm 0x0 va 0xFFFF6000 pte 0x0 pa 0x0 perm 0x0 va 0xFFFF7000 pte 0x0 pa 0x0 perm 0x0 va 0xFFFF8000 pte 0x0 pa 0x0 perm 0x0 va 0xFFFF9000 pte 0x0 pa 0x0 perm 0x0 va 0xFFFFA000 pte 0x0 pa 0x0 perm 0x0 va 0xFFFFB000 pte 0x0 pa 0x0 perm 0x0 va 0xFFFFC000 pte 0x0 pa 0x0 perm 0x0 va 0xFFFFD000 pte 0x0 pa 0x0 perm 0x0 va 0xFFFFE000 pte 0x21FC94C7 pa 0x87F25000 perm 0xC7 va 0xFFFFF000 pte 0x2000184B pa 0x80006000 perm 0x4B print_pgtbl: OK 结合 print_pgtbl 的实现，我们可以知道 pgtbltest 遍历了用户进程虚拟地址空间开头和末尾的一些地址，并打印出它们对应的 PTE、物理地址、权限位。让我们先来看看 PTE 的结构： 然后我们以 va 0x4000 pte 0x21FC70D7 pa 0x87F1C000 perm 0xD7 为例，解析一下其打印的内容。首先我们从 PTE 中提取出 Physical Page Number（PPN）和权限位： &#x2F;&#x2F; 打印 PPN &#x2F;&#x2F; 虚拟地址的末尾 12 位是 0, 所以物理地址偏移量为 0 &#x2F;&#x2F; 物理地址为 ((pte &gt;&gt; 10) &lt;&lt; 12) + 0 即 0x87f1c000 (gdb) p &#x2F;x (0x21FC70D7 &gt;&gt; 10) $17 &#x3D; 0x87f1c &#x2F;&#x2F; 构造一个末尾 10 位为 1 的量, 方便后续取出权限位 (gdb) set $mask &#x3D; ((1 &lt;&lt; 10) - 1) (gdb) p &#x2F;t $mask $18 &#x3D; 1111111111 &#x2F;&#x2F; 分别用二进制和十六进制打印权限位 (gdb) p &#x2F;t (0x21FC70D7 &amp; $mask) $19 &#x3D; 11010111 (gdb) p &#x2F;x (0x21FC70D7 &amp; $mask) $20 &#x3D; 0xd7 检验可知和 print_pgtbl 的打印结果一致。对照权限位的末五位 10111 和 PTE 的末尾五位 UXWRV，可知这里是用户内存、不可执行、可写、可读、合法。 我们可以再检查一下 va 0xFFFFF000 pte 0x2000184B pa 0x80006000 perm 0x4B，会发现它的权限位末五位是 01011，说明这里是非用户内存、可以执行、不可写、可读、合法。 对照下面的用户进程虚拟内存空间图可知我们分析的第一段虚拟地址 0x4000 大约在开头位置，确实是用户的东西；而分析的第二段 0xFFFFF000 则在接近末尾的位置，用于存储系统调用相关的陷阱代码。 我们还可以进一步打印一下内存里的值。启动 gdb，用 file user/_pgtbltest 加载符号表，然后在 main 设置断点，这样我们就能在加载用户页表时打印各个虚拟地址的值： (gdb) p *0x0 $7 &#x3D; -335146751 (gdb) p *0x1000 $8 &#x3D; 72 (gdb) p *0x5000 Cannot access memory at address 0x5000 (gdb) p *0xFFFFE000 Cannot access memory at address 0xffffe000 对照最开始的 print_pgtbl 的打印结果（关注其权限位），可以看到我们能正确打印 0x0 和 0x1000 ，它们是用户内存、可读、合法的虚拟地址的内容。而 0x5000 是不合法的地址所以无法打印，0xFFFFE000 是非用户内存（内核内存）所以无法打印。 Speed up system calls这道题让我们创建一个特殊的内存页并把进程 pid 存储在里面，这样我们在获取 pid 时就不必做系统调用 getpid，而是可以直接调用 ugetpid，从而无需陷入内核以提高效率。 提示里说我们创建的这个页面会和 trapframe 有很多相似之处——它们都在进程初始化时自动创建，在进程退出时自动释放。所以我们可以分为以下几步完成任务： 定义 usyscall：在 struct proc 里添加 struct usyscall *usyscall 进程初始化时创建页面：阅读 fork 的代码可以知道我们调用 allocproc 以创建进程。 在 allocproc 里，我们用 kalloc 给 trapframe 分配了一个物理页，然后调用 proc_pagetable 来做页表映射。 static struct proc *allocproc(void) &#123; // ... // Allocate a trapframe page. if ((p->trapframe = (struct trapframe *)kalloc()) == 0) &#123; freeproc(p); release(&amp;p->lock); return 0; &#125; // An empty user page table. p->pagetable = proc_pagetable(p); // ... 所以照葫芦画瓢就行，先在 allocproc 里加入给 usyscall 分配物理页的代码（记得把 pid 存进去）： // Allocate a usyscall page if ((p->usyscall = (struct usyscall *)kalloc()) == 0) &#123; freeproc(p); release(&amp;p->lock); return 0; &#125; p->usyscall->pid = p->pid; 然后在 proc_pagetable 加入页表映射的代码： // map the usyscall page just below the trapframe page, for // data sharing between userspace and the kernel if (mappages(pagetable, USYSCALL, PGSIZE, (uint64)(p->usyscall), PTE_R | PTE_U) &lt; 0) &#123; uvmunmap(pagetable, TRAPFRAME, 1, 0); uvmunmap(pagetable, TRAMPOLINE, 1, 0); uvmfree(pagetable, 0); return 0; &#125; 退出时释放：我们知道进程调用 exit 来下班，但其实调用 exit 后进程并没有立即销毁自身，而是进入 ZOMBIE 态等待父进程的 wait 来回收。具体可以看看 proc.c，这里不多赘述。 总之看向 wait 函数，可以发现我们调用 freeproc 来释放进程。 static void freeproc(struct proc *p) &#123; if (p->trapframe) kfree((void *)p->trapframe); p->trapframe = 0; if (p->pagetable) proc_freepagetable(p->pagetable, p->sz); // ... 对照代码对 trapframe 的处理，我们要在 freeproc 里加入释放物理页的代码： if (p->usyscall) kfree((void *)p->usyscall); p->usyscall = 0; 然后修改 proc_freepagetable 以删除页表映射： uvmunmap(pagetable, USYSCALL, 1, 0); 闲着也是闲着，不如和我一起看看 uvmfree 为什么没有自动释放 trapframe 和 usyscall： void uvmfree(pagetable_t pagetable, uint64 sz) &#123; if (sz > 0) uvmunmap(pagetable, 0, PGROUNDUP(sz) / PGSIZE, 1); freewalk(pagetable); &#125; 这段代码调用 uvmunmap 来释放所有在页表里有记录的物理页，然后调用 freewalk 来释放页表自身。 这里的 uvmunmap(pagetable, 0, PGROUNDUP(sz) / PGSIZE, 1) 表示释放虚拟地址从 0 到 0 + PGROUNDUP(sz) / PGSIZE 的内容，即释放用户内存的内容。 但 trapframe 和 usyscall 不是用户内存的内容，它们被存放在虚拟地址的顶部（分别在 TRAPFRAME 和 USYSCALL），所以它们没有被释放。 Print a page table先来看看打印结果吧： page table 0x0000000087f22000 ..0x0000000000000000: pte 0x0000000021fc7801 pa 0x0000000087f1e000 .. ..0x0000000000000000: pte 0x0000000021fc7401 pa 0x0000000087f1d000 .. .. ..0x0000000000000000: pte 0x0000000021fc7c5b pa 0x0000000087f1f000 .. .. ..0x0000000000001000: pte 0x0000000021fc701b pa 0x0000000087f1c000 .. .. ..0x0000000000002000: pte 0x0000000021fc6cd7 pa 0x0000000087f1b000 .. .. ..0x0000000000003000: pte 0x0000000021fc6807 pa 0x0000000087f1a000 .. .. ..0x0000000000004000: pte 0x0000000021fc64d7 pa 0x0000000087f19000 ..0xffffffffc0000000: pte 0x0000000021fc8401 pa 0x0000000087f21000 .. ..0xffffffffffe00000: pte 0x0000000021fc8001 pa 0x0000000087f20000 .. .. ..0xffffffffffffd000: pte 0x0000000021fd4c13 pa 0x0000000087f53000 .. .. ..0xffffffffffffe000: pte 0x0000000021fd00c7 pa 0x0000000087f40000 .. .. ..0xfffffffffffff000: pte 0x000000002000184b pa 0x0000000080006000 结果比 2024 的作业文档多了一行 .. .. ..0x0000000000000000: pte 0x0000000021fc7c5b pa 0x0000000087f1f000 这是正确表现。2024 的作业文档这里写错了，2025 的版本就加入了这行。 如提示所言，这个函数和 freewalk 很像，我们先来看看 freewalk： void freewalk(pagetable_t pagetable) &#123; // there are 2^9 = 512 PTEs in a page table. for (int i = 0; i &lt; 512; i++) &#123; pte_t pte = pagetable[i]; if ((pte &amp; PTE_V) &amp;&amp; (pte &amp; (PTE_R | PTE_W | PTE_X)) == 0) &#123; // this PTE points to a lower-level page table. uint64 child = PTE2PA(pte); freewalk((pagetable_t)child); pagetable[i] = 0; &#125; else if (pte &amp; PTE_V) &#123; panic(\"freewalk: leaf\"); &#125; &#125; kfree((void *)pagetable); &#125; 它遍历 L0 级页表的 512 个 PTE，对每个 PTE，用 PTE2PA(pte) 找到它指向的次级页表的物理地址，然后递归。它忽略了叶子 PTE，在打印时我们不需要忽略叶子。 我们再来看看打印结果的形式 .. 虚拟地址: pte PTE的值 pa 物理地址的值 参考 freewalk 我们就能拿到 PTE，调用 PTE2PA 就能得到 pa，但怎么获得虚拟地址呢？我们来看看虚拟地址的翻译： 从这里可以看出，如果把 Offset 置零，我们需要 L2、L1、L0 页表的 PTE 的索引来确定虚拟地址。但我们当然有办法获得这些索引，我们不是在遍历页表吗，for (int i = 0; i &lt; 512; i++) 里的 i 就是我们需要的索引！所以如果我们的索引是 i, j, k，我们打印的虚拟地址就是 ((i &lt;&lt; 30) + (j &lt;&lt; 21) + (k &lt;&lt; 12)) 大致思路就是这样。还有一些小细节： 作业文档里在遍历 L2 和 L1 级页表时也打印了虚拟地址，这里打印的地址是把次级索引当作零算出的地址。比如如果我们在遍历 L1 页表，L2 页表的索引是 i，L1 页表的索引是 j，打印的就是 ((i &lt;&lt; 30) + (j &lt;&lt; 21) + (0 &lt;&lt; 12)) 为了在递归时得知上一级页表的信息，我们加入了 father_va 用于记录上一级的虚拟地址 符号拓展用了一些 tricky 的性质，在 255 &lt;&lt; 30 那行的注释里写的应该还算清楚 总之可以写出下面的代码： const int MAX_LEVEL = 2; void _vmprint_helper(pagetable_t pagetable, uint64 father_va, int level) &#123; // there are 2^9 = 512 PTEs in a page table. for (int i = 0; i &lt; 512; i++) &#123; pte_t pte = pagetable[i]; if (pte &amp; PTE_V) &#123; for (int i = level; i &lt;= MAX_LEVEL; i++) &#123; printf(\" ..\"); &#125; // 255 &lt;&lt; 30 is automatically sign extended to 0xffffffffc0000000 uint64 va = father_va + (i &lt;&lt; (12 + 9 * level)); printf(\"%p: pte %p pa %p\\n\", (void *)va, (void *)pte, (void *)PTE2PA(pte)); // this PTE points to a lower-level page table. if (level != 0) &#123; _vmprint_helper((pagetable_t)PTE2PA(pte), va, level - 1); &#125; &#125; &#125; &#125; void vmprint(pagetable_t pagetable) &#123; printf(\"page table %p\\n\", pagetable); _vmprint_helper(pagetable, 0, MAX_LEVEL); &#125; Use superpages这道题让我们给 xv6 加入超级页。当用户请求一块超过 2MB 的内存，我们就分配超级页而非大量的小页来优化性能。 我们先来看看普通页和超级页各自是如何翻译虚拟地址的： 普通页： 普通页在翻译时把虚拟地址分成 L2, L1, L0, Offset 四个部分。前三者用于在不同级别的页表里做偏移找到下一个页的开头的物理地址（一个 Page Directory 也是一个页），Offset 则用于计算最终的物理地址偏移。 Sv39 规定 PPN 宽度为 44 位，Offset 宽度 12 位，一个普通页的大小就是 $2^{12}$ bytes = 4KB. 在找到了 L0 leaf 后，我们就能用 (PPN &lt;&lt; 12) + Offest 来计算虚拟地址对应的物理地址了。 超级页： 超级页则把虚拟地址分成 L2, L1, Offset 三个部分。 Sv39 规定超级页的 Offset 为 21 位，这是把原本的 L0 和 Offset 合并成了一个 21 位的 Offset。超级页大小就是 $2^{21}$ bytes 即 2MB. 超级页是 2MB 对齐的，所以我们需要 $56 - \\log (2097152) = 35$ 位来描述一个超级页的开头，所以超级页对应的 L1 leaf 存储的 PPN 的末尾 9 位为 0. 这里有 $2097152$ 是因为 2MB = 2097152 bytes. 在找到 L1 leaf 后，我们同样用 (PPN &lt;&lt; 12) + Offest 来计算虚拟地址对应的物理地址。 测试代码遵循提示，我们先来看看 superpg_test 做了什么。要说明的是，2024 版本的测试不全面而且有 bug——在 supercheck 函数的末尾的 for 循环里，条件应该是 i &lt; 512 * PGSIZE 而非 i &lt; 512，应该改成下面这样： // check whether different va are mapped to different pa for (int i = 0; i &lt; 512 * PGSIZE; i += PGSIZE) &#123; *(int *)(s + i) = i; &#125; for (int i = 0; i &lt; 512 * PGSIZE; i += PGSIZE) &#123; if (*(int *)(s + i) != i) err(\"wrong value\"); &#125; 总之我们下面分析 2025 版本的测试。2025 版本的测试共包括 supercheck、superpg_fork 和 superpg_free 三个函数，我们主要关注 supercheck。supercheck 判断从 end 之后第一个对齐超级页的地址开始是否是超级页，具体的判断方法可以参考下面的注释： void supercheck(char *end) &#123; pte_t last_pte = 0; uint64 a = (uint64)end; uint64 s = SUPERPGROUNDUP(a); // Check that virtual address up to the next superpage boundary are mapped to PTE for (; a &lt; s; a += PGSIZE) &#123; pte_t pte = (pte_t)pgpte((void *)a); if (pte == 0) &#123; err(\"no pte\"); &#125; &#125; // Check that all virtual address in the superpage share the same valid PTE for (uint64 p = s; p &lt; s + 512 * PGSIZE; p += PGSIZE) &#123; pte_t pte = (pte_t)pgpte((void *)p); if (pte == 0) err(\"no pte\"); if ((uint64)last_pte != 0 &amp;&amp; pte != last_pte) &#123; err(\"pte different\"); &#125; if ((pte &amp; PTE_V) == 0 || (pte &amp; PTE_R) == 0 || (pte &amp; PTE_W) == 0) &#123; err(\"pte wrong\"); &#125; last_pte = pte; &#125; // Check that different va are mapped to different pa for (int i = 0; i &lt; 512 * PGSIZE; i += PGSIZE) &#123; *(int *)(s + i) = i; &#125; for (int i = 0; i &lt; 512 * PGSIZE; i += PGSIZE) &#123; if (*(int *)(s + i) != i) err(\"wrong value\"); &#125; &#125; 然后我们简要提一下另外两个函数的作用： superpg_fork 检查超级页在 fork 后是否被正确复制为超级页。 superpg_free 检查 sbrk 能否正确释放整个超级页，以及能否在释放超级页的部分内存时将超级页退化为多个普通页（2024 版本没测试这一点，但这个是很值得做的功能）。 sbrk 调用链接下来我们分析用户在调用 sbrk 时具体调用了哪些函数。这分为两种情况： 分配：sys_sbrk-&gt;growproc-&gt;uvmalloc -&gt; kalloc/kfree 释放：sys_sbrk -&gt; growproc -&gt; uvmdealloc -&gt; uvmunmap 要注意的是当分配内存出错时，uvmalloc 也会调用 uvmdealloc。 我们从最底层出发，先在 kalloc.c 里完成对超级页的支持。这包括以下步骤： 添加一个超级页链表 struct &#123; struct spinlock lock; struct run *superlist; struct run *freelist; &#125; kmem; 在初始化代码里初始化这个超级页链表 const int MAX_SUPER = 32; void freerange(void *pa_start, void *pa_end) &#123; char *p; p = (char *)PGROUNDUP((uint64)pa_start); int sz; int super_cnt = 0; for (; p + PGSIZE &lt;= (char *)pa_end; p += sz) &#123; if (super_cnt &lt; MAX_SUPER &amp;&amp; (uint64)p % SUPERPGSIZE == 0 &amp;&amp; p + SUPERPGSIZE &lt;= (char *)pa_end) &#123; sz = SUPERPGSIZE; superfree(p); super_cnt += 1; &#125; else &#123; sz = PGSIZE; kfree(p); &#125; &#125; &#125; 添加 superalloc 和 superfree 函数（照抄 kalloc 和 kfree）： void *superalloc(void) &#123; struct run *r; acquire(&amp;kmem.lock); r = kmem.superlist; if (r) kmem.superlist = r->next; release(&amp;kmem.lock); if (r) memset((char *)r, 5, SUPERPGSIZE); // fill with junk return (void *)r; &#125; void superfree(void *pa) &#123; struct run *r; if (((uint64)pa % SUPERPGSIZE) != 0 || (char *)pa &lt; end || (uint64)pa >= PHYSTOP) &#123; panic(\"superfree\"); &#125; // Fill with junk to catch dangling refs. memset(pa, 1, SUPERPGSIZE); r = (struct run *)pa; acquire(&amp;kmem.lock); r->next = kmem.superlist; kmem.superlist = r; release(&amp;kmem.lock); &#125; 至此，最底层的工作就做完了。 分配内存回顾内存分配的调用链：sys_sbrk-&gt;growproc-&gt;uvmalloc -&gt; kalloc/kfree，在开始编写代码之前我们先分析一下每一层的职责。 sys_sbrk 是系统调用，负责系统和用户的交互 grow_proc 是进程抽象的一个接口，负责管理进程状态 uvmalloc 是虚拟内存层，负责管理进程眼中的“内存”，管理虚拟到物理的映射 kalloc 和 kfree 则是物理内存层，管理物理内存 我们在这里要修改的是 uvmalloc. 简单读下它原本的代码可以发现它主要调用的是 kalloc 和 mappages. 在超级页中，前者对应 superalloc，而对后者我自己写了一个 mapsuperpages 作为对应。为了让 mapsuperpages 跑起来，我还写了个 l1walk 函数用于找到一个虚拟地址对应的 L1 PTE. 先来看看 l1walk： pte_t *l1walk(pagetable_t pagetable, uint64 va, int alloc) &#123; if (va >= MAXVA) panic(\"walk\"); pte_t *pte = &amp;pagetable[PX(2, va)]; if (*pte &amp; PTE_V) &#123; pagetable = (pagetable_t)PTE2PA(*pte); return &amp;pagetable[PX(1, va)]; &#125; else &#123; if (!alloc || (pagetable = (pde_t *)kalloc()) == 0) &#123; return 0; &#125; memset(pagetable, 0, PGSIZE); *pte = PA2PTE(pagetable) | PTE_V; return &amp;pagetable[PX(1, va)]; &#125; &#125; 它和 walk 函数基本一致，不过 walk 是返回 leaf，而这里的 l1walk 返回 L1 PTE. 然后看看 mapsuperpages： int mapsuperpages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm) &#123; uint64 a, last; pte_t *pte; if ((va % SUPERPGSIZE) != 0) panic(\"mapsuperpages: va not aligned\"); if ((size % SUPERPGSIZE) != 0) panic(\"mapsuperpages: size not aligned\"); if (size == 0) panic(\"mapsuperpages: size\"); a = va; last = va + size - SUPERPGSIZE; for (;;) &#123; if ((pte = l1walk(pagetable, a, 1)) == 0) &#123; printf(\"mapsuperpages: l1walk failed\\n\"); return -1; &#125; if (*pte &amp; PTE_V) panic(\"mapsuperpages: remap\"); *pte = PA2PTE(pa) | perm | PTE_V | PTE_R; if (a == last) break; a += SUPERPGSIZE; pa += SUPERPGSIZE; &#125; return 0; &#125; 这基本是照抄 mappages，只是把普通页改成了超级页。 最后看看我们对 uvmalloc 的修改。uvmalloc 主要分为两部分，第一部分是用 kalloc/superalloc 请求物理内存，第二部分是用 mappages/mapsuperpages 把虚拟内存映射到物理内存上。 我们在注释里标出了修改的地方，修改 1 对应请求物理内存的第一部分，修改 2 对应做映射的第二部分： uint64 uvmalloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz, int xperm) &#123; char *mem; uint64 a; int sz; if (newsz &lt; oldsz) return oldsz; oldsz = PGROUNDUP(oldsz); for (a = oldsz; a &lt; newsz; a += sz) &#123; // 修改1从这里开始 if (a % SUPERPGSIZE == 0 &amp;&amp; a + SUPERPGSIZE &lt;= newsz) &#123; sz = SUPERPGSIZE; mem = superalloc(); // If no superpages, use regular pages if (mem == 0) &#123; sz = PGSIZE; mem = kalloc(); &#125; &#125; else &#123; sz = PGSIZE; mem = kalloc(); &#125; // 修改1到这里结束 if (mem == 0) &#123; uvmdealloc(pagetable, a, oldsz); return 0; &#125; #ifndef LAB_SYSCALL memset(mem, 0, sz); #endif // 修改2从这里开始 if (sz == PGSIZE) &#123; if (mappages(pagetable, a, sz, (uint64)mem, PTE_R | PTE_U | xperm) != 0) &#123; kfree(mem); uvmdealloc(pagetable, a, oldsz); &#125; &#125; else &#123; if (mapsuperpages(pagetable, a, sz, (uint64)mem, PTE_R | PTE_U | xperm) != 0) &#123; superfree(mem); uvmdealloc(pagetable, a, oldsz); &#125; &#125; // 修改2到这里结束 &#125; return newsz; &#125; 释放内存在完成了分配内存的工作后，我们就能写释放内存相关的代码了。 回顾调用链：sys_sbrk -&gt; growproc -&gt; uvmdealloc -&gt; uvmunmap，我们要修改 uvmunmap. 这部分代码比较棘手。它原本只是在按部就班地删掉页表里从 va 出发的 npages 个物理页的映射，并选择性释放物理内存，但在加入超级页后它需要完成这些工作： 让 uint64 a 从 va 出发，如果遇到了普通页，走普通页的 unmap 流程，然后 a += PGSIZE 如果遇到了超级页，判断 a 是超级页的开头还是超级页的中间 如果是超级页的开头，走超级页的 unmap 流程（和普通页 unmap 基本一致），然后 a += SUPERPGSIZE 如果是超级页的中间，把超级页退化成若干个普通页，再走普通页释放流程，然后 a += PGSIZE 这里主要是上面步骤中的 2b 的“退化”比较棘手，我是把页表里对应超级页的 L1 leaf 设置成了 invalid，然后把超级页视作多个普通页的合并，从超级页的开头出发做若干次 mappages 从而完成退化。思路可以参考下图： 这里是退化部分的代码： int perm = PTE_FLAGS(*pte); uint64 super_va_st = SUPERPGROUNDDOWN(a); uint64 super_pa_st = PTE2PA(*pte); *pte = (*pte >> 1) &lt;&lt; 1; // Make pte invalid to make `mappages` work for (uint64 super_va = super_va_st, super_pa = super_pa_st; super_va &lt; super_va_st + SUPERPGSIZE; super_va += PGSIZE, super_pa += PGSIZE) &#123; if (mappages(pagetable, super_va, PGSIZE, super_pa, perm) != 0) &#123; panic(\"uvmunmap: mappages failed\"); &#125; &#125; 当然这样的退化有一个潜在风险——每个进程的超级页上限在进程启动时就决定了，我们的退化会让本进程的超级页上限减一。如果有什么自动合并普通页为超级页的功能就好了… 另外，我的代码把之前步骤里描述的 1 和 2b 整合了一下（毕竟它们最后都走的是普通页释放流程），总之这里是完整代码： void uvmunmap(pagetable_t pagetable, uint64 va, uint64 npages, int do_free) &#123; uint64 a; pte_t *pte; int sz; if ((va % PGSIZE) != 0) panic(\"uvmunmap: not aligned\"); for (a = va; a &lt; va + npages * PGSIZE; a += sz) &#123; // If `a` corresponds to a superpage and the superpage starts at `a`, // free the superpage if ((pte = l1walk(pagetable, a, 0)) != 0 &amp;&amp; PTE_LEAF(*pte) &amp;&amp; a % SUPERPGSIZE == 0) &#123; sz = SUPERPGSIZE; if ((*pte &amp; PTE_V) == 0) &#123; printf(\"va=%ld pte=%ld\\n\", a, *pte); panic(\"uvmunmap: not mapped\"); &#125; if (do_free) &#123; uint64 pa = PTE2PA(*pte); superfree((void *)pa); &#125; *pte = 0; &#125; else &#123; sz = PGSIZE; // If `a` corresponds to a superpage but the superpage doesn't // start at `a`, demote the superpage into regular pages if (pte != 0 &amp;&amp; PTE_LEAF(*pte)) &#123; // Potential issue: // Each process has a max number of superpages defined as // `MAX_SUPER`. But whenever a superpage is demoted, the // process's max number of superpages permanently minus one, // since we view superpage as multiple regular pages. // // A possible solution is to kalloc multiple regular pages, // copy memory into them, and superfree the superpage. int perm = PTE_FLAGS(*pte); uint64 super_va_st = SUPERPGROUNDDOWN(a); uint64 super_pa_st = PTE2PA(*pte); *pte = (*pte >> 1) &lt;&lt; 1; // Make pte invalid to make `mappages` work for (uint64 super_va = super_va_st, super_pa = super_pa_st; super_va &lt; super_va_st + SUPERPGSIZE; super_va += PGSIZE, super_pa += PGSIZE) &#123; if (mappages(pagetable, super_va, PGSIZE, super_pa, perm) != 0) &#123; panic(\"uvmunmap: mappages failed\"); &#125; &#125; &#125; // Free the regular page that begins at `a` if ((pte = walk(pagetable, a, 0)) == 0) panic(\"uvmunmap: walk\"); if ((*pte &amp; PTE_V) == 0) &#123; printf(\"va=%ld pte=%ld\\n\", a, *pte); panic(\"uvmunmap: not mapped\"); &#125; if (PTE_FLAGS(*pte) == PTE_V) panic(\"uvmunmap: not a leaf\"); if (do_free) &#123; uint64 pa = PTE2PA(*pte); kfree((void *)pa); &#125; *pte = 0; &#125; &#125; &#125; fork最艰难的工作已经做完了，我们只要修改 uvmcopy 就能下班了！这里的修改只是加入一个简单的分类，在遇到普通页时走普通流程，遇到超级页时走超级流程。咱就直接放代码了： int uvmcopy(pagetable_t old, pagetable_t new, uint64 sz) &#123; pte_t *pte; uint64 pa, i; uint flags; char *mem; int szinc; for (i = 0; i &lt; sz; i += szinc) &#123; // super page case if ((pte = l1walk(old, i, 0)) != 0 &amp;&amp; PTE_LEAF(*pte)) &#123; szinc = SUPERPGSIZE; if ((*pte &amp; PTE_V) == 0) panic(\"uvmcopy: page not present\"); pa = PTE2PA(*pte); flags = PTE_FLAGS(*pte); if ((mem = superalloc()) == 0) goto err; memmove(mem, (char *)pa, SUPERPGSIZE); if (mapsuperpages(new, i, SUPERPGSIZE, (uint64)mem, flags) != 0) &#123; superfree(mem); goto err; &#125; &#125; // regular page case else &#123; szinc = PGSIZE; if ((pte = walk(old, i, 0)) == 0) panic(\"uvmcopy: pte should exist\"); if ((*pte &amp; PTE_V) == 0) panic(\"uvmcopy: page not present\"); pa = PTE2PA(*pte); flags = PTE_FLAGS(*pte); if ((mem = kalloc()) == 0) goto err; memmove(mem, (char *)pa, PGSIZE); if (mappages(new, i, PGSIZE, (uint64)mem, flags) != 0) &#123; kfree(mem); goto err; &#125; &#125; &#125; return 0; err: uvmunmap(new, 0, i / PGSIZE, 1); return -1; &#125;","categories":[{"name":"公开课","slug":"公开课","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"MIT-6.S081","slug":"公开课/MIT-6-S081","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/MIT-6-S081/"},{"name":"Labs","slug":"公开课/MIT-6-S081/Labs","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/MIT-6-S081/Labs/"}],"tags":[]},{"title":"探索日志[3]","slug":"others/thoughts/探索日志3","date":"2025-10-27T13:56:16.000Z","updated":"2025-10-28T02:14:10.603Z","comments":true,"path":"wiki/others/thoughts/探索日志3/","permalink":"http://rinevard.github.io/wiki/others/thoughts/%E6%8E%A2%E7%B4%A2%E6%97%A5%E5%BF%973/","excerpt":"","text":"书接上上上回（探索日志[0]），今天和上上次参加 Ludum Dare Compo 结识的朋友一起吃饭了，难道说我就要失去社恐属性和宅属性了吗！ 总之就是他这几天来北京玩，我就鼓起勇气问他要不要来找我玩（其实很大程度上是为了水一篇探索日志，探索日志驱动探索），然后今天就一起吃了披萨薯条炸鸡。 感觉自己宅的很大原因是互联网太有趣了。今天也没有和他一起到处玩（根据我的经验和想象，人们一般是会在相聚时去一些地点闲逛的），而是在饭店边吃饭边玩游戏顺便闲聊。咱还给他试了试最近做的新原型（探索日志[2]，感觉探索日志的相互引用都可以变成节点图了），感觉还不错。然后我们就在饭店待了两个多小时，直到他去赶高铁回学校。 我还蛮喜欢这样的交流的，果然还是要主动去和别人结交才行。好耶，这又是一个水探索日志的机会。等我下次 gamejam 看到喜欢的游戏就去找作者加好友，成功了就水一篇，失败了也能水一篇。当然，如果只是把范围局限在游戏领域也太狭窄了，不过等我水完再说吧。 为什么酒店叫酒店呢，它在字面上看起来很像饭店，却是居住的地方。我上网搜了一下（如我所言，互联网太有趣了），这是因为它是从 “Hotel” 翻译过来的。对清末的中国上层社会，”Hotel” 的第一功能是饮宴，而非住宿。传统中国贵人出行都带着仆人，所以 “Hotel” 的小间对他们并不是住宿的地方，而只是聚宴的地方，所以被翻译成了“酒店”。 有趣的生活太多了，一个人是体验不过来的，所以要认识更多的经历过有趣生活的人，才能看到更多有趣的体验。 又或许人们只是因为碰巧相遇，才碰巧认识了彼此吧。 当然还是要炫耀一下收到的小卡片的！","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/"},{"name":"碎碎念","slug":"杂谈/碎碎念","permalink":"http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}],"tags":[]},{"title":"探索日志[2]","slug":"others/thoughts/探索日志2","date":"2025-10-27T13:56:15.000Z","updated":"2025-10-28T02:16:47.945Z","comments":true,"path":"wiki/others/thoughts/探索日志2/","permalink":"http://rinevard.github.io/wiki/others/thoughts/%E6%8E%A2%E7%B4%A2%E6%97%A5%E5%BF%972/","excerpt":"","text":"陪跑了 Supercell 举办的 Global AI Game Hack. 虽然感觉自己做的游戏并不比获奖作品差，但无所谓了，我做出了自己满意的作品。 只是陪跑是称不上探索的（又不是第一次陪跑了）。这次主要是尝试做了以前构思过，但感觉“这根本做不到！”的作品，而且还做出来了。 我们该怎样做一个基于 LLM 的游戏？我的第一个答案是牌生万物，这是一个把卡牌放到一起让 AI 基于堆在一起的卡牌讲故事的游戏。一些试玩的玩家还挺喜欢这个游戏，不过介于 AI 很难写出有意义的故事，我简单改了改就没有继续做下去了（现在它叫做《西行牌录》）。 让我们回到之前的问题，我们该怎样做一个基于 LLM 的游戏？我们当然会想，如果让每个 NPC 都由 LLM 驱动，这个世界就会有无穷的可能性。这是我一开始就反对的答案。我认为 AI 回复的信息密度太低，还会胡编乱造，没有任何意义。更何况两个 AI 之间聊了几句就会开始相互复读了。不过后来玩到了一个 AI 会相互交互聊天的游戏，亲身进入一个 NPC 有自己的生活的游戏感觉超酷！当然我还是不认为这个东西有什么拓展空间，不过确实挺酷的。 那这次我的答案是什么呢？我想带来尽可能多的可能性，让玩家能做到他们能想到的大部分事情。以前我玩到过允许自定义规则的 LLM 游戏，但作者的实现方法是让 LLM 拼凑一堆预制的规则组件，于是经常出现“我想要这个规则但 AI 写不出来”的情况。因此我想，如果要真正做到尽可能多的可能性，就只能把整个游戏状态都交给 LLM 管理。 听上去就做不到不是吗？我想出这个想法时也感觉“这根本做不到！文字就算了，动画怎么办？还有更多更多的东西怎么办？”，因此没有去做。但如上文所言，我在这次 hackathon 试着做了这个想法（为什么它不叫 gamejam 而叫 hackathon 呢，明明是做游戏…）。 我见过的许多游戏设计资料都告诉我，“原型是很可能失败的，找到失败之处就是原型制作的目的。”但你我皆知我们都有对失败的恐惧。在面对一个看上去就做不到的概念时，我对“实现这个概念”的预期就是失败，即使是这样也要做下去吗… 即使是朝着失败也要做下去吗？几周前参加的 Ludum Dare 还提前一天出结果了，撞上了这个 hackathon 的开头，我也没拿到满意的成绩。即使是这样也要做下去吗？我是不是根本做不出有趣的游戏？ 我看向了 Jeremy Ryan，Hope Falters 的作者（这是我最喜欢的游戏之一），想看看 ta 在最开始时做出的作品是怎样的。我看向了一些别的我喜欢的作者，想看看他们在最开始时做出的作品是怎样的。我看向了一些做了很久游戏但做的还是很糟糕，但还是在做游戏的作者。我看向了几个年龄小于我，排名也小于我的作者。即使是这样也要做下去吗？ 无所谓了，即使是这样也要做下去。而如开头所言，陪跑了。 但至少我的朋友在玩了我的游戏以后发出了“这居然会陪跑吗”的声音，至少在试玩时几个玩家都挺喜欢的，这就好了。 嗯，即使要放弃，也要等到大家都不喜欢的那天吧。 给这个游戏剪辑的笨蛋小视频，可能不符合文章氛围，慎点：https://youtu.be/P-J1xkifbYA 说完情绪上的挣扎了，不妨再来聊聊设计。你知道的，我一直都喜欢随便聊聊游戏设计上的东西。 在得到了“把整个游戏状态都交给 LLM 管理”这个概念后，我脑海中就呈现出了这个游戏现在的样子——让玩家组合词汇来创造魔法，LLM 解析魔法并改变场面。不过我感觉自己以前的设计都是除了概念一无是处的设计，所以这次想试试之前看到的“注重外围设计”的做法。 据我理解，外围设计就是在核心概念之外做一些设计来呈现这个概念的可能性。比如说俄罗斯方块的概念可能是“凑满一行就消除”，外围设计就是不同形状的积木。如果积木只有正方形和长条，游戏也能工作，但就没有现在这么丰富的可能性了。 这次我做的外围设计包括用于掩饰生成速度较慢的 TTS 旁白、一些手动设计的高概念词汇。 写到这里突然有些疑惑。既然在得到了这个“LLM 管理游戏状态”的概念后我就想出了这个游戏现在的样子，那我为什么会感觉“这根本做不到”呢？我不知道，可能只是恐惧失败吧。 《游戏设计艺术》向读者发出的最后一个问题是：“为什么我要做现在在做的事”。贯彻一个主题的作品会变得更加有力，我们每个人也都有自己的主题。那么我为什么要做游戏，我的主题又是什么？我会寻找答案。","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/"},{"name":"碎碎念","slug":"杂谈/碎碎念","permalink":"http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}],"tags":[]},{"title":"如何在七天内制作游戏原型","slug":"others/translation/七天原型","date":"2025-10-15T13:47:11.000Z","updated":"2025-10-15T14:10:39.846Z","comments":true,"path":"wiki/others/translation/七天原型/","permalink":"http://rinevard.github.io/wiki/others/translation/%E4%B8%83%E5%A4%A9%E5%8E%9F%E5%9E%8B/","excerpt":"","text":"翻译自 How to Prototype a Game in Under 7 Days 来自四位在一个学期内做了超过 50 款游戏的研究生的心得 作者：Kyle Gabler, Kyle Gray, Matt Kucic 和 Shalin Shodhan 这里有一个疯狂的游戏点子：拖动那些会说垃圾话的粘液球，建造一座越来越高的巨塔。它们蠕动、咯咯笑，并爬上兄弟们的背向上攀爬。但要小心！这是一场与重力的持久战。如果你建造的塔太不稳定，它就会倒塌。 “黏黏世界”在上线数月内下载量超过了10万次，在一本杂志中被誉为“月度网络游戏”，在G4频道和GDC的实验性游戏工作坊上进行了演示，并且是我们在卡内基梅隆大学娱乐技术中心的实验性游戏项目中所制作的五十多款游戏之一。 和其余的游戏一样，它也是由一个人在一周之内完成的。 该项目始于2005年春季，目标是尽可能多地发现新的游戏玩法并给它们做原型。我们四名研究生组成了团队，把自己关在房间里，一个学期都遵守着下面三条规则： 每个游戏必须在七天内完成， 每个游戏必须由一个人完成， 每个游戏必须基于一个共同的主题，例如“重力”、“植被”、“蜂群”等。 随着项目进行，我们对蜂拥而至的流量、游戏杂志的关注以及行业专业人士和学者们都问着的同样的问题感到惊讶和激动：“你们是如何这么快地制作这些游戏的？”以及“我们该怎么做？” 我们在这里将一切全盘托出。结合以下的建议、技巧和例子，我们将讨论那些有用的和没用的方法。我们将向你展示如何进入快速原型制作的思维状态，如何组建一个高效的团队，以及如果你想过创造新东西但不知从何下手时应该从哪里开始。我们希望这些经过认真验证的指南对你的下一个项目，无论大小，能派上用场！ 为了便于阅读，本文的建议和技巧会被分为四个部分：准备、设计、开发和通用的技巧。祝你阅读愉快！ 准备：快速是一种心态快速原型不仅是前期制作中的一个有用工具——它还可以成为一种生活方式！本节将展示如何准备并开始像一个快速原型制作者那样思考。 拥抱失败的可能性——它鼓励创造性冒险“风险”对我们的影响太大了。据我们所知，对失败的恐惧是电影IP改编游戏和续作高达两位数的游戏不断被制作出来的原因。这就像总是选择去麦当劳，而不是一家未曾探索过的新餐厅——总是依赖于一个众所周知的、尚可的选项，而不是冒险尝试未知但可能美味的选择。 一个好的快速原型制作者会知道失败是可以接受的！找到失败之处就是原型制作的目的，所以尽情去做吧！即使你失败了，也还会有无数的机会，而且很可能你总能学到些东西。只有拥抱失败，才可能做出有价值的实验。 Mr. Gray：“《Mime After Mime》和《A Mime to Kill》是我做的两款只有声音没有画面的游戏。尽管它们是彻头彻尾的失败品，但整个团队都为能冒如此大的风险来证明纯音频游戏的失败而感到兴奋，我可以自豪地说它们是我做的。随着我在整个项目中积累经验，我逐渐能进行更有针对性的冒险，它们带来了成功的游戏。” 强制缩短开发周期（更多时间 != 更高质量）你只需要几天时间。有一种很自然的想法是：“我们一周做了一个很棒的游戏。所以如果我们花两周时间，它会好上两倍！”。当然，事实并非如此。我们发现，通常任何游戏点子都可以在不到一周的时间内有效地进行原型设计。多余的时间往往会产生递减的回报。例如，一些原型只用了一个晚上就完成了，而另一些则多花了一两周的时间。令人惊讶的是，我们发现开发时间与游戏最终的成功程度之间没有关联。 对创造的约束让你更想创造我们最成功的游戏都源于特定的主题或“玩具”，比如“重力”、“蜂群”，或者“制作一款主要面向女性休闲玩家的游戏”。不知为什么，在有限制的情况下，创造变得更容易了。 此外，当一个团队的人都围绕一个特定主题同时做原型时，我们都倾向于避免使用那些显而易见的机制。这种挑战让我们去探索并挖掘主题中所有可能的游戏玩法。 在项目后期，我们逐渐偏离了这种模式，这最终对我们造成了损害。没有了主题约束，游戏制作时间更长，方向性更差，团队凝聚力也下降了。那种“我们都在一条船上”的感觉减少了，更糟糕的是，我们失去了那种曾激发额外创造力和技巧的友好竞争感。 我们探索过的一些主题有：“重力”、“弹簧”、“进化”、“声音”、“捕食者与猎物”、“令人上瘾的游戏”、“绘画”、“指数增长”、“植被”、“平衡”，以及其他一些个人主题。 组建一支优秀的团队和一位客观的顾问——心态与才华同等重要团队中的每个成员都必须熟悉游戏开发的所有方面。每个人都负责自己的编程、美术、声音以及最终产品中的其他一切。但能力并非一切。理想情况下，每个人都必须以这样的理解来对待这种开发方式：设计是至高无上的——从美术到工程的一切都只是为最终设计服务。一个深谙此道的平庸工程师很可能比一个没有这种心态的优秀工程师更成功。 项目顾问 Jesse Schell 说：”我一直痴迷于产生新游戏创意的过程，所以当 Shalin、Matt 和两位 Kyle 提出这个项目时，我自然感到非常激动。我把它看作一个在创造力方面进行对照实验的机会，并希望能学到有用的游戏设计知识。作为指导老师，我努力确保团队尝试多种不同的技术、从错误中学习、不在行不通的想法上纠结太久，并努力保证每个人都在寻找最适合自己的创作过程。” “我对如何改进游戏提出过一些建议，但大多数时候我尽量不干涉。我感觉自己有点像个园丁——我做了一些浇水和除草的工作，但开花结果全靠他们。正如这篇论文所示，团队能够得出一些非常有用的结论——并且最终做出了一些好游戏！关于创作过程的优化还有更多东西需要学习，卡内基梅隆大学娱乐技术中心计划继续进行这个项目。” 并行开发以最大化效果那么，一旦我们组建了团队，我们做了什么？我们各自独立工作！这听起来可能很奇怪，但独立工作的好处实在太大了，不容忽视： 缓解风险：通过同时开发四个原型，我们可以在做出冒险的设计决策时感到安心，因为至少有一两个可能会成功。 友好竞争：每个人都因只专注于自己而受益。就像资本主义一样！ 更广泛的主题探索：我们四个人都专注于同一个主题，这迫使我们深入思考主题。如果我们都做了一样的游戏，那该多尴尬啊！这迫使我们进入一些有益的创作领域，并让我们避免了显而易见的切入点。 分享与关怀：虽然我们没有共享代码（可以共享也可以不共享），但我们发现分享概念和理解很有帮助。例如，如果一个团队成员发现了一种表示弹簧系统的有效方法，每个人都会受益。 随着几周过去，我们发现团队合作在每个周期的开始和结束时最有价值。在每个周期开始时，团队合作有助于提炼和比较想法。一旦进入开发阶段，我们发现合作更多是一种干扰——因为每个人都完全沉浸在自己的工作中。到每个周期结束时，我们会回到房间里一起工作到凌晨，体验竞赛快结束的感觉。这种合作价值随时间变化的图表可能像这样： 设计：头脑风暴的神话和创造力一个好点子可能在瞬间产生，但等待点子可能是一种煎熬。没有办法强迫一个好点子迸发出来，但这一部分内容应该能帮助你培养你的创造力。 正式头脑风暴的成功率为 0%我们真的很努力了——天呐，我们真的希望头脑风暴能奏效！我们安排了“头脑风暴会议”和“圆桌会议”，我们用不同颜色的记号笔在白板和超大便利贴上写画，我们甚至用了像“蓝天”这样的激励性短语来帮助我们摆脱思维定势。但最终，在我们创造的所有游戏中，没有一个是通过大家坐在一起进行头脑风暴会议得出的结果。 为什么会这样？我们也非常震惊。但经过一番调查，我们发现创造力确实是无法规划的。你不能说：“大家4:15开个会头脑风暴一下，到5:00我们就能拿出四个超棒的游戏点子！” 但头脑风暴并非无用。通过精心组织头脑风暴会议，我们仍然可以期待（至少）两件合理的事情。第一，当然是让所有人都开始思考。在开始思考后，过了一会儿，或许在回家的路上，或许在洗澡时，又或许在遛狗时，一个绝妙的点子会在你的脑海中迸发出来。当然，也或许不会。但据我们所知，神秘的大脑在我们最不经意间做了大量的思考。 第二，当有具体的东西可以讨论时，头脑风暴就有用了。比如，“我们如何改进这个？”比“让我们随便想点什么！”更好。又如，给出一个半成形的点子并让其他人来充实它是相当有用的。比起创作者，人们更适合当评论家，不是吗？ 收集概念艺术和音乐以创造情绪目标作为头脑风暴的替代品，我们发现收集一些具有个人意义的艺术和音乐特别有用。人们评论说，许多游戏如“Gravity Head”和“On a Rainy Day”创造了引人入胜的氛围并具有强烈的情感吸引力。这不是偶然的。在许多情况下，配乐和初期美术共同创造了一种感受，推动了玩法、故事和最终美术的设定。 Mr. Gabler：“《黏黏世界》的想法是我在回家路上听 Astor Piazzolla 的《Tango Apasionado》开头时产生的，我脑海中浮现出一个日落时分小镇的朦胧景象，每个人都离开家，搬出椅子、桌子和任何他们能找到的东西，在市中心建造一座巨塔。我不知道确切原因，但他们想往上爬，再往上爬——但他们不是很好的土木工程师，所以你需要帮助他们。最终的原型变得更欢快一些，我把音乐换成了 Piazzolla 的更欢快的《Libertango》。这是一个初始情绪目标造就了整个游戏的例子。” 在脑中模拟——做原型的原型这真的很简单！你要做的就是想象你的游戏玩家说：“哇！”然后倒推并填补空白。是什么让他们享受你的游戏？他们感受到了什么？游戏中是什么让他们有了这种体验？ 对我们的那些最成功的游戏来说，我们并不对它们变得好玩感到意外——在最好的情况下，我们在接触任何一行代码之前就知道这个想法是靠谱的，因为我们已经在思维里模拟过了游戏。反之亦然，没有一个游戏是出乎意料地成功的，我们总是先知先觉。（可惜的是，这并没有阻止我们去追求那些半生不熟的想法。） 在你的脑海中模拟也使得最终原型的开发变得非常容易，因为你会确切地知道你将要做什么。你不会为了在设计上“试错”浪费时间修改代码。 一位团队成员承认：”我经常在一周的前3、4天里，只是为了’灵感’而闲逛看 O-Zone 音乐视频、倒挂在懒人沙发上听音乐、偶尔运行一些糟糕的大脑模拟。最后周四或周五来临时，我会感到恐慌，因为我仍然不知道周一要交什么，所以我就会采纳最强的那个想法，并根据本周自己喜欢上的东西进行调整，直到感觉像一个有趣的游戏，然后接下来几天熬夜写代码和画画。对我来说（我想对我们所有人来说），花在’前期制作’上的日子无疑比花在实际开发上的日子更有价值。” 开发：没人知道你是怎么做的，也没人在乎一旦你有了一个好点子，这里有一些技巧可以让你迅速做出一个 demo！ 先做玩具从核心机制开始。无论是弹簧系统、群体行为、重力等等，花不了几个小时就能把游戏主题做出来。这个“玩具”应该是游戏的核心机制。它不需要任何目标或决策，没有输赢，只是一个好玩的东西。 Mr. Gabler：“对《Super Tummy Bubble》来说，‘玩具’只是一堆悬浮在小容器里的泡泡。我玩了一会儿这个玩具，把泡泡扔来扔去，然后调整了一下直到我感觉手指戳进泡泡里很有趣。之后，是时候加入一些游戏性了。在这个游戏里，游戏性包括寄生着不同虫子的泡泡、‘戳破’的概念、‘连锁’的概念、分数计数器等。” 如果能偷懒，那就偷懒这可以说是这个项目最重要的教训之一。通常“正确”的解决方案并非最佳解决方案。有策略地偷懒会为你节省时间和金钱；它会让你的游戏更快，你的牙齿更白。大胆地、经常地偷懒！如果一个简单的阴影和烘焙纹理同样有效，就不要设置复杂的光照和阴影（《Darwin Hill》）。如果你可以用同样的效果蒙混过关，就不要为了分析用户的绘画而设置复杂的模式识别系统（《Suburban Brawl》）。当快速拉伸的位图能更快更容易地达到同样效果时，就不要绘制样条曲线或创建自己的矢量艺术库（《黏黏世界》）。我们发现，这条规则也是生活中一条极好的通用法则。懒人们，注意了。 及时止损，割舍心头之爱在项目开始时，我们有一种想要挽救一切的愿望——再多花一点时间和精力，一个糟糕的游戏肯定会变成天才之作！我们有一个这样的注定失败的原型——它始于一个美丽的弹簧系统。它能挤压和拉伸，让你想抓住它并到处拉扯，但它就是没有变成一个引人入胜的游戏。最初的弹簧系统机制只花几个小时就创建好了，但随后它却耗费了整整一周的编码和重构时间。这是一次可悲的尝试，试图强行将这个机制变成一个游戏。 快速识别走不通的想法、及时止损并继续前进非常重要。我们发现，顺其自然比花时间试图挽救现有的东西更有价值。如果以后灵光一闪，你总可以再回来。 Mr. Kucic：“我的‘土豆’最终成为了一个在 Flash 中构建的完美的软体模拟系统，唯一的问题是它一点也不好玩。它给我带来的头痛比死亡金属还多。我浪费了一周时间，而它甚至都不能动。你得知道什么时候该继续，什么时候该放弃。” 漂亮的包装无法挽救糟糕的设计（或者说，“烂泥扶不上墙”）我们发现游戏玩家比你想象的要聪明，他们能看穿你是否在耍花招。如果游戏玩法很糟糕，那就没救了——世界上所有的美术、音乐和联动都无法让它成为一个好游戏。这就像是给一个无趣的游戏机制加入最新的3D动画电影角色，没人会被糊弄。 Mr. Gray：“《Spin to Win》的‘游戏玩法’是旋转你的鼠标来转动多个圆圈。为了掩盖它不好玩的事实，我用60年代《Bewitched》风格的艺术和音乐给游戏做了漂亮的包装。但无论我怎么打磨这个游戏，它都有趣不起来。尽管我付出了所有的爱，它还是很快就成了网站上最被讨厌的游戏之一。” 但整体美学很重要！合理运用美术、音效和音乐这实际上与我们最初的一个假设相反。我们当时认为美术和音效根本不会对原型有影响，但我们错了！玩一个精心打磨的游戏实际上比玩有着完全相同的代码，但艺术粗糙、音效差的游戏感觉更好。不过，重要的是要做出以下区分——单纯打磨美学无法挽救糟糕的设计，但它确实有能力让一个好游戏变得更好玩。这并不意味着你需要极其精美的图形或环绕声。这只是说你可以通过将所有东西紧密结合起来而受益。记住，即使是“蹩脚”也可以是一种紧密结合的美学，只要你以正确的方式呈现它。 没人关心你的代码质量再次强调，值得注意的是，一个伟大的工程师不一定能成为一个伟大的原型制作者。”正确”和”可复用”的方案通常不是我们在快速、一次性代码中所寻求的。对于每个问题，你应该能够想出一大堆解决方案，并选择那个能最快做完的方案。用户永远不会看到你伟大的代码，他们也不在乎。 Mr. Shodhan：“代码的过度设计很容易让我们做出一些通用工具或技术演示，但他们并不可玩。这就像是一个摇滚明星沉浸在自己的艺术中，而观众在打哈欠！对‘进化’那个主题，我用细分曲面和卡通渲染效果做了一个程序，通过杂交祖先树来进化3D模型。这里有很多很酷的技术，但完全没有游戏性！” 通用的技巧：关于营造多汁乐趣的教程除了在原型制作方面吸取了惨痛的教训外，我们还偶然发现了一些通用的准则。以下是一些显著增加“乐趣”的准则。 复杂不一定有趣如果人类以“球和平面”这个主题的变体来娱乐自己数千年，我们可能在这些新奇的视频游戏上做得太过头了。我们完全可能用基本的元素来获得乐趣。想想《俄罗斯方块》、《吃豆人》以及任何经典的街机游戏。就像罗密欧与朱丽叶的爱情故事原型一样，这些游戏的机制如此之好，以至于几十年后我们仍在使用它们。镜头光晕、凹凸贴图、泛光和其他惊人的新技术是不错，但它们不会让你的游戏更有趣。用一个简单的原型向自己证明你的核心机制值得一做，在你确信之后，把它变得漂亮。 创造一种拥有感来让玩家不断重玩我们偶然发现，最具重玩价值的游戏是那些与创造或自定义相关的游戏。例如，“用手和雨伞制作一棵令人毛骨悚然的树”，或者“画你自己的房子”，或者“建造你自己的塔”，或者“进化你自己的突变生物种族”。显然我们能在许多地方中见到这种现象——游戏里的捏脸功能、自定义的手机铃声、乃至那些“与众不同，表达自我”的广告。所以，跳上这趟潮流吧！创造一种拥有感，让他们不断重玩。 “实验性”不意味着”复杂”在项目早期，我们制作的许多游戏都太过复杂。它们的用户界面令人困惑，而且按键映射到的动作也不自然或不直观。除非我们能最小化玩家理解游戏之前的疑惑时间，否则玩家会感到沮丧，再也不玩这个游戏，甚至再也不来我们网站。幸运的是，我们发现既可以做到”实验性”，又可以保持易于理解。 Mr. Shodhan：“我的第一轮游戏‘Spaceball Munch’是老游戏‘Gorillas’的3D版本，在那个游戏里，你指定一个角度和速度，让一个猩猩向另一个猩猩扔香蕉。现在你不仅在3D环境中，更是用着弧形视角，还在一个球形场地上进行游戏。所以你要考虑两个角度和一个速度。另外，它现在也不再是一个离散的回合制游戏，而是需要控制一个连续的粒子流，同时必须击中所有这些移动的物体。这张截图展示了这种毫无意义的复杂度” 朝着一个明确定义的目标前进人们很容易忘记设置一个明确定义的目标。没有游戏目标，一个原型就只是一个玩具，而不是一个游戏。出于某种原因，人们似乎喜欢有失败的机会。一个目标可以是任何事情——比如“在x时间内收集x个小部件”，或者“保持系统稳定”，或者“在不碰到任何坏东西的情况下穿越一个空间”。但找到一个不让人觉得牵强的目标还是很难的（比如时限一般就很牵强）。我们发现，最好的目标是游戏玩法中固有的部分，比如在《黏黏世界》中，隐含的目标就是简单地“向上建造”。 让它多汁！多汁（Juicy）是我们用来形容持续且丰富的用户反馈的术语。一个多汁的游戏元素在你触摸它时会弹跳、扭动、喷射并发出一点声音。一个多汁的游戏很活泼，它对你做的每件事都有反应——一点点输入就会产生大量的回应和连锁反应，这让玩家感觉自己掌控着世界。它也在互动时不断让玩家知道自己正在做什么，引导他们了解游戏规则。 你可能经历过的一些多汁的例子可能包括： 《Alien Hominid》：非常夸张的敌人爆炸和血液飞溅。 《马里奥兄弟》：在一个充满金币的房间里弹跳，叮当声很让人满足。 弹珠机：一股永无止境的球流全在你的控制之下。 《超级方块战士2 Turbo》：连击时，动画和特效层出不穷。 最后的想法这次关于实验性游戏项目的团队合作是一件非常愉快的事。我们希望下次当你尝试一些新的或有点疯狂的东西时，这些建议和技巧能对你有所帮助。谁知道呢，你今天早上有的那个小想法可能就是下一个神作。召集一些朋友或者单干，快去尝试并制作原型吧！你可能会给自己一个惊喜。 我们的顾问友好地指出，“快速原型可能很像怀一个孩子。没人指望每次都能赢，但你总是学到新东西，而且这通常很有趣！” 祝你原型制作愉快！ 此页面转载自 Gamasutra 网站：http://www.gamasutra.com/features/20051026/gabler_01.shtml 便捷清单！ 准备：快速是一种心态 拥抱失败的可能性——它鼓励创造性冒险 强制缩短开发周期（更多时间 != 更高质量） 对创造的约束让你更想创造 组建一支优秀的团队和一位客观的顾问——心态与才华同等重要 并行开发以最大化效果 设计：头脑风暴的神话和创造力 正式头脑风暴的成功率为 0% 收集概念艺术和音乐以创造情绪目标 在脑中模拟——做原型的原型 开发：没人知道你是怎么做的，也没人在乎 先做玩具 如果能偷懒，那就偷懒 及时止损，割舍心头之爱 漂亮的包装无法挽救糟糕的设计（或者说，”烂泥扶不上墙”） 但整体美学很重要！合理运用美术、音效和音乐 没人关心你的代码质量 通用的技巧：关于营造多汁乐趣的教程 复杂不一定有趣 创造一种拥有感来让玩家不断重玩 “实验性”不意味着”复杂” 朝着一个明确定义的目标前进 让它多汁！","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/"},{"name":"翻译","slug":"杂谈/翻译","permalink":"http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/%E7%BF%BB%E8%AF%91/"}],"tags":[]},{"title":"Lab 2.1 系统调用流程——以sleep为例","slug":"learning/open-course/MIT-6.S081/Labs/lab2_1-syscall_process","date":"2025-10-15T08:02:38.000Z","updated":"2025-10-19T03:44:03.330Z","comments":true,"path":"wiki/learning/open-course/MIT-6.S081/Labs/lab2_1-syscall_process/","permalink":"http://rinevard.github.io/wiki/learning/open-course/MIT-6.S081/Labs/lab2_1-syscall_process/","excerpt":"","text":"我们知道应用程序在User mode下运行，而系统函数的执行需要Supervisor mode，那在系统调用时，User mode是怎么进入Supervisor mode的呢？我们以sleep的执行为例，看看都发生了什么。首先我们用 git checkout util 切换到 util 分支上。 在此之前，我们要先简介一下ECALL指令和stvec（Supervisor Trap Vector Base Address Register）寄存器。 ECALL 会触发一个异常，如果我们在用户态触发这个异常，程序计数器 pc 就会根据 stvec 进行跳转，到达异常处理处。 以下是 risc-v 手册 对 ECALL 的解释： When executed in U-mode, S-mode, or M-mode, it generates an environment-call-from-U-mode exception, environment-call-from-S-mode exception, or environment-call-from-M-mode exception, respectively, and performs no other operation. 如果在 U-mode 执行，ECALL 指令会产生一个来自 U-mode 的环境调用异常；如果在 S-mode 执行，则产生来自 S-mode 的环境调用异常；如果在 M-mode 执行，则产生来自 M-mode 的环境调用异常。 以下是 risc-v 手册对 stvec 寄存器的简介： BASE是4字节对齐的（RISC-V 手册 P80），所以在MODE == 0时，我们跳转到的地址是 (stvec &gt;&gt; 2) &lt;&lt; 2，而由于 MODE == 0，这个值就是 stvec ；在MODE == 1时，我们转到的地址是 (stvec &gt;&gt; 2) &lt;&lt; 2 + 4*cause 接下来我们就可以开始看看系统调用时究竟发生了什么！我们会以sleep为例。 首先我们打开gdb-multiarch（参考 Note 0 的”用终端调试“），然后用 set prompt \\\\001\\\\033[1;33m\\\\002(gdb) \\\\001\\\\033[0m\\\\002 来高亮 “(gdb)” 以方便观察自己的输入。 用 file user/_sleep 切换到用户符号表，接着用c运行到xv6的shell启动。 观察右边的终端可以看到shell已经成功启动了。 然后我们在gdb里按下ctrl+c来中断，并用 b main 设置断点，再使用 layout split 让gdb显示出源码和汇编代码。接下来我们在gdb里输入 c 以让xv6继续执行，否则xv6的shell会处于暂停状态，不能处理输入。 然后在xv6的shell里执行 sleep 1 ，它会在断点处停下。 观察左边的gdb，可以看到它停在了sleep.c的main函数。 随便执行一下直到到达sleep这行，n 表示执行一行c语言，si表示执行一个汇编语句。 我们用si进入atoi，然后交替着用n和si，在快到return时用si，就能离开atoi回到sleep.c。 观察左边的gdb，和上图相比，虽然c语言的位置没有变化，但汇编代码的位置是有变化的。 之后用si，会发现我们跳转到了 usys.S，它把sleep的系统调用号放到寄存器a7里，然后借助ecall来执行系统调用。 观察左边的gdb发现我们已经进入了usys.S 如果我们直接用几个si，会发现ecall并没有像jal之类的跳转语句一样带我们到一些神奇的地方，而是直接到了下一行。这是因为ecall不是跳转，而是抛出了一个异常，内核自动处理了异常。 这样看来，我们要找到这个异常的开始处并设置断点才行。还记得我们之前说过ecall抛出异常时pc会跳转到哪里吗？答案是它会根据寄存器stvec的值进行跳转。让我们借助p /x $stvec看看stvec的值。 观察左边的gdb，发现stvec的值是 0x3ffffff000，至少在我这里是这样。 回顾一下stvec寄存器的结构和功能，会发现执行ecall后，pc会跳转到BASE所在的地址。我们之前说过，BASE是4字节对齐的（RISC-V 手册 P80），所以在MODE == 0时，我们跳转到的地址是 (stvec &gt;&gt; 2) &lt;&lt; 2，而由于 MODE == 0，这个值就是 stvec。 我们接下来把断点设置在这个值，然后用si到达ecall语句处 观察左边的gdb，我们现在已经在ecall这里了。 如果我们的操作正确，接下来的si会触发一个异常导致我们跳转到 0x3ffffff000 并触发断点，希望我们没有翻车~ 观察左边的gdb，发现我们成功跳转到了一个未知的地方！ 按我的理解，由于我们在U-mode下执行ecall以触发异常，所以我们现在已经进入了S-mode。不过我翻了很多资料还是没有找到能明确支持这一点的证据（也没有找到明确反对的证据），所以我保留我的观点。 总之一切顺利！让我们暂停一下，想想这个 0x3ffffff000 的地址代表什么。在内核启动时通过file kernel/kernel 加载内核符号表并在usertrapret设置断点，我们可以发现 0x3ffffff000 这个地址和 kernel/trap.c 里的trampoline_uservec 相等。 trampoline是什么？trampoline是在进程虚拟内存的顶部的一块空间，映射到的物理地址存放着跳转进和跳转出内核的代码。看起来在做系统调用时，我们通过ecall跳转进内核。这样一切都说得通了~ 让我们打开trampoline.S，对比左边gdb显示的代码和右边的trampoline.S，会发现它们确实能对上！ 好吧，也不是完全能对上，你会注意到右边的 li a0,TRAPFRAME 在左边似乎对应了三条语句，这是怎么回事呢？实际上，li 是RISC-V 汇编中的伪指令，实际执行时，li 会被汇编器翻译为一条或多条真正的 RISC-V 指令。 嗯，这样就能对上了！ 读一读trampoline.S，我们发现它会把用户进程的寄存器等信息保存到trapframe里，然后跳转到内核的usertrap函数。 因此接下来我们要用file kernel/kernel把符号表切换到kernel，再用si n 来一次执行多条汇编语句，直到指令jr处： 比较左边和右边，发现它们的汇编代码确实能对上，接下来我们要准备跳转了。 陷阱，启动！ 如果你发现你的gdb没有顺利显示出c语言代码，可能是你忘记切换符号表到内核了，用file kernel/kernel来切换，然后补一个si就能显示出来了。 由于一切正常，我们可以一路按n直到到达syscall这里。 比较左边和右边的代码，它们是能对应上的。接下来让我们准备进入syscall 我们用s进入syscall函数。n和s都会执行当前行，不过如果当前行是函数，n不会进入函数，而s会。 syscall函数从trapframe中取出系统调用号，然后调用它。还记得吗，我们调用系统函数时先进入了usys.S，然后把系统调用号保存到了a7。之后由于我们转入了内核，我们在trapoline.S里把所有的用户空间的寄存器都保存到了trapframe中。 总之我们在这里调用了sys_sleep，我们进入它看看。 可以发现它就是真正干活的地方！它非常忠实地执行了sleep的逻辑。 我们可以注意到 n 就是存放着我们最开始传入的参数的变量，内核通过argint来找到我们一开始传入的参数。argint的思路和我们之前找到系统调用号类似，也是从trapframe中找到存放着传入参数的寄存器。 让我们继续往后，看看在执行完逻辑以后发生了什么吧。 回到usertrap，我们一路往下到达usertrapret，然后用s进入它。 看函数名上面的注释就能发现它会带我们回到用户空间。 我们用n一路运行到底，再看看注释，发现注释说我们会跳转到trampoline.S。 观察左边的gdb，p /x trampoline_userret 没有打印值是因为trampoline_userret被编译器优化掉了，我们要手动把它的表达式写出来再打印，总之我们打印出了 0x3ffffff09c。 在那里设个断点，然后准备继续。 多按几个si 到达跳转语句处，不出意外的话再用一次si 就会带我们进入trapoline.S的userret部分了。 一切的一切都符合预期，我们成功进入了trampoline.S。 对比左右的汇编代码可以发现它们是对应的。与之前相同，li被展开了。 然后我们一路按si到达sret语句处。sret会做什么呢？让我们看看riscv手册： The SRET instruction is used to return from a trap taken into S-mode. […] When executing SRET, the privilege level is set to the value in the SPP field of the sstatus register; […] the pc is set to the value stored in the sepc register. SRET 指令用于从进入 S-mode 的陷阱中返回。[…] 当执行 SRET 时，特权级别被设置为sstatus 寄存器中 SPP 字段的值；[…] 程序计数器 pc 被设置为存储在 sepc 寄存器中的值。 我们借助 p /x sepc 打印这个寄存器的值看看~（请忽视左图里我之前写成spec的手误） 0x342是什么？如果你记忆力很好的话，会发现它恰好就是usys.S里的ret那行！ （这鬼才记得住啊喂） 总之我们看看之前的截图吧，我们可以发现0x342确实是ret那行，就是下面的截图中高亮的汇编代码下面那行。 我们用b *0x342设个断点在那里，然后执行si ，我们回到了用户空间！同时，sret也让我们回到了U-mode。 用file user/_sleep切换符号表，再执行si，我们回来了。 至此，我们就完成了一个完整的系统调用。 总结一下，当我们进行系统调用时，我们先进入usys.S，然后ecall触发异常并跳转到trapoline.S的uservec处，之后到达trap.c的usertrap函数，它会调用syscall函数以执行系统函数的逻辑，执行完后进入usertrapret函数，再跳转到trapoline.S的userret处，最后回到usys.S，再回到用户的代码里。 第一次跳转到trapoline.S主要是保存了用户的各个寄存器到trapframe，第二次跳转是从trapframe中恢复了这些寄存器。","categories":[{"name":"公开课","slug":"公开课","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"MIT-6.S081","slug":"公开课/MIT-6-S081","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/MIT-6-S081/"},{"name":"Labs","slug":"公开课/MIT-6-S081/Labs","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/MIT-6-S081/Labs/"}],"tags":[]},{"title":"Lab 2 System calls","slug":"learning/open-course/MIT-6.S081/Labs/lab2-syscall","date":"2025-10-15T07:54:38.000Z","updated":"2025-10-15T08:10:39.024Z","comments":true,"path":"wiki/learning/open-course/MIT-6.S081/Labs/lab2-syscall/","permalink":"http://rinevard.github.io/wiki/learning/open-course/MIT-6.S081/Labs/lab2-syscall/","excerpt":"","text":"在开始之前，我们回顾一下怎么启动调试模式： 在一个终端里执行 make qemu-gdb ，make qemu-gdb CPUS=1 可以只使用一个核心，比起多线程更便于调试。 在另一个终端里执行 gdb-multiarch kernel/kernel ，进入 gdb 后执行 target remote localhost:26001，这里的端口号不一定是 26001，看 make qemu-gdb CPUS=1 的打印结果就行。 这样就进入调试模式了。另外，我习惯用 set prompt \\001\\033[1;33m\\002(gdb) \\001\\033[0m\\002 来高亮 “(gdb)” 这几个字。 Using gdblab 开头让我们熟悉一下 gdb 的使用。启动调试模式以后按部就班就能完成，我们这里记录一下常用的一些 gdb 指令： c 或 continue - 继续执行直到遇到下一个断点 n 或 next - 单步执行,会跳过函数调用 s 或 step - 单步执行,会进入函数内部 si - 执行一条汇编指令 finish - 运行到当前函数返回为止 p &#x2F;x $mstatus - 以十六进制打印CPU当前模式 backtrace（缩写bt） - 显示函数调用栈 set prompt \\\\001\\\\033[1;33m\\\\002(gdb) \\\\001\\\\033[0m\\\\002 - 高亮(gdb) until - 运行到指定行号为止 System call tracing这道题让我们实现一个系统调用，按着 hints 按部就班就能做掉。唯一要注意的是在 syscall 里打印 trace 相关的内容时要把系统调用的返回值 ret 从原本的 uint64 转换为 long long，否则对那些可能返回 -1 的系统调用，我们无法正确打印 -1. 在照着 hints 实现之后，看看系统调用是如何进行的也是更有趣的事情。我在 Lab 2.1 系统调用流程——以sleep为例 中写得还挺详细的，这里不多赘述细节。 简而言之，当我们进行系统调用时： 进入由 usys.pl 生成的 usys.S ecall 触发异常并跳转到 trapoline.S 的 uservec 处 到达 trap.c 的 usertrap 函数，它会调用 syscall 函数以执行系统函数的逻辑 系统函数执行完成后进入usertrapret函数 跳转到 trapoline.S 的userret处 最后回到 usys.S 回到用户的代码里。 让我们根据这个流程来看看 hints 的每一步的原因： 把 $U/_trace 加入到 Makefile 中是为了编译时识别到 trace。 在 user.h 里加入 trace 是为了让用户的 trace.c 识别到 trace 这个函数。 在 usys.pl 里加入 trace 是为了让 usys.pl 在生成的 usys.S 里加入 trace 相关的内容，它是我们进行系统调用时的第一站。 在 syscall.h 里加入 trace 是因为我们通过寄存器里存储的整数确定调用的系统函数，很多地方都使用了这个文件里定义的常量。 在 syscall.c 和 sysproc.c 里加入的函数则是实际的逻辑部分，由 syscall 函数调用。 Attack xv6在 xv6 的 syscall 分支上有一个漏洞——进程被回收后，它曾经使用的物理内存不会被重置为垃圾数据，而是保持之前的状态。所以我们可以打破内存隔离，访问别的已经被回收的进程的内存。 我们看向 secret.c，会发现它请求了 32 个物理页大小的物理内存，然后把一串字符放在了某个物理页的开头。所以我们只要在 attck.c 里也请求一些物理页，然后找到这串字符串就行。 我们先请求 32 个物理页然后依次打印出每个物理页开头的一串字符，结果如下： 第 1 页: �� 第 2 页: � 第 3 页: � 第 4 页: �� 第 5 页: � 第 6 页: 0� 第 7 页: � 第 8 页: � 第 9 页: ��&#x2F;cea.ae 第 10 页: @�7�G�������f���13��fv␦3 第 11 页: P�#4��&quot;�����&#96;Bdaa��q�&quot;� �� 第 12 页: �� � attackte 第 13 页: p� 第 14 页: &#96;� 第 15 页: ��� 第 16 页: ��7�G�������f���13��fv␦3 第 17 页: ��very very secret pw is: &#x2F;cea.ae 第 18 页: �� 第 19 页: p� 第 20 页: 0� 第 21 页: 0�� 第 22 页: @�� 第 23 页: P�� 第 24 页: �� 第 25 页: ��� 第 26 页: P� 第 27 页: @� 第 28 页: 0� 第 29 页: � �&amp;�J����lE�&#96;*&amp;�J� 第 31 页: ������?��� 第 32 页: ��� 可以注意到大多数都是乱码，这是因为内存里有非文本的二进制数据，它们不能被当作文本输出。 当然，我们会注意到第 17 页有 “very very secret pw is: /cea.ae”，它与 secret.c 写入的内容唯一的区别是少了 “my very ” 这八个字符。为什么会有八个字符的差异呢？ 看向 kallc.c 的 kfree： void kfree(void *pa) &#123; struct run *r; if (((uint64)pa % PGSIZE) != 0 || (char *)pa &lt; end || (uint64)pa >= PHYSTOP) panic(\"kfree\"); #ifndef LAB_SYSCALL // Fill with junk to catch dangling refs. memset(pa, 1, PGSIZE); #endif r = (struct run *)pa; acquire(&amp;kmem.lock); r->next = kmem.freelist; kmem.freelist = r; release(&amp;kmem.lock); &#125; 结合 struct run 的定义，就能知道 r-&gt;next = kmem.freelist 这句语句是把一个指针放在了输入的物理地址的前八个 bytes 中。这正是之前八个字符的差异的由来。 总结一下，在运行 secret.c 的进程被回收后，其中包含 “my very very very secret pw is: /cea.ae” 的物理页的开头八个 bytes 被指针覆盖，所以只剩下了 “[8 bytes 指针]very very secret pw is: /cea.ae”. 所以我们多请求几个新的物理页然后遍历它们，用前缀 “very very secret pw is: ” 来匹配就行。 我们在文末会更具体地讲讲进程被回收的过程，但先让我们来看看代码： int strncmp(const char *str1, const char *str2, int n); // kalloc.c 的 kfree 函数里把物理页的开头换成了一个指针. // 所以我们丢失了开头的 sizeof(指针) 个字符. const int overwrite_len = sizeof(void *); int main(int argc, char *argv[]) &#123; char *end; char *prefix = \"my very very very secret pw is: \"; int cmplen = strlen(prefix) - overwrite_len; // 遍历新插入的32个物理页 for (int i = 0; i &lt; 32; i++) &#123; end = sbrk(PGSIZE); if (strncmp(end + overwrite_len, prefix + overwrite_len, cmplen) == 0) &#123; write(2, end + 32, 8); exit(0); &#125; &#125; exit(1); &#125; 这里把内容写进文件描述符 2 是因为 attacktest.c 里开了一个管道，运行 attack.c 的进程的文件描述符 2 连接着管道写端，运行 attacktest.c 的进程则在读取管道读端。下面的代码就是把 attack.c 的文件描述符 2 连接到管道写端的代码： if (pid == 0) &#123; close(fds[0]); close(2); dup(fds[1]); char *newargv[] = &#123;\"attack\", 0&#125;; exec(newargv[0], newargv); printf(\"exec %s failed\\n\", newargv[0]); exit(1); &#125; 进程被回收的过程一个进程调用 exit(int) 后会进入 ZOMBIE 状态，但并不立即释放物理内存，而是会唤醒其父进程： void exit(int status) &#123; // 我们在这里省略了很多代码，有兴趣可以自己看 proc.c wakeup(p->parent); p->state = ZOMBIE; &#125; 父进程调用 wait(uint64) 会找到 ZOMBIE 子进程并调用 freeproc 来回收它： int wait(uint64 addr) &#123; // 我们在这里省略了很多代码，有兴趣可以自己看 proc.c struct proc *pp; struct proc *p = myproc(); for (;;) &#123; for (pp = proc; pp &lt; &amp;proc[NPROC]; pp++) &#123; if (pp->parent == p &amp;&amp; pp->state == ZOMBIE) &#123; // Found one. pid = pp->pid; freeproc(pp); return pid; &#125; // Wait for a child to exit. sleep(p, &amp;wait_lock); // DOC: wait-sleep &#125; &#125; freeproc 则又调用 proc_freepagetable 来回收物理内存： // Free a process's page table, and free the // physical memory it refers to. void proc_freepagetable(pagetable_t pagetable, uint64 sz) &#123; uvmunmap(pagetable, TRAMPOLINE, 1, 0); uvmunmap(pagetable, TRAPFRAME, 1, 0); uvmfree(pagetable, sz); &#125; 其中的 uvmfree(pagetable, sz) 就在释放物理内存了： // Free user memory pages, // then free page-table pages. void uvmfree(pagetable_t pagetable, uint64 sz) &#123; if (sz > 0) uvmunmap(pagetable, 0, PGROUNDUP(sz) / PGSIZE, 1); freewalk(pagetable); &#125; 让我们看向 uvmunmap，它获取每一页的物理地址然后调用 kfree： // Remove npages of mappings starting from va. va must be // page-aligned. The mappings must exist. // Optionally free the physical memory. void uvmunmap(pagetable_t pagetable, uint64 va, uint64 npages, int do_free) &#123; uint64 a; pte_t *pte; int sz; if ((va % PGSIZE) != 0) panic(\"uvmunmap: not aligned\"); for (a = va; a &lt; va + npages * PGSIZE; a += sz) &#123; sz = PGSIZE; if ((pte = walk(pagetable, a, 0)) == 0) panic(\"uvmunmap: walk\"); if ((*pte &amp; PTE_V) == 0) &#123; printf(\"va=%ld pte=%ld\\n\", a, *pte); panic(\"uvmunmap: not mapped\"); &#125; if (PTE_FLAGS(*pte) == PTE_V) panic(\"uvmunmap: not a leaf\"); if (do_free) &#123; uint64 pa = PTE2PA(*pte); kfree((void *)pa); &#125; *pte = 0; &#125; &#125; 更细节的释放 trapframe、释放页表我们就不在这里多说了。","categories":[{"name":"公开课","slug":"公开课","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"MIT-6.S081","slug":"公开课/MIT-6-S081","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/MIT-6-S081/"},{"name":"Labs","slug":"公开课/MIT-6-S081/Labs","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/MIT-6-S081/Labs/"}],"tags":[]},{"title":"探索日志[1]","slug":"others/thoughts/探索日志1","date":"2025-10-13T12:11:11.000Z","updated":"2025-10-27T13:34:23.367Z","comments":true,"path":"wiki/others/thoughts/探索日志1/","permalink":"http://rinevard.github.io/wiki/others/thoughts/%E6%8E%A2%E7%B4%A2%E6%97%A5%E5%BF%971/","excerpt":"","text":"不知道人们平常是怎样与他人相识的。许久以前我就在想，自己的社交方式是否有点不太像一般人类🫠🫠咱更偏好那种“大家一起做一件都感兴趣的事情然后渐渐就认识了”的社交方式，但似乎这种做法相对少见，而且我以前也没怎么因此认识到新朋友。 在不短的质疑期后，渐渐地也发现自己也是能用这种方法交到朋友的，至少是能结识人类的。比如说这次的探索日志就和 GMTK Jam 在小红书拉到的美术同学有关（赞美小红书喵 “我对普通的人类没有兴趣。你们之中如果有画画人、音乐人、音效人或者异世界人就来找我吧！”虽然我不是这么拉人的（没人会这么拉人吧！），但总之就是拉到了这位中传的美术同学一起来gamejam，这是八月的事了。 今天鹰角在中传开了个宣讲会，咱作为资深粥粥人当然想去听听看。访客进中传需要找校内同学或老师预约，于是咱就找了这位美术同学然后成功进入中传了。 一般来说故事应该跌宕起伏，比方说我们起码要写写在中传遇到的趣事，然后写写有什么糟糕的地方，然后再华丽收场，不过事情就是很平平淡淡。鹰角的宣讲会很普通，虽然发了点周边但我并没有抽中有趣的奖品，中传的饭比北理的好吃，但好吃得不多。 可我确实从来没有去外校玩的经历，更别说要找外校同学预约才能进的学校了🫠🫠咱能从社恐进化成现在这样能主动拉人组队还能联系别人已经很好了不是吗（） 探索也不是次次有趣，倒不如说探索的结果普普通通才是理所应当的吧。现在是晚上十点五十分，我在良乡大学城北的地铁站没有摆渡车，要骑车回学校了。","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/"},{"name":"碎碎念","slug":"杂谈/碎碎念","permalink":"http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}],"tags":[]},{"title":"Assignment 7 Path Tracing","slug":"learning/open-course/GAMES101/Hw/Hw7-path-tracing","date":"2025-10-10T14:10:44.000Z","updated":"2025-10-10T15:04:14.905Z","comments":true,"path":"wiki/learning/open-course/GAMES101/Hw/Hw7-path-tracing/","permalink":"http://rinevard.github.io/wiki/learning/open-course/GAMES101/Hw/Hw7-path-tracing/","excerpt":"","text":"大致流程这次的作业挺难的。首先我们来对照公式解释一下大致的代码流程： $$\\begin{align*}L_o(p, \\vec{\\omega_o})= &amp;L_e(p, \\vec{\\omega_o}) + \\int_{\\Omega} f_r(p, \\vec{\\omega_i}, \\vec{\\omega_o}) L_i(p, \\vec{\\omega_i}) (\\vec{\\omega_i} \\cdot n) d\\omega_i\\= &amp;L_e(p, \\vec{\\omega_o}) + \\int_{\\Omega_{光源方向}} f_r(p, \\vec{\\omega_i}, \\vec{\\omega_o}) L_i(p, \\vec{\\omega_i}) (\\vec{\\omega_i} \\cdot n) d\\omega_i\\&amp;+ \\int_{\\Omega_{非光源方向}} f_r(p, \\vec{\\omega_i}, \\vec{\\omega_o}) L_i(p, \\vec{\\omega_i}) (\\vec{\\omega_i} \\cdot n) d\\omega_i \\end{align*}$$ 如果点 $p$ 是光源，直接返回其自发光项 $L_e$. 随机采样一个光源方向 $w_s$，根据公式计算 $L_\\text{direct}$. 随机采样一个方向 $w_i$，按轮盘赌决定是否结束弹射。 如果不结束且 $w_i$ 没打到光源，根据公式计算 $L_\\text{indirect}$. 返回 $L_\\text{direct}+L_\\text{indirect}$ 然后放代码： Vector3f Scene::castRay(const Ray &amp;ray, int depth) const &#123; Intersection shade_point_inter = intersect(ray); if (!shade_point_inter.happened) &#123; return Vector3f(); &#125; // ----------------Contribution from emission---------------- if (shade_point_inter.m->hasEmission()) &#123; // Light source doesn't reflect light, so we return here return shade_point_inter.m->getEmission(); &#125; // ----------------Contribution from the light source---------------- Vector3f wo = -normalize(ray.direction); Vector3f normal = normalize(shade_point_inter.normal); Vector3f l_direct = Vector3f(); Intersection light_sample; float pdf_light; sampleLight(light_sample, pdf_light); // If the ray is not blocked in the middle, compute its contribution Vector3f light_normal = normalize(light_sample.normal); Vector3f shade_point = shade_point_inter.coords; Vector3f ws = normalize(light_sample.coords - shade_point); Vector3f direct_ray_origin = shade_point + ws * EPSILON; Ray ray_to_light(direct_ray_origin, ws); Intersection inter_between_light = intersect(ray_to_light); if ((!inter_between_light.happened) || inter_between_light.distance > (light_sample.coords - direct_ray_origin).norm() - EPSILON) &#123; l_direct = light_sample.emit * shade_point_inter.m->eval(ws, wo, normal) \\ * std::max(dotProduct(ws, normal), 0.0f) * std::max(dotProduct(-ws, light_normal), 0.0f) \\ / std::pow((light_sample.coords - direct_ray_origin).norm(), 2) / pdf_light; &#125; // ----------------Contribution from other reflectors---------------- Vector3f l_indirect = Vector3f(); // Russian Roulette test if (get_random_float() &lt; RussianRoulette) &#123; Vector3f wi = normalize(shade_point_inter.m->sample(wo, normal)); Vector3f indirect_ray_origin = shade_point + wi * EPSILON; Ray reflected_ray(indirect_ray_origin, wi); Intersection reflected_inter = intersect(reflected_ray); // If reflected_ray hitting a non-emitting object, compute its contribution if (reflected_inter.happened &amp;&amp; reflected_inter.m->hasEmission()) &#123; l_indirect = Vector3f(); &#125; else &#123; l_indirect = castRay(reflected_ray, depth + 1) * shade_point_inter.m->eval(wi, wo, normal) \\ * std::max(dotProduct(wi, normal), 0.0f) \\ / (shade_point_inter.m->pdf(wi, wo, normal)) / RussianRoulette; &#125; &#125; return l_direct + l_indirect; &#125; 再来看看图 代码细节接下来我们再聊聊具体的代码细节。自发光项比较简单，我们略过。 $L_\\text{direct}$直接光部分。首先要注意的是，各个射线 $w_i, w_o, w_s$ 都是从着色点指向外的单位方向向量。这是一个图形学里常用的约定，所以不要问为什么不是指向内了（） 然后在发出射线时，最好做一个微小的偏移以避免发出的射线和着色点平面相交。这就是我们 direct_ray_origin = shade_point + ws * EPSILON 做了加法的原因。 Vector3f wo = -normalize(ray.direction); Vector3f normal = normalize(shade_point_inter.normal); Vector3f l_direct = Vector3f(); Intersection light_sample; float pdf_light; sampleLight(light_sample, pdf_light); // If the ray is not blocked in the middle, compute its contribution Vector3f light_normal = normalize(light_sample.normal); Vector3f shade_point = shade_point_inter.coords; Vector3f ws = normalize(light_sample.coords - shade_point); Vector3f direct_ray_origin = shade_point + ws * EPSILON; Ray ray_to_light(direct_ray_origin, ws); Intersection inter_between_light = intersect(ray_to_light); if ((!inter_between_light.happened) || inter_between_light.distance > (light_sample.coords - direct_ray_origin).norm() - EPSILON) &#123; l_direct = light_sample.emit * shade_point_inter.m->eval(ws, wo, normal) \\ * std::max(dotProduct(ws, normal), 0.0f) * std::max(dotProduct(-ws, light_normal), 0.0f) \\ / std::pow((light_sample.coords - direct_ray_origin).norm(), 2) / pdf_light; &#125; 另外，我们有从光源采样计算直接光的公式： $$\\begin{align*}&amp;\\int_{\\Omega_{光源方向}} f_r(p, \\vec{\\omega_i}, \\vec{\\omega_o}) L_i(p, \\vec{\\omega_i}) (\\vec{\\omega_i} \\cdot n) d\\omega_i\\=&amp;\\int_{A} f_r(p, \\vec{\\omega_i}, \\vec{\\omega_o}) L_i(p, \\vec{\\omega_i}) \\frac{\\cos\\theta\\cos\\theta_i}{\\lVert p’-p \\rVert^2} dA \\end{align*}$$ 用蒙特卡罗近似就是代码里写的东西了。 $L_\\text{indirect}$间接部分。首先要做俄罗斯轮盘赌，然后要检查打到的是否是光源。 如果通过了轮盘赌，而且打到的不是光源，就要计算间接光。 与直接光一样，我们要做微小偏移，这就是 indirect_ray_origin = shade_point + wi * EPSILON . 然后套公式就行。 Vector3f l_indirect = Vector3f(); // Russian Roulette test if (get_random_float() &lt; RussianRoulette) &#123; Vector3f wi = normalize(shade_point_inter.m->sample(wo, normal)); Vector3f indirect_ray_origin = shade_point + wi * EPSILON; Ray reflected_ray(indirect_ray_origin, wi); Intersection reflected_inter = intersect(reflected_ray); // If reflected_ray hitting a non-emitting object, compute its contribution if (reflected_inter.happened &amp;&amp; reflected_inter.m->hasEmission()) &#123; l_indirect = Vector3f(); &#125; else &#123; l_indirect = castRay(reflected_ray, depth + 1) * shade_point_inter.m->eval(wi, wo, normal) \\ * std::max(dotProduct(wi, normal), 0.0f) \\ / (shade_point_inter.m->pdf(wi, wo, normal)) / RussianRoulette; &#125; &#125; 结果对 EPSILON 挺敏感的，可以把 EPSILON 适当调大点，我用的是 0.00020 .","categories":[{"name":"公开课","slug":"公开课","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"GAMES101","slug":"公开课/GAMES101","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/"},{"name":"Assignments","slug":"公开课/GAMES101/Assignments","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/Assignments/"}],"tags":[]},{"title":"Note 6 BRDF and Rendering Eequation","slug":"learning/open-course/GAMES101/Notes/Note6-BRDF-and-renderingequation","date":"2025-10-10T13:45:28.000Z","updated":"2025-10-10T14:49:51.245Z","comments":true,"path":"wiki/learning/open-course/GAMES101/Notes/Note6-BRDF-and-renderingequation/","permalink":"http://rinevard.github.io/wiki/learning/open-course/GAMES101/Notes/Note6-BRDF-and-renderingequation/","excerpt":"","text":"我们之前已经学过了 Blinn-Phong 光照模型，但它只是一个启发式模型，在物理上是不正确的。接下来我们看看物理上正确的光照是怎样的，以及如何用计算机近似求解接近正确的光照。 辐射度量学在了解光照的物理模型之前，我们先来看看一些物理量。最关键的物理量有四个，分别是 Radiant flux/power $\\Phi$，单位 $W$. Radiant intensity $I$，单位 $\\frac{W}{\\text{sr}}$. Irradiance $E$，单位 $\\frac{W}{m^2}$. Radiance $L$，单位 $\\frac{W}{\\text{sr}\\cdot m^2}$. 接下来让我们看看它们的具体定义。 Radiant flux/power $\\Phi$Radiant flux/power 符号 $\\Phi$，单位 $W$. 定义为 $$\\Phi = \\frac{dQ}{dt}$$ Radiant intensity $I$Radiant Intensity 符号 $I$，单位 $\\frac{W}{\\text{sr}}$，表示某个定点接收/穿过/发出的，在指定方向 $\\vec{\\omega}$ 上的，单位立体角的 Power. 定义为 $$I(\\vec{\\omega})=\\frac{d\\Phi}{d\\omega}$$ 这里的符号略显混乱。左边的参数 $\\vec{\\omega}$ 是一个方向向量，右边的 $d\\omega$ 则是这个方向上立体角的微分。 我们知道方向向量 $\\vec{\\omega}$ 也能在球坐标下被表示为 $(\\theta,\\varphi)$。对给定的 $(\\theta,\\varphi)$，我们可以算出其在球面上的面积微分，也能进一步求出立体角微分 $d\\omega$，如下所示 $$\\begin{align}&amp;dA=r^2 \\sin \\theta \\space d\\theta \\space d\\varphi\\&amp;d\\omega=\\frac{dA}{r^2}=\\sin \\theta \\space d\\theta \\space d\\varphi\\end{align}$$ 下图是对 Solid angle 和 Radiant Intensity 两个概念的图解 Irradiance $E$Irradiance 符号 $E$，单位 $\\frac{W}{m^2}$. 表示点 $x$ 周围单位面积接收/穿过/发出的 Power，定义为 $$E(x)=\\frac{d\\Phi}{dA}$$ 下图计算并对比了平行光穿过两个不同截面时的 irradiance：垂直截面 $A$，以及与垂直方向成 $\\theta$ 角的倾斜截面 $A’$。 其中 $\\Phi=\\Phi’$ 是因为能量守恒，光束穿过任何一个完整截面的功率是固定的。 Radiance $L$Radiance $L$ 的单位是 $\\frac{W}{\\text{sr}\\cdot \\space m^2}$，表示表面某点 $x$ 周围单位投影面积接收/穿过/发出的，在指定方向 $\\vec{w}$ 上的，单位立体角的 radiant flux. 定义为 $$L(x,\\vec{\\omega})=\\frac{d^2\\Phi}{d\\omega ds}=\\frac{d^2\\Phi}{d\\omega ds_{0}\\cos\\theta}$$ 这里的 $ds$ 是投影前面积，$ds_0 \\cos\\theta$ 是投影面积。 下图是对 Irradiance 和 Radiance的图解 BRDF和材质现在我们可以看看光照的物理模型了，其中最关键的是 BRDF，即双向反射分布函数。它定义了从方向 $\\vec{\\omega_i}$ 射入的光线打到某个表面上反射到 $\\vec{\\omega_r}$ 方向的强度： $$f_r(p,\\vec{\\omega_i}, \\vec{\\omega_r}) = \\frac{dL_r(p,\\vec{\\omega_r})}{dE_i(p,\\vec{\\omega_i})}$$ 你可能会疑惑为什么之前我们说 $E$ 是关于 $x$ 的函数，现在却除了坐标 $p$ 外还多了一个方向参数 $\\omega_i$，这是因为 BRDF 里的 $E$ 是微分。具体可以看看下面这个式子： $$E(x) = \\int_{\\Omega} L_i(x,\\vec{\\omega_i}) \\cos\\theta_i d\\omega_i\\dE_i(x, \\vec{\\omega_i}) = L_i(x, \\vec{\\omega_i}) \\cos\\theta_i d\\omega_i $$ 你可能还会疑惑，为什么分母用 $E$ 呢？和分母一样统一用 $L$ 不是更优雅吗？ 据 https://www.zhihu.com/question/28476602/answer/41003204 这个答案所说，测量出射的 Radiance $L$ 很方便，但测量入射的 Irradiance $L$ 很困难，而测量入射的 $dE$ 挺方便，因此我们就使用了 $\\frac{dL}{dE}$. 我们把上面的 $dE_i(x,\\vec{\\omega_i})$ 代入 BRDF，就得到了 $$f_r(p,\\vec{\\omega_i}, \\vec{\\omega_r}) = \\frac{dL_r(p,\\vec{\\omega_r})}{L_i(x,\\vec{w_i})\\cos\\theta_i dw_i}$$ 物体的材质就用 BSDF（反射的BRDF+折射的BTDF）表示。我们这里只聊 BRDF，因为 BTDF 和 BRDF 接近。BRDF 的获取包括但不限于这两种方式： 现实测量。我们可以找到许多包含大量 BRDF 测量数据的数据集，比如 MERL 数据集。 微表面模型。用粗糙度、金属度等参数来构建启发式的 BRDF 函数。 还值得一提的是，由 Helmholtz Reciprocity Principle，有 $$f_r(p,\\vec{\\omega_i}, \\vec{\\omega_o}) = f_r(p,\\vec{\\omega_o}, \\vec{\\omega_i})$$ 也就是说交换入射出射方向，BRDF 函数 $f_r$ 不变。 渲染方程现在我们先看看反射方程，再看看渲染方程。 反射方程是通过 BRDF 求出 $L_r$ 的方程，对 BRDF 的公式积分一下就行： $$L_r(p, \\vec{\\omega_r}) = \\int_{\\Omega} f_r(p, \\vec{\\omega_i}, \\vec{\\omega_r}) L_i(p, \\vec{\\omega_i}) (\\vec{\\omega_i} \\cdot \\vec{n}) d\\omega_i $$ 其中 $\\vec{n}$ 是点 $p$ 处的法线方向，$\\vec{\\omega_i} \\cdot \\vec{n}$ 是 BRDF 定义里的 $\\cos\\theta_i$. 而渲染方程，不考虑折射，只是比反射方程多了一个自发光项： $$L_o(p, \\vec{\\omega_o}) = L_e(p, \\vec{\\omega_o}) + \\int_{\\Omega} f_r(p, \\vec{\\omega_i}, \\vec{\\omega_o}) L_i(p, \\vec{\\omega_i}) (\\vec{\\omega_i} \\cdot n) d\\omega_i$$ 你可能会好奇右侧的 $L_i(p,\\vec{\\omega_i})$ 怎么求出来。由能量守恒，我们可以从 $p$ 出发顺着 $-\\vec{\\omega_i}$ 找到第一个交点 $q$，然后就有 $$L_i(p,\\vec{\\omega_i})=L_o(q,-\\vec{\\omega_i})$$ 实际算法由上可知，我们要求解下面的方程： $$L_o(p, \\vec{\\omega_o}) = L_e(p, \\vec{\\omega_o}) + \\int_{\\Omega} f_r(p, \\vec{\\omega_i}, \\vec{\\omega_o}) L_o(\\text{raycast}(p, -\\vec{\\omega_i}), -\\vec{\\omega_i}) (\\vec{\\omega_i} \\cdot n) d\\vec{\\omega_i}$$ 这是一个积分，还是一个递归，我们先用蒙特卡罗算法近似积分，得到 $$L_o(p, \\vec{\\omega_o}) \\approx L_e(p, \\vec{\\omega_o}) +\\frac{1}{N}\\sum_{k=1}^{N}\\frac{f_r(p, \\vec{\\omega_i}^{(k)}, \\vec{\\omega_o}) L_o(\\text{raycast}(p, -\\vec{\\omega_i}^{(k)}), -\\vec{\\omega_i}^{(k)}) (\\vec{\\omega_i} ^{(k)}\\cdot n) }{p(\\vec{\\omega_i}^{(k)})}$$ 其中 $\\vec{\\omega_i}^{(k)}$ 是随机采样的方向向量，$p(\\vec{\\omega_i}^{(k)})$ 是采样到它的概率。 有了这个求和，我们就可以开始递归了，大致算法如下： 从 $p$ 射出朝随机方向 $\\vec{\\omega_i}^{(k)}$ 的射线，打到 $q^{(k)}$. 计算 $L_o(q,-w_i^{(k)})$，然后代入式子，求得 $L_o(p,\\vec{\\omega_o})$。 等等，这不是无限递归吗？确实如此。所以我们会假设如果射线打到了光源就只返回自发光项 $L_e$. 但这不还是很复杂吗，假设我们对每个点发射 $10$ 条射线，弹射以后就要发射 $10^2$ 个，再弹射就要 $10^3$ 个！ 没错，所以我们只对每个点发出 $1$ 条射线并计算其弹射后的完整路径，然后对每个点追踪多条路径并取平均。虽然这不完全符合上面的公式，但很有效。 让我们来看看新的算法吧： 如果点 $p$ 是光源，直接返回其自发光项。 随机采样一个方向 $w_i$，从 $p$ 发出一条朝向 $w_i$ 的射线，打到点 $q$. 计算点 $q$ 的 $L_o(q,-w_i)$，代入公式，求得 $L_o(p,w_o)$. 对求得的多个 $L_o(p,w_o)$ 取平均。 这个算法当然可以进一步优化，比如说上面还是有潜在的无限弹射风险，所以要用俄罗斯轮盘赌来在每次弹射时都有随机概率停止弹射（这被称作RR）；又比如上面打到光源的概率太低，所以可以从光源采样射线（这被称作NEE）。不过这些东西就留到作业 7 的解析里再说吧。 参考资料Stanford CS348B, Spring 2022：https://gfxcourses.stanford.edu/cs348b/spring22 多伦多大学图形学讲义：https://www.dgp.toronto.edu/public_user/elf/2522/light.pdf Introduction to Radiometry and Photometry UE4 的 BRDF 实现：https://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf","categories":[{"name":"公开课","slug":"公开课","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"GAMES101","slug":"公开课/GAMES101","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/"},{"name":"Notes","slug":"公开课/GAMES101/Notes","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/Notes/"}],"tags":[]},{"title":"探索日志[0]","slug":"others/thoughts/探索日志0","date":"2025-10-10T12:10:11.000Z","updated":"2025-10-27T13:33:04.965Z","comments":true,"path":"wiki/others/thoughts/探索日志0/","permalink":"http://rinevard.github.io/wiki/others/thoughts/%E6%8E%A2%E7%B4%A2%E6%97%A5%E5%BF%970/","excerpt":"","text":"第二次参加了 Ludum Dare，第二次参加了 Compo 赛道。Compo 要求单人从零开始在 48 小时内做出一个能玩的东西。不觉得这很酷吗，作为一个玩家我觉得这太酷了，很符合我对极客的想象。 上一次参加 Compo 结识了一位很有趣的朋友，所以这次又参加了 Compo 而不是组队的 Jam。不过这次似乎至少到现在为止还没结识到很有趣的朋友（） 从上学期就开始想，大学的每天都太相似，日复一日。因此想每周都做一些没做过的事情。虽然没坚持很久，但我想这确实是值得做的。所以从现在开始简单写写探索日志吧，时不时探索一下。 这次除了自己参加之外，还和墨鱼游研社的同学们一起组织了一个活动，和社团的大家一起参加了这场 gamejam，咱们社团最后一共做了四个游戏。我做了 SwarmSurge. 怎样的生活值得我过，我该过怎样的生活？我确实还没想明白。Jam 是生活里为数不多的一抹奇幻色彩，惊艳又短暂。在有趣的故事结束之后，我们又该做什么，又该去往何方？ 也难怪会喜欢凉宫春日。虽然她性格恶劣想一出是一出，但她是让世界变得更热闹的凉宫春日团团长！阿虚曾问自己：“对这种超乎常识的学园生活，你就不觉得快乐吗？”他的回答是：“当然快乐了，别问我这种明摆着的事情。” 对这些奇幻色彩，我难道不感觉快乐吗？当然快乐了。我会一直探索下去，即使每天都是某个雨日。","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/"},{"name":"碎碎念","slug":"杂谈/碎碎念","permalink":"http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}],"tags":[]},{"title":"Note 5 RayTracing","slug":"learning/open-course/GAMES101/Notes/Note5-RayTracing","date":"2025-09-25T13:48:28.000Z","updated":"2025-09-25T13:51:26.850Z","comments":true,"path":"wiki/learning/open-course/GAMES101/Notes/Note5-RayTracing/","permalink":"http://rinevard.github.io/wiki/learning/open-course/GAMES101/Notes/Note5-RayTracing/","excerpt":"","text":"渲染可以分为两个大类：object-order rendering 和 Image-order rendering. 前者以场景中的物体（通常是如三角形）为基本单位进行迭代，遍历场景中的每一个物体，然后确定该物体会影响屏幕上的哪些像素；后者以屏幕上的像素为基本单位进行迭代，遍历输出图像中的每一个像素，然后对于每个像素，它会找出场景中的哪个物体或物体的哪个部分决定了该像素的颜色。 我们之前学的光栅化是前者，而我们接下来要介绍的光线追踪就是后者。 光线追踪基本思想光线追踪的思想基于光路可逆——既然光路可逆，那么打到摄像机里的光就可以看作从摄像机发出的射线，我们只要打出射线然后计算射线打到的点的颜色就好了。 其实基本思路真的就是这么简单！如下图所示，我们从眼睛里发出经过每个像素的射线，然后射线打到物体上就得到了物体的基本颜色。而射线还会反射、折射，我们计算反射、折射后的射线打到的颜色，再加到基本颜色上，就得到了这个像素的颜色。 光线追踪也自然地生成了阴影——如果射线打中的点和光源的连线间有物体遮挡，这点就是阴影，否则就不是阴影。 碰撞检测既然如此，我们只要检测射线和三角形的碰撞就好了。我们可以用下面的 Möller Trumbore Algorithm 来做检测，其思路是解 “直线上的点 = 三角形重心坐标表示” 这个方程： 考虑射线 $\\vec{O} + t\\vec{D}$ 和三角形 $P_0, P_1, P_2$，我们要解方程 $$\\vec{O} + t\\vec{D} = (1-b_1-b_2)\\vec{P_0} + b_1\\vec{P_1} + b_2\\vec{P_2}$$ 这是一个线性方程组，解为 $$\\begin{bmatrix} t \\ b_1 \\ b_2 \\end{bmatrix} = \\frac{1}{\\vec{S_1} \\cdot \\vec{E_1}} \\begin{bmatrix} \\vec{S_2} \\cdot \\vec{E_2} \\ \\vec{S_1} \\cdot \\vec{S} \\ \\vec{S_2} \\cdot \\vec{D} \\end{bmatrix}$$ 其中 $$\\begin{aligned}\\vec{E_1} &amp;= \\vec{P_1} - \\vec{P_0} \\\\vec{E_2} &amp;= \\vec{P_2} - \\vec{P_0} \\\\vec{S} &amp;= \\vec{O} - \\vec{P_0} \\\\vec{S_1} &amp;= \\vec{D} \\times \\vec{E_2} \\\\vec{S_2} &amp;= \\vec{S} \\times \\vec{E_1}\\end{aligned}$$ 性能优化在做射线和三角形的碰撞检测时，简单地遍历场景里的每个三角形显然太慢了，所以我们用包围盒来优化。如果一个射线没有碰到包围盒，自然就不会碰到盒子里的物体；如果碰到了，再和盒子里的物体做碰撞检测。 常见包围盒包围盒有两种思路，一种是基于空间的划分，另一种是基于物体的划分。前者的代表包括四叉树、八叉树；后者的代表是 BVH. 四叉树、八叉树把空间进行平分，当一个区域里还剩较多物体时就再在这个区域里平分一次。 BVH 为每组物体建立包围盒，然后再把父包围盒划分成子包围盒。 射线和包围盒的碰撞检测包围盒有六个面，我们可以把相对的面划分成一组从而得到三组面。计算射线 $\\vec{O} + t\\vec{D}$ 与这三组面的交点后，我们会得到 $[t_{x, \\text{enter}}, t_{x, \\text{exit}}],[t_{y, \\text{enter}}, t_{y, \\text{exit}}],[t_{z, \\text{enter}}, t_{z, \\text{exit}}]$，之后计算下面的交集： $$[t_\\text{raymin},t_\\text{raymax}]\\cap[t_{x, \\text{enter}}, t_{x, \\text{exit}}]\\cap[t_{y, \\text{enter}}, t_{y, \\text{exit}}]\\cap[t_{z, \\text{enter}}, t_{z, \\text{exit}}]$$ 如果交集为空则无交点，否则有交点。 为了方便计算，包围盒一般是与坐标轴平行的。","categories":[{"name":"公开课","slug":"公开课","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"GAMES101","slug":"公开课/GAMES101","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/"},{"name":"Notes","slug":"公开课/GAMES101/Notes","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/Notes/"}],"tags":[]},{"title":"Assignment 6 Bounding Box","slug":"learning/open-course/GAMES101/Hw/Hw6-bounding-box","date":"2025-09-24T09:46:44.000Z","updated":"2025-09-24T12:56:28.461Z","comments":true,"path":"wiki/learning/open-course/GAMES101/Hw/Hw6-bounding-box/","permalink":"http://rinevard.github.io/wiki/learning/open-course/GAMES101/Hw/Hw6-bounding-box/","excerpt":"","text":"这次的作业要求实现用包围盒来加快光线追踪，再用 BVH 优化。 首先我们要把 hw5 里的代码复制过来，让我不解的是代码里明明已经提供了 rayTriangleIntersect 函数，PDF 里却还说“将你的光线-三角形相交函数粘贴到此处”，明明直接调用它就好了，如下所示： inline Intersection Triangle::getIntersection(Ray ray) &#123; Intersection inter; float u, v, t; inter.happened = rayTriangleIntersect(v0, v1, v2, ray.origin, ray.direction, t, u, v); if (inter.happened) &#123; inter.coords = ray.origin + t * ray.direction; inter.normal = normal; inter.distance = t; inter.obj = this; inter.m = m; &#125; return inter; &#125; 然后我也不太喜欢代码框架对 IntersectP 的定义，在我看来既然另外两个参数能通过 ray 算出来，就完全没有理由作为参数传入。 于是我就改成了这个只保留 ray 参数的样子： inline bool Bounds3::IntersectP(const Ray&amp; ray) const &#123; // invDir: ray direction(x,y,z), invDir=(1.0/x,1.0/y,1.0/z), use this because Multiply is faster that Division auto tMinVec = (pMin - ray.origin) * ray.direction_inv; auto tMaxVec = (pMax - ray.origin) * ray.direction_inv; float tMinx = std::max(&#123;std::min(tMinVec.x, tMaxVec.x), static_cast&lt;float>(ray.t_min)&#125;); float tMiny = std::max(&#123;std::min(tMinVec.y, tMaxVec.y), static_cast&lt;float>(ray.t_min)&#125;); float tMinz = std::max(&#123;std::min(tMinVec.z, tMaxVec.z), static_cast&lt;float>(ray.t_min)&#125;); float tMaxx = std::min(&#123;std::max(tMinVec.x, tMaxVec.x), static_cast&lt;float>(ray.t_max)&#125;); float tMaxy = std::min(&#123;std::max(tMinVec.y, tMaxVec.y), static_cast&lt;float>(ray.t_max)&#125;); float tMaxz = std::min(&#123;std::max(tMinVec.z, tMaxVec.z), static_cast&lt;float>(ray.t_max)&#125;); float tMin = std::max(&#123;tMinx, tMiny, tMinz&#125;); float tMax = std::min(&#123;tMaxx, tMaxy, tMaxz&#125;); return (tMin &lt;= tMax); &#125; 思路就是计算这个交集： $$[t_\\text{raymin},t_\\text{raymax}]\\cap[t_{x, \\text{enter}}, t_{x, \\text{exit}}]\\cap[t_{y, \\text{enter}}, t_{y, \\text{exit}}]\\cap[t_{z, \\text{enter}}, t_{z, \\text{exit}}]$$ 对于最后的 getIntersection，小 AI 说可以在发生相交时更新 ray 的 t_max，然后在射线和盒子的交点大于 t_max 时不再检测盒子内部的相交，这可以优化性能。我认为他说得非常有道理，但改起来有点麻烦，就不改了。 Intersection BVHAccel::getIntersection(BVHBuildNode* node, const Ray&amp; ray) const &#123; if (!node->bounds.IntersectP(ray)) &#123; return Intersection(); &#125; // leaf node checks ray's intersection with obj if (node->left == nullptr &amp;&amp; node->right == nullptr) &#123; if (node->object == nullptr) &#123; return Intersection(); &#125; return node->object->getIntersection(ray); &#125; // parent with only one child returns child's intersection else if (node->left == nullptr) &#123; return getIntersection(node->right, ray); &#125; else if (node->right == nullptr) &#123; return getIntersection(node->left, ray); &#125; // parent with two children returns the closer intersection else &#123; Intersection inter1 = getIntersection(node->left, ray); Intersection inter2 = getIntersection(node->right, ray); if (!inter1.happened &amp;&amp; !inter2.happened) &#123; return Intersection(); &#125; else if (!inter1.happened) &#123; return inter2; &#125; else if (!inter2.happened) &#123; return inter1; &#125; return (inter1.distance &lt; inter2.distance) ? inter1 : inter2; &#125; &#125; 咱还是在最后放放图图","categories":[{"name":"公开课","slug":"公开课","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"GAMES101","slug":"公开课/GAMES101","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/"},{"name":"Assignments","slug":"公开课/GAMES101/Assignments","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/Assignments/"}],"tags":[]},{"title":"Assignment 5 Raytracing","slug":"learning/open-course/GAMES101/Hw/Hw5-raytracing","date":"2025-09-22T11:46:16.000Z","updated":"2025-09-26T04:09:50.574Z","comments":true,"path":"wiki/learning/open-course/GAMES101/Hw/Hw5-raytracing/","permalink":"http://rinevard.github.io/wiki/learning/open-course/GAMES101/Hw/Hw5-raytracing/","excerpt":"","text":"如果只是实现要求的话，感觉这会是很无聊的一次作业。为了让事情有趣一点，我们来看看 castRay 函数的实现吧。我们会把作业代码放在文末。 castRay 函数的分析castRay 函数实现了课上讲的光线追踪，它从 orig 打出朝着 dir 方向的射线，并返回颜色。其工作流程如下： 首先，检查当前的递归深度depth。当depth超过场景设定的最大深度scene.maxDepth时，函数返回黑色。这就是开头的代码： if (depth > scene.maxDepth) &#123; return Vector3f(0.0,0.0,0.0); &#125; 然后，计算射线是否与场景中的任何物体相交。如果没有发生相交，说明射线射向了场景的背景，函数将返回背景颜色。 如果射线击中了某个物体，函数将根据该物体的材质类型，进入不同的处理分支计算颜色。接下来我们会分析这些分支。 我们可以看到物体被分为了三种材质，分别是既有镜面反射又有折射的 REFLECTION_AND_REFRACTION、只有反射的 REFLECTION、只有漫反射的 DIFFUSE_AND_GLOSSY。REFLECTION_AND_REFRACTION 和 REFLECTION 部分的代码比较相似，我们就先讨论 REFLECTION_AND_REFRACTION 的代码，再讨论 DIFFUSE_AND_GLOSSY 的代码。 REFLECTION_AND_REFRACTION这里的反射/折射材质自身是没有颜色的，也就是说它们只显示反射/折射后射线打到的点的颜色。所以代码思路比较简单，如果射线打到了这种材质的物体上，它会反射/折射，我们需要计算出反射/折射后的射线打到的颜色，这就对应着下面的代码： Vector3f reflectionColor = castRay(reflectionRayOrig, reflectionDirection, scene, depth + 1); Vector3f refractionColor = castRay(refractionRayOrig, refractionDirection, scene, depth + 1); 代码里还考虑了菲涅尔效应来计算反射和折射的比例。菲涅尔效应的公式有点复杂，我们就不讲解了。这里的 kr 就是菲涅尔方程算出的反射系数，而由能量守恒，折射系数就是 $1-\\text{kr}$。 hitColor 就是这个点的最终颜色： float kr = fresnel(dir, N, payload->hit_obj->ior); hitColor = reflectionColor * kr + refractionColor * (1 - kr); 我们也会注意到，代码在开头对反射/折射点做了一个小小的偏移，这似乎是为了避免反射/折射时立即打到自己（咱也不确定，这是猜测） Vector3f reflectionRayOrig = (dotProduct(reflectionDirection, N) &lt; 0) ? hitPoint - N * scene.epsilon : hitPoint + N * scene.epsilon; 我们都看到菲涅尔效应的代码了，不如再看看纯反射/纯折射的球是怎样的。注意靠近我们观察者的球，我们可以先把 kr 设为 1 来看看纯反射的结果： 再来看看纯折射的结果： 与文末的图比较一下，就会发现菲涅尔效应确实就是反射和折射的叠加。 DIFFUSE_AND_GLOSSY再来看看 DIFFUSE_AND_GLOSSY 部分，这里是正常的 Phong 模型着色。唯一要注意的是，要判断射线打到的点和光源之间有没有物体遮挡，如果有遮挡这里就是阴影。 我认为这一部分的代码有问题，它只考虑了漫反射分量在不在阴影里，而没考虑镜面反射分量。这里是原本的代码： // 漫反射 lightAmt += inShadow ? 0 : light->intensity * LdotN; // 镜面反射 Vector3f reflectionDirection = reflect(-lightDir, N); specularColor += powf(std::max(0.f, -dotProduct(reflectionDirection, dir)), payload->hit_obj->specularExponent) * light->intensity; 我想我们应该做这样的修改： if (!inShadow) &#123; // 漫反射 lightAmt += light->intensity * LdotN; // 镜面反射 Vector3f reflectionDirection = reflect(-lightDir, N); specularColor += powf(std::max(0.f, -dotProduct(reflectionDirection, dir)), payload->hit_obj->specularExponent) * light->intensity; &#125; 作业代码接下来咱就直接放作业代码了。 首先是 rayTriangleIntersect： bool rayTriangleIntersect(const Vector3f&amp; v0, const Vector3f&amp; v1, const Vector3f&amp; v2, const Vector3f&amp; orig, const Vector3f&amp; dir, float&amp; tNear, float&amp; u, float&amp; v) &#123; auto e1 = v1 - v0; auto e2 = v2 - v0; auto s = orig - v0; auto s1 = crossProduct(dir, e2); auto s2 = crossProduct(s, e1); auto coefficient = 1.0 / dotProduct(s1, e1); tNear = coefficient * dotProduct(s2, e2); u = coefficient * dotProduct(s1, s); v = coefficient * dotProduct(s2, dir); return (tNear >= 0) &amp;&amp; (u >= 0) &amp;&amp; (v >= 0) &amp;&amp; ((1 - u - v) >= 0); &#125; 然后是 Render 的部分： for (int i = 0; i &lt; scene.width; ++i) &#123; // generate primary ray direction float x; float y; // I don't understand what are the guiding comments talking about. // Anyway, the code is assuming the distance between eye and screen is one, since abs(dir.z) == 1 // With this assumption we can compute screen's width and height // Then we map x from [0, scene.width - 1] to [-screen_width / 2, screenwidth / 2] // and map y from [0, scene.height - 1] to [screen_height / 2, -screen_height / 2] float screen_height = 2 * scale; float screen_width = imageAspectRatio * screen_height; x = (screen_width / (scene.width - 1)) * (i + 0.5) - (screen_width / 2.0); y = (-screen_height / (scene.height - 1)) * (j + 0.5) + (screen_height / 2.0); Vector3f dir = normalize(Vector3f(x, y, -1)); // Don't forget to normalize this direction! framebuffer[m++] = castRay(eye_pos, dir, scene, 0); &#125; 看看结果吧！如果和前面的纯反射/纯折射对照，会发现前面的球确实就是反射和折射的叠加（反射很淡，不过仔细看也是能看出来的！）","categories":[{"name":"公开课","slug":"公开课","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"GAMES101","slug":"公开课/GAMES101","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/"},{"name":"Assignments","slug":"公开课/GAMES101/Assignments","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/Assignments/"}],"tags":[]},{"title":"Assignment 4 Geometry","slug":"learning/open-course/GAMES101/Hw/Hw4-geometry","date":"2025-09-22T11:44:16.000Z","updated":"2025-09-22T11:44:41.718Z","comments":true,"path":"wiki/learning/open-course/GAMES101/Hw/Hw4-geometry/","permalink":"http://rinevard.github.io/wiki/learning/open-course/GAMES101/Hw/Hw4-geometry/","excerpt":"","text":"这次作业过于简单，我们直接放代码。 cv::Point2f recursive_bezier(const std::vector&lt;cv::Point2f> &amp;control_points, float t) &#123; // TODO: Implement de Casteljau's algorithm if (control_points.size() == 2) &#123; return ((1 - t) * control_points[0] + t * control_points[1]); &#125; std::vector&lt;cv::Point2f> new_control_points = &#123;&#125;; for (int i = 0; i &lt; control_points.size() - 1; i++) &#123; new_control_points.push_back((1 - t) * control_points[i] + t * control_points[i + 1]); &#125; return recursive_bezier(new_control_points, t); &#125; void bezier(const std::vector&lt;cv::Point2f> &amp;control_points, cv::Mat &amp;window) &#123; // TODO: Iterate through all t = 0 to t = 1 with small steps, and call de Casteljau's // recursive Bezier algorithm. float step = 0.001; for (float t = 0; t &lt;= 1; t += step ) &#123; auto point = recursive_bezier(control_points, t); window.at&lt;cv::Vec3b>(point.y, point.x)[1] = 255; &#125; &#125; 另外，由于咱以前在 Godot 里导入字体时见过多通道符号距离场的设置，而且发现开启多通道符号距离场的字体显示清晰了一大截，所以我找了找一些关于 SDF 的资料，感觉这个不错：动态 SDF 字体渲染方法 | 十三","categories":[{"name":"公开课","slug":"公开课","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"GAMES101","slug":"公开课/GAMES101","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/"},{"name":"Assignments","slug":"公开课/GAMES101/Assignments","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/Assignments/"}],"tags":[]},{"title":"Note 4 Geometry","slug":"learning/open-course/GAMES101/Notes/Note4-Geometry","date":"2025-09-19T12:10:28.000Z","updated":"2025-09-19T12:13:54.595Z","comments":true,"path":"wiki/learning/open-course/GAMES101/Notes/Note4-Geometry/","permalink":"http://rinevard.github.io/wiki/learning/open-course/GAMES101/Notes/Note4-Geometry/","excerpt":"","text":"课上只是简单提了下几何专题，我也认为这个专题相较于别的几个没那么重要，所以只是记一下隐式表示和参数表示的相关内容，再简单提一句网格处理。 隐式表示和参数表示对一个几何图形，我们一般有两种表示方法，一种是用普通方程 $f(x,y,z)=0$ 来表示，另一种是用参数方程 $g(u,v)=(x,y,z)$ 来表示。前者是隐式表示，因为不能方便地求出这个方程表示的所有点；后者是参数表示，通过参数 $(u,v)$ 的变化可以轻易求出这个方程表示的所有点。 不过隐式表示也有优点，它能很方便地判断一个点 $(x,y,z)$ 是否在曲线上 / 曲线内 / 曲线外。接下来我们看看隐式表示和参数表示的代表应用。 隐式表示：符号距离场符号距离场（Signed Distance Filed, SDF）是隐式表示的代表应用之一，自 2007 年 Valve 的论文以来，它一直被用于游戏内的文本渲染。虽然现在用的更多是多通道符号距离场（MSDF），但我们这里只简单介绍下符号距离场，因为后者更加复杂。 符号距离场就是带符号的距离场，对给定的点 $(u,v)$，我们记录它到图形的最近距离——如果它在图形内部（图形的线条是有宽度的，这个内部指在线条内而非几何闭环内），距离为正值，否则为负值。 在 V 社的论文中，他们先对矢量文字做了光栅化得到了 $4096\\times 4096$ 的图像，然后基于这张图得到了 $64\\times 64$ 的符号距离场。 下图展示了原图和符号距离场。图像不透明度是在 $[0,1]$ 间的非负数，为了可视化符号距离场，我们把距离为正的内部映射到 $(0.5, 1]$，距离为 $0$ 的边缘被映射到 $0.5$，距离为负的外部映射到 $[0, 0.5)$. 得到了符号距离场之后，我们就能对任何一个点插值出它与图形的距离，然后根据这个距离决定它是否显示出来。我们之前已经提过了距离到不透明度的映射，我们可以简单设置一个阈值来决定是否显示某个像素： baseColor.a = distAlphaMask >= 0.5; 我个人的思考是，不要因为我们可视化了符号距离场就把它当作图像。它本质上是一个距离函数 $d(u,v)$，我们的 $64\\times 64$ 的 SDF 图像的每个像素表示的不是“平均颜色”，而是“像素中心点到图形的距离”。要把它看作点，而非方块。 参数表示：贝塞尔曲线和曲面贝塞尔曲线和曲面是参数表示的很好例子，我们先来看看计算贝塞尔曲线的常用算法和一般公式。 贝塞尔曲线常用的生成贝塞尔曲线的 Casteljau Algorithm 如下，我们以四个点求三阶贝塞尔曲线为例： def bezier(t: float): # 第一层线性插值 p0_1 = (1 - t) * p0 + t * p1 p1_1 = (1 - t) * p1 + t * p2 p2_1 = (1 - t) * p2 + t * p3 # 第二层线性插值 p0_2 = (1 - t) * p0_1 + t * p1_1 p1_2 = (1 - t) * p1_1 + t * p2_1 # 第三层（最后一层）线性插值 p_final = (1 - t) * p0_2 + t * p1_2 return p_final 看看这个算法也就知道贝塞尔曲线是怎么来的了。 三阶公式是 $$\\mathbf{B}(t) = (1-t)^3 \\mathbf{P}_0 + 3(1-t)^2 t \\mathbf{P}_1 + 3(1-t) t^2 \\mathbf{P}_2 + t^3 \\mathbf{P}_3$$ 一般的 $n$ 阶公式是 $$\\mathbf{B}(t) = \\sum_{i=0}^{m} \\binom{m}{i} (1-t)^{m-i} t^i \\mathbf{P}_i$$ 下图中，左图是 Godot 里的 Curve，它就用到了贝塞尔曲线；右图贝塞尔曲线的生成方法，和上面提到的 Casteljau Algorithm 一致。 再看看左图，我们会发现它是由三个贝塞尔曲线拼接而成的，而且看起来很平滑，这就是所谓的“分段贝塞尔曲线”。高阶贝塞尔曲线不容易控制，所以我们更倾向于把几个低阶贝塞尔曲线拼接起来形成复杂曲线。 贝塞尔曲面我们同样用 Casteljau Algorithm 生成贝塞尔曲面： def _de_casteljau_1d(points, t): \"\"\"对一维点序列执行 Casteljau 算法。\"\"\" while len(points) > 1: points = [(1 - t) * p1 + t * p2 for p1, p2 in zip(points, points[1:])] return points[0] def bezier_surface(control_points, u, v): \"\"\"计算贝塞尔曲面上的一点。\"\"\" intermediate_points = [_de_casteljau_1d(row, u) for row in control_points] final_point = _de_casteljau_1d(intermediate_points, v) return final_point 如下图中的右图所示，我们本质上是先沿着一个轴向生成一组贝塞尔曲线，再在曲线上取值生成一组新的控制点，然后用这组新控制点定义一条新的曲线，最后在新的曲线上取值得到曲面上的最终点。 网格处理生成三角形网格后，我们经常还希望做一些处理，比如细分来让模型更光滑；减少三角形数量来简化网格。下面简单提一下网格细分和网格简化的常用算法。 网格细分网格细分算法的绝对主流是 Catmull-Clark 细分，Blender 的表面细分修改器的默认算法就是这个。它可以细分任意形状的多边形，但在细分四边形时效果最好。 课上还提到了用于细分三角形的 Loop 细分，不过两个细分都只是简单提了提概念，我们这里不多记笔记。 网格简化网格简化的基本思路是每次把一条边坍缩成一个点。我们用二次误差衡量每条边坍缩后引入的误差，然后选择最小的边来坍缩，之后重新计算二次误差（因为坍缩后形状会改变），然后再次选择最小的边，如此重复。这是个贪婪算法，但能拿到不错的结果。 具体公式我们也不写，因为课上没详细讲，我也不感兴趣，用到的时候去查查就好了。","categories":[{"name":"公开课","slug":"公开课","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"GAMES101","slug":"公开课/GAMES101","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/"},{"name":"Notes","slug":"公开课/GAMES101/Notes","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/Notes/"}],"tags":[]},{"title":"Note 3 Shading","slug":"learning/open-course/GAMES101/Notes/Note3-Shading","date":"2025-09-17T04:10:28.000Z","updated":"2025-09-17T04:03:13.842Z","comments":true,"path":"wiki/learning/open-course/GAMES101/Notes/Note3-Shading/","permalink":"http://rinevard.github.io/wiki/learning/open-course/GAMES101/Notes/Note3-Shading/","excerpt":"","text":"יְהִי אוֹר起初，计算机的世界尚未渲染，显示器中空虚混沌，渊面黑暗。 唯有顶点与多边形悬于虚空，不见其形，不辨其色。 那声音说：“要有光。” 就有了光。 光是好的，于是那声音将光与暗分开了。光所照之处，物体的正面得以显现；光所不至的背面，则归于阴影。从此，三维的世界有了明暗与层次。 这光并非一体。 那普照万物，均匀散开，使物体显其本色的，称之为漫反射。 那汇于一点，锐利夺目，使光滑之物尽显其耀的，称之为镜面反射。 那弥漫于环境，充盈于阴影，使黑暗不至完全吞噬一切的，称之为环境光。 有漫反射，有镜面反射，有环境光，共同构成了这虚拟世界的第一个白昼。 漫反射（Diffuse Reflection）在漫反射中，光向四面八方散去，所以物体漫反射出的光与摄像机位置无关，而仅与以下几项有关： 光强 $c_l$. 物体材质 $c_r$. 不同物体对光的反射率是不同的，即使是同一个物体也对不同颜色的光有不同反射率。 物体表面法线 $\\mathbf{n}$. 光源方向 $\\mathbf{l}$. 最终结果可以写成 $$L_d = c_r c_l \\max (0, \\mathbf{n} \\cdot \\mathbf{l})$$ 由于光强一般随距离衰减，所以 $c_l$ 一般反比于距离的平方 $r^2$. 镜面反射（Specular Reflection）镜面反射中，光主要向一个方向反射，所以镜面反射的光与摄像机位置有关。 $$L_s = c_pc_l\\max(0, \\mathbf n \\cdot \\mathbf h)^p$$ 其中 $c_p$ 是自定义的 RGB 值，允许我们控制高光颜色，指数 $p$ 是为了保证我们只在小范围内看到高光，$p$ 越大这个高光可见范围越小，而 $\\mathbf h$ 的定义如下： $$\\mathbf h = (\\mathbf e + \\mathbf l).\\text{normalized()}$$ 还有一种写法把 $\\mathbf n \\cdot \\mathbf h$ 换成了 $\\mathbf r \\cdot \\mathbf e$，简单计算可以发现 $\\mathbfn$ 和 $\\mathbf h$ 的夹角是 $\\mathbf r$ 和 $\\mathbf e$ 的夹角的一半，所以这两个写法在思路上是一样的，都在考虑反射光方向和摄像机方向的夹角，不过在数值上会略有差别。本文采用 $\\mathbf n \\cdot \\mathbf h$ 的写法。 环境光（Ambient Lighting）如果只考虑漫反射和镜面反射，我们会发现没有面朝光源的物体完全是黑色的，但现实里显然不是如此。这是因为在现实里，光经过多次反射而照亮了那些没有面朝光源的物体。我们可以近似地认为有一种充斥着整个空间的光，并把它叫做环境光，公式如下： $$L_a=c_r c_a$$ 其中 $c_a$ 是环境光的强度。 冯氏光照模型综合来看，我们就得到了冯氏光照模型，公式如下： $$L=c_r(c_a+c_l\\max{(0,\\mathbf n \\cdot \\mathbf l)})+c_pc_l\\max(0, \\mathbf n \\cdot \\mathbf h)^p$$ 其中 $c_r$ 是物体材质，表示物体对光的反射率，一般是一个 Vector3f 类型的值，因为物体对不同颜色的光有不同反射率； $c_a$ 是环境光强，一般是一个 Vector3f 类型的值； $c_l$ 是光强，一般与物体和光源的距离成反比，一般是一个 Vector3f 类型的值； $c_p$ 是高光颜色，一般也是一个 Vector3f 类型的值。 UV映射为了把贴图贴到模型上，需要有一个 $(x, y, z) \\rightarrow (u, v)$ 的函数 $\\phi$. 我们期望这个函数有这些性质： 单射：我们不希望两个 3D 点映射到同一个 2D 点上 大小不变性：在 3D 模型上的三角形多大，我们希望 2D 的三角形也差不多大小 形状不变性：3D 模型的三角形映射到 2D 上后，两个三角形应尽量相似 连续：如果两个点在 3D 世界模型上相近，我们希望它们在 2D 上也相近 贴图有许多应用，最容易想到的是颜色贴图，它直接把颜色贴到模型上，也被称作漫反射贴图。 法线贴图、金属度贴图、粗糙度贴图则进一步决定了模型的各种属性。比如法线贴图定义了每一点的法线，在计算光照时会借助这个法线来得到更真实的结果。 着色方法模型由三角形划分来表示，那么每个三角形用怎样的颜色呢？ 平面着色（Flat Shading）我们通过光照计算颜色，而计算光照需要法线。平面着色直接求这个三角形的法线，然后按光照公式计算这个三角形的颜色。这种方法得到的每个三角形都是单色的。 逐顶点着色（Gouraud Shading）逐顶点着色则求三角形顶点的法线，并为三角形顶点着色，然后对内部的每个点插值内部颜色。 那么顶点的法线是什么呢？一个顶点一般在多个面上，把这些面的法线做加权平均就好，权值可以是面的面积。 逐像素着色（Phong Shading）逐像素着色同样求三角形顶点的法线，然后对内部的每个点插值内部法线，从法线再求各个点的颜色。 插值是通过重心坐标来插值。对三角形 $ABC$ 内的某一点 $P$，它可以表示为 $$P=\\frac{S_{APB}C+S_{BPC}A+S_{CPA}B}{S_{ABC}}$$ 这里的 $S$ 是面积，这里的形如 $S_{APB}/S_{ABC}$ 的式子就是各个点的权值。 在插值时，我们希望在世界空间 / 摄像机空间做插值，即在 viewing transformation 前进行插值，而不是 viewing transformation 后。 但我们一般在光栅化时才进行插值，这时已经把物体变换到了 NDC 空间，所以我们还要进行透视矫正。公式如下，具体推导可以参考 Homework 3 的笔记。 $$\\begin{align}&amp;\\alpha = \\frac{\\alpha’ / w_0}{\\alpha’ / w_0 + \\beta’ / w_1 + \\gamma’ / w_2}\\&amp;\\beta= \\frac{\\beta’ / w_1}{\\alpha’ / w_0 + \\beta’ / w_1 + \\gamma’ / w_2}\\&amp;\\gamma= \\frac{\\gamma’ / w_2}{\\alpha’ / w_0 + \\beta’ / w_1 + \\gamma’ / w_2}\\end{align}$$ 其中 $\\alpha’,\\beta’,\\gamma’$ 是屏幕空间的重心坐标，$\\alpha,\\beta,\\gamma$ 是世界空间的重心坐标。我们用世界空间的重心坐标作为权重来插值。 渲染管线渲染流程基本如下： Input：输入 3D 世界的顶点 Vertex Processing：用各种变换矩阵把顶点变换到屏幕空间 Triangle Processing：根据传入的顶点连接方式在屏幕空间连接三角形 Rasterization：把三角形转化成片元 / 像素 Fragement Processing：应用贴图、光照等 Framebuffer Operations：深度测试等 纹理放大和纹理缩小在做纹理映射时，贴图太小和贴图太大都会有问题。 纹理放大贴图太小时要做纹理放大，对采样点做双线性插值即可。 纹理缩小贴图太大时直觉上比贴图太小更好处理，但恰恰相反。还记得频谱吗，贴图太大代表高频有更多信息，我们会因采样频率不足而无法正确反映高频信息，导致结果出现锯齿、摩尔纹等走样问题。 最常用的缓解方法是 Mipmapping。基本思路是，我们分析屏幕上每个像素在贴图上覆盖的像素数量，对那些覆盖较多的，就让他们去被缩小的贴图上采样，这样就能缓解欠采样问题。 首先我们要创建“缩小的贴图”，Mipmap链包含一系列纹理 $D_0, D_1, D_2, \\ldots, D_N$，其中 $D_i$ 的分辨率为 $\\frac{W}{2^i} \\times \\frac{H}{2^i}$，直到最内层为 $1 \\times 1$ 像素。 然后我们要分析单个屏幕像素覆盖了多少纹理像素，大致思路是计算屏幕空间的相邻点映射到贴图空间后的距离。贴图空间里相邻像素距离为 $1$，所以如果屏幕空间的相邻点映射到贴图空间后的距离为 $x$，我们就认为它覆盖了 $x$ 个像素。 这个“单个屏幕像素覆盖了多少纹理像素”的估算被记作 $\\rho$，公式如下： $$\\rho = \\max\\left( \\sqrt{\\left(\\frac{\\partial u}{\\partial x}\\right)^2 + \\left(\\frac{\\partial v}{\\partial x}\\right)^2}, \\sqrt{\\left(\\frac{\\partial u}{\\partial y}\\right)^2 + \\left(\\frac{\\partial v}{\\partial y}\\right)^2} \\right)$$ 取 $\\max$ 是为了尽可能取层级更低的 Mipmap。一个屏幕像素覆盖的纹理像素越多，它对应的 Mipmap 层级就越小。总之，我们宁可模糊，也不要欠采样。 最后用 $\\lambda = \\log_2{\\rho}$ 就能算出这个屏幕像素对应的纹理层级。比如当 $\\lambda = 0$ 时，表示一个屏幕像素恰好对应一个纹理像素，应使用原始纹理 $D_0$. 计算出层级 $\\lambda$ 后还要做采样。显然 $\\lambda$ 大多数时候都不是整数，所以有两种常见的采样方法： 最近邻Mipmap滤波（Nearest Mipmap Filtering） 选择最接近 $\\lambda$ 的整数层级 $d = \\text{round}(\\lambda)$ 做采样，在这一层可以是最近邻或双线性滤波。 三线性滤波（Trilinear Filtering） 确定 $\\lambda$ 两侧的两个整数层级：$d_1 = \\lfloor\\lambda\\rfloor$ 和 $d_2 = \\lceil\\lambda\\rceil = d_1 + 1$，在这两层分别做双线性滤波采样得到颜色 $C_1$ 和 $C_2$，然后得到最终颜色 $$ C = (1 - f) \\cdot C_1 + f \\cdot C_2 $$ 其中 $f = \\lambda - \\lfloor\\lambda\\rfloor$ 为 $\\lambda$ 的小数部分。 其他小知识虎书提到的planar projection、spherical coordinates、cylindrical coordinates、cubemaps本质上都是把3d表面投影到一个理想的简单几何体上，然后把简单几何体展开成平面。","categories":[{"name":"公开课","slug":"公开课","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"GAMES101","slug":"公开课/GAMES101","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/"},{"name":"Notes","slug":"公开课/GAMES101/Notes","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/Notes/"}],"tags":[]},{"title":"Assignment 3 Pipeline and Shading","slug":"learning/open-course/GAMES101/Hw/Hw3-pipeline-and-shading","date":"2025-09-13T11:45:16.000Z","updated":"2025-09-13T12:04:25.374Z","comments":true,"path":"wiki/learning/open-course/GAMES101/Hw/Hw3-pipeline-and-shading/","permalink":"http://rinevard.github.io/wiki/learning/open-course/GAMES101/Hw/Hw3-pipeline-and-shading/","excerpt":"","text":"本次作业对 bump_fragment_shader、displacement_fragment_shader 的要求非常不严谨，至少包括这些问题： 这两个 shdaer 需要的贴图是凹凸贴图，凹凸贴图本应该是灰度图，这里使用 RGB 贴图。 在计算切线空间到世界空间的变换矩阵 TBN 时使用了错误的公式。正确的公式需要知道三角形的三个顶点及其 UV 坐标。 displacement 方法没有在光栅化前偏移顶点位置，而只调整了显示颜色。 我们先介绍一下 TBN 的正确计算方式和从 bump texture 算出梯度的方法，再依次介绍一下各个作业的做法。 TBN的正确计算方式我们先来看看什么是 TBN 以及为什么需要 TBN. 为了简单起见，我们先考虑法线贴图。下文把世界空间里按法线贴图修正后的法线称作“修正法线”，把世界空间里修正前的法线称作“几何法线”，这里默认它们都是归一化的。 考虑世界空间的某一点 $Q$，假设它在法线贴图中对应的一点为 $Q’$，我们知道点 $Q’$ 对应的法线被用于计算世界空间点 $Q$ 的修正法线。但等等，直接把 RGB 值复制过去看起来是错误的，因为随着物体转动，点 $Q$ 对应的法线也应当转动。因此，我们需要一个矩阵来实现这种从法线贴图上的法线到世界空间的修正法线的变换。 贴图是二维的，因此我们再额外定义一个垂直纸面向外的轴 $n$，它表示法线的“默认方向”，这就得到了三维的切线空间。如果点 $Q’$ 对应的法线是 $(0,0,1)$，那么世界空间的点 $Q$ 的修正法线就是原本的几何法线。 接下来就要考虑如何找到这个从切线空间到世界空间的旋转矩阵了。为了简单起见，我们先考虑单个三角形的旋转。之后我们会对每个点求出它自己的旋转矩阵。没错，每个点的旋转矩阵不同，这是因为每个点对应的矩阵会把 $(0,0,1)$ 映射到该点的几何法线，而每个点的几何法线一般不同。 如下图所示，我们希望把法线贴图上的 $P_0’P_1’P_2’$ 旋转为世界空间的 $P_0P_1P_2$，设这里的旋转矩阵为 $M$，世界空间的 $P_0P_1P_2$ 的几何法线为 $\\mathbf{n}$，则有 $$\\begin{align*} &amp;M[0,0,1]^T=\\mathbf n \\end{align*} $$ 但光靠这一个方程当然解不出 $M$，所以我们再考虑两个额外的方程： $$\\begin{align*} &amp;M (P_1’-P_0’)=k(P_1-P_0)\\&amp;M (P_2’-P_0’)=k(P_2-P_0) \\end{align*} $$ 也就是说，我们希望这个矩阵把切线空间三角形的边向量旋转到世界空间的边向量上，这看起来是一个合理的要求。这里的 $k$ 是边的长度的缩放比例，严格来说每条边的缩放比例不一定相等，但只要 UV 映射前后的三角形大体是相似三角形，我们就可以认为缩放比例都为 $k$. 下面我们来解方程。首先我们设 $$\\begin{align}&amp;M=\\begin{pmatrix} T &amp; B &amp; N\\end{pmatrix}\\&amp;P_1’-P_0’= [\\Delta u_1,\\Delta v_1,0]^T\\&amp;P_2’-P_0’= [\\Delta u_2,\\Delta v_2,0]^T\\end{align}$$ 下面两个式子利用了 $P_k’$ 的第三个分量为 $0$ 的性质。 结合第一个方程就能得到 $N=\\mathbf n$，这里的 $\\mathbf n$ 表示世界空间的 $P_0P_1P_2$ 的几何法线。再结合另外两个方程就能得到 $$\\begin{align}&amp;\\Delta u_1 T+\\Delta v_1 B=k(P_1-P_0)\\&amp;\\Delta u_2 T+\\Delta v_2 B=k(P_2-P_0)\\end{align}$$ 之后我们可以解出 $T,B,N$ 的值 $$\\begin{align}&amp;T=k\\frac{\\Delta v_2(P_1-P_0)-\\Delta v_1(P_2-P_0)}{\\Delta u_1 \\Delta v_2-\\Delta u_2 \\Delta v_1}\\&amp;B=k\\frac{\\Delta u_2(P_1-P_0)-\\Delta u_1(P_2-P_0)}{\\Delta u_2 \\Delta v_1-\\Delta u_1 \\Delta v_2}\\&amp;N=\\mathbf n\\end{align}$$ 这个公式是不能用的，因为里面有未知数 $k$. 接下来我们解决这个问题。 我们期望 TBN 矩阵是一个旋转矩阵，而旋转矩阵是正交矩阵，所以我们会对 TBN 做施密特正交化和归一化。只要 $P_0P_1P_2$ 和 $P_0’P_1’P_2’$ 大体是相似三角形，那么它们本来就差不多正交（回顾我们对 TBN 的定义，会发现相似说明 TBN 只对 $P_0’P_1’P_2’$ 做了旋转和缩放，这表明 TBN 正交），所以这种正交化不会把 TBN 变化太多。而由于我们会对 TBN 做单位化，所以我们可以放心地令 $k=1$ 来用下面的公式求出 TBN： $$\\begin{align}&amp;T=\\frac{\\Delta v_2(P_1-P_0)-\\Delta v_1(P_2-P_0)}{\\Delta u_1 \\Delta v_2-\\Delta u_2 \\Delta v_1}\\&amp;B=\\frac{\\Delta u_2(P_1-P_0)-\\Delta u_1(P_2-P_0)}{\\Delta u_2 \\Delta v_1-\\Delta u_1 \\Delta v_2}\\&amp;N=\\mathbf{n}\\end{align}$$ 最后，我们希望 N 在正交化前后不变，所以在正交化后我们有 $$\\begin{align*}&amp;T’=T-(N\\cdot T)N\\&amp;B’=B-(N\\cdot B)N-(T’\\cdot B)T’/T’^2\\&amp;N’=\\mathbf n \\end{align*}$$ 再做个单位化就能得到顶点的 TBN 矩阵了。还记得 TBN 矩阵是做什么的吗，我们用它来实现从切线空间到世界空间的变换。所以对点 $Q$，假设其法线贴图对应的法线为 $\\mathbf n’$，那么修正后的法线就是 $M_{\\text{TBN}}\\mathbf n’$. 很好，我们现在能把单个三角形做变换了，但在真正的模型中，每个点的几何法线方向一般都不同，这就意味着它们一般都有不同的 TBN 矩阵。与计算顶点法线类似，我们会找到每个顶点相邻的所有三角形，并对它们的 $T$ 和 $B$ 做加权平均来得到这个顶点的 $T$ 和 $B$. 在实践中，我们一般只计算出每个顶点的 $T$，然后在需要 $B$ 时通过叉乘 $N\\times T$ 来计算。对那些非顶点的点，我们用重心坐标插值来算出其 $N$ 和 $T$，然后也做正交化和单位化来保证 TBN 矩阵的正交性。 最后我们再简单分析一下怎么根据凹凸贴图做法线修正。在修正法线时，凹凸贴图与法线贴图的唯一区别就是没有直接给出法线。回顾一下切线空间的定义，我们就可以给凹凸贴图同样设置沿纸面向外的 $n$ 轴，然后把凹凸贴图想象成一个按灰度值起伏的曲面，这个曲面的法线就和法线贴图提供的法线相对应。 具体来说，点 $(u,v)$ 处的法线可以用 $(h(u)-h(u+1,v),h(v)-h(u,v+1),1)$ 来近似，其中 $h(u,v)$ 表示凹凸贴图在点 $(u,v)$ 处的灰度值，$h(u+1,v)$ 表示 $(u,v)$ 右边一格的灰度值。 有时由于我们把贴图做了归一化，我们会改用 $h(u+1/\\text{width},v)$，但记住它表示相邻格子的灰度值就行。 最后把这个法线和 TBN 矩阵相乘即可得到修正法线。 参考 Computing Tangent Space Basis Vectors for an Arbitrary Mesh - Eric Lengyel 作业代码rasterize_triangle注意这里的插值算法要对所有的属性都做透视矫正，我们简单推导一下透视矫正的公式： 假设我们在对点 $Q$ 的某个属性进行插值，在世界空间中，它所在的三角形为 $P_0P_1P_2$. 投影变换后，它们分别变成了 $Q’$ 和 $P_0’P_1’P_2’$. 用重心坐标分别表示 $Q$ 和 $Q’$，会得到 $$\\begin{align*}&amp;Q=\\alpha P_0+\\beta P_1+\\gamma P_2 \\ &amp;Q’=\\alpha’ P_0’+\\beta’ P_1’+\\gamma’ P_2’\\end{align*}$$ 这里的 $Q,Q’,P_k,P_k’$ 都是形如 $[x,y,z,1]^T$ 的向量。 在插值属性时，我们希望用 $\\alpha, \\beta,\\gamma$ 来插值，而不是使用 $\\alpha’, \\beta’,\\gamma’$ 插值，因为我们当然不希望属性会因透视位置不同而不同。这就需要我们根据 $\\alpha’, \\beta’,\\gamma’$ 算出 $\\alpha, \\beta,\\gamma$. 不妨设投影变换矩阵为 $M$，则有 $$\\begin{align}&amp;MQ=\\alpha MP_0+\\beta MP_1+\\gamma MP_2\\end{align}$$ 这里的 $MP_k$ 是形如 $[x_k,y_k,z_k,w_k]^T$ 的用齐次坐标表示的向量，它与形如 $[x,y,z,1]^T$ 的 $P_k’$ 虽然在数学上表示同一个点，但在数值上不同。（还记得吗，齐次坐标下的 $[x,y,z,1]$ 和 $[ax,ay,az,a]$ 表示同一个点） 因此我们希望对向量的系数做一些调整，来让各个向量变成 $[x,y,z,1]^T$ 的形式，从而找出 $\\alpha’, \\beta’,\\gamma’$ 和 $\\alpha, \\beta,\\gamma$ 的关系。 简单变换一下，我们能把上面的式子写成 $$\\begin{align}&amp;MQ=\\alpha w_0\\frac{MP_0}{w_0}+\\beta w_1\\frac{MP_1}{w_1}+\\gamma w_2\\frac{MP_2}{w_2}\\end{align}$$ 现在右边的各个向量 $\\frac{MP_k}{w_k}$ 都已经是 $[x,y,z,1]^T$ 的形式了，我们给它们的系数做个归一化就能让左边的向量也变成 $[x,y,z,1]^T$ 的形式： $$\\frac{MQ}{\\alpha w_0 + \\beta w_1 + \\gamma w_2}=\\frac{1}{\\alpha w_0 + \\beta w_1 + \\gamma w_2}\\bigg(\\alpha w_0\\frac{MP_0}{w_0}+\\beta w_1\\frac{MP_1}{w_1}+\\gamma w_2\\frac{MP_2}{w_2}\\bigg)$$ 由此我们就有 $$\\begin{align}&amp;\\frac{\\alpha w_0}{\\alpha w_0 + \\beta w_1 + \\gamma w_2}=\\alpha’\\&amp;\\frac{\\beta w_1}{\\alpha w_0 + \\beta w_1 + \\gamma w_2}=\\beta’\\&amp;\\frac{\\gamma w_2}{\\alpha w_0 + \\beta w_1 + \\gamma w_2}=\\gamma’\\end{align}$$ 解上面的方程的小技巧是借助除法和重心坐标和为 $1$ 的性质得到下面的等价的方程组 $$\\begin{align}&amp;\\frac{\\alpha’}{\\beta’}=\\frac{\\alpha w_0}{\\beta w_1}\\&amp;\\frac{\\alpha’}{\\gamma’}=\\frac{\\alpha w_0}{\\gamma w_2}\\&amp;\\alpha + \\beta + \\gamma = 1\\end{align}$$ 然后就能求出 $$\\begin{align}&amp;\\alpha = \\frac{\\alpha’ / w_0}{\\alpha’ / w_0 + \\beta’ / w_1 + \\gamma’ / w_2}\\&amp;\\beta= \\frac{\\beta’ / w_1}{\\alpha’ / w_0 + \\beta’ / w_1 + \\gamma’ / w_2}\\&amp;\\gamma= \\frac{\\gamma’ / w_2}{\\alpha’ / w_0 + \\beta’ / w_1 + \\gamma’ / w_2}\\end{align}$$ 由此，我们就从屏幕空间的重心坐标 $\\alpha’,\\beta’,\\gamma’$ 算出了世界空间的重心坐标 $\\alpha,\\beta,\\gamma$，之后就能用世界空间的重心坐标来正确插值了。 //Screen space rasterization void rst::rasterizer::rasterize_triangle(const Triangle&amp; t, const std::array&lt;Eigen::Vector3f, 3>&amp; view_pos) &#123; auto v = t.toVector4(); // Find bounding box float left = v[0].x(); float right = v[0].x(); float bottom = v[0].y(); float top = v[0].y(); for (auto&amp; vec: v) &#123; left = std::min(left, vec.x()); right = std::max(right, vec.x()); bottom = std::min(bottom, vec.y()); top = std::max(top, vec.y()); &#125; // Update pixels in bounding box for (int x = static_cast&lt;int>(left); x &lt;= static_cast&lt;int>(right) + 1; x++) &#123; for (int y = static_cast&lt;int>(bottom); y &lt;= static_cast&lt;int>(top) + 1; y++) &#123; auto[alpha, beta, gamma] = computeBarycentric2D(x, y, t.v); // If (x, y) is not inside triangle, continue if (alpha &lt; 0 || beta &lt; 0 || gamma &lt; 0) &#123; continue; &#125; // Interpolate z value, color, normal, texcoords, shadingcoords, viewpos float alpha_corrected = alpha / v[0].w(); float beta_corrected = beta / v[1].w(); float gamma_corrected = gamma / v[2].w(); float w_reciprocal = alpha_corrected + beta_corrected + gamma_corrected; auto z_interpolated = interpolate(alpha_corrected, beta_corrected, gamma_corrected, v[0].z(), v[1].z(), v[2].z(), w_reciprocal); auto color_interpolated = interpolate(alpha_corrected, beta_corrected, gamma_corrected, t.color[0], t.color[1], t.color[2], w_reciprocal); auto normal_interpolated = interpolate(alpha_corrected, beta_corrected, gamma_corrected, t.normal[0], t.normal[1], t.normal[2], w_reciprocal); auto texcoordes_interpolated = interpolate(alpha_corrected, beta_corrected, gamma_corrected, t.tex_coords[0], t.tex_coords[1], t.tex_coords[2], w_reciprocal); auto viewpos_interpolated = interpolate(alpha_corrected, beta_corrected, gamma_corrected, view_pos[0], view_pos[1], view_pos[2], w_reciprocal); // A lower z-value means it is displayed in front if (z_interpolated &lt; depth_buf[y * width + x]) &#123; depth_buf[y * width + x] = z_interpolated; fragment_shader_payload payload( color_interpolated, normal_interpolated, texcoordes_interpolated, texture ? &amp;*texture : nullptr ); payload.view_pos = viewpos_interpolated; auto pixel_color = fragment_shader(payload); set_pixel(Vector2i(x, y), pixel_color); &#125; &#125; &#125; &#125; phong 和 texturephong 的代码按着 phong 模型实现即可。texture 的代码几乎是一模一样的。 我唯一好奇的地方是为什么末尾乘了 255.0f，难道光照模型的各个数值取值都在 $(0,1)$ 之间？但看光强似乎又不是这样。 Eigen::Vector3f phong_fragment_shader(const fragment_shader_payload&amp; payload) &#123; Eigen::Vector3f ka = Eigen::Vector3f(0.005, 0.005, 0.005); Eigen::Vector3f kd = payload.color; Eigen::Vector3f ks = Eigen::Vector3f(0.7937, 0.7937, 0.7937); auto l1 = light&#123;&#123;20, 20, 20&#125;, &#123;500, 500, 500&#125;&#125;; auto l2 = light&#123;&#123;-20, 20, 0&#125;, &#123;500, 500, 500&#125;&#125;; std::vector&lt;light> lights = &#123;l1, l2&#125;; Eigen::Vector3f amb_light_intensity&#123;10, 10, 10&#125;; Eigen::Vector3f eye_pos&#123;0, 0, 10&#125;; float p = 150; Eigen::Vector3f color = payload.color; Eigen::Vector3f point = payload.view_pos; Eigen::Vector3f normal = payload.normal; Eigen::Vector3f result_color = &#123;0, 0, 0&#125;; Eigen::Vector3f ambient = ka.cwiseProduct(amb_light_intensity); result_color += ambient; for (auto&amp; light : lights) &#123; // TODO: For each light source in the code, calculate what the *ambient*, *diffuse*, and *specular* // components are. Then, accumulate that result on the *result_color* object. Eigen::Vector3f vec_to_light = light.position - point; Eigen::Vector3f diffuse = kd.cwiseProduct(light.intensity / vec_to_light.squaredNorm()) * MAX(0, normal.normalized().dot(vec_to_light.normalized())); Eigen::Vector3f vec_to_eye = eye_pos - point; Eigen::Vector3f h = vec_to_light.normalized() + vec_to_eye.normalized(); Eigen::Vector3f specular = ks.cwiseProduct(light.intensity / vec_to_light.squaredNorm()) * pow(MAX(0, normal.normalized().dot(h.normalized())), p); // The ambient component is only added once before the for loop result_color += (diffuse + specular); &#125; return result_color * 255.f; &#125; Eigen::Vector3f texture_fragment_shader(const fragment_shader_payload&amp; payload) &#123; Eigen::Vector3f texture_color = &#123;0, 0, 0&#125;; if (payload.texture) &#123; // TODO: Get the texture value at the texture coordinates of the current fragment texture_color = payload.texture->getColor(payload.tex_coords.x(), payload.tex_coords.y()); &#125; Eigen::Vector3f ka = Eigen::Vector3f(0.005, 0.005, 0.005); Eigen::Vector3f kd = texture_color / 255.f; Eigen::Vector3f ks = Eigen::Vector3f(0.7937, 0.7937, 0.7937); auto l1 = light&#123;&#123;20, 20, 20&#125;, &#123;500, 500, 500&#125;&#125;; auto l2 = light&#123;&#123;-20, 20, 0&#125;, &#123;500, 500, 500&#125;&#125;; std::vector&lt;light> lights = &#123;l1, l2&#125;; Eigen::Vector3f amb_light_intensity&#123;10, 10, 10&#125;; Eigen::Vector3f eye_pos&#123;0, 0, 10&#125;; float p = 150; Eigen::Vector3f color = texture_color; Eigen::Vector3f point = payload.view_pos; Eigen::Vector3f normal = payload.normal; Eigen::Vector3f result_color = &#123;0, 0, 0&#125;; Eigen::Vector3f ambient = ka.cwiseProduct(amb_light_intensity); result_color += ambient; for (auto&amp; light : lights) &#123; // TODO: For each light source in the code, calculate what the *ambient*, *diffuse*, and *specular* // components are. Then, accumulate that result on the *result_color* object. Eigen::Vector3f vec_to_light = light.position - point; Eigen::Vector3f diffuse = kd.cwiseProduct(light.intensity / vec_to_light.squaredNorm()) * MAX(0.0f, normal.normalized().dot(vec_to_light.normalized())); Eigen::Vector3f vec_to_eye = eye_pos - point; Eigen::Vector3f h = vec_to_light.normalized() + vec_to_eye.normalized(); Eigen::Vector3f specular = ks.cwiseProduct(light.intensity / vec_to_light.squaredNorm()) * pow(MAX(0.0f, normal.normalized().dot(h.normalized())), p); // The ambient component is only added once before the for loop result_color += (diffuse + specular); &#125; return result_color * 255.f; &#125; bump 和 displacement如开头所言，本次作业对这两个 shader 的要求非常不严谨，我们就简单放下代码，不多解释了。在一些不严谨的地方我已经写了注释。 Eigen::Vector3f bump_fragment_shader(const fragment_shader_payload&amp; payload) &#123; Eigen::Vector3f ka = Eigen::Vector3f(0.005, 0.005, 0.005); Eigen::Vector3f kd = payload.color; Eigen::Vector3f ks = Eigen::Vector3f(0.7937, 0.7937, 0.7937); auto l1 = light&#123;&#123;20, 20, 20&#125;, &#123;500, 500, 500&#125;&#125;; auto l2 = light&#123;&#123;-20, 20, 0&#125;, &#123;500, 500, 500&#125;&#125;; std::vector&lt;light> lights = &#123;l1, l2&#125;; Eigen::Vector3f amb_light_intensity&#123;10, 10, 10&#125;; Eigen::Vector3f eye_pos&#123;0, 0, 10&#125;; float p = 150; Eigen::Vector3f color = payload.color; Eigen::Vector3f point = payload.view_pos; Eigen::Vector3f normal = payload.normal; float kh = 0.2, kn = 0.1; // TODO: Implement bump mapping here // Let n = normal = (x, y, z) // Vector t = (x*y/sqrt(x*x+z*z),sqrt(x*x+z*z),z*y/sqrt(x*x+z*z)) // Vector b = n cross product t // Matrix TBN = [t b n] // dU = kh * kn * (h(u+1/w,v)-h(u,v)) // dV = kh * kn * (h(u,v+1/h)-h(u,v)) // Vector ln = (-dU, -dV, 1) // Normal n = normalize(TBN * ln) // Note: The formula is WRONG in theory // To calculate the TBN matrix correctly, we need the triangle's vertices and their corresponding UV coordinates // read https://learnopengl.com/Advanced-Lighting/Normal-Mapping and // https://terathon.com/blog/tangent-space.html for more details float x = normal.x(); float y = normal.y(); float z = normal.z(); float u = payload.tex_coords.x(); float v = payload.tex_coords.y(); float w = payload.texture->width; float h = payload.texture->height; Eigen::Vector3f t = Eigen::Vector3f(x*y/sqrt(x*x+z*z),sqrt(x*x+z*z),z*y/sqrt(x*x+z*z)); Eigen::Vector3f b = normal.cross(t); Eigen::Matrix3f TBN; TBN &lt;&lt; t, b, normal; // In theory the texture should be a grayscale image // However we use an ordinary RGB image here, so we take norm // read https://games-cn.org/forums/topic/frequently-asked-questionskeep-updating/ for more details float dU = kh * kn * (payload.texture->getColor(u+1.0f/w, v).norm() - payload.texture->getColor(u, v).norm()); float dV = kh * kn * (payload.texture->getColor(u, v+1.0f/h).norm() - payload.texture->getColor(u, v).norm()); Eigen::Vector3f ln = Eigen::Vector3f(-dU, -dV, 1); normal = (TBN * ln).normalized(); Eigen::Vector3f result_color = &#123;0, 0, 0&#125;; result_color = normal; return result_color * 255.f; &#125; Eigen::Vector3f displacement_fragment_shader(const fragment_shader_payload&amp; payload) &#123; Eigen::Vector3f ka = Eigen::Vector3f(0.005, 0.005, 0.005); Eigen::Vector3f kd = payload.color; Eigen::Vector3f ks = Eigen::Vector3f(0.7937, 0.7937, 0.7937); auto l1 = light&#123;&#123;20, 20, 20&#125;, &#123;500, 500, 500&#125;&#125;; auto l2 = light&#123;&#123;-20, 20, 0&#125;, &#123;500, 500, 500&#125;&#125;; std::vector&lt;light> lights = &#123;l1, l2&#125;; Eigen::Vector3f amb_light_intensity&#123;10, 10, 10&#125;; Eigen::Vector3f eye_pos&#123;0, 0, 10&#125;; float p = 150; Eigen::Vector3f color = payload.color; Eigen::Vector3f point = payload.view_pos; Eigen::Vector3f normal = payload.normal; float kh = 0.2, kn = 0.1; // TODO: Implement displacement mapping here // Let n = normal = (x, y, z) // Vector t = (x*y/sqrt(x*x+z*z),sqrt(x*x+z*z),z*y/sqrt(x*x+z*z)) // Vector b = n cross product t // Matrix TBN = [t b n] // dU = kh * kn * (h(u+1/w,v)-h(u,v)) // dV = kh * kn * (h(u,v+1/h)-h(u,v)) // Vector ln = (-dU, -dV, 1) // Position p = p + kn * n * h(u,v) // Normal n = normalize(TBN * ln) // Note: The formula is WRONG in theory // When using Displacement Mapping, the points should be offset in the camera space before rasterizing, // instead of only changing its color // read https://learnopengl.com/Advanced-Lighting/Normal-Mapping and // https://terathon.com/blog/tangent-space.html for more details float x = normal.x(); float y = normal.y(); float z = normal.z(); float u = payload.tex_coords.x(); float v = payload.tex_coords.y(); float w = payload.texture->width; float h = payload.texture->height; Eigen::Vector3f t = Eigen::Vector3f(x*y/sqrt(x*x+z*z),sqrt(x*x+z*z),z*y/sqrt(x*x+z*z)); Eigen::Vector3f b = normal.cross(t); Eigen::Matrix3f TBN; TBN &lt;&lt; t, b, normal; // In theory the texture should be a grayscale image // However we use an ordinary RGB image here, so we take norm // read https://games-cn.org/forums/topic/frequently-asked-questionskeep-updating/ for more details float dU = kh * kn * (payload.texture->getColor(u+1.0f/w, v).norm() - payload.texture->getColor(u, v).norm()); float dV = kh * kn * (payload.texture->getColor(u, v+1.0f/h).norm() - payload.texture->getColor(u, v).norm()); Eigen::Vector3f ln = Eigen::Vector3f(-dU, -dV, 1); // In theory we should bias the point using the original normal // but to match the homework answer, we bias the point using the corrected normal normal = (TBN * ln).normalized(); point += kn * normal * payload.texture->getColor(u, v).norm(); Eigen::Vector3f result_color = &#123;0, 0, 0&#125;; Eigen::Vector3f ambient = ka.cwiseProduct(amb_light_intensity); result_color += ambient; for (auto&amp; light : lights) &#123; // TODO: For each light source in the code, calculate what the *ambient*, *diffuse*, and *specular* // components are. Then, accumulate that result on the *result_color* object. Eigen::Vector3f vec_to_light = light.position - point; Eigen::Vector3f diffuse = kd.cwiseProduct(light.intensity / vec_to_light.squaredNorm()) * MAX(0.0f, normal.normalized().dot(vec_to_light.normalized())); Eigen::Vector3f vec_to_eye = eye_pos - point; Eigen::Vector3f h = vec_to_light.normalized() + vec_to_eye.normalized(); Eigen::Vector3f specular = ks.cwiseProduct(light.intensity / vec_to_light.squaredNorm()) * pow(MAX(0.0f, normal.normalized().dot(h.normalized())), p); // The ambient component is only added once before the for loop result_color += (diffuse + specular); &#125; return result_color * 255.f; &#125;","categories":[{"name":"公开课","slug":"公开课","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"GAMES101","slug":"公开课/GAMES101","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/"},{"name":"Assignments","slug":"公开课/GAMES101/Assignments","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/Assignments/"}],"tags":[]},{"title":"Assignment 2 Rasterizing","slug":"learning/open-course/GAMES101/Hw/Hw2-rasterizing","date":"2025-08-26T12:15:16.000Z","updated":"2025-08-26T12:21:11.482Z","comments":true,"path":"wiki/learning/open-course/GAMES101/Hw/Hw2-rasterizing/","permalink":"http://rinevard.github.io/wiki/learning/open-course/GAMES101/Hw/Hw2-rasterizing/","excerpt":"","text":"本次作业要求我们实现 Z-buffer 、栅格化和 SSAA（也就是超采样）。我们先看看前两个东西，再看看 SSAA。 Z-buffer和栅格化代码框架我们要补全的 rasterize_triangle 函数在 draw 函数内被调用，可以看到 draw 函数已经做好了三角形的投影变换，我们只要把 $[0, \\text{width}] \\times [0,\\text{height}] \\times [n,f]$ 里的三角形渲染到屏幕上就好。输入的三角形大概形如这样： -------input triangle--------- 529.259 350 49.3857 1 -- 350 529.259 49.3857 1 -- 170.741 350 49.3857 1 -- ----------------------------- insideTriangle 函数用课上讲的叉乘法判断点是否在三角形内。“在三角形内”这个说法也不是特别严谨，更准确地说应该是判断三角形在屏幕上的二维投影是否包含这个点。 /* Return whether (x, y) is in the triangle, ignoring its z value. */ static bool insideTriangle(float x, float y, const std::array&lt;Vector4f, 3>&amp; triangle) &#123; Vector2f point1 = &#123;triangle[0].x(), triangle[0].y()&#125;; Vector2f point2 = &#123;triangle[1].x(), triangle[1].y()&#125;; Vector2f point3 = &#123;triangle[2].x(), triangle[2].y()&#125;; Vector2f checked_point = &#123;x, y&#125;; auto cross_product = [](const Vector2f&amp; v1, const Vector2f&amp; v2) &#123; return v1.x() * v2.y() - v1.y() * v2.x(); &#125;; float side1 = cross_product(point1 - checked_point, point1 - point2); float side2 = cross_product(point2 - checked_point, point2 - point3); float side3 = cross_product(point3 - checked_point, point3 - point1); return (side1 > 0 &amp;&amp; side2 > 0 &amp;&amp; side3 > 0) || (side1 &lt; 0 &amp;&amp; side2 &lt; 0 &amp;&amp; side3 &lt; 0); &#125; rasterize_triangle 函数这个实现好像没什么特别值得说的地方，简简单单采采样，然后用 depth_buf 实现 z-buffer 就好。 //Screen space rasterization void rst::rasterizer::rasterize_triangle(const Triangle&amp; t) &#123; auto v = t.toVector4(); // Find bounding box float left = v[0].x(); float right = v[0].x(); float bottom = v[0].y(); float top = v[0].y(); for (auto&amp; vec: v) &#123; left = std::min(left, vec.x()); right = std::max(right, vec.x()); bottom = std::min(bottom, vec.y()); top = std::max(top, vec.y()); &#125; // Update pixels in bounding box for (int x = static_cast&lt;int>(left); x &lt;= static_cast&lt;int>(right) + 1; x++) &#123; for (int y = static_cast&lt;int>(bottom); y &lt;= static_cast&lt;int>(top) + 1; y++) &#123; if (!insideTriangle(x+0.5, y+0.5, v)) &#123; continue; &#125; // Interpolate z value auto[alpha, beta, gamma] = computeBarycentric2D(x+0.5, y+0.5, t.v); float w_reciprocal = 1.0/(alpha / v[0].w() + beta / v[1].w() + gamma / v[2].w()); float z_interpolated = alpha * v[0].z() / v[0].w() + beta * v[1].z() / v[1].w() + gamma * v[2].z() / v[2].w(); z_interpolated *= w_reciprocal; // A lower z-value means it is displayed in front if (z_interpolated &lt; depth_buf[y * width + x]) &#123; depth_buf[y * width + x] = z_interpolated; set_pixel(Vector3f(x, y, z_interpolated), t.getColor()); &#125; &#125; &#125; &#125; SSAA的实现SSAA 的实现相较而言更困难一些，由于杂七杂八要改的地方比较多，我就先说下大致思路，再聊聊咱踩的两个坑。 不过在此之前，先来看看我们的成果吧！（这是动图 大致思路我们要先把所有内容渲染到大小为 $(\\text{width} * 2, \\text{height} * 2)$ 的自定义 buffer 里，再根据自定义 buffer 的内容填充屏幕上的像素。 要注意的是，我们不能直接在 rasterize_triangle 里把三角形画到屏幕上（具体原因见“踩坑1”那一节），而是要在 rasterize_triangle 中把三角形画到自定义的 buffer 里，再新增一个 resolve 函数并把它放到 draw 的最后，从而把自定义 buffer 里的内容画到屏幕上： void rst::rasterizer::resolve() &#123; for (int y = 0; y &lt; height; y++) &#123; for (int x = 0; x &lt; width; x++) &#123; frame_buf[y * width + x] = Vector3f::Zero(); for (int i = 0; i &lt; 4; i++) &#123; frame_buf[y * width + x] += ssaa_frame_buf[(y * width + x) * 4 + i]; &#125; frame_buf[y * width + x] /= 4.0; &#125; &#125; &#125; 更细节一些的话，我们需要做这些工作： 在 rasterizer.hpp 里加入 ssaa_frame_buf 和 resolve 的定义。 修改 rasterizer 的初始化函数和 clear 函数，正确初始化和重置 ssaa_frame_buf。 修改 set_pixel 函数，让它把内容画到 ssaa_frame_buf 里，而非 frame_buf 里。 修改 rasterize_triangle，让它用使用更高的采样率。 实现 resolve 函数。 杂七杂八要改的地方比较多，这里就不放更多代码了。 踩坑1SSAA、filtering 都建立在“我们对理想图像进行滤波”的基础上。也就是说，要先把世界里的对象按正确的前后顺序变为一个二维图像，然后再滤波。所以直接在 rasterize_triangle 里把像素划分成子像素然后取平均并不能实现 SSAA，而是会在三角形重叠的地方显示出黑边。 让我们来看一个具体例子。考虑一个 1/4 被绿色三角形占据、3/4 被蓝色三角形占据的像素，SSAA 会把 1/4 绿 + 3/4 蓝 作为这个像素的颜色。 而如果直接在 rasterize_triangle 里把像素划分成子像素然后取平均，那么栅格化蓝色三角形时，这个像素被当成 3/4 蓝；栅格化绿色三角形时，这个像素被当成 1/4 绿。无论谁在前面，最终结果要么是 3/4 蓝，要么是 1/4 绿，总与 SSAA 的结果 1/4 绿 + 3/4 蓝 不同。 踩坑2insideTriangle 的参数 x 和 y 的类型原本是 int，而在 SSAA 里我们把像素划分成了四个子像素，这些子像素的坐标大多不是整数。因此我们要把 insideTriangle 的 x 和 y 的类型改成 float. static bool insideTriangle(int x, int y, const Vector3f* _v) &#123; // TODO : Implement this function to check if the point (x, y) is inside the triangle represented by _v[0], _v[1], _v[2] &#125;","categories":[{"name":"公开课","slug":"公开课","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"GAMES101","slug":"公开课/GAMES101","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/"},{"name":"Assignments","slug":"公开课/GAMES101/Assignments","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/Assignments/"}],"tags":[]},{"title":"Note 2 Rasterizing","slug":"learning/open-course/GAMES101/Notes/Note2-Rasterizing","date":"2025-08-25T08:10:28.000Z","updated":"2025-09-23T07:19:39.089Z","comments":true,"path":"wiki/learning/open-course/GAMES101/Notes/Note2-Rasterizing/","permalink":"http://rinevard.github.io/wiki/learning/open-course/GAMES101/Notes/Note2-Rasterizing/","excerpt":"","text":"在 Transformation 部分，我们已经可以把一个三维空间里的三角形投影到平面上。但怎么把一个纯色三角形绘制到屏幕上呢？我们知道屏幕由大量的像素点组成，那么怎么确定每个像素点是什么颜色呢？ 我们通过采样给每个像素点涂上颜色。我们可以检查每个像素的中心点是否在这个三角形内部，如果在则涂上三角形的颜色。虽然这样绘制的三角形会有锯齿，效果一般，但基本思想就是这样。 那么如果有多个三角形，而且他们之间有遮挡关系呢？这就需要 Z-Buffer 出场了。 Z-BufferZ-Buffer 的算法如下面的伪代码所示。思路是对每个像素所在的所有三角形，取 z 值最小的三角形的颜色作为这个像素的颜色。 foreach (Triangle triangle in triangles) &#123; foreach (Vector3 sample in triangle.GetSamples()) &#123; // z 值越小显示越靠前 if (sample.z &lt; zBuffer[sample.x, sample.y]) &#123; frameBuffer[sample.x, sample.y] = sample.rgb; zBuffer[sample.x, sample.y] = sample.z; &#125; &#125; &#125; 这也有良好的并行性，因为三角形的遍历顺序和最终结果无关，像素的绘制顺序也和最终结果无关。 虎书还提到我们会将 $z$ 值映射到 $[0, B-1]$，用整数存储 $z$ 值，但其实这是现在不再使用的方法，我们现在通常使用 24 位或 32 位的浮点数来存储深度值。（怪不得我查了好久资料都没查到“整数映射”的具体代码，原来早就不用了！！！） 走样现象我们之前说过，简单的采样会出现锯齿，如下图所示。 锯齿、摩尔纹之类的采样图像与原图不符的现象被统称为走样（Aliasing）现象，走样的实质是原图的高频信号被错误采样。为了明确什么是”高频信号”并找到缓解走样现象的方法，我们先看看一些数学知识。 数学知识为了不让文章太长，这里我们省略所有的证明。不过所有的证明都并不困难，有空的话可以自己证一下试试。在开始之前，我们会问：这些数学知识有用吗？ In a word, mostly no, sometimes yes, and occasionally, maybe.— https://www.dgp.toronto.edu/public_user/elf/2522/sampling.pdf 卷积我们先来看看三种卷积——离散-离散卷积、连续-连续卷积、离散-连续卷积。下面的 $f_{\\rightarrow t}$ 表示将函数 $f$ 向右平移 $t$ 长度得到的新函数： 离散-离散卷积 $$\\begin{align}&amp;(ab)[i]=\\sum_{j}a[j]b[i-j]\\&amp;(ab)=\\sum_{j}a[j]b_{\\rightarrow j}\\end{align}$$ 连续-连续卷积 $$\\begin{align}&amp;(fg)(x)=\\int_{-\\infty}^{\\infty}f(t)g(x-t)dt\\&amp;(fg)=\\int_{-\\infty}^{\\infty}f(t)g_{\\rightarrow t}dt\\end{align}$$ 离散-连续卷积 $$\\begin{align}&amp;(af)(x)=\\sum_{i}a[i]f(x-i)\\&amp;(af)=\\sum_{i}a[i]f_{\\rightarrow i}\\end{align}$$ 我们会注意到，卷积可以表示为函数平移后的加权和。 卷积是过会儿会用到的妙妙小工具。 傅里叶级数和傅里叶变换我们之前提到，走样的实质是原图的高频信号被错误采样。图像作为一个 $R^2\\rightarrow \\text{RGBA}$的函数，怎么会有高频和低频之分呢？uh actually☝️🤓 我们处理的绝大多数函数都有频域，这个频域可以通过傅里叶变换得到。 先回顾一下傅里叶级数。熟知在 $[-\\frac{T}{2},\\frac{T}{2}]$ 内，函数 $f(x)$ 可以表示为 $$f(x)=\\sum_{n=-\\infty}^{\\infty}c_n e^{inw_0 x}$$ 其中 $$\\begin{align*}&amp;c_n=\\frac{1}{T}\\int_{-\\frac{T}{2}}^{\\frac{T}{2}} f(t)e^{-inw_0t}dt\\&amp;w_0=\\frac{2\\pi}{T} \\end{align*}$$ 这本质上是函数在闭区间内的正交基展开，这个展开的周期为 $T$. 当 $T \\rightarrow \\infty$ 时，令 $w_n=nw_0$，$\\Delta w=w_n-w_{n-1}=w_0$ 再结合积分的定义，我们就能（不太严谨地）求出 $$f(x)=\\frac{1}{2\\pi}\\int_{-\\infty}^{\\infty}\\bigg(\\int_{-\\infty}^{\\infty}f(t)e^{-iwt}dt \\bigg)e^{iwx}dw$$ 我们可以令 $u=\\frac{w}{2\\pi}$ 从而去掉积分外面的那个系数 $$f(x)=\\int_{-\\infty}^{\\infty}\\bigg(\\int_{-\\infty}^{\\infty}f(t)e^{-2\\pi iut}dt \\bigg)e^{2\\pi iux}du$$ 而 $e^{2\\pi iux}$ 的系数 $$\\hat f(u)=\\int_{-\\infty}^{\\infty}f(t)e^{-2\\pi iut}dt$$ 就是 $f$ 的傅里叶变换了，它也记作 $\\mathcal{F}(f)$. 把 $\\hat f$ 代入就得到了逆傅里叶变换 $$f(x)=\\int_{-\\infty}^{\\infty}\\hat f(u)e^{2\\pi iux}du$$ 逆傅里叶变换把函数变成了不同频率的三角函数的积分/求和，这就是我们之前所说的“高频信号”和“低频信号”的含义。之后我们会介绍采样导致高频信号丢失的原因，不过在此之前我们先看看傅里叶变换的一些性质。 傅里叶变换的性质我们列举傅里叶变换的几个常用的性质。 如果 $f$ 是实函数，$\\hat f$ 是偶函数。 函数和傅里叶变换的平方积分相等 $$ \\int (f(x))^2dx=\\int (\\hat f(u))^2du $$ 原函数拉长，傅里叶变换收紧 $$ \\mathcal{F}(f(x/b))=b\\hat f(bu) $$ 狄拉克脉冲函数和冲激串狄拉克脉冲函数的定义如下： $$\\delta(t) =\\begin{cases}\\infty, &amp; t = 0 \\0, &amp; t \\neq 0\\end{cases}$$ 我们可以把连续信号的均匀间隔采样表示为冲激串 $$s_T(x) = \\sum_{n=-\\infty}^{\\infty}\\delta(x-nT)$$ 与原函数 $f$ 的乘积，这里的 $T$ 表示两个采样点之间的间隔。 $s_T$ 的傅里叶变换为 $$\\hat s_T(u)=\\frac{1}{T}\\sum_{n=-\\infty}^{\\infty}\\delta(u-\\frac{n}{T})$$ 它仍然是一系列狄拉克函数的和。 卷积定理之前说过，将 $s_T$ 和原函数 $f$ 相乘能获得许多重要的采样性质，我们很快就会讨论他们了，在此之前我们还要补充最后一个知识——卷积定理。 $$\\begin{align}&amp;\\mathcal{F}(f g)=\\hat f\\hat g\\&amp;\\mathcal{F}(fg)=\\hat f \\hat g\\end{align}$$ 这就是说，时域的卷积对应频域的乘积，频域的乘积对应时域的卷积。 走样的原因一开始我们就说过，走样的实质是原图的高频信号被错误采样。现在我们的数学工具已经足以分析究竟为什么发生了错误采样，以及如何缓解他们了。 先来看看为什么我们没有正确采样高频信号。 假设我们希望对这样的函数进行采样，通过傅里叶变换我们可以得到其频域（右一） 我们之前说过，可以把连续函数的均匀间隔采样表示为冲激串 $s_{T}(x)=\\sum_{n=-\\infty}^{\\infty}\\delta(x-nT)$ 和原函数 $f$ 的乘积，而我们也已经知道冲激串的傅里叶变换还是冲激串 $$\\hat s_T(u)=\\frac{1}{T}\\sum_{n=-\\infty}^{\\infty}\\delta(u-\\frac{n}{T})$$ 再结合卷积定理 $\\mathcal{F}(s_Tf)=\\hat s_T * \\hat f$，以及“卷积就是函数平移后的加权和”，我们就能推出，采样结果的傅里叶变换就是原函数的傅里叶变换的无穷个复制各按 $\\frac{n}{T}$ 平移的和。 由于我们的采样间隔 $T$ 不够小，即采样率 $\\frac{1}{T}$ 不够大，所以相邻的两个复制间发生了重叠，导致高频信号和低频信号产生混合，这就引起了走样。而这正是“高频信号被错误采样”的实质。 当我们在光栅化时，我们还把像素填上了颜色，这是在“reconstruction”即重建图像。不过由于在采样时我们已经发生了走样，无论怎么重建都不会有一个非常完美的结果了。 滤波器和走样的缓解方法为了缓解走样，我们自然就要避免发生重叠。避免发生重叠的思路主要有两种： 增加采样率，这样就能让相邻的两个复制距离增大。 用滤波器减弱高频信号的强度。 对图像的光栅化来说，增加分辨率就对应前者；在采样前对原图应用各种滤波器就对应后者。 我们当然会问，增加采样率能缓解走样，那增加到多大合适呢？我们希望相邻的两个复制间的距离足够大以至于不发生重叠，这就需要输入信号的最高频率小于采样频率的一半。采样频率的一半也被称为奈奎斯特频率。理论上说，只要奈奎斯特频率高于被采样信号的最高频率，我们就能完美复原原信号。 接下来我们看看几个常见的滤波器，它们常被用于和别的函数做卷积。由于我们知道卷积可以被理解为一种“加权平均”，所以我们希望滤波器都是归一化的。 名称 公式 Box filter（离散） $a_{\\text{box},r}[i] =\\begin{cases}1/(2r + 1) &amp; |i| \\le r, \\0 &amp; \\text{otherwise}.\\end{cases}$ Box filter（连续） $f_{\\text{box},r}(x) =\\begin{cases}1/(2r) &amp; -r \\le x &lt; r, \\0 &amp; \\text{otherwise}.\\end{cases}$ Tent filter $f_{\\text{tent}}(x) =\\begin{cases}1 - |x| &amp; |x| &lt; 1, \\0 &amp; \\text{otherwise};\\end{cases}$ Gaussian filter $f_{g, \\sigma}(x) = \\frac{1}{\\sigma\\sqrt{2\\pi}}e^{-x^2/2\\sigma^2}$ 名称 公式 B-Spline Cubic Filter $f_B(x) = \\frac{1}{6}\\begin{cases}-3(1 - |x|)^3 + 3(1 - |x|)^2 + 3(1 - |x|) + 1 &amp; -1 \\le x \\le 1, \\(2 - |x|)^3 &amp; 1 \\le |x| \\le 2, \\0 &amp; \\text{otherwise}.\\end{cases}$ Catmull-Rom Cubic Filter $f_C(x) = \\frac{1}{2}\\begin{cases}-3(1 - |x|)^3 + 4(1 - |x|)^2 + (1 - |x|) &amp; -1 \\le x \\le 1, \\(2 - |x|)^3 - (2 - |x|)^2 &amp; 1 \\le |x| \\le 2, \\0 &amp; \\text{otherwise}.\\end{cases}$ Mitchell-Netravali Cubic Filter $f_M(x) = \\frac{1}{3}f_B(x) + \\frac{2}{3}f_C(x)\\= \\frac{1}{18}\\begin{cases}-21(1 - |x|)^3 + 27(1 - |x|)^2 + 9(1 - |x|) + 1 &amp; -1 \\le x \\le 1, \\7(2 - |x|)^3 - 6(2 - |x|)^2 &amp; 1 \\le |x| \\le 2, \\0 &amp; \\text{otherwise}.\\end{cases}$ 除了过滤高频信号之外，滤波器还在重建图像时发挥着重要作用。还记得吗，离散-连续卷积能把一系列离散点变成一个连续函数。在根据采样点重建图像时，我们基本就是在做采样点和滤波器的卷积。在光栅化的“把每个像素点的中心采样颜色填到像素点上”这一步中，我们就是在将采样点和 Box filter 做卷积。 总而言之，为了缓解走样，我们可以以图像细节丰富度为代价，先用低通滤波器滤波，再采样+重建。当然，如果我们有更高分辨率的屏幕就更好了~ 其他小知识常见滤波器的傅里叶变换 卷积的单位元任何离散信号和单位脉冲序列做卷积，结果还是原本的离散信号 $$\\delta[n] =\\begin{cases}1, &amp; n = 0 \\0, &amp; n \\neq 0\\end{cases}$$ 任何连续信号和狄拉克函数做卷积，结果还是原本的连续信号 $$\\delta(t) =\\begin{cases}\\infty, &amp; t = 0 \\0, &amp; t \\neq 0\\end{cases}$$ 二维卷积和二维滤波器我们这里只给出连续-连续的二维卷积，别的情况都差不多。 $$\\begin{align}&amp;(fg)(x,y)=\\int\\intf(x-x’,y-y’)g(x’,y’)dx’dy’\\end{align*}$$ 对滤波器 $f(x)$，我们简单地定义 $g(x,y)=f(x)f(y)$ 就得到了这个滤波器对应的二维滤波器。一个比较好的性质是，如果 $f$ 是归一化的，那么 $g$ 也是归一化的。 伽马值显示器的显示亮度关于输入信号不是线性关系。假设输入信号为 $a\\in[0,1]$，则有 $$\\text{Displayed intensity}=(\\text{Maximum intensity})a^\\gamma$$ 这里的 $\\gamma$ 一般在 $2.2$ 左右。虽然在最开始这是 CRT 显示器的物理特性所致，但有趣的是，人眼也恰好对暗部变化比亮部变化更敏感，所以它现在作为一个刻意的设计保留了下来。 伽马矫正在影像系统中也有极大作用。假设我们在拍摄一个苹果的照片，苹果的物理亮度是 $0.5$，相机忠实地把它记录了下来。而当显示器显示时，就显示出了 $0.5^{2.2}\\approx 0.22$ 的物理亮度，这显然不是我们想要的。因此在我们拍摄照片之后，相机的图像处理器就会自动对照片进行伽马矫正。 图像锐化Unsharp Mask 是一个经典的图像锐化算法。令高斯模糊核为 $G$，冲激函数为 $\\delta$，它先提取原始图像的高频信号 $$I_{detail} = I_{orig} - I_{orig} * G$$ 再把这些高频信号加入回原图中 $$I_{sharp} = I_{orig} + \\alpha I_{detail}$$ 综合起来就是 $$I_{sharp}=I_{orig}*((1+\\alpha)\\delta-G)$$ 图像缩放直接对一个像素化的图像采样虽然效率很高，但效果不佳。先用连续的滤波器重建信号，再用低通滤波器过滤高频信号，再采样会得到更好的结果，这被称为 resampling，重采样。","categories":[{"name":"公开课","slug":"公开课","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"GAMES101","slug":"公开课/GAMES101","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/"},{"name":"Notes","slug":"公开课/GAMES101/Notes","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/Notes/"}],"tags":[]},{"title":"Assignment 1 Transformation","slug":"learning/open-course/GAMES101/Hw/Hw1-transformation","date":"2025-08-22T03:00:58.000Z","updated":"2025-08-22T03:14:43.978Z","comments":true,"path":"wiki/learning/open-course/GAMES101/Hw/Hw1-transformation/","permalink":"http://rinevard.github.io/wiki/learning/open-course/GAMES101/Hw/Hw1-transformation/","excerpt":"","text":"本次作业要求我们实现旋转矩阵、投影矩阵。我们先简单看下作业是怎么做的，再看看代码框架里的几个有趣的地方。 作业实现两个旋转矩阵绕 $z$ 轴的旋转矩阵实现起来很简单，把课上的内容翻译成代码就好。在使用 std 的 sin 和 cos 时要注意把角度转换成弧度。 Eigen::Matrix4f get_model_matrix(float rotation_angle) &#123; Eigen::Matrix4f model = Eigen::Matrix4f::Identity(); float angle_rad = rotation_angle * MY_PI / 180.0; Eigen::Matrix4f rotate; float sine = std::sin(angle_rad); float cosine = std::cos(angle_rad); rotate &lt;&lt; cosine, -sine, 0, 0, sine, cosine, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1; model = rotate * model; return model; &#125; 提高项里的旋转矩阵用课上讲的 Rodrigues’ rotation formula 就行： /* Computes the 4x4 rotation matrix representing a rotation of rotation_angle (in degree) around a given normalized axis vector that passes through the origin, using Rodrigues' rotation formula. */ Eigen::Matrix4f get_rotation(Vector3f axis, float rotation_angle) &#123; float angle_rad = rotation_angle * MY_PI / 180.0; Eigen::Matrix3f rot_mat = std::cos(angle_rad) * Eigen::Matrix3f::Identity(); rot_mat += (1 - std::cos(angle_rad)) * axis * axis.transpose(); Eigen::Matrix3f cross_product_mat; cross_product_mat &lt;&lt; 0, -axis.z(), axis.y(), axis.z(), 0, -axis.x(), -axis.y(), axis.x(), 0; rot_mat += std::sin(angle_rad) * cross_product_mat; Eigen::Matrix4f trans_mat = Eigen::Matrix4f::Identity(); trans_mat.topLeftCorner&lt;3, 3>() = rot_mat; return trans_mat; &#125; 投影矩阵投影矩阵就相对复杂一些了，先上代码 Eigen::Matrix4f get_projection_matrix(float eye_fov, float aspect_ratio, float zNear, float zFar) &#123; // Students will implement this function Eigen::Matrix4f projection = Eigen::Matrix4f::Identity(); Eigen::Matrix4f perspective; float cotangent = 1.0 / std::tan(eye_fov / 2.0); float z_delta = zFar - zNear; perspective &lt;&lt; cotangent / aspect_ratio, 0, 0, 0, 0, cotangent, 0, 0, 0, 0, -(zFar + zNear) / z_delta, -2 * zFar * zNear / z_delta, 0, 0, -1, 0; projection = perspective * projection; return projection; &#125; 首先我们会发现输入的 zNear 和 zFar 都是正数，他们表示近平面和远平面到原点的距离，这与课上讲的不同。课上讲的 $n$ 和 $f$ 表示近平面和远平面在 $z$ 轴的坐标，他们是负数。 然后我们分析 rasterizer.cpp 里的 draw 函数，下面这段代码里，v 是三角形的三个顶点构成的数组，三个顶点都已经被变换到了 $[-1,1]^3$ 的正方体中。 注意 vert.z() = vert.z() * f1 + f2 这行代码，把 $-1$ 代入右边得到 $-n$，$1$ 代入右边得到 $-f$，因此我们有理由猜测 $[-n,-f]$ 被映射到了 $[-1,1]$. float f1 = (100 - 0.1) / 2.0; float f2 = (100 + 0.1) / 2.0; // ... for (auto &amp; vert : v) &#123; vert.x() = 0.5*width*(vert.x()+1.0); vert.y() = 0.5*height*(vert.y()+1.0); vert.z() = vert.z() * f1 + f2; &#125; 总结一下我们的发现： 输入的 zNear 和 zFar 都是正数，表示近平面和远平面到原点的距离 $[-n,-f]$ 被映射到了 $[-1,1]$ 最终我们能写出这样的投影矩阵： $$\\large\\text{M}_\\text{per} =\\begin{bmatrix}\\frac{1}{\\text{aspect} \\times \\tan(\\frac{\\text{fov}}{2})} &amp; 0 &amp; 0 &amp; 0 \\0 &amp; \\frac{1}{\\tan(\\frac{\\text{fov}}{2})} &amp; 0 &amp; 0 \\0 &amp; 0 &amp; -\\frac{f+n}{f-n} &amp; -\\frac{2fn}{f-n} \\0 &amp; 0 &amp; -1 &amp; 0\\end{bmatrix}$$ 翻译成代码就好。 代码框架里有趣的地方ind 的作用首先我们看向 main.cpp 的 main 函数里的这段代码 std::vector&lt;Eigen::Vector3f> pos&#123;&#123;2, 0, -2&#125;, &#123;0, 2, -2&#125;, &#123;-2, 0, -2&#125;&#125;; std::vector&lt;Eigen::Vector3i> ind&#123;&#123;0, 1, 2&#125;&#125;; pos 显然是三角形的三个顶点，但 ind 是做什么的？uh actually🤓☝️它定义了如何将顶点连接起来。对三角形来说它当然没什么用，但对多边形来说，它就很有用了。 比如说，想象一下我们在画一个六边形，我们需要六个顶点。但由于在渲染时我们主要绘制三角形，所以我们要把六边形拆分成多个三角形，而拆分出的每个三角形就对应着 ind 里的一个元素了。 对六边形来说，我们可能会定义下面这样的 pos 和 ind std::vector&lt;Eigen::Vector3f> pos &#123; &#123;2, 0, -2&#125;, // 0: 右 &#123;1, 1.732, -2&#125;, // 1: 右上 &#123;-1, 1.732, -2&#125;, // 2: 左上 &#123;-2, 0, -2&#125;, // 3: 左 &#123;-1, -1.732, -2&#125;,// 4: 左下 &#123;1, -1.732, -2&#125; // 5: 右下 &#125;; std::vector&lt;Eigen::Vector3i> ind &#123; &#123;0, 1, 2&#125;, &#123;0, 2, 3&#125;, &#123;0, 3, 4&#125;, &#123;0, 4, 5&#125; &#125;; id 的作用继续看向 main.cpp 的 main 函数，把目光投向这段代码 auto pos_id = r.load_positions(pos); auto ind_id = r.load_indices(ind); // ... r.draw(pos_id, ind_id, rst::Primitive::Triangle); 在这里，我们把 id 传入了 draw 函数来画图。但为什么要用 id 呢？直接 &amp; 传参不行吗？ 【TODO：我不知道。AI说在正式的渲染代码里，我们会在load时做一些操作诸如把数据上传到显存，或者重新组织上传的各个数据来提高效率，但咱也不知道是不是真的。】","categories":[{"name":"公开课","slug":"公开课","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"GAMES101","slug":"公开课/GAMES101","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/"},{"name":"Assignments","slug":"公开课/GAMES101/Assignments","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/Assignments/"}],"tags":[]},{"title":"Note 1 Transformation","slug":"learning/open-course/GAMES101/Notes/Note1-transformation","date":"2025-08-19T07:10:28.000Z","updated":"2025-08-22T03:14:43.967Z","comments":true,"path":"wiki/learning/open-course/GAMES101/Notes/Note1-transformation/","permalink":"http://rinevard.github.io/wiki/learning/open-course/GAMES101/Notes/Note1-transformation/","excerpt":"","text":"2D Transformation在二维空间中，我们能用二维矩阵表示所有的线性变换。但二维空间中的平移在二维空间中不是线性变换，因此我们希望找到另一个空间，并将二维空间嵌入，让二维平移在这个空间中变为线性变换。把笛卡尔坐标扩展为齐次坐标，就得到了这样的空间。 对二维空间的一点 $(x,y)$，三元组 $(xZ,yZ,Z)$ 即为该点的齐次坐标。如 $(1,2)$ 可表示为 $(1,2,1)$ 或 $(100,200,100)$. 换句话说，二维空间的任何点都能表示为齐次坐标 $(X,Y,Z)$，其中 $Z\\neq 0$. 另外，如果我们把无穷远点也考虑进来，我们就可以用 $(x,y,0)$ 表示无穷远点。 叽里咕噜说什么呢，快告诉我怎么用线性变换表示平移！ 对二维空间的一点 $(x,y)$，首先将它转化为齐次坐标得到 $(x,y,1)$，然后与下面的矩阵相乘 $$M = \\begin{bmatrix}1 &amp; 0 &amp; t_x \\0 &amp; 1 &amp; t_y \\0 &amp; 0 &amp; 1\\end{bmatrix}$$ 就得到了 $(x+t_x,y+t_y,1)$. 然后再转换回笛卡尔坐标，就得到了 $(x+t_x,y+t_y)$. 这样一来，旋转、平移就能统一成下面的形式： $$M = \\begin{bmatrix}\\cos \\theta &amp; -\\sin \\theta &amp; t_x \\\\sin \\theta &amp; \\cos \\theta &amp; t_y \\0 &amp; 0 &amp; 1\\end{bmatrix}$$ 3D Transformation与二维的情况类似，我们也把三维空间嵌入一个新空间。 对三维空间的一点 $(x,y,z)$，三元组 $(xS,yS,zS,S)$ 即为该点的齐次坐标。如 $(1,2,3)$ 可表示为 $(1,2,3,1)$ 或 $(100,200,300,100)$. 换句话说，三维空间的任何点都能表示为齐次坐标 $(X,Y,Z,S)$，其中 $S\\neq 0$. 我们这里讨论右手坐标系，下面给出按右手定则旋转 $\\theta$ 角度的矩阵： $$R_x(\\theta) = \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; \\cos \\theta &amp; -\\sin \\theta &amp; 0 \\ 0 &amp; \\sin \\theta &amp; \\cos \\theta &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix}$$ $$R_y(\\theta) = \\begin{bmatrix} \\cos \\theta &amp; 0 &amp; \\sin \\theta &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; 0 \\ -\\sin \\theta &amp; 0 &amp; \\cos \\theta &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix}$$ $$R_z(\\theta) = \\begin{bmatrix} \\cos \\theta &amp; -\\sin \\theta &amp; 0 &amp; 0 \\ \\sin \\theta &amp; \\cos \\theta &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix}$$ 你会注意到沿 $y$ 轴旋转的矩阵和别的不一样，但这是完全正确的，认真算一算就好了。 （我没感觉这里有什么“深刻含义”，但感觉即使有也应该不会很有用……） （不过不知道如果推广到 $n$ 维旋转会不会有用） （可我们生活在三次元！） 值得注意的是，旋转矩阵都是正交矩阵，所以它的转置就是它的逆。 世界上还存在一个叫做 Rodrigues 旋转公式的东西，它给出了向量 $v$ 绕单位向量 $k$ 旋转 $\\theta$ 角度得到的结果。（按右手定则旋转） $$\\mathbf{v}_{\\text{rot}} = \\mathbf{v} \\cos\\theta + (\\mathbf{k} \\times \\mathbf{v}) \\sin\\theta +\\\\mathbf{k}(\\mathbf{k} \\cdot \\mathbf{v})(1 - \\cos\\theta)$$ 当然也可以把这个旋转矩阵写出来： $$\\mathbf{R}(\\mathbf{k}, \\theta) = \\cos(\\theta)\\mathbf{I} + (1 - \\cos(\\theta))\\mathbf{k}\\mathbf{k}^T + \\sin(\\theta)\\begin{bmatrix} 0 &amp; -k_z &amp; k_y \\ k_z &amp; 0 &amp; -k_x \\ -k_y &amp; k_x &amp; 0 \\end{bmatrix}$$ 最右边那个矩阵是 $k$ 的叉乘矩阵啦~ Viewing transformation2D 和 3D transformation 都是基础变换，接下来我们研究游戏里的画面是如何渲染到屏幕上的。 如下图所示，我们有一个摄像机、两个方块，那么我们是怎么计算出摄像机拍摄的画面的呢（参考右下角）？ 我们按照下面的流程进行操作： Camera transformation首先，我们变换空间让摄像机位于坐标原点，且面向 $z$ 轴负方向，头顶朝 $y$ 轴正方向。对上图来说，就是把 $w$ 变换为 $z$ 轴，把 $v$ 变换为 $y$ 轴。 对应的矩阵是 $$\\text{M}_{\\text{cam}} =\\begin{bmatrix}u_x &amp; u_y &amp; u_z &amp; 0 \\v_x &amp; v_y &amp; v_z &amp; 0 \\w_x &amp; w_y &amp; w_z &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}\\times\\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; -\\text{cam}_x \\0 &amp; 1 &amp; 0 &amp; -\\text{cam}_y \\0 &amp; 0 &amp; 1 &amp; -\\text{cam}_z \\0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}$$ 这里的小技巧是，旋转矩阵的逆是其转置，所以我们先算出 $xyz$ 轴变换到 $uvw$ 轴的旋转矩阵，再对其转置，就得到了把 $uvw$ 变换到 $xyz$ 的矩阵。 Projection transformation然后，我们把相机拍摄的区域变换到 $[-1,1]^3$ 中，这是一个规范化，为未来把区域放到屏幕上做准备。在此之前，我们要先确定相机能够拍摄的区域的范围。这里涉及到的变量主要有 fov、aspect ratio、near、far. 下图能清晰地解释 fov 和 aspect ratio。fov 即 field of view，表示用角度衡量的可见范围；aspect ratio 则是显示区域的宽高比。 near 和 far 则定义了剔除边界，我们只渲染满足 $z \\in [\\text{near}, \\text{far}]$ 的东西。原点、近平面和原平面共同划分出了一块有限的空间，这就是摄像机拍摄的区域（视锥），我们会把他变换到 $[-1,1]^3$ 中。 变换分为两步，第一步是把视锥变换为长方体，第二步把长方体变换为 $[-1,1]^3$ 的正方体。 在第一步变换时，我们希望满足以下两点： near 和 far 平面上的点的 $z$ 值不变 近大远小，且缩放比例符合相似三角形的规律 结合齐次坐标，我们就能得到以下矩阵： $$\\begin{align*}\\text{M}_\\text{per} &amp;= \\begin{bmatrix}\\frac{2}{r-l} &amp; 0 &amp; 0 &amp; -\\frac{r+l}{r-l} \\0 &amp; \\frac{2}{t-b} &amp; 0 &amp; -\\frac{t+b}{t-b} \\0 &amp; 0 &amp; \\frac{2}{n-f} &amp; -\\frac{n+f}{n-f} \\0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}\\times\\begin{bmatrix}n &amp; 0 &amp; 0 &amp; 0 \\0 &amp; n &amp; 0 &amp; 0 \\0 &amp; 0 &amp; n+f &amp; -nf \\0 &amp; 0 &amp; 1 &amp; 0\\end{bmatrix}\\&amp;= \\begin{bmatrix}\\frac{2n}{r-l} &amp; 0 &amp; -\\frac{r+l}{r-l} &amp; 0 \\0 &amp; \\frac{2n}{t-b} &amp; -\\frac{t+b}{t-b} &amp; 0 \\0 &amp; 0 &amp; \\frac{n+f}{n-f} &amp; -\\frac{2nf}{n-f} \\0 &amp; 0 &amp; 1 &amp; 0\\end{bmatrix}\\end{align*}$$ 第一个等号右边的式子中，右边的矩阵把视锥压缩为一个长方体，左边的矩阵把这个长方体变换到 $[-1,1]^3$. 我们可以根据 $\\text{near},\\text{fov},\\text{aspectRatio}$ 求出 $l,t,r,b$. $$\\begin{align*}&amp;\\text{t} = -n \\times \\tan\\left(\\frac{\\text{fov}}{2}\\right)\\&amp;\\text{b} = -\\text{t}\\&amp;\\text{r} = \\text{t} \\times \\text{aspectRatio}\\&amp;\\text{l} = -\\text{r} \\end{align*}$$ 也就是说，我们可以把投影矩阵写为： $$\\large\\text{M}_\\text{per} =\\begin{bmatrix}-\\frac{1}{\\text{aspect} \\times \\tan(\\frac{\\text{fov}}{2})} &amp; 0 &amp; 0 &amp; 0 \\0 &amp; -\\frac{1}{\\tan(\\frac{\\text{fov}}{2})} &amp; 0 &amp; 0 \\0 &amp; 0 &amp; \\frac{n+f}{n-f} &amp; -\\frac{2nf}{n-f} \\0 &amp; 0 &amp; 1 &amp; 0\\end{bmatrix}$$ Viewport transformation最后，我们会把 $[-1,1]^3$ 的内容的宽高映射为屏幕大小。在这个变换中 $z$ 坐标不变，因此变换矩阵为： $$\\large\\text{M}_\\text{viewport}=\\begin{bmatrix}\\frac{width}{2} &amp; 0 &amp; 0 &amp; \\frac{width}{2} \\0 &amp; \\frac{height}{2} &amp; 0 &amp; \\frac{height}{2} \\0 &amp; 0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}$$ 总结总而言之，我们的变换矩阵为 $$\\begin{align}&amp;\\text{M}=\\text{M}\\text{viewport}\\text{M}\\text{per}\\text{M}_\\text{cam}\\end{align}$$ 其中 $$\\begin{align*}&amp;\\text{M}_{\\text{cam}} =\\begin{bmatrix}u_x &amp; u_y &amp; u_z &amp; 0 \\v_x &amp; v_y &amp; v_z &amp; 0 \\w_x &amp; w_y &amp; w_z &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}\\times\\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; -\\text{cam}_x \\0 &amp; 1 &amp; 0 &amp; -\\text{cam}_y \\0 &amp; 0 &amp; 1 &amp; -\\text{cam}z \\0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}\\\\large&amp;\\text{M}\\text{per} =\\begin{bmatrix}-\\frac{1}{\\text{aspect} \\times \\tan(\\frac{\\text{fov}}{2})} &amp; 0 &amp; 0 &amp; 0 \\0 &amp; -\\frac{1}{\\tan(\\frac{\\text{fov}}{2})} &amp; 0 &amp; 0 \\0 &amp; 0 &amp; \\frac{n+f}{n-f} &amp; -\\frac{2nf}{n-f} \\0 &amp; 0 &amp; 1 &amp; 0\\end{bmatrix}\\&amp;\\large\\text{M}_\\text{viewport}=\\begin{bmatrix}\\frac{width}{2} &amp; 0 &amp; 0 &amp; \\frac{width}{2} \\0 &amp; \\frac{height}{2} &amp; 0 &amp; \\frac{height}{2} \\0 &amp; 0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix} \\end{align*}$$ 要注意的是，我们讨论的 $n$ 和 $f$ 被定义为坐标值，它们是小于 0 的。一些地方把 $n$ 和 $f$ 定义为到近/远平面的距离，这是大于 0 的，这会引起投影矩阵的变化。另外，不同的坐标系约定也会引起矩阵的变化。 比如在OpenGL中， $n$ 和 $f$ 被定义为到近/远平面的距离，这是大于 0 的，而且他们的 projection transformation 把拍摄内容从右手坐标系的视图空间映射到左手坐标系的标准设备坐标（NDC）空间。特别地，$z$ 轴的 $[ -n,-f]$ 被映射到 $[-1,1]$ （这似乎说明在 NDC 空间中，$z$ 值较小的内容渲染更靠前？） 他们的 $\\text{M}_\\text{their-per}$ 为： $$\\large\\text{M}_\\text{their-per} =\\begin{bmatrix}\\frac{1}{\\text{aspect} \\times \\tan(\\frac{\\text{fov}}{2})} &amp; 0 &amp; 0 &amp; 0 \\0 &amp; \\frac{1}{\\tan(\\frac{\\text{fov}}{2})} &amp; 0 &amp; 0 \\0 &amp; 0 &amp; -\\frac{f+n}{f-n} &amp; -\\frac{2fn}{f-n} \\0 &amp; 0 &amp; -1 &amp; 0\\end{bmatrix}$$ Godot 使用和 OpenGL 一样的矩阵，下面是他们设置 $\\text{M}_\\text{per}$ 的代码。还要注意的是，他们使用 column-major 的方法存储数据，即 $$M =\\begin{pmatrix}\\text{columns}[0][0] &amp; \\text{columns}[1][0] \\\\text{columns}[0][1] &amp; \\text{columns}[1][1]\\end{pmatrix}$$ void Projection::set_perspective(real_t p_fovy_degrees, real_t p_aspect, real_t p_z_near, real_t p_z_far, bool p_flip_fov) &#123; if (p_flip_fov) &#123; p_fovy_degrees = get_fovy(p_fovy_degrees, 1.0 / p_aspect); &#125; real_t sine, cotangent, deltaZ; real_t radians = Math::deg_to_rad(p_fovy_degrees / 2.0); deltaZ = p_z_far - p_z_near; sine = Math::sin(radians); if ((deltaZ == 0) || (sine == 0) || (p_aspect == 0)) &#123; return; &#125; cotangent = Math::cos(radians) / sine; set_identity(); columns[0][0] = cotangent / p_aspect; columns[1][1] = cotangent; columns[2][2] = -(p_z_far + p_z_near) / deltaZ; columns[2][3] = -1; columns[3][2] = -2 * p_z_near * p_z_far / deltaZ; columns[3][3] = 0; &#125;","categories":[{"name":"公开课","slug":"公开课","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"GAMES101","slug":"公开课/GAMES101","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/"},{"name":"Notes","slug":"公开课/GAMES101/Notes","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/Notes/"}],"tags":[]},{"title":"杀戮尖塔的框架如此自洽，我们能离开它吗？","slug":"game-design/杀戮尖塔框架","date":"2025-07-10T12:22:38.000Z","updated":"2026-01-02T03:36:22.508Z","comments":true,"path":"wiki/game-design/杀戮尖塔框架/","permalink":"http://rinevard.github.io/wiki/game-design/%E6%9D%80%E6%88%AE%E5%B0%96%E5%A1%94%E6%A1%86%E6%9E%B6/","excerpt":"","text":"img{ width: 70%; } 最近在设计卡牌游戏（你知道的，我一直是牌佬），发现以前做的翻牌游戏原型的翻牌玩法本身随机性过强，从而拓展空间过小，但“棋盘上的随从交互”非常有趣，于是就打算从它出发开始进一步设计。初步的想法是做卡牌肉鸽。（哇，又一个卡牌肉鸽） 我对肉鸽并没有特别的喜爱，因为我一直想着，如果我们拿走了玩家的时间，起码要补偿一些什么，而肉鸽似乎并没有补偿一些我很喜欢的东西。不过无论如何，我还是挺喜欢打牌的，杀戮尖塔、炉石狗头人冒险、邪恶冥刻都是我很喜欢的游戏，所以做个卡牌肉鸽也还挺不错。按我的理解，肉鸽最重要的是每个小关卡的体验，因此我就着手开始做每局牌局的原型了。 然后让我们开始最有趣的设计环节！ 现在我们面前有一个3x5的牌桌，那么接下来该做什么？我们先随便拿点手牌吧，可以把手牌放到牌桌上来召唤随从，然后和敌方随从打架。但手牌从哪里来，费用机制又怎么做呢？这就引出了本文的核心内容——杀戮尖塔的框架如此自洽，我们能离开它吗？ 杀戮尖塔杀戮尖塔为什么是神？在谈论这个问题之前，我想先说说其他卡牌游戏相较于爬塔究竟差在了哪里（误 总之，让我们来看看杀戮尖塔自洽的设计吧。 单局牌局的自洽杀戮尖塔的手牌从哪里来，费用机制又是怎样的？在杀戮尖塔中，如果不考虑特殊效果，我们在回合开始时会丢弃所有手牌并抽五张牌，并且费用重置为三费。 我们先来聊聊前者。前者在玩起来时感觉十分自然，但从设计的角度，其实是一个并不显然的设计。我简单调研了一下，发现回合开始时刷新手牌似乎是DBG游戏的标配，其开山鼻祖是《皇舆争霸》（Dominion），接下来我们来看看它有怎样的效果。 我认为最关键的两点是，减少了卡手的可能性、降低了策略性。刷新手牌显然能减少卡手，但为什么降低了策略性呢，以及这是好事吗？ 为什么它降低了策略性？因为手牌的刷新就意味着玩家减少了对下一回合的预期。回合制游戏的很大一部分策略性是由对下一回合的预期引起的。对炉石（以及很多CCG）来说，我会根据场面考虑每张牌什么时候打出有最大收益，甚至猜测对手接下来的行动并预留一些卡牌。而杀戮尖塔则杜绝了这种预期，让玩家根据敌人当前回合的意图，结合每回合发的牌打最优解。 是的，最优解。对很多卡牌游戏来说，最优解的计算量是极大的，而杀戮尖塔极大地简化了这个计算量，让每回合最优解的计算都并不困难，从而降低了思维量。这当然不是坏事，我认为这是相当优秀的设计。游戏并不是为了难倒玩家而存在的，比起难倒玩家，让玩家通过自己的努力克服难关更重要。 如果手牌刷新，那费用自然也要刷新，这便是手牌和费用的自洽了。而由此也能推出杀戮尖塔不做随从的理由了。随从是持续性的，而法术是一次性的。如果手牌在刷新，那怎么和随从打combo呢？ 所以我认为怪物火车并不如杀戮尖塔自洽。我这回合费用不足以打出所有的治疗牌，然后回合结束治疗牌就全被扔到弃牌堆里了，那我缺的combo谁给我补啊😭 如果总结一下，我会说杀戮尖塔的每一局都给我带来了炉石里奥秘法般的体验，依靠法术轰炸创死对面，但没有很多的同时依靠多张卡牌的combo，单局牌局运营不多。 每局游戏的自洽每局游戏的自洽又可以分为思维量要求的张弛有度，以及游戏机制本身的自洽。 先说前者。单局牌局策略性较低，但一整局游戏中运营是一个策略性很高的操作，也因此既不会玩得太累，也不会太简单。 再说后者。主要要说的是“血量保持”的机制。如果单局牌局的双方始终强度接近（比如对称式卡牌游戏），那血量显然也是需要在每局刷新的。不过对非对称游戏来说，控制强度接近实在有点困难，血量保持和每一大层的血量回复是一个简单的平衡手段。 原本还想说说易进难出的卡组，但实在没感觉它和别的东西很“自洽”。我对机制“自洽”的理解是把这个机制换成别的，游戏就很难工作了。比如把抽卡换成每回合抽一张，那费用重置就会导致一下就把牌打完；把血量换成每局重置，那游戏就简单一大截了。 而卡组的易进难出看起来是一个控制强度的自然手段，简单地把它改为限制卡组最少十五张，允许自由增删，似乎也不会破坏整个游戏。虽然没有原来好，但至少不是毁灭性的。 有趣的是，杀戮尖塔似乎并没有很多提高单卡强度的手段，而许多类似的卡牌肉鸽会做大量的单卡强度的提高。比如——邪恶冥刻。 邪恶冥刻我们聊聊莱西模组，这最接近卡牌肉鸽。 单局牌局的自洽邪恶冥刻每回合抽一张牌（可选抽牌组的牌或者松鼠牌），费用不自然回复，而是依靠献祭随从获得。它的原型来自ludum dare 43这场gamejam，献祭机制在那里就被定下来了。献祭机制确实非常好玩，所以整个游戏都是以它为核心发展出去的。 献祭是费用机制，那抽牌机制是怎么根据献祭被确定的呢？抽牌无非两种，一种是刷新，一种是保留手牌每回合抽卡。献祭机制导致高费牌难以立即打出，毕竟如果把高费牌刷掉，下次抽到就不知道是什么时候了。所以显然保留手牌更合适。 比起杀戮尖塔，邪恶冥刻的单局牌局更具”持续性“，我们不仅能考虑到下一回合，还能考虑到下下回合。随从站场、手牌不刷新、献祭机制都是持续性的体现。 但运气成分实在是太高了！过牌的缺乏导致我们极度依赖于起手，费用不自然回复和五点伤害差就输又强化了这一点。 不过说到底，这些问题都是因为每回合只抽一张牌对卡组构筑提出了极高的要求。好牌可能沉底，新牌也可能沉底，一沉底这局就没法玩了。 作者Daniel用奇妙的方式解决了问题——他做了个特殊的起手机制，另外在地图上提供大量的牌组改造节点，并鼓励超模单卡。我们会在下一节讨论这一点。 在此之前，我们来看看邪恶冥刻的原型吧：https://dmullinsgames.itch.io/sacrifices-must-be-made 每局游戏的自洽 如我们之前所言，每回合只抽一张牌对卡组构筑提出了极高的要求。一个自然的思路是允许玩家自由调整卡组，只是设置些许限制，比如每张牌最多带两张、至少二十张牌什么的。但邪恶冥刻并不是这么做的。 首先邪恶铭刻的起始手牌一定包含一只松鼠和一张零费或一费的牌，这就保证玩家第一回合总有牌可出。 另外在邪恶冥刻中，删卡并不是很困难的事，造超模单卡也非常简单。祭坛、真菌学家节点可以同时实现这两点，骨王可以删卡，画家可以复制超模单卡，每层可以拿两三张稀有卡。这就让玩家能够迅速提升单卡质量，靠超模单卡和对面打架。 也因此在邪恶冥刻中经常会出现一回合秒对面的局，说实话我觉得这并不是太好的设计，不过确实挺自洽的。 我的游戏（哇，你的游戏和杀戮尖塔、邪恶冥刻都是一级标题，那一定和他们一样厉害吧 现在我们面前有一个3x5的牌桌，那么接下来该做什么？我们先随便拿点手牌吧，可以把手牌放到牌桌上来召唤随从，然后和敌方随从打架。但手牌从哪里来，费用机制又怎么做呢？ 随从是站场的持续性的东西，所以我们就不刷新手牌了，而是每回合抽一张牌。费用刷新也未尝不可，不过我挺喜欢邪恶冥刻的献祭机制的，所以就直接搬过来用了。邪恶冥刻太卡手了，所以我们每回合再给玩家塞一张松鼠牌。 不过要说明的是，这些只是理论推导。在实际做原型的时候我也测试了刷新手牌、刷新费用，发现确实还是每回合抽一张牌+献祭机制和这个随从交互机制的契合度最高。理论和实际相符说明理论有一定指导意义，以后可以接着用，理论与实际不符说明理论在胡扯，就要调整了。 至此，我们完成了单局牌局的设计。之后我把牌桌改成了4x5，发现更有策略也更好玩了，找人试玩了一下之后激进地改成了5x7，居然又更有策略更好玩了，那暂时就这样吧。 这里是试玩链接： 开始游戏（将在新标签页打开） 喜欢的话可以填个问卷，谢谢喵！ 问卷（将在新标签页打开） 那么每局游戏该怎么做呢？由于我们的机制和邪恶冥刻相似，所以它会遇到的问题我们也都会遇到。最关键的两点就是牌越多越菜和关键牌沉底。 一开始我尝试解决前者，然后偶然间得到了一个我觉得还不错的，能同时解决这两个问题的方案。 解决问题无非从单局牌局和整局游戏考虑，我想了半天没想到怎么用在单局内解决问题，于是就想研究下通过调整整局游戏的运营来解决问题。 在玩卡牌肉鸽的时候，我们经常遇到选牌加入牌组不如跳过的情况，这就是典型的“牌越多越菜”。那怎么保证每次选牌都有补强呢？考虑到我们的献祭机制，我就想到把可选牌献祭成随时可以使用的一次性道具，这样每次选牌都至少能让玩家变强一点。 道具怎么做呢？初步想法是把牌的费用减半，法术牌不变，随从牌在下个回合开始时自动被献祭。 有趣的是，它也缓解了关键牌沉底的问题，毕竟一方面道具能帮助我们过渡，另一方面我们也能直接把关键牌献祭成道具，然后就不用担心沉底了。","categories":[{"name":"游戏设计","slug":"游戏设计","permalink":"http://rinevard.github.io/categories/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[]},{"title":"第一章——系统接口","slug":"learning/open-course/MIT-6.S081/Notes/note1-sys-interface","date":"2025-06-01T03:18:38.000Z","updated":"2025-08-22T03:14:43.992Z","comments":true,"path":"wiki/learning/open-course/MIT-6.S081/Notes/note1-sys-interface/","permalink":"http://rinevard.github.io/wiki/learning/open-course/MIT-6.S081/Notes/note1-sys-interface/","excerpt":"","text":"img{ width: 70%; } 常用的系统接口 系统调用 描述 fork() 创建进程 exit() 结束当前进程 wait() 等待子进程结束 kill(pid) 结束 pid 所指进程 getpid() 获得当前进程 pid sleep(n) 睡眠 n 秒 exec(filename, *argv) 加载并执行一个文件 sbrk(n) 为进程内存空间增加 n 字节 open(filename, flags) 打开文件，flags 指定读/写模式 read(fd, buf, n) 从文件中读 n 个字节到 buf write(fd, buf, n) 从 buf 中写 n 个字节到文件 close(fd) 关闭打开的 fd dup(fd) 复制 fd pipe( p) 创建管道， 并把读和写的 fd 返回到p chdir(dirname) 改变当前目录 mkdir(dirname) 创建新的目录 mknod(name, major, minor) 创建设备文件 fstat(fd) 返回文件信息 link(f1, f2) 给 f1 创建一个新名字(f2) unlink(filename) 删除文件 进程 系统调用 描述 fork() 创建进程 exit() 结束当前进程 wait() 等待子进程结束 kill(pid) 结束 pid 所指进程 getpid() 获得当前进程 pid exec(filename, *argv) 加载并执行一个文件 sbrk(n) 为进程内存空间增加 n 字节 I/O 系统调用 描述 open(filename, flags) 打开文件，flags 指定读/写模式 read(fd, buf, n) 从文件中读 n 个字节到 buf write(fd, buf, n) 从 buf 中写 n 个字节到文件 close(fd) 关闭打开的 fd dup(fd) 复制 fd 代码示例： char buf[512]; void cat(int fd) &#123; int n; while ((n = read(fd, buf, sizeof(buf))) > 0) &#123; // 写入标准输出 if (write(1, buf, n) != n) &#123; fprintf(2, \"cat: write error\\n\"); exit(1); &#125; &#125; if (n &lt; 0) &#123; fprintf(2, \"cat: read error\\n\"); exit(1); &#125; &#125; int main(int argc, char *argv[]) &#123; int fd, i; if (argc &lt;= 1) &#123; cat(0); exit(0); &#125; for (i = 1; i &lt; argc; i++) &#123; if ((fd = open(argv[i], O_RDONLY)) &lt; 0) &#123; fprintf(2, \"cat: cannot open %s\\n\", argv[i]); exit(1); &#125; cat(fd); close(fd); &#125; exit(0); &#125; 不妨再来看看CSAPP的两张图 open两次： fork： 管道 系统调用 描述 pipe( p) 创建管道， 并把读和写的 fd 返回到p，其中p是 int p[2] p[0]: 读端(read end)的文件描述符 p[1]: 写端(write end)的文件描述符 样例： grep fork sh.c | wc -l 命令将第一个命令(grep)的输出作为第二个命令(wc)的输入，| 就是管道符号。 下面的代码是 | 的实现示例，大体思路是把 | 左边的标准输出重定向到pipe的写端，把 | 右边的标准输入重定向到pipe的读端。 注意要关闭管道的所有写入端来让 read 返回，因为当 pipe 中没有数据时，read 会阻塞等待新数据写入，或是写入端都关闭，如果有新数据写入就读取，如果所有写入端都关闭就返回 0（对应EOF）. // 假设我们的命令是 grep fork sh.c | wc -l case PIPE: pcmd = (struct pipecmd *)cmd; if (pipe(p) &lt; 0) panic(\"pipe\"); if (fork1() == 0) &#123; close(1); // 释放文件描述符1，从而让dup把文件描述符1绑定到p[1]指向的东西 dup(p[1]); //换句话说，我们在重定向标准输出到pipe的写端 close(p[0]); close(p[1]); runcmd(pcmd->left); // 对应 grep fork sh.c &#125; if (fork1() == 0) &#123; close(0); // 与上面类似，重定向标准输入到pipe的读端 dup(p[0]); close(p[0]); close(p[1]); runcmd(pcmd->right); // 对应 wc -l &#125; close(p[0]); close(p[1]); wait(0); wait(0); break; 文件系统 系统调用 描述 chdir(dirname) 改变当前目录 mkdir(dirname) 创建新的目录 mknod(name, major, minor) 创建设备文件 fstat(fd) 返回文件信息 link(f1, f2) 给 f1 创建一个新名字(f2) unlink(filename) 删除文件 我们通常认为文件名就是文件本身，但实际上名称是一个硬链接(hard link)。一个文件可以有多个硬链接——例如，一个目录至少有两个硬链接：目录名和 . （在目录内时）。它还有来自每个子目录的一个硬链接（每个子目录中的 .. 文件）。 那文件是什么呢？一个文件和一个 inode 一一对应，inode存放着这个文件的相关信息 xv6系统的inode结构包括下面这些内容： struct dinode &#123; short type; // File type short major; // Major device number (T_DEVICE only) short minor; // Minor device number (T_DEVICE only) short nlink; // Number of links to inode in file system uint size; // Size of file (bytes) uint addrs[NDIRECT + 1]; // Data block addresses &#125;; 可以通过 fstat 获取文件描述符指向的文件的信息。dinode是磁盘上存储的详细信息，stat是暴露给用户的文件信息接口 struct stat &#123; int dev; // File system's disk device uint ino; // Inode number short type; // Type of file short nlink; // Number of links to file uint64 size; // Size of file in bytes &#125;; 仅当我们把所有指向某个inode的链接都删除，这个inode才会被删除。 在下面的示例中，我们用 ln 创建了两个连接 file2 和 file3，它们都和 file1 指向的 inode 相同。可以看到，如果用 echo 修改 file2，那么 file1 也会被修改，因为我们修改的实际上是 inode，而它们指向同一个inode。ls -l 列出目录中的文件和目录的详细信息，第二个值是inode的link数。我们可以把链接视作文件的“别名”。 $ echo &quot;What&#39;s in a name? That which we call a rose, by any other word would smell as sweet.&quot; &gt; file1.txt $ ls file1.txt open-course programs $ cat file1.txt What&#39;s in a name? That which we call a rose, by any other word would smell as sweet. $ ln file1.txt file2.txt $ ln file1.txt file3.txt $ ls -l total 20 -rw-r--r-- 3 rinevard rinevard 85 May 29 11:37 file1.txt -rw-r--r-- 3 rinevard rinevard 85 May 29 11:37 file2.txt -rw-r--r-- 3 rinevard rinevard 85 May 29 11:37 file3.txt drwxr-xr-x 3 rinevard rinevard 4096 May 28 11:00 open-course drwxr-xr-x 2 rinevard rinevard 4096 May 28 10:19 programs $ echo &quot;-- William Shakespeare&quot; &gt;&gt; file2.txt $ cat file1.txt What&#39;s in a name? That which we call a rose, by any other word would smell as sweet. -- William Shakespeare 你可能会好奇目录的链接数怎么计算，是这样的： 每个目录默认有2个链接，一个是目录自身的”.”，另一个是父目录中指向该目录的链接 目录中每包含一个子目录，链接数就会+1，因为每个子目录都会创建”..”链接指向父目录 在下面的例子中，rootdir 的链接数是 4，因为父目录有一个指向它的链接”rootdir”，它自己有一个指向自己的链接”.”，它的两个子目录dir1和dir2分别有指向它的链接”..” ~/open-course/rootdir$ ls dir1 dir2 file1.md file2.md file3.md ~/open-course/rootdir$ ls ../ -l total 8 drwxr-xr-x 11 rinevard rinevard 4096 May 31 16:40 mit-6.828 drwxr-xr-x 4 rinevard rinevard 4096 Jun 1 10:58 rootdir 文件路径格式：以 “/” 开头的是从根目录出发的路径，否则是从当前文件夹出发的路径 ~/open-course$ ls mit-6.828 ~/open-course$ ls mit-6.828/ LICENSE Makefile README conf grade-lab-util gradelib.py kernel mkfs user ~/open-course$ ls /home/rinevard/ open-course programs unix shell的许多命令都是用户级别的，而非内置的。shell通过fork子进程并调用exec来执行它们。但cd是内置的，因为cd改变了shell自身的工作目录。 // Read and run input commands. while (getcmd(buf, sizeof(buf)) >= 0) &#123; if (buf[0] == 'c' &amp;&amp; buf[1] == 'd' &amp;&amp; buf[2] == ' ') &#123; // Chdir must be called by the parent, not the child. buf[strlen(buf) - 1] = 0; // chop \\n if (chdir(buf + 3) &lt; 0) fprintf(2, \"cannot cd %s\\n\", buf + 3); continue; &#125; if (fork1() == 0) runcmd(parsecmd(buf)); wait(0); &#125;","categories":[{"name":"公开课","slug":"公开课","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"MIT-6.S081","slug":"公开课/MIT-6-S081","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/MIT-6-S081/"},{"name":"Notes","slug":"公开课/MIT-6-S081/Notes","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/MIT-6-S081/Notes/"}],"tags":[]},{"title":"Lab 1 Xv6 and Unix utilities","slug":"learning/open-course/MIT-6.S081/Labs/lab1-util","date":"2025-05-31T03:18:38.000Z","updated":"2025-10-15T08:09:56.939Z","comments":true,"path":"wiki/learning/open-course/MIT-6.S081/Labs/lab1-util/","permalink":"http://rinevard.github.io/wiki/learning/open-course/MIT-6.S081/Labs/lab1-util/","excerpt":"","text":"img{ width: 80%; } 在开始 lab 之前，我们先来解释一下为什么我们写的代码能直接在 xv6 的 shell 里执行。我们来看看 sh.c 的部分代码： // Read and run input commands. while (getcmd(buf, sizeof(buf)) >= 0) &#123; if (buf[0] == 'c' &amp;&amp; buf[1] == 'd' &amp;&amp; buf[2] == ' ') &#123; // Chdir must be called by the parent, not the child. buf[strlen(buf) - 1] = 0; // chop \\n if (chdir(buf + 3) &lt; 0) fprintf(2, \"cannot cd %s\\n\", buf + 3); continue; &#125; if (fork1() == 0) runcmd(parsecmd(buf)); wait(0); &#125; 从这里我们看出，shell通过fork子进程来执行命令。如果进一步看看 runcmd 函数，就会发现它调用了 exec，因此 shell 能执行用户写的代码。 有趣的是，从这段代码里我们也能看出 cd 是内置在 shell 里的命令，这是因为 cd 改变了shell自身的工作目录。 sleep这题让我们简单熟悉下接口。其实这里用 printf 更易读，不过我当时做的时候没发现有 printf #include \"kernel/types.h\" #include \"user/user.h\" #include \"kernel/fcntl.h\" int main(int argc, char *argv[]) &#123; char *errmsg = \"sleep: missing operand\\n\"; if (argc != 2) &#123; write(1, errmsg, strlen(errmsg)); exit(1); &#125; sleep(atoi(argv[1])); exit(0); &#125; pingpong这题让我们接触一下管道的使用，难者不会，会者不难 #include \"kernel/types.h\" #include \"user/user.h\" #include \"kernel/fcntl.h\" int main() &#123; char buf[512]; int p_parent_sender[2]; int p_child_sender[2]; pipe(p_parent_sender); pipe(p_child_sender); if (fork() == 0) &#123; // 子进程先读 read(p_parent_sender[0], buf, 2); printf(\"%d: received ping\\n\", getpid()); write(p_child_sender[1], buf, 2); close(p_parent_sender[0]); close(p_parent_sender[1]); close(p_child_sender[0]); close(p_child_sender[1]); exit(0); &#125; // 父进程先写 write(p_parent_sender[1], buf, 2); read(p_child_sender[0], buf, 2); printf(\"%d: received pong\\n\", getpid()); close(p_parent_sender[0]); close(p_parent_sender[1]); close(p_child_sender[0]); close(p_child_sender[1]); exit(0); &#125; primes这题很有趣，是一个并发素数筛法。这个算法理论上是可以提高效率的，毕竟在运行了一段时间后，各个进程里都有一些数等待筛选，这时各个进程在同时用自己的素数筛选输入的数。 网上很多代码都是2020版的，当时的要求是找出 2-35 间的素数。这些代码能过老版本的要求，但过不了2024版要求的 2-280。我认真看了一两份代码，发现它们在用 fork 创建子进程的子进程后，忘了关闭子子进程的连接到父进程的描述符。可以看下面示意图的第三个框，这些代码忘了关闭 child child process 的 fd_read. 我画了示意图来解释我的代码~ #include \"kernel/types.h\" #include \"kernel/stat.h\" #include \"user/user.h\" const int NUM = 280; int connected_fork(int *); void do_child(int); int main() &#123; int pid; int fd = -1; if ((pid = connected_fork(&amp;fd)) == 0) &#123; do_child(fd); exit(0); &#125; int n; for (n = 2; n &lt;= NUM; n++) &#123; write(fd, (void *)&amp;n, sizeof(int)); &#125; close(fd); wait(0); exit(0); &#125; /* * 创建子进程. 父进程的 fd 和子进程的 fd 会被分别设置为一个 pipe 的两端. * 对父进程, fd 被设置为写端. * 对子进程, fd 被设置为读端. * * return 0 if is child else child's pid */ int connected_fork(int *fd) &#123; int p[2]; pipe(p); int pid; if ((pid = fork()) == 0) &#123; // child close(p[1]); *fd = p[0]; &#125; else &#123; // parent close(p[0]); *fd = p[1]; &#125; return pid; &#125; /* * 从 fd_read 中读取数字, 打印第一个数, * 筛选其他数并新建子进程把被筛选后的数写入子进程. 在运行完成后关闭 fd_read. */ void do_child(int fd_read) &#123; int n = -1; int prime = -1; int fd = -1; while (read(fd_read, (void *)&amp;n, sizeof(int)) > 0) &#123; if (prime == -1) &#123; prime = n; printf(\"prime %d\\n\", prime); &#125; if ((n % prime) != 0) &#123; if (fd == -1 &amp;&amp; connected_fork(&amp;fd) == 0) &#123; // fd == -1 等价于没有子进程 // 如果没有子进程就创建子进程并让它开始工作 close(fd_read); do_child(fd); return; &#125; write(fd, (void *)&amp;n, sizeof(int)); &#125; &#125; close(fd_read); // fd == -1 等价于没有子进程, 说明它是最后一个进程 // 最后一个进程不需要关闭描述符, 也不需要等待 if (fd == -1) &#123; return; &#125; close(fd); wait(0); &#125; /* * 个人认为关闭 fd_read 不应该是 do_child 的工作, 我觉得\"谁创建, * 谁关闭\"会更合适. 也就是说, 我觉得让调用 do_child 的函数关闭 fd_read * 更合适. * * 但如果 do_child 不关闭 fd_read, 子孙进程就会保留父进程未关闭的描述符, * 从而耗尽 xv6 的资源. */ find在 ls.c 的基础上稍微改改就好了，要注意的是递归时不要递归进 “.” 和 “..” 两个文件夹 我们实现的 find &lt;path&gt; &lt;name&gt; 的功能和 Linux 里的 find &lt;path&gt; -name &lt;name&gt; 一致 #include \"kernel/types.h\" #include \"kernel/stat.h\" #include \"user/user.h\" #include \"kernel/fs.h\" #include \"kernel/fcntl.h\" void find(const char *path, const char *name); const char *basename(const char *path); int main(int argc, char *argv[]) &#123; if (argc != 3) &#123; printf(\"usage: find &lt;path> &lt;filename>\\n\"); &#125; find(argv[1], argv[2]); exit(0); &#125; /* * 在以 path 为根节点的文件树下搜索名为 name 的文件, * 如果找到则打印其路径. */ void find(const char *path, const char *name) &#123; int fd; if ((fd = open(path, O_RDONLY)) &lt; 0) &#123; fprintf(2, \"find: cannot open %s\\n\", path); return; &#125; struct stat st; if (fstat(fd, &amp;st) &lt; 0) &#123; fprintf(2, \"find: cannot stat %s\\n\", path); close(fd); return; &#125; if (strcmp(basename(path), name) == 0) &#123; printf(\"%s\\n\", path); &#125; // 只有文件夹有递归的必要 if (st.type != T_DIR) &#123; close(fd); return; &#125; char buf[512], *p; struct dirent de; // 第一个 +1 对应 '/', 第二个 +1 对应结尾的 '\\0' if (strlen(path) + 1 + DIRSIZ + 1 > sizeof(buf)) &#123; printf(\"ls: path too long\\n\"); &#125; strcpy(buf, path); p = buf + strlen(buf); *p++ = '/'; while (read(fd, &amp;de, sizeof(de)) == sizeof(de)) &#123; if (de.inum == 0 || strcmp(de.name, \".\") == 0 || strcmp(de.name, \"..\") == 0) continue; memmove(p, de.name, DIRSIZ); p[DIRSIZ] = 0; if (stat(buf, &amp;st) &lt; 0) &#123; printf(\"ls: cannot stat %s\\n\", buf); continue; &#125; find(buf, name); &#125; &#125; /* * 获取路径 path 的最后一部分 */ const char *basename(const char *path) &#123; const char *p; for (p = path + strlen(path); p >= path &amp;&amp; *p != '/'; --p) ; ++p; return p; &#125; xargsxargs 将标准输入（stdin）数据转换成命令行参数，一般和管道一起使用。在 linux 中，xargs 默认的命令是 echo. 上面的解释可能不太清晰，通过两个例子就能看出来它在做什么了： 第一个例子是直接使用 xargs $ xargs -n 1 echo Im prefix 111 Im prefix 111 222 Im prefix 222 （按 ctrl+D 终止输入) 第二个例子是和管道联用 $ (echo 1 ; echo 2) | xargs -n 1 echo 1 2 $ 我们实现的 xargs &lt;command&gt; 的功能和 Linux 里的 xargs -n 1 &lt;command&gt; 一致 #include \"kernel/types.h\" #include \"kernel/param.h\" #include \"user/user.h\" int main(int argc, char *argv[]) &#123; if (argc &lt; 2) &#123; fprintf(2, \"usage: xargs command\\n\"); exit(1); &#125; char *cmd = argv[1]; char *cmdargs[MAXARG]; int cmdargc = 0; // 在更改 cmdargc 前, 最好检查 cmdargc &lt; MAXARG, // 不过为了简化代码, 我们就不检查了 // argv[0] 是 'xargs', argv[1] 是 command, 之后是参数 // cmdargs 应当形如 [command, arg1, arg2, ..., addition_arg1, ...] cmdargc = argc - 1; for (int i = 0; i &lt; cmdargc; i++) &#123; cmdargs[i] = argv[i + 1]; &#125; char buf[512]; // 输入行 char *p = buf; // 输入行的末尾 while (read(0, p, 1) > 0) &#123; if (p[0] == '\\n') &#123; p[0] = '\\0'; cmdargs[cmdargc] = buf; ++cmdargc; cmdargs[cmdargc] = 0; ++cmdargc; if (fork() == 0) &#123; exec(cmd, cmdargs); &#125; wait(0); // 重置 p = buf; cmdargc = argc - 1; &#125; else &#123; ++p; &#125; &#125; exit(0); &#125;","categories":[{"name":"公开课","slug":"公开课","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"MIT-6.S081","slug":"公开课/MIT-6-S081","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/MIT-6-S081/"},{"name":"Labs","slug":"公开课/MIT-6-S081/Labs","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/MIT-6-S081/Labs/"}],"tags":[]},{"title":"慢慢地冲浪","slug":"others/thoughts/网上冲浪","date":"2025-05-28T03:50:11.000Z","updated":"2025-08-19T07:08:07.564Z","comments":true,"path":"wiki/others/thoughts/网上冲浪/","permalink":"http://rinevard.github.io/wiki/others/thoughts/%E7%BD%91%E4%B8%8A%E5%86%B2%E6%B5%AA/","excerpt":"","text":"在互联网上冲浪时，偶尔会看到一些博客，若是它们帮到了我，我经常也会点进主页看看作者都写了怎样的文章，都有怎样的故事。 很多人的网站里全是技术文章，我对这样的网站确实没什么兴致。我更喜欢杂谈类的文章，那种像是在夜深人静时，独自一人在电脑前慢慢写下的文章。读这样独处时写下的文章，总让我觉得自己和作者的灵魂更近了一点。 在互联网上随机漫游，对着完全不认识自己的人产生单箭头，如果运气好的话说不定会是双箭头，真的非常有趣。我可能还是喜欢慢一点的故事，喜欢有着很长很长回复的贴子，喜欢把自己遇见的趣事分享到网上的视频，喜欢随意的、真诚的文章。它们只是被放在那里，等着十年后被另一个人偶然发现，那是痕迹。 /* 隐藏草书 */ .hidden-text { font-size: 18px; text-align: center; margin: 20px 0; /* padding: 20px; */ line-height: 1.5; color: transparent; cursor: default } .hidden-fancy-text::selection { color: black; background: white; } 就像这里的痕迹。","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/"},{"name":"碎碎念","slug":"杂谈/碎碎念","permalink":"http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}],"tags":[]},{"title":"在开始之前","slug":"learning/open-course/MIT-6.S081/BeforeStory","date":"2025-05-27T07:20:38.000Z","updated":"2025-08-22T03:14:43.982Z","comments":true,"path":"wiki/learning/open-course/MIT-6.S081/BeforeStory/","permalink":"http://rinevard.github.io/wiki/learning/open-course/MIT-6.S081/BeforeStory/","excerpt":"","text":"最近发现了 Arthal 的笔记，感觉写得非常精美！回头看看自己对 15213 labs 的笔记，感觉写得确实太粗糙了，希望我的 6.S081 的笔记也能写得详细一些。 咳咳，我知道我还没写 15213 的 proxylab，不过我感觉csapp网络那一章写得有点含糊，所以晚点再做吧。","categories":[{"name":"公开课","slug":"公开课","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"MIT-6.S081","slug":"公开课/MIT-6-S081","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/MIT-6-S081/"}],"tags":[]},{"title":"Ludum Dare参加指南","slug":"game-design/ldjam参赛指南","date":"2025-04-13T01:36:38.000Z","updated":"2025-07-20T09:55:53.012Z","comments":true,"path":"wiki/game-design/ldjam参赛指南/","permalink":"http://rinevard.github.io/wiki/game-design/ldjam%E5%8F%82%E8%B5%9B%E6%8C%87%E5%8D%97/","excerpt":"","text":"零、在文章开始之前本文包含了对 Ludum Dare 的介绍、参与流程及个人看法。写作的契机是参与 Ludum Dare 后体验很好，但在中文互联网上没有找到很全面的介绍资料，只找到了 规则介绍。在规则介绍之外，我希望聊聊 Ludum Dare 的体验为什么好（比起我参加过的其他 gamejam），并按时间线介绍一下参与流程。 一、什么是 Ludum Dare官网写到，”Ludum Dare is an event where you create a game from scratch in a weekend based on a theme.”（出自 rules），即“Ludum Dare 是一个围绕某个主题在一个周末从零开始做出一个游戏的活动。”更具体一点，Ludum Dare 主要分为两个赛道，分别是单人 48 小时做一个游戏和组队 72 小时做一个游戏。 这时候有经验的读者就会问了，这不就是 gamejam 吗？正是如此！Ludum Dare 是非常早期的 gamejam，它自 2002 年开始举办，每年举办两次，到今天已经办了 57 届。每届 Ludum Dare 都会吸引全球数以万计的开发者，如 2021 年的 49 届收到了近 3000 款游戏提交， 2023 年的第 52 届收到了 1632 款游戏提交（数据来源）。在这大量的提交游戏中，也有许多精品作品从此发源，比如邪恶铭刻（inscryption）的原型 Sacrifices Must Be Made 就于 Ludum Dare 43 制作。 二、为什么参加 Ludum Dare中国有那么多本土的 gamejam，那为什么要顶着语言障碍参加 Ludum Dare 呢？我认为最重要的两点是游戏质量高、收获反馈多。 先说前者，gamejam 总是有竞赛性质的，在 Ludum Dare 里我们要和全世界的优秀开发者竞争，单是看着这些开发者围绕主题的奇思妙想就已经让人觉得值回票价了（并没有票价，这是免费活动），而如果取得了好排名则更是会给人相当的成就感。 再说后者，介于 Ludum Dare 的算法，每个游戏基本都会获得 20 个以上的评分，而且你玩的游戏越多，Ludum Dare 就会把你的游戏放在推荐榜越靠前的位置，从而就会有越多人玩你的游戏。以我的经验来看，玩的游戏数量和收获的评分数量基本接近，而且很多玩了我们游戏的开发者会在游戏下给出评论来反馈，非常利于我们了解自己游戏的优秀之处（可惜的是评论一般不说缺点，以夸夸居多）。 下面再举几个 Ludum Dare 的其他优势： 足不出户：与线下 gamejam 不同，参加 Ludum Dare 无需报名，只要注册账号并在提交时间截止前提交游戏即可。 玩游戏方便：大部分开发者都会提供游戏的 web 版本，即使不提供 web 版本也可以直接在对应的游戏页面下载游戏。 交流机会：我们可以给别的游戏提供反馈，也可以在别的游戏评论区里询问开发者的设计思路，一般都会收到积极的回复。 和大神合影：每届的 Ludum Dare 都会有一些大神来参加，如果恰巧碰上了自己感兴趣的大神，就有了在他们的游戏评论区夸夸的合影机会！ 三、参与流程Ludum Dare 的流程大概是主题投票、制作、评分与反馈、结果公布。为了顺利参赛，首先我们要在 Ludum Dare 上注册一个账号。注册账号需要邀请码，我们可以在 Google 上用 ludum dare invitation code 之类的关键词或者在举办者的主页上找到邀请码。我找到的第 57 届的邀请码有 Time4LD57 和 BirdSiteLD57。 在注册成功之后，我们要想想这次是单人参赛还是组队参赛。Ludum Dare 有三条赛道，Compo、Jam 和 Extra. Compo 是经典模式，要求单人 48 小时内做游戏，所有内容包括美术、音效等都需要在 48 小时内从零开始做出，而且必须开源源代码。我们可以使用任何已经写过的基础代码和任何工具。如果你的游戏收到了 20 个以上的评分，会得到最终评分。 Jam 相对宽松，只要求组队 72 小时内做游戏，可以使用任何已经写过的基础代码，也允许使用部分预制素材。若美术或音效非原创，需要在提交时关闭对应类别的打分。比如如果我们用了第三方美术，就要在提交时关闭 Graphics 的打分。如果你的游戏收到了 20 个以上的评分，会得到最终评分。 Extra 则是轻松组，时间宽裕至 3 周，单人或团队均可，内容以原创为主但允许预制素材，美术或音效非原创可退出对应评分类别，源代码提交可选，但无最终排名。 赛道在提交时才需要确定，所以如果你原本打算参加 Compo，但没来得及赶上 Compo 的截止提交时间，也可以转去 Jam 的提交。 想好了赛道后，就能进入之后的环节了。 主题投票官方会提供大量的主题（第 57 届有 1000 多个），经过初选轮、复选轮、决赛轮，最终得出一个结果主题。我们当然不必给每个主题都投票，我的个人建议是在决赛轮投一下就行。而且即使不投票也是能参赛的！参赛的唯一要求就是在提交时间截止前提交作品。 是否围绕主题做游戏也是可选的，主题只是最终评分中的一部分，Ludum Dare 的宗旨是鼓励开发者把游戏做出来。 制作阶段进入制作阶段后，我们就可以开始做游戏了！点击右上角的 join event，就能创建游戏草稿页。我们会在上传阶段填充这个草稿页。 制作游戏需要大家各显神通，我简单谈谈个人建议吧。 设计一般来说，我们要快速地找到多个想法，然后选择自己觉得最有前途的想法做下去。由于制作时间很紧，我们注定不能做大做全。比起大而全，小而美是更好的选择。一个只有三关的认真打磨过的作品比一个有十关的每关都很粗糙的作品要好得多。 程序尽管 Ludum Dare 允许设计桌游乃至更不被定义的游戏（我见过一个翻文件夹的游戏），但我们这里只讨论电子游戏。程序方面，选用自己最熟悉的工具即可。有熟练的游戏引擎就选游戏引擎，喜欢不用引擎开发就不用引擎开发。 音乐我是音乐萌新，虽然听说过 FL studio 之类的工作站，但我现在还没学会。所以我这里推荐一个简单的音乐制作网站——Musiclab，我使用里面的SongMaker做出了能听的东西。 音效sfxr是很简单的音效制作网站，我看不懂参数，所以我的工作流是把我想要的效果告诉 AI，AI 告诉我怎么调参，效果出乎意料地还算不错。 美术我用Piskel画简单的像素画，偶尔也用Krita来画别的东西。 抛开 Extra 赛道不谈，这个阶段持续 48 小时或 72 小时，我最后的建议是在参与的同时保持充足的睡眠，好好睡觉好好吃饭很重要！ 上传阶段在制作阶段结束后，会给额外的一小时来上传。尽管官网给了额外一小时的上传时间，我还是建议大家在制作阶段的末尾就开始研究怎么上传游戏，以防万一嘛。 我们可以在这段时间里填充右上角 My Game 的草稿页，按着页面要求填写即可。 我们可以把游戏压缩包上传到页面上，同时 Ludum Dare 支持 Embed HTML5，也就是说我们可以根据Embedding Guide直接把游戏的网页版上传到官网的游戏页面上。建议大家同时把网页版上传到 itch 上，毕竟官网的网页版游戏支持做得不算很完美。 记得退出自己不符合/不想要的打分选项。 评分阶段至此，恭喜你做出了自己的游戏！ 评分阶段持续三周，在评分阶段，我们可以试玩别人的游戏并打分，你打分的游戏越多，推荐算法给你的游戏的推荐优先级就越高。同时高质量评论也能提高你游戏的推荐优先级。 评分阶段允许继续编辑页面，比如如果你发现游戏页面的描述有问题，随时可以进行修改。修游戏内的 bug 也是被允许的，但要求在修 bug 以后显式地在游戏页面标出自己做的修改（写一个简要的 devlog），而且不能增加新功能。 结果公布游戏会根据打分来排名。没有奖品，你的游戏就是最好的奖品！ 四、其他资料可以在rules页面找到详细的参加规则，强烈建议在参加前阅读。 可以在这篇规则介绍找到中文的规则介绍，但不如上面那个全面。 本文的结构参考了 Google 编程之夏(GSoC)：海量优质项目，丰厚报酬，你竟然还不知道？","categories":[{"name":"gamejam","slug":"gamejam","permalink":"http://rinevard.github.io/categories/gamejam/"}],"tags":[]},{"title":"技巧的分类，冰山之下的深度","slug":"game-design/冰山之下的深度","date":"2025-03-08T04:22:38.000Z","updated":"2025-08-20T11:13:48.877Z","comments":true,"path":"wiki/game-design/冰山之下的深度/","permalink":"http://rinevard.github.io/wiki/game-design/%E5%86%B0%E5%B1%B1%E4%B9%8B%E4%B8%8B%E7%9A%84%E6%B7%B1%E5%BA%A6/","excerpt":"","text":"img{ width: 70%; } 《体验引擎》里提到，“深度游戏能够通过高水平的技巧创造有意义的玩法。深度（depth）这个概念用于描述游戏中需要学习的内容有多少。”在这里，我们将探讨一下如何对技巧的类型进行区分，以及如何创造这些技巧来提高游戏深度，同时不让游戏门槛过高。 既然要求有深度，那游戏里必然有很多技巧。我们有必要对技巧做一个区分——技巧可以被分为“规则涌现的技巧”和“预设的技巧”。围棋的各种技巧就是前者的一个很好的例子（uh actually☝️🤓 数学是更好的例子），而“炸弹能炸开有裂缝的墙”就是后者的一个例子。 基于规则的技巧创造“基于规则的技巧”是相对困难的，因为这要求我们创造能涌现出许多技巧的规则。这种纯粹的创造性活动恐怕没有什么经验可以写，我能说的也只是多去学学不同领域的知识。如果要做出有灵性的规则，当然不能只是玩各个游戏并尝试“学习经验”（你学的都是别人做过的规则！），而是要更多去看看自己从未见过的领域。比如说，比起盯着《baba is you》学，不如去学学编程。编程的“赋值”被 baba 做掉了，但编程的“语句执行顺序”是不是就可以做成 noita 的魔杖？编程的“抽象”思想会不会也可以做成另一个有趣的规则？ 虽然说“这种创造性活动恐怕没什么经验可写”，但还是写了一堆东西。我确实对基于规则的技巧更感兴趣，这完美实现了“冰山之下的深度”（我在这里点题了！）。不过接下来我们还是聊聊没有灵感时也能做的东西吧。 预设的技巧比起创造基于规则的技巧，创造预设的技巧则简单很多。我们可以随便口胡一些预设的技巧，比如“土狼跳”、“攻击过程中按冲刺能取消攻击”、“在开启技能的前摇时移动来消除前摇而直接开启技能”（唉，取消），实际上为了保证手感，几乎所有游戏都用了大量的预设的技巧。对预设的技巧来说，实际难点在于如何把深度藏在冰山之下，不让玩家因直面大量技巧而感到无所适从。 把深度藏在冰山之下听着很高大上，实际上最好用的藏深度的做法就是把预设的技巧逐渐呈现给玩家。每过几关给玩家一个新能力就是这种做法。更巧妙的做法是把多个预设的技巧融入到同一个操作之中，用恰当的关卡设计让技巧逐渐呈现出来。典型的例子是《闰跃之年》，开局跳一下就死了，那怎样跳才能活下来呢？这就是被藏在冰山下的预设的技巧了。 有的游戏还会把预设的技巧伪装成规则涌现的技巧，这让技巧显得更优雅，但实际上不是很本质的改进。围绕一个摸棱两可的主题设计一些预设的技巧，就能做到这一点。我能想到的最好的例子就是《蔚蓝》。蔚蓝把蹭墙跳、凌波微步这些预设的技巧藏在了“惯性”的后面，让各个技巧看起来都是涌现的。虽然这些技巧看起来都和惯性有联系，但实际上玩家并不能根据规则本身推理出这些技巧的存在，因此这是”把预设的技巧伪装成规则涌现的技巧“。 结尾基于规则的技巧和预设的技巧并非截然对立。大多数情况下，我们都逐渐学到所有的预设的技巧，再把预设的技巧作为规则组合起来形成基于规则的技巧。 还要注意的是，这种技巧的区分是在呈现给玩家的层面上，而非在实现层面上。如果你硬编码出 noita 的所有可能的法术搭配并写出对应效果，这在实现层面上显然是“预设”的，但对玩家来说，这仍然是“基于规则”的，毕竟玩家可以基于规则推理出可能的技巧。相较而言，如果我们设计一个和法术相关的游戏，每个法术在代码层面上都是几个小法术的组合，但玩家看到的只是组合好的各个法术而不能自己去组合法术，这在实现层面上是“基于规则”的，但对玩家来说是“预设”的。 多说一句，“在实现层面上基于规则，但呈现出来的效果是预设的”实际上是很适合做成探索类游戏的。核心思路是，首先把大量的预设的现象呈现给玩家，再让玩家逐步探索现象背后的规则。这种思路在别的游戏里也有，不过全是解谜游戏，我们完全可以做一个更有趣的探索类游戏。比如说玩家看到了火球术，之后我们逐渐引导玩家发现火球术本质上是火焰魔法+移动魔法，玩家就能进而基于规则构建出新魔法了。","categories":[{"name":"游戏设计","slug":"游戏设计","permalink":"http://rinevard.github.io/categories/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[]},{"title":"这里有什么？","slug":"learning/open-course/这是哪里","date":"2025-03-02T06:28:38.000Z","updated":"2025-08-22T03:16:04.281Z","comments":true,"path":"wiki/learning/open-course/这是哪里/","permalink":"http://rinevard.github.io/wiki/learning/open-course/%E8%BF%99%E6%98%AF%E5%93%AA%E9%87%8C/","excerpt":"","text":"本来只打算在博客里写杂谈和游戏设计相关文章的，不过想想看把学习笔记在这里记一记似乎也不错。那这里就是学习记录了，主要是写给未来的自己用的。🫠 应该只有朋友们（cyber friends）会看到这个网站，所以记录一下也是在表明我还在认真学习，没有进入摸鱼态。读者也别忘了终身学习。","categories":[{"name":"公开课","slug":"公开课","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"}],"tags":[]},{"title":"母鸡卡的各种神奇假药","slug":"others/animation/母鸡卡的各种神奇假药","date":"2025-02-15T13:31:31.000Z","updated":"2025-08-20T11:13:48.877Z","comments":true,"path":"wiki/others/animation/母鸡卡的各种神奇假药/","permalink":"http://rinevard.github.io/wiki/others/animation/%E6%AF%8D%E9%B8%A1%E5%8D%A1%E7%9A%84%E5%90%84%E7%A7%8D%E7%A5%9E%E5%A5%87%E5%81%87%E8%8D%AF/","excerpt":"","text":"img{ width: 50%; } 整理一下我觉得很有趣的假药，太真的和我不感兴趣的就不放进来了。 你知道的，母鸡卡已经烂完了，但追番过程中看吧友假药的体验还是很有趣的。追番时的怒气值从第九集开始积累，在第十二集达到巅峰，也有了删掉这篇文章的想法。但想了想看假药的体验确实足够有趣，于是就这样吧。释怀是不太能释怀的，整部动画的割裂感实在令人感到恶心。（2025.3.21 更新） 关于整体走向的假药时间轮回说时间轮回 是第九集出现的假药 第九集灾难般的爆爆爆让许多假药的讨论度都大幅下降，不过时间乱序说重新登场，更是出现了时间轮回说。（致敬传奇第十话——我的战场不在这里） 我感觉时间轮回不太可能，不过这个想法太酷了！至于时间乱序，最明显的证据是第九集 18:40 和第二集 13:34 能连起来。或许可以结合瞳孔变化说来看看第二集是 mortis 还是睦头？ 那么贯穿全剧，把时间重排起来的线索是什么呢？一种说法是手机电量 叙诡说叙诡说 是第二集出现的假药，在三四集得到完善，第五集后讨论度大幅下降。 前四集剧情跳跃、旁白由初华声优念出是因为这是初华在叙述故事！那么，是在对谁讲述呢？ 一种假药是初华对失忆的祥子讲述故事，在叙述中美化自己，好让祥子待在自己身边。理由是祥子在前四集唯独对初华态度比较好，这是初华对自己的美化。 另一种是初华对自己讲述故事，只是在自我欺骗“乐队依然存在”，因此剧本漏洞百出。但无论叙述多少次，乐队都逃不掉解散的结局。 上面的蓝色链接是“初华对自己讲述故事”。 内鬼内鬼说 是第四集出现的假药，主要用于解释观感奇怪的解散。 母鸡卡解散的剧情逻辑混乱，这是因为队里有内鬼，内鬼只要把队解散掉就行了。由于我比较喜欢祥子，所以我接下来讲全队内鬼，祥子 1vn 的剧情。 整个事务所都是丰川家族安排的内鬼，上到其他乐队成员下到工作人员，都对“丰川家希望祥子回家”这件事或多或少有了解，因此工作人员浑水摸鱼，除了祥子以外的乐队成员都不在乎乐队。祥子 1vn 硬生生把母鸡卡带到了武道馆，不愧是美强惨大女主，数值太高了。 这太数值怪啦，不合理的！不过内鬼说还是很有趣而且很靠谱的，我觉得比较真的是初华喵梦内鬼，睦和海玲知情。 人偶人偶说 是第七集出现的假药。 mujica 结尾全员人偶化。“在 mujica 的短暂月光下，五个人偶短暂的复活了，在舞台上高歌一曲。给出了一场完美 live。” 关于个人的假药初华蜘蛛侠蜘蛛侠 其实初华的真实身份是蜘蛛侠，各种蜘蛛意象是暗示初华被蜘蛛咬过。能力越大，责任越大，蜘蛛侠要打击犯罪，所以既不去 Mujica 排练，也不去 sumimi 排练，还说自己忙。初华让祥子在门口等 10 秒其实是在藏蜘蛛战衣，她 10 秒就能收拾好房间、第三集隔着几十米听到祥子和睦的对话都是因为她有超能力。众所周知祥子是蓝色章鱼，初华把祥子带到自己家实际上是为了监视章鱼博士。而且，既然有双面人睦、企鹅人高松灯、章鱼博士祥子，有蜘蛛侠初华也不奇怪。 叙诡叙诡说 之前已经提过，这里的链接是第二集播出后的初版假药。 之前已经说过了，旁白由初华的声优念出、前几集逻辑诡异，都是因为这是初华讲述的故事。初华是母鸡卡故事的叙述者。 缓存不足缓存不足说 是第四集出现的假药。 “初华对某些记忆的深刻程度，可能不会被时间冲淡，而一些日常记忆可能会被很快的忘却。在她心目中，自己和心爱的祥子度过的每个夏天、出道时祥子发来的短信鼓励可能一直占据着她脑内非常非常多的缓存。这些和祥子一起的快乐的记忆对初华来说可能就像是刚刚经历的一样，那份喜悦、甜蜜、饥渴就像冰一样无时无刻不在侵蚀初华的大脑，所以初华才会给人一种难以形容的超重女印象。” 认知障碍初华认知障碍说 是第一集出现的假药。 初华的眼里一直都只有祥子，别人的形象在她眼里是扭曲的。众所周知，MyGO 第八集里有初华的回忆，回忆里明显能看出初华见过祥子的人偶。然而在母鸡卡第二集里，她却好像是不认识人偶的样子。答案是初华在小时候将睦认知成了人偶。 失忆初华失忆说 是第二集出现的假药。 为什么初华如此空洞？为什么初华的童年记忆和祥子有偏差？为什么初华忘了祥子的玩偶？因为初华经历过一次失忆。初华拿着以前的日记本，努力扮演“真正的初华”。 祥子⭐ 压抑丰川祥子 ⭐ 压抑说 祥子对大雷情有独钟，组乐队是为了接近大雷。 人偶祥子人偶说 是第七集出现的假药，主要用于解释第七集祥子的形象变化。 第 7 集的祥子为了睦成为了舍弃自我的人偶，她装出了白祥的样子，因为“只要睦能回来就好了”。 祥爹演戏祥爹演戏说 是第五集出现的假药。 祥爹演戏把祥子气走，让祥子回归家族。 睦装双重人格睦装双重人格说 是第四集出现的假药。 如题，主要依据是第四集睦在初华车上的第一句“嗯”是睦的声线。 mortis 小小祥mortis 小小祥说 应该是第六集出现的假药。 睦小时候只有祥子一个朋友，mortis 是睦以白祥为模板塑造的人格，扮演小祥。 写文章时整理的假药链接 叙诡 内鬼说 人偶说 睦祥黑手说 圣经说 元素说 蜘蛛侠 叙诡说 缓存不足说 初华认知障碍说 初华失忆说 祥子失聪说 祥子人偶说 祥爹演戏说 睦装双重人格说 mortis 小小祥说 mortis 锡兵说 雨伞颜色 祥睦姐妹说 天天吃假药吃傻了做出来的冰山图 四演 mortis 四演祥子 歌剧魅影说","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/"},{"name":"二次元","slug":"杂谈/二次元","permalink":"http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/%E4%BA%8C%E6%AC%A1%E5%85%83/"}],"tags":[]},{"title":"对探索类游戏的思考","slug":"game-design/对探索类游戏的思考","date":"2025-02-14T12:36:38.000Z","updated":"2025-08-19T07:50:56.136Z","comments":true,"path":"wiki/game-design/对探索类游戏的思考/","permalink":"http://rinevard.github.io/wiki/game-design/%E5%AF%B9%E6%8E%A2%E7%B4%A2%E7%B1%BB%E6%B8%B8%E6%88%8F%E7%9A%84%E6%80%9D%E8%80%83/","excerpt":"","text":"为什么要探索呢？设想一下，如果我们乘上了飞船，飞入太空，忽然发现一颗行星朝着反方向转动了。这时你会不会想去那里？如果我们在网上发现了一个网站，点开第一个链接发现里面是你的家庭住址（我超，盒！），你会不会想继续翻别的链接？人类探索的动力被命名为好奇心，好奇驱动探索。 好吧，我们不妨把话说得更明白一些，好奇驱动探索的意思就是：“我相信那里有值得关注的东西，但不确切知道是什么，所以我要去探索。” 这听起来真的是再平凡不过的事情了，那就来分析一下怎么激发玩家的好奇心，再让好奇驱动探索吧。 相信有值得关注的东西在探索之前，首先要让玩家相信“那里有值得关注的东西”。值得关注的东西并不难做，它们可以是奇观、奖励乃至挑战，关键是怎样让玩家相信“那里有东西”。 做法很多，我们来找几个例子，看看关注探索感的游戏都是怎么做到这一点的。 首先来看类银河城游戏，对有经验的玩家，获得新能力就自然想到“以前有个过不去的路能靠这个能力过去”，然后也就想到“那里有值得关注的东西”；看到墙就自然想到假墙，然后就想到“那里有值得关注的东西”了。然而，这种做法过度依赖玩家的先验知识。对一个新接触类银河城的玩家来说，到处迷路才是更可能发生的事情，他们根本不知道“哪里有值得关注的东西”。 我想这也是类银河城游戏相对小众的原因，它只给有经验的玩家提供了探索感，而给新玩家提供了迷路感。能力锁尚且好说，假墙就实在是不利于探索感的塑造了，毕竟大多数玩家的先验知识是“墙体不可破坏”，根本就不会想到“墙后面有值得关注的东西”。不过假墙并非一无是处，它能给玩家一种“秘密”的感觉，这就是题外话了。所以说如果做类银河城，起码要提醒一下玩家这些设计的存在，而不是盲目地抄别的银河城的做法。在空洞骑士开局的时候，我们必须打碎一面墙才能前进，这就是一个不错的提醒。 接下来看看清单式开放世界。虽然在地图上到处塞问号的方法为人诟病，但这也确实非常清晰地把“那里有东西”传达给了玩家。那为什么为人诟病呢？主要是因为问号里的东西千篇一律，连“值得关注的东西”都没做到。那如果把每个问号都塞一个精美的支线，会好点吗？恐怕也不一定，因为被动地接受问号和主动发现问号带来的“值得关注感”是不一样的。自己找到的东西，就算再无聊也会想看完。 这里就不谈塞尔达了。说起来不太好意思，但我在玩的时候确实没感到什么探索欲望。一是我没感觉到哪里有东西，二是因为我也没感觉有什么值得我关注的东西。（球球了，不要开除我的玩家籍） 然后谈谈星际拓荒吧，这篇文章可以说就是为了星际拓荒而写的。星际拓荒的做法主要有两种，一种是奇观，另一种是非常直白地用文字告诉你“那里有东西”。前者不必多说，后者的文字描述本身也足以让玩家觉得那里“值得关注”。 不确切知道有什么这一点看起来不难实现，但和前一点结合起来就很难了。玩家玩了一段时间游戏后，很快就会对奖励有一定预期，如果做不到打破这种预期，就会让玩家丧失好奇心，丧失探索欲。 这一点在有经验的玩家身上体现的尤其明显。对一个普普通通的探索类游戏，他们对一切几乎都有预期，因此也会丧失探索欲。 其实，绝大多数游戏都让玩家丧失了探索欲，让我们以清单式开放世界为例，看看问号是如何让玩家失去探索欲的。 假设我们面前有一个玩家在玩游戏，我们看看会发生什么。玩家到了第一个问号，是一个有趣的战斗！玩家很开心。玩家到了第二个问号，是一个高级武器！玩家很开心。……玩家到了第 16 个问号，是一个已经重复过不知道多少遍的的战斗，在战斗结尾还奖励了一个高级武器！玩家对此早有预期，不再想去下一个问号了。 看见了吗，玩家就是这样丧失探索欲，沦为清问号机器的。 开放世界里的问号这么说来，把每个问号的内容都换成一个玩家猜不到是什么的精美的支线就能激发探索欲？这确实能改善现状，但也并非全然如此。问号始终没有完全做到让玩家觉得那个地方“值得关注”，毕竟问号是设计师在地图上标出来的，而不是玩家主动标出的。 许多类银河城里也提供了在地图上打标记的功能，我们可以横向对比一下。很明显，一张全是自己标出的问号的地图和一张全是游戏自带的问号的地图相比，前者更能激发探索欲。究其根本，就在于前者的每个问号都真的让玩家相信“那里有值得关注的东西”。 那么怎么改进开放世界里的问号呢？我也不确定。说到底问号这个东西根本就没让玩家觉得“那里有值得关注的东西”不是吗？终究要让玩家觉得自己是主动关注到那里的才行，问号还是太被动了。 文末写到这里，关于探索的内容就基本写完了，最后是一些让探索更有趣的小技巧，我随便列一些，不再详谈。 能力软锁：常见于类银河城。能力软锁不仅是关卡设计手段，也是控制可选路线数量的工具。限制选项数量的重要性不必多说。 线索：好的秘密需要提示，而非随机乱逛。我实在是欣赏不了到处乱藏东西的银河城。这还会涉及到电波式谜题（我感觉比“点击式谜题”更好理解）和逻辑谜题的差异，不详谈。 知识积累：游戏应该逐步教会玩家识别探索机会的能力，也被称作“知识锁”。 一个相当有趣的体验是“新视角”，即发现了过去没有发现的探索机会。能力成长、环境变化、知识积累都能带来新视角。其中我最喜欢的是环境变化和知识积累带来的新视角，大概是因为不常见吧。 让我们试试一个简单的传达探索的体验的 demo 。我们看到了下面的东西： 所以，这就是探索了？ 你好奇那里有什么吗？既然你读完了文章，希望你也会好奇作者还能整出什么新活吧。我本来应该在里面放置一些有趣的东西来满足你的好奇心，不过考虑到时间有限，就只能放个普通的彩蛋了。 /* 隐藏草书 */ .hidden-fancy-text { font-family: 'Brush Script MT', cursive; font-size: 20px; /* text-align: center; */ margin: 20px 0; /* padding: 20px; */ line-height: 1.5; color: transparent; cursor: default } .hidden-fancy-text::selection { color: darkred; background: white; } 如果作者在认真做游戏的话，我们也应该会见面的。","categories":[{"name":"游戏设计","slug":"游戏设计","permalink":"http://rinevard.github.io/categories/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[]},{"title":"欢迎！","slug":"欢迎！","date":"2025-02-06T02:25:53.000Z","updated":"2025-08-20T11:13:48.854Z","comments":true,"path":"wiki/欢迎！/","permalink":"http://rinevard.github.io/wiki/%E6%AC%A2%E8%BF%8E%EF%BC%81/","excerpt":"","text":"这是一篇欢迎文章，欢迎来到我的网站！ 如你所见，左边是网站的文章列表，以文件夹的形式排布；左上方的“首页”就是这里的网页，“文章历史”记录了文章的诞生时间线，“关于”是我的自我介绍；右边是文章的目录，悬停会展开目录，点击就能跳转到对应位置。 本站使用了我和 LLM 基于 Hexo 的 Wikitten 做的自制主题！ 我应该主要会在这里放一些杂谈和游戏相关的文章，欢迎来看！","categories":[],"tags":[]}],"categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/"},{"name":"碎碎念","slug":"杂谈/碎碎念","permalink":"http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"},{"name":"公开课","slug":"公开课","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"CS144","slug":"公开课/CS144","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/CS144/"},{"name":"Labs","slug":"公开课/CS144/Labs","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/CS144/Labs/"},{"name":"MIT-6.S081","slug":"公开课/MIT-6-S081","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/MIT-6-S081/"},{"name":"Labs","slug":"公开课/MIT-6-S081/Labs","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/MIT-6-S081/Labs/"},{"name":"翻译","slug":"杂谈/翻译","permalink":"http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/%E7%BF%BB%E8%AF%91/"},{"name":"GAMES101","slug":"公开课/GAMES101","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/"},{"name":"Assignments","slug":"公开课/GAMES101/Assignments","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/Assignments/"},{"name":"Notes","slug":"公开课/GAMES101/Notes","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/GAMES101/Notes/"},{"name":"游戏设计","slug":"游戏设计","permalink":"http://rinevard.github.io/categories/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/"},{"name":"Notes","slug":"公开课/MIT-6-S081/Notes","permalink":"http://rinevard.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/MIT-6-S081/Notes/"},{"name":"gamejam","slug":"gamejam","permalink":"http://rinevard.github.io/categories/gamejam/"},{"name":"二次元","slug":"杂谈/二次元","permalink":"http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/%E4%BA%8C%E6%AC%A1%E5%85%83/"}],"tags":[]}