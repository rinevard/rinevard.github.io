{"meta":{"title":"Rinevard","subtitle":"","description":"","author":"Rinevard","url":"http://rinevard.github.io","root":"/"},"pages":[{"title":"无穷的远方，无尽的人们","date":"2025-03-20T13:12:59.559Z","updated":"2025-03-20T13:12:59.559Z","comments":true,"path":"links/index.html","permalink":"http://rinevard.github.io/links/index.html","excerpt":"","text":"这里是一些有趣的人们，我的生活因他们而增添了一抹奇幻色彩。你知道的，我并没有很多社交技能点，所以便用这种方法来告诉未来的自己——我曾遇见过一些有趣的人。 北理工先是一些算是同辈的人吧 示例链接 1 - 描述文字 示例链接 2 - 描述文字 示例链接 3 - 描述文字 然后是一些前辈，虽然年龄也差不太多就是了 范滇东的博客 - 如果没有前辈开发的 bit101，我的北理生活想必不会那么有趣。 周弈帆的博客 - 一个有趣的前辈，写的博客对我有启发。 这个页面是突发奇想做出来的，如果它让我和人们有了更多的联系，那实在很有趣！抱着对这份奇幻色彩的期待，便觉得这些文字值得写了。"},{"title":"Categories","date":"2025-02-06T02:38:03.136Z","updated":"2025-02-06T02:38:03.136Z","comments":true,"path":"categories/index.html","permalink":"http://rinevard.github.io/categories/index.html","excerpt":"","text":"这里什么也没有哦~文件夹已经很方便了，为什么还要用分类呢？"},{"title":"About","date":"2025-02-07T13:52:21.292Z","updated":"2025-02-07T13:52:21.292Z","comments":true,"path":"about/index.html","permalink":"http://rinevard.github.io/about/index.html","excerpt":"","text":"这里是 Rinevard. 喜欢独立游戏之类的新鲜事物。我应该主要会在站里放一些杂谈和游戏相关的文章，欢迎来看！ 偶尔会出现的爱好是取名，我还用过 Lyraine、鲤鱼、江知鹤（读起来和 rinevard 蛮像的）之类的名字。 如果想和我联系，欢迎发邮件到 rinevard@outlook.com！（不过不一定会看） 我的 Github 账号: Rinevard"},{"title":"探索的奖励","date":"2025-02-11T02:04:52.000Z","updated":"2025-02-14T07:33:52.506Z","comments":true,"path":"secret/index.html","permalink":"http://rinevard.github.io/secret/index.html","excerpt":"","text":"/* 隐藏文本相关样式 */ .secret-text::selection { color: white; background: black; } .secret-text { background: transparent; cursor: default; /* 鼠标样式保持默认 */ } #output { white-space: pre; font-family: monospace; font-size: 12px; line-height: 12px; letter-spacing: unset; transform: unset; overflow-y: hidden; background: transparent; cursor: default; /* 鼠标样式保持默认 */ } /* 草书效果相关样式 */ .cursive-text { font-family: 'Brush Script MT', cursive; font-size: 20px; color: darkred; /* text-align: center; */ margin: 20px 0; /* padding: 20px; */ line-height: 1.5; cursor: default; } /* 草书效果相关样式 */ .center-cursive-text { font-family: 'Brush Script MT', cursive; font-size: 20px; color: darkred; text-align: center; margin: 20px 0; /* padding: 20px; */ line-height: 1.5; cursor: default; } /* 隐藏草书 */ .hidden-fancy-text { font-family: 'Brush Script MT', cursive; font-size: 22px; /* text-align: center; */ margin: 20px 0; /* padding: 20px; */ line-height: 1.5; color: transparent; cursor: default; } .hidden-fancy-text::selection { color: darkred; background: white; } /* 人迹罕至的路 */ .paths-container { display: flex; justify-content: center; margin: 20px 0; font-family: 'Brush Script MT', cursive; font-size: 20px; } /* 修改链接样式 */ .paths-container a.path { padding: 15px; text-decoration: none !important; border: none; /* 移除可能的边框 */ background: none; /* 移除可能的背景 */ } /* 有人的路径样式 */ .paths-container a.path-visible { color: #5a3921 !important; /* 使用 !important 来确保优先级 */ } /* 隐藏的路径样式 */ .paths-container a.path-hidden { color: transparent !important; /* 使用 !important 来确保优先级 */ } /* 悬停效果 */ .paths-container a.path-hidden:hover { color: #5a3921 !important; transition: color 0.3s ease; } /* visited状态 */ .paths-container a.path-visible:visited { color: #5a3921 !important; } .paths-container a.path-hidden:visited { color: transparent !important; } .paths-container a.path-hidden:hover:visited { color: #5a3921 !important; } 对不起骗了大家这么久，其实我是一条鲤鱼。 ..-*=. ......:::....... .:=*****:. ..:=++*++=---------=++**+=:.. .:+********-. ...+*+:.. ..:=*+:.-***************-. ..:-*+.. .=***************: .:=+*=**: .:***************+. ..-=- +*: .:****************: ..:+ +*: .:****************- .+* ** +*: .:****************- .-** +*: .:****************: +...+ +*: .:****************. :.:=****-. .:***************- ..:-++-.. ..-++-*************=. ..:=**+=:..... .....:-+**+:....-**********=.. ...:-===++++++==-:... .-*******=. ..=***+. ..-*:. 嗯，实在是太敷衍了，所以我稍微加了点东西。 祝你好运，也祝你玩得开心。 黄昏的树林里分出两条路， 所幸在此我能同时去涉足 人来人往的路 人迹罕至的路 或许哪天还会再来看看这里的变化？启程了，再见啦。"},{"title":"人迹罕至的路","date":"2025-02-14T06:12:25.238Z","updated":"2025-02-14T06:12:25.238Z","comments":true,"path":"secret/jurora-path.html","permalink":"http://rinevard.github.io/secret/jurora-path.html","excerpt":"","text":"/* 草书效果相关样式 */ .center-cursive-text { font-family: 'Brush Script MT', cursive; font-size: 24px; color: darkred; text-align: center; margin: 20px 0; /* padding: 20px; */ line-height: 1.5; cursor: default; } /* 隐藏草书 */ .hidden-fancy-text { font-family: 'Brush Script MT', cursive; font-size: 24px; text-align: center; margin: 20px 0; /* padding: 20px; */ line-height: 1.5; color: transparent; } .hidden-fancy-text::selection { color: darkred; background: white; } /* 人迹罕至的路 */ .secret-message { color: transparent; cursor: default; font-family: 'Brush Script MT', cursive; /* 使用草书字体 */ font-size: 24px; text-align: center; margin: 20px 0; line-height: 1.5; } .secret-message:hover { color: darkred; transition: color 0.5s ease; /* 稍微延长过渡时间 */ } 一片树林里分出两条路—— 而我选择了人迹更少的一条， &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 从此决定了我一生的道路。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"},{"title":"人来人往的路","date":"2025-02-14T06:44:57.617Z","updated":"2025-02-14T06:44:57.617Z","comments":true,"path":"secret/many-people-path.html","permalink":"http://rinevard.github.io/secret/many-people-path.html","excerpt":"","text":"/* 草书效果相关样式 */ .center-cursive-text { font-family: 'Brush Script MT', cursive; font-size: 24px; color: black; text-align: center; margin: 20px 0; line-height: 1.5; cursor: default; } /* 重叠文字效果 */ .text-overlay-container { position: relative; height: 100px; margin: 20px 0; } .overlapping-text { position: absolute; width: 100%; font-family: 'Brush Script MT', cursive; font-size: 24px; text-align: center; color: black; opacity: 0.15; cursor: default; } /* 为每行文字设置不同的位置和透明度 */ .text-1 { top: 0; opacity: 0.8; } .text-2 { top: 12px; opacity: 0.6; } .text-3 { top: 24px; opacity: 0.4; } .text-4 { top: 36px; opacity: 0.2; } .text-5 { top: 48px; opacity: 0.1; } .text-6 { top: 60px; color: transparent; } 一片树林里分出两条路—— 而我选择了人来人往的一条， 只看到了六道印迹。 脚印 脚印 脚印 脚印 脚印 脚印"},{"title":"Tags","date":"2025-02-06T02:37:47.887Z","updated":"2025-02-06T02:37:47.887Z","comments":true,"path":"tags/index.html","permalink":"http://rinevard.github.io/tags/index.html","excerpt":"","text":"这里什么也没有哦~文件夹已经很方便了，为什么还要用标签呢？"}],"posts":[{"title":"Ludum Dare参加指南","slug":"game-design/ldjam参赛指南","date":"2025-04-13T01:36:38.000Z","updated":"2025-04-13T01:35:59.031Z","comments":true,"path":"wiki/game-design/ldjam参赛指南/","permalink":"http://rinevard.github.io/wiki/game-design/ldjam%E5%8F%82%E8%B5%9B%E6%8C%87%E5%8D%97/","excerpt":"","text":"零、在文章开始之前本文包含了对 Ludum Dare 的介绍、参与流程及个人看法。写作的契机是参与 Ludum Dare 后体验很好，但在中文互联网上没有找到很全面的介绍资料，只找到了 规则介绍。在规则介绍之外，我希望聊聊 Ludum Dare 的体验为什么好（比起我参加过的其他 gamejam），并按时间线介绍一下参与流程。 一、什么是 Ludum Dare官网写到，”Ludum Dare is an event where you create a game from scratch in a weekend based on a theme.”（出自 rules），即“Ludum Dare 是一个围绕某个主题在一个周末从零开始做出一个游戏的活动。”更具体一点，Ludum Dare 主要分为两个赛道，分别是单人 48 小时做一个游戏和组队 72 小时做一个游戏。 这时候有经验的读者就会问了，这不就是 gamejam 吗？正是如此！Ludum Dare 是非常早期的 gamejam，它自 2002 年开始举办，每年举办两次，到今天已经办了 57 届。每届 Ludum Dare 都会吸引全球数以万计的开发者，如 2021 年的 49 届收到了近 3000 款游戏提交， 2023 年的第 52 届收到了 1632 款游戏提交（数据来源）。在这大量的提交游戏中，也有许多精品作品从此发源，比如邪恶铭刻（inscryption）的原型 Sacrifices Must Be Made 就于 Ludum Dare 43 制作。 二、为什么参加 Ludum Dare中国有那么多本土的 gamejam，那为什么要顶着语言障碍参加 Ludum Dare 呢？我认为最重要的两点是游戏质量高、收获反馈多。 先说前者，gamejam 总是有竞赛性质的，在 Ludum Dare 里我们要和全世界的优秀开发者竞争，单是看着这些开发者围绕主题的奇思妙想就已经让人觉得值回票价了（并没有票价，这是免费活动），而如果取得了好排名则更是会给人相当的成就感。 再说后者，介于 Ludum Dare 的算法，每个游戏基本都会获得 20 个以上的评分，而且你玩的游戏越多，Ludum Dare 就会把你的游戏放在推荐榜越靠前的位置，从而就会有越多人玩你的游戏。以我的经验来看，玩的游戏数量和收获的评分数量基本接近，而且很多玩了我们游戏的开发者会在游戏下给出评论来反馈，非常利于我们了解自己游戏的优秀之处（可惜的是评论一般不说缺点，以夸夸居多）。 下面再举几个 Ludum Dare 的其他优势： 足不出户：与线下 gamejam 不同，参加 Ludum Dare 无需报名，只要注册账号并在提交时间截止前提交游戏即可。 玩游戏方便：大部分开发者都会提供游戏的 web 版本，即使不提供 web 版本也可以直接在对应的游戏页面下载游戏。 交流机会：我们可以给别的游戏提供反馈，也可以在别的游戏评论区里询问开发者的设计思路，一般都会收到积极的回复。 和大神合影：每届的 Ludum Dare 都会有一些大神来参加，如果恰巧碰上了自己感兴趣的大神，就有了在他们的游戏评论区夸夸的合影机会！ 三、参与流程Ludum Dare 的流程大概是主题投票、制作、评分与反馈、结果公布。为了顺利参赛，首先我们要在 Ludum Dare 上注册一个账号。注册账号需要邀请码，我们可以在 Google 上用 ludum dare invitation code 之类的关键词或者在举办者的主页上找到邀请码。我找到的第 57 届的邀请码有 Time4LD57 和 BirdSiteLD57。 在注册成功之后，我们要想想这次是单人参赛还是组队参赛。Ludum Dare 有三条赛道，Compo、Jam 和 Extra. Compo 是经典模式，要求单人 48 小时内做游戏，所有内容包括美术、音效等都需要在 48 小时内从零开始做出，而且必须开源源代码。我们可以使用任何已经写过的基础代码和任何工具。如果你的游戏收到了 20 个以上的评分，会得到最终评分。 Jam 相对宽松，只要求组队 72 小时内做游戏，可以使用任何已经写过的基础代码，也允许使用部分预制素材。若美术或音效非原创，需要在提交时关闭对应类别的打分。比如如果我们用了第三方美术，就要在提交时关闭 Graphics 的打分。如果你的游戏收到了 20 个以上的评分，会得到最终评分。 Extra 则是轻松组，时间宽裕至 3 周，单人或团队均可，内容以原创为主但允许预制素材，美术或音效非原创可退出对应评分类别，源代码提交可选，但无最终排名。 赛道在提交时才需要确定，所以如果你原本打算参加 Compo，但没来得及赶上 Compo 的截止提交时间，也可以转去 Jam 的提交。 想好了赛道后，就能进入之后的环节了。 主题投票官方会提供大量的主题（第 57 届有 1000 多个），经过初选轮、复选轮、决赛轮，最终得出一个结果主题。我们当然不必给每个主题都投票，我的个人建议是在决赛轮投一下就行。而且即使不投票也是能参赛的！参赛的唯一要求就是在提交时间截止前提交作品。 是否围绕主题做游戏也是可选的，主题只是最终评分中的一部分，Ludum Dare 的宗旨是鼓励开发者把游戏做出来。 制作阶段进入制作阶段后，我们就可以开始做游戏了！点击右上角的 join event，就能创建游戏草稿页。我们会在上传阶段填充这个草稿页。 制作游戏需要大家各显神通，我简单谈谈个人建议吧。 设计一般来说，我们要快速地找到多个想法，然后选择自己觉得最有前途的想法做下去。由于制作时间很紧，我们注定不能做大做全。比起大而全，小而美是更好的选择。一个只有三关的认真打磨过的作品比一个有十关的每关都很粗糙的作品要好得多。 程序尽管 Ludum Dare 允许设计桌游乃至更不被定义的游戏（我见过一个翻文件夹的游戏），但我们这里只讨论电子游戏。程序方面，选用自己最熟悉的工具即可。有熟练的游戏引擎就选游戏引擎，喜欢不用引擎开发就不用引擎开发。 音乐我是音乐萌新，虽然听说过 FL studio 之类的工作站，但我现在还没学会。所以我这里推荐一个简单的音乐制作网站——Musiclab，我使用里面的SongMaker做出了能听的东西。 音效sfxr是很简单的音效制作网站，我看不懂参数，所以我的工作流是把我想要的效果告诉 AI，AI 告诉我怎么调参，效果出乎意料地还算不错。 美术我用Piskel画简单的像素画，偶尔也用Krita来画别的东西。 抛开 Extra 赛道不谈，这个阶段持续 48 小时或 72 小时，我最后的建议是在参与的同时保持充足的睡眠，好好睡觉好好吃饭很重要！ 上传阶段在制作阶段结束后，会给额外的一小时来上传。尽管官网给了额外一小时的上传时间，我还是建议大家在制作阶段的末尾就开始研究怎么上传游戏，以防万一嘛。 我们可以在这段时间里填充右上角 My Game 的草稿页，按着页面要求填写即可。 我们可以把游戏压缩包上传到页面上，同时 Ludum Dare 支持 Embed HTML5，也就是说我们可以根据Embedding Guide直接把游戏的网页版上传到官网的游戏页面上。建议大家同时把网页版上传到 itch 上，毕竟官网的网页版游戏支持做得不算很完美。 记得退出自己不符合&#x2F;不想要的打分选项。 评分阶段至此，恭喜你做出了自己的游戏！ 评分阶段持续三周，在评分阶段，我们可以试玩别人的游戏并打分，你打分的游戏越多，推荐算法给你的游戏的推荐优先级就越高。同时高质量评论也能提高你游戏的推荐优先级。 评分阶段允许继续编辑页面，比如如果你发现游戏页面的描述有问题，随时可以进行修改。修游戏内的 bug 也是被允许的，但要求在修 bug 以后显式地在游戏页面标出自己做的修改（写一个简要的 devlog），而且不能增加新功能。 结果公布游戏会根据打分来排名。没有奖品，你的游戏就是最好的奖品！ 四、其他资料可以在rules页面找到详细的参加规则，强烈建议在参加前阅读。 可以在这篇规则介绍找到中文的规则介绍，但不如上面那个全面。 本文的结构参考了 Google 编程之夏(GSoC)：海量优质项目，丰厚报酬，你竟然还不知道？","categories":[{"name":"gamejam","slug":"gamejam","permalink":"http://rinevard.github.io/categories/gamejam/"}],"tags":[]},{"title":"第十章——系统级I/O","slug":"learning/open-course/CMU-15-213/Notes/Chapter10-system-io","date":"2025-04-11T02:00:00.000Z","updated":"2025-04-13T02:02:21.876Z","comments":true,"path":"wiki/learning/open-course/CMU-15-213/Notes/Chapter10-system-io/","permalink":"http://rinevard.github.io/wiki/learning/open-course/CMU-15-213/Notes/Chapter10-system-io/","excerpt":"","text":"img{ width: 75%; } 文件所有的 I&#x2F;O 设备都被视为文件，因此我们能用一致的方式处理各种输入输出。 文件类型分为以下几类 普通文件：包含用户数据，可以是文本文件（如.txt）或二进制文件（如.jpg、.exe） 目录：包含一系列链接，每个连接将一个文件名映射到一个文件 套接字（socket）：跨网络通信用的文件 读写文件文件描述符（file descriptor）文件描述符是一个非负整数，代表进程打开的文件的标识符。在进程中，每当打开一个文件时，操作系统会分配一个文件描述符给它。 默认情况下，0 表示标准输入（stdin），1 表示标准输出（stdout），2 表示标准错误（stderr）。通过系统调用（如 open）打开文件后，会返回一个新的文件描述符（如 3、4 等），具体值取决于当前进程中已使用的描述符情况。 以下是一个使用 open 系统调用的示例，展示如何打开一个文件并获取文件描述符： 1234567891011121314151617181920212223242526#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main() &#123; // 打开文件 &quot;example.txt&quot;，以只读模式 int fd = open(&quot;example.txt&quot;, O_RDONLY); if (fd == -1) &#123; perror(&quot;open failed&quot;); return 1; &#125; printf(&quot;文件描述符: %d\\\\n&quot;, fd); // 使用文件描述符进行操作（如读取） char buffer[100]; ssize_t bytes_read = read(fd, buffer, sizeof(buffer)); if (bytes_read == -1) &#123; perror(&quot;read failed&quot;); close(fd); return 1; &#125; // 关闭文件描述符 close(fd); return 0;&#125; 不足值（short count）“不足值”是指在读写操作中，实际读取或写入的字节数少于请求的字节数。原因有遇到 EOF、从终端读文本行（如果读终端，read 一次只传输一个文本行）、读写网络套接字。 比如调用 read(fd, buffer, 100)请求读取 100 字节，但文件只剩 50 字节可用，则返回 50（不足值）。 我们需要检查返回值，确认实际读写字节数，并根据需要调整逻辑（如循环读取剩余数据）。 描述符表、文件表、v-node 表操作系统在内核中维护了三层数据结构来管理文件： 描述符表：每个进程独有，记录该进程打开的所有文件描述符及其对应的文件表项。 文件表：所有进程共享，表项包括偏移值、引用计数（即当前指向该表的描述符表项数）、指向 v-node 表中对应项的指针。关闭一个描述符会减少相应的文件表表项的引用计数，减到零会删除。 v-node 表（或 inode 表）：与具体文件系统相关，记录文件的元数据（如文件大小、权限、存储位置）。每个文件在 v-node 表中有一个唯一条目。 调用 open 打开文件的具体过程当调用 open 系统调用打开一个文件时，操作系统会执行以下步骤： 验证和查找文件： 内核检查文件路径、权限等，确定文件是否存在且进程有权访问。 找到文件对应的 v-node（或 inode），如果文件已在 v-node 表中，则复用，否则创建新条目。 分配文件表项： 内核在文件表（file table）中创建一个新表项，记录文件的偏移量（初始为 0）、访问模式（如只读、读写）、引用计数（初始为 1）以及指向对应 v-node 的指针。 更新描述符表： 内核在调用进程的描述符表（file descriptor table）中分配一个未使用的最小描述符编号（如 3，若 0、1、2 已占用）。 将该描述符指向新创建的文件表项。 返回文件描述符： open 调用返回分配的文件描述符给进程，供后续操作（如 read、write）使用。 open 两次： fork： 基于缓冲区的读写基于缓冲区的读写将数据先写入内存缓冲区，等缓冲区满或显式刷新（如 fflush）时再一次性与底层设备做数据交换，降低了 I&#x2F;O 开销。 在使用读写时，我们应尽可能使用 stdio 标准库。stdio（标准输入输出库）提供了基于缓冲区的 I&#x2F;O 操作（如 fopen、fread、fwrite、printf 等），相比直接使用低级系统调用（如 read、write），它的效率更高而且更不易出错。","categories":[{"name":"学习","slug":"学习","permalink":"http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"公开课","slug":"学习/公开课","permalink":"http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"CMU-15-213","slug":"学习/公开课/CMU-15-213","permalink":"http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/"},{"name":"Notes","slug":"学习/公开课/CMU-15-213/Notes","permalink":"http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/Notes/"}],"tags":[]},{"title":"Shlab调试记录和一键测试脚本","slug":"learning/open-course/CMU-15-213/Labs/Shlab","date":"2025-04-03T09:04:28.000Z","updated":"2025-04-03T09:15:49.780Z","comments":true,"path":"wiki/learning/open-course/CMU-15-213/Labs/Shlab/","permalink":"http://rinevard.github.io/wiki/learning/open-course/CMU-15-213/Labs/Shlab/","excerpt":"","text":"写在前面用时 10h30min, 通过所有测试。这个 lab 还是比较直接的, 按着 trace 的顺序逐步实现即可, 难点主要在调试和不熟悉系统调用语法上。我在写代码的过程中遇到了两个调了蛮久的 bug, 分别在 trace13 和 trace16 上, 下面简要复盘一下。 调试trace16先说 trace16 的 bug, 这个调了半小时。trace16 测试的是 shell 能否处理子进程被外部信号中断或停止的情况。我遇到的问题是 trace16 在 ./mystop 那里卡住了, 于是猜测原因是 jobs 没能正确更新子进程的暂停状态。后面加了点调试语句发现果然如此。那么修复思路就是在子进程暂停后把它对应的 job 状态进行更新。但怎么知道子进程什么时候暂停呢？答案是 sigchld_handler. 我一开始以为 sigchld_handler 只会在某个子进程终止后被调用, 所以只在 sigchld_handler 里写了回收已经终止的子进程的逻辑。后来发现子进程只要状态发生变化就会发 SIGCHLD 信号给父进程, 子进程终止只是一种情况, 暂停、恢复也会发送这个信号。所以让 sigchld_handler 检查已经停止的子进程, 并更新它们对应的 jobs 状态就修复了这个 bug. trace13然后是 trace13 的 bug, 这个调了两小时半。这里的问题是在 fg %1 卡住。第一个猜测自然是进程没能被正确移到前台, 但加了调试语句后发现它确实被移到前台了。之后的猜测就是 waitfg 的实现有误, 这个猜测看起来很合理, 毕竟 handout 里写 waitfg 大概需要 20 行, 而我只用了 4 行。但测了半天发现 waitfg 也没问题。 进一步加入各种调试语句, 发现在 fg %1 之后, 进程确实被顺利移到了前台, jobs 也正确更新了, waitfg 只是因为它没结束, 所以一直循环着等着它。好吧, 那我猜是 sigchld_handler 没能正确回收它。我检查了一下, 发现终止的进程也都被正确回收了。那还能是什么原因呢？难道它被暂停了, 但没有被正确启动, 导致我们的 shell 误以为这个暂停着的进程是前台进程, 从而卡住了？这听起来就像是一个并行导致的问题, 于是我又调试了好久, 最后发现它确实被正确启动了, 这个进程只是单纯地还没有终止而已。 那这怎么可能呢？凭什么它在 tshref 里几秒钟就执行完了, 在我的实现里五分钟了都没执行完？原来是我的“启动”写错了。我使用的是 kill(job-&gt;pid, SIGCONT), 这个代码只把启动信号发给了这一个子进程, 而不是发给它所在的进程组, 从而让这个子进程所在组的别的进程没有被正确启动。而看看 mysplit.c 的代码, 会发现它等待它的子进程执行完才会终止, 所以我们把代码改成 kill(-job-&gt;pid, SIGCONT) 就解决了这个 bug. 就因为这一个负号, 我调试了两个半小时, 而且我感觉我一路下来的各种猜想也都很合理, 只能感叹系统级代码真难调试啊。 感想也算是学到了几招吧： 在调用系统函数时一定要检查返回值, 不然会报一些很难调试的错误 在修改全局变量时一定要用 sigprocmask 拦截别的信号, 避免冲突 子进程只要状态发生变化就会发 SIGCHLD 信号给父进程, 终止、暂停、恢复都会发送这个信号 可以用 waitpid 来检查子进程的变化状态, 它会回收终止的子进程 只在信号处理程序中调用异步安全的函数 调试时大胆猜想, 小心求证 一键测试脚本我让 AI 写了一份一键测试脚本, 比官方的形如 make test13 的测试方便不少。脚本的功能是在 traceA 到 traceB（要求 A &lt; B）上分别运行 tsh 和 tshref, 并把输出结果放到两个文件中。比如说, 如果我们输入 ./test_traces.sh 1 5, 就能测试 trace01.txt 到 trace05.txt, 并将结果分别保存到 _tshref_output.txt 和 _tsh_output.txt。之后用各种编辑器自带的比较文件功能就能很方便的比较输出异同。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#!/bin/bash# 脚本名称：test_traces.sh# 显示用法usage() &#123; echo &quot;用法: $0 lower upper&quot; echo &quot; lower: 开始的 trace 文件编号 (1-16)&quot; echo &quot; upper: 结束的 trace 文件编号 (1-16)&quot; echo &quot;示例: $0 1 5&quot; echo &quot; 这将测试 trace01.txt 到 trace05.txt，并将输出分别保存到 _tshref_output.txt 和 _tsh_output.txt&quot;&#125;# 检查是否提供了两个参数if [ &quot;$#&quot; -ne 2 ]; then echo &quot;错误: 请提供 lower 和 upper 两个参数&quot; usage exit 1filower=$1upper=$2ref_output_file=&quot;_tshref_output.txt&quot;tsh_output_file=&quot;_tsh_output.txt&quot;# 清空输出文件（如果已存在）&gt; &quot;$ref_output_file&quot;&gt; &quot;$tsh_output_file&quot;# 获取当前工作目录（模仿 make 的 Entering directory 格式）directory=$(pwd)# 循环运行指定范围的 trace 文件for ((i=lower; i&lt;=upper; i++)); do # 补齐两位数格式（例如 01, 02, ..., 16） trace_num=$(printf &quot;%02d&quot; $i) # 输出 make 样式的进入目录信息（仅第一次循环时） if [ $i -eq $lower ]; then echo &quot;make[1]: Entering directory \\`$directory&#x27;&quot; &gt;&gt; &quot;$ref_output_file&quot; echo &quot;make[1]: Entering directory \\`$directory&#x27;&quot; &gt;&gt; &quot;$tsh_output_file&quot; fi # 为 tshref 输出添加分隔符和内容 echo &quot;===== Trace $trace_num =====&quot; &gt;&gt; &quot;$ref_output_file&quot; echo &quot;./sdriver.pl -t trace$trace_num.txt -s ./tshref -a \\&quot;-p\\&quot;&quot; &gt;&gt; &quot;$ref_output_file&quot; head -n 1 &quot;trace$trace_num.txt&quot; &gt;&gt; &quot;$ref_output_file&quot; ./sdriver.pl -t &quot;trace$trace_num.txt&quot; -s ./tshref -a &quot;-p&quot; &gt;&gt; &quot;$ref_output_file&quot; 2&gt;&amp;1 echo &quot;&quot; &gt;&gt; &quot;$ref_output_file&quot; # 添加空行作为间隔 # 为 tsh 输出添加分隔符和内容 echo &quot;===== Trace $trace_num =====&quot; &gt;&gt; &quot;$tsh_output_file&quot; echo &quot;./sdriver.pl -t trace$trace_num.txt -s ./tsh -a \\&quot;-p\\&quot;&quot; &gt;&gt; &quot;$tsh_output_file&quot; head -n 1 &quot;trace$trace_num.txt&quot; &gt;&gt; &quot;$tsh_output_file&quot; ./sdriver.pl -t &quot;trace$trace_num.txt&quot; -s ./tsh -a &quot;-p&quot; &gt;&gt; &quot;$tsh_output_file&quot; 2&gt;&amp;1 echo &quot;&quot; &gt;&gt; &quot;$tsh_output_file&quot; # 添加空行作为间隔doneecho &quot;测试完成。参考实现结果已保存到 $ref_output_file，学生实现结果已保存到 $tsh_output_file&quot; 用法简述 保存脚本： 将上述代码保存到一个文件，例如 test_traces.sh。 赋予执行权限： 在终端中运行以下命令，为脚本添加执行权限：1chmod +x test_traces.sh 这一步是必须的，因为在 Linux&#x2F;Unix 系统中，脚本默认没有执行权限，需要手动赋予。 运行脚本： 使用以下格式运行脚本：1./test_traces.sh lower upper lower：起始的 trace 文件编号（1-16）。 upper：结束的 trace 文件编号（1-16）。 示例：1./test_traces.sh 1 5 这将测试 trace01.txt 到 trace05.txt，并将结果分别保存到 _tshref_output.txt 和 _tsh_output.txt。 检查输出： 测试完成后，比较 _tshref_output.txt（参考实现结果）和 _tsh_output.txt（学生实现结果）。 用各种编辑器自带的比较文件功能就能很方便的比较输出异同。 注意事项 环境要求：确保当前目录下有 sdriver.pl、tshref、tsh 以及对应的 traceXX.txt 文件，否则脚本会报错。 覆盖输出：每次运行脚本时，输出文件（_tshref_output.txt 和 _tsh_output.txt）会被清空并重新生成。","categories":[{"name":"学习","slug":"学习","permalink":"http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"公开课","slug":"学习/公开课","permalink":"http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"CMU-15-213","slug":"学习/公开课/CMU-15-213","permalink":"http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/"},{"name":"Labs","slug":"学习/公开课/CMU-15-213/Labs","permalink":"http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/Labs/"}],"tags":[]},{"title":"第八章——异常控制流","slug":"learning/open-course/CMU-15-213/Notes/Chapter8-exception-control-flow","date":"2025-03-31T03:26:01.000Z","updated":"2025-04-13T02:02:37.529Z","comments":true,"path":"wiki/learning/open-course/CMU-15-213/Notes/Chapter8-exception-control-flow/","permalink":"http://rinevard.github.io/wiki/learning/open-course/CMU-15-213/Notes/Chapter8-exception-control-flow/","excerpt":"","text":"img{ width: 70%; } 当我们在程序执行时按下 ctrl+c ，究竟发生了什么？为解答这个问题，我们引入异常控制流（exceptional control flow，ECF）的概念。异常控制流允许我们将控制转移到其他程序，从而实现一些神奇的效果，比如中断程序、上下文切换、调用系统函数。 异常异常是异常控制流的一种形式，分为四类： 类别 异步&#x2F;同步 产生原因 例子 中断（interrupt） 异步 外部事件 外部时钟（timer interrupt） 陷阱（trap） 同步 执行内部指令 系统调用（system calls） 故障（fault） 同步 执行内部指令 除以零 终止（abort） 同步 执行内部指令 硬件错误 注意：一定要检查系统调用的返回值，不然会出现一些很难调试的错误！ 异常发生后，控制会转移给异常处理程序。在处理完成后，根据异常的具体内容可能会返回到原程序的下一条指令，也可能返回到原程序的当前指令，也可能不返回。： 进程并发和上下文切换我们可以并发地执行多个进程，如下图所示： 但我们是怎么实现这种并发的呢？答案是上下文切换。下图展现了单核 CPU 的上下文切换，每个进程都有自己的上下文。 上下文切换的原因多种多样，举两个常见例子：用户可能执行系统调用而等待某个事件（比如用 waitpid 等待子进程终止），这时内核就可以让当前进程休眠并切换到另一个进程；系统每隔若干毫秒也会产生一次定时器中断的异常，并切换到新的进程。 进程的创建、终止和回收我们可以用 fork 来创建一个当前进程的复制——它执行一次，返回两次，分别返回到父进程和父进程的子进程中。对父进程，它返回子进程的 pid；对子进程，它返回 0. 子进程在终止后不会自动被清楚，而是进入“僵死进程”状态，直到被父进程回收。如果父进程终止了，init 进程会成为它的孤儿进程的养父。很明显，这里有潜在的内存泄漏。那么，怎么回收子进程呢？ 我们可以用 waitpid 来等待子进程终止，在 waitpid 返回后，这个终止的子进程会被回收。 我们可以用 execve 来加载并运行程序。execve 函数在当前进程的上下文中加载并运行一个新程序，只有在出现错误时，它才会返回到调用程序。注意，它并没有创建一个新进程，而是在当前进程的上下文中加载并运行新程序。 来看一个综合运用上面的东西的例子吧： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;int main() &#123; pid_t pid; pid = fork(); if (pid &lt; 0) &#123; perror(&quot;fork failed&quot;); exit(1); &#125; else if (pid == 0) &#123; // 子进程 printf(&quot;Child process (PID: %d) running...\\n&quot;, getpid()); // 使用 execve 加载并运行 &quot;ls&quot; 程序 char *argv[] = &#123;&quot;/bin/ls&quot;, NULL&#125;; // 参数列表 char *envp[] = &#123;NULL&#125;; // 环境变量列表 execve(&quot;/bin/ls&quot;, argv, envp); // 如果 execve 返回，说明执行失败 perror(&quot;execve failed&quot;); exit(1); &#125; else &#123; // 父进程 printf(&quot;Parent process (PID: %d), waiting for child (PID: %d)...\\n&quot;, getpid(), pid); // 使用 waitpid 等待子进程终止并回收 int status; waitpid(pid, &amp;status, 0); // 阻塞等待子进程 pid 结束 if (WIFEXITED(status)) &#123; printf(&quot;Child exited with status %d\\n&quot;, WEXITSTATUS(status)); &#125; &#125; return 0;&#125; 信号信号允许内核异步通知目标进程发生了特定事件。 发送和接收信号发送信号信号可以由内核自动生成，例如： 当某个子进程的状态发生变化时（比如终止、暂停、恢复），内核会发送一个 SIGCHLD 信号给父进程； 当某个进程尝试除以 0 时，内核会发送一个 SIGFPE 信号给该进程。此外，进程也可以通过 kill 函数手动请求内核向其他进程发送信号。 接收信号当内核将信号传递给目标进程，并迫使进程对此信号采取行动（例如执行信号处理程序或默认行为）时，进程就接收了该信号。需要注意的是，如果信号被阻塞或暂时未处理，它不会被视为“已接收”，而是进入待处理状态。 我们能用 signal 函数修改接收信号后的行为。 未接收的信号会怎样？如果信号发出后未被立即接收，它会变成一个待处理信号。内核为每个进程维护一个表示待处理信号的位向量（pending signal bit vector），用以追踪有哪些信号尚未处理。由于信号不排队，同一时刻同一类型的待处理信号最多只有一个（即位向量中该位被置为 1）。如果某个类型已经有了待处理信号，被发送过来的同类信号会被简单地丢弃。此外，内核还为每个进程维护一个表示被阻塞信号的位向量（blocked signal bit vector），用来记录当前被屏蔽、不允许传递的信号。 异步的风险下面的例子很好地说明了异步的风险 1234567891011121314151617181920212223242526272829303132333435363738394041#include &quot;csapp.h&quot;volatile sig_atomic_t pid;void sigchld_handler(int s) &#123; int olderrno = errno; pid = waitpid(-1, NULL, 0); // 在子进程终止后更新pid errno = olderrno;&#125;void sigint_handler(int s) &#123;&#125;int main(int argc, char **argv) &#123; sigset_t mask, prev; Signal(SIGCHLD, sigchld_handler); // 在子进程终止后更新pid Signal(SIGINT, sigint_handler); Sigemptyset(&amp;mask); Sigaddset(&amp;mask, SIGCHLD); while (1) &#123; Sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev); /* Block SIGCHLD */ if (Fork() == 0) &#123; /* Child */ exit(0); &#125; /* Parent */ pid = 0; // 我们 block 信号，这样即使子进程在这条语句前终止，pid也能正确更新 Sigprocmask(SIG_SETMASK, &amp;prev, NULL); /* Unblock SIGCHLD */ /* Wait for SIGCHLD to be received (wasteful) */ while (!pid) &#123; pause(); // 潜在的竞争！ &#125; /* Do some work after receiving SIGCHLD */ printf(&quot;.&quot;); &#125; exit(0);&#125; 先来看看下面的局部代码： 12345678Sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev); /* Block SIGCHLD */if (Fork() == 0) &#123; /* Child */ exit(0);&#125;/* Parent */pid = 0; // 我们 block 信号，这样即使子进程在这条语句前终止，pid也能正确更新Sigprocmask(SIG_SETMASK, &amp;prev, NULL); /* Unblock SIGCHLD */ 如果不使用 block，而子进程在 pid&#x3D;0 这条语句前终止，那么信号处理程序会先把 pid 设置为子进程 pid，然后 pid 被重置为 0，导致我们没能正确记录 pid。这就是阻塞信号的重要性。 再来看看这里： 123while (!pid) &#123; pause(); // 潜在的竞争！&#125; 我们的原意是在没有接收到信号时暂停，以避免空循环浪费处理器资源。具体来说，在收到子进程终止的信号后 pause 状态会结束，然后执行信号处理代码，然后进入下一个循环。 但这个 pause 带来了潜在的竞争。比如说，如果在 while 测试后和 pause 前收到信号，之后又没有别的信号，pause 就会进入永久睡眠。这就是竞争的风险。 对这个例子，解决办法是用 sigsuspend 替换 pause，我们不多说了。","categories":[{"name":"学习","slug":"学习","permalink":"http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"公开课","slug":"学习/公开课","permalink":"http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"CMU-15-213","slug":"学习/公开课/CMU-15-213","permalink":"http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/"},{"name":"Notes","slug":"学习/公开课/CMU-15-213/Notes","permalink":"http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/Notes/"}],"tags":[]},{"title":"Cachelab理论分析","slug":"learning/open-course/CMU-15-213/Labs/Cachelab","date":"2025-03-26T10:37:28.000Z","updated":"2025-03-26T10:38:34.242Z","comments":true,"path":"wiki/learning/open-course/CMU-15-213/Labs/Cachelab/","permalink":"http://rinevard.github.io/wiki/learning/open-course/CMU-15-213/Labs/Cachelab/","excerpt":"","text":"img{ width: 60%; } 先放一个最终结果在这里 Part A 模拟 cache用时 3h. 一开始因为 16 进制踩了坑。我第一个看的 trace 文件是 yi.trace，我把里面的地址当成了十进制，分析了半天总感觉不对，后来惊醒这是十六进制。 part A 不难，正常模拟一遍就好。由于 handout 里说，“you should assume that memory accesses are aligned properly, such that a single memory access never crosses block boundaries”，所以对每行记录，我们只要考虑其指令类型和地址即可，不必考虑操作大小。我使用了这样的数据结构： 1234567891011typedef struct &#123; int valid; unsigned long lineTag; int lruCount; // 记录上一次访问到现在的时间&#125; CacheLine;typedef struct &#123; CacheLine *lines;&#125; CacheSet;CacheSet *sets = malloc((1 &lt;&lt; s)* sizeof(CacheSet)); 在核心循环里，对某个给定的 set，我们在遍历过程中从前往后填充每个 set 的 line，思路如下： 对每个地址，用位运算得到其 setIdx 和 tag，然后找到对应的 set，遍历里面的所有 line. 如果找到了空 line，直接填充进去；如果找到了对应的 tag，就 hit 了；如果没找到对应 tag，说明需要驱逐某个 line，找到 lru 最大的 line（即最久没有访问过的 line）并把它换掉即可。 注意正确更新遍历的 set 里的每个 line 的 lruCount. 用下面的位运算就能得到 setIdx 和 tag： 1234unsigned long mask = -1;mask = ~(mask &lt;&lt; s); // 000...11 (s 个 1)unsigned long setIdx = (address &gt;&gt; b) &amp; mask;unsigned long tag = address &gt;&gt; (b + s); 还有一个小 trick 是可以用这样的写法来简化代码，毕竟我们并不关心操作在类型上的差异，只关心操作的地址： 12345678910switch (operation) &#123; case &#x27;M&#x27;: // M = L + S, 其 &#x27;S&#x27; 总会命中 hits++; // fall through case &#x27;L&#x27;: // fall through case &#x27;S&#x27;: // 真正的工作&#125; Part B用时 7 h，拼尽全力也只能把 64x64 拿到 1411 miss，上网找了找别人的思路，最后得到了 1179 miss. 最后结果如下： Points Max pts MissesTrans perf 32x32 8.0 8 287Trans perf 64x64 8.0 8 1179Trans perf 61x67 10.0 10 1997 我参考的文章是这篇： CSAPP - Cache Lab 的更(最)优秀的解法 - 知乎，作者直接拿到了 64x64 的理论最优解，非常强大。不过我没有在对角线上做微调，而是只参考了作者对一般块的读写顺序。 我的三个转置都没有特别考虑对角线的情况。一方面是因为嫌麻烦，另一方面是因为我觉得这种“两个内存块位置恰好差 2 的幂次导致缓存抖动”的事情太特殊，所以没额外处理。 分块大小的确定首先，分块优化是一定要做的。但分成多大的块呢？最朴素的想法是，我们希望块尽可能大来装满 cache，但不要太大以至于 cache 装不下。 我们有 $2^5 &#x3D; 32$ 个 sets，每个 set 一个 line，每个 line 存 8 个 int，也就是说，我们最多能存 $32*8 &#x3D; 256 &#x3D; 2^8$ 个 int. 我们希望同时把 A 的块和 B 的块放到 cache 中，两个块大小应当相同，所以每个块可以放 $256&#x2F;2 &#x3D; 128$ 个 int. 128 不是完全平方数，所以我们可以分块成 8x8. 初版代码回到之前的 8x8 分块的讨论上来。总之，我写出了我的初版代码。思路就是分块，然后把 A 的块存到 tmp 数组里，然后复制到 B 里。为什么要用 tmp 做中转呢？答案是为了避免缓存冲突： 12345678910111213141516171819202122232425void transpose_submit(int M, int N, int A[N][M], int B[M][N])&#123; int blockSize = 8; int rowBlock, colBlock, i, j; // 向上取整, 计算出总 block 数. // 可能会含有不是正方形的 block int rowBlocks = (N + blockSize - 1) / blockSize; int colBlocks = (M + blockSize - 1) / blockSize; int tmp[blockSize][blockSize]; // cachelab不允许开数组 for (rowBlock = 0; rowBlock &lt; rowBlocks; rowBlock++) &#123; for (colBlock = 0; colBlock &lt; colBlocks; colBlock++) &#123; for (i = rowBlock * blockSize; i &lt; (rowBlock + 1) * blockSize &amp;&amp; i &lt; N; i++) &#123; for (j = colBlock * blockSize; j &lt; (colBlock + 1) * blockSize &amp;&amp; j &lt; M; j++) &#123; tmp[j - colBlock * blockSize][i - rowBlock * blockSize] = A[i][j]; &#125; &#125; for (j = colBlock * blockSize; j &lt; (colBlock + 1) * blockSize &amp;&amp; j &lt; M; j++) &#123; for (i = rowBlock * blockSize; i &lt; (rowBlock + 1) * blockSize &amp;&amp; i &lt; N; i++) &#123; B[j][i] = tmp[j - colBlock * blockSize][i - rowBlock * blockSize]; &#125; &#125; &#125; &#125;&#125; 结果很不错： Cache Lab summary:Points Max pts MissesTrans perf 32x32 8.0 8 261Trans perf 64x64 8.0 8 1029Trans perf 61x67 10.0 10 1725 正当我觉得 cachelab 不过如此的时候，忽然发现 handout 里写了不允许开数组（哈哈，你想得到的 cmu 老师想不到吗），于是被迫手动展开了 j 循环，使用 8 个变量来读取每行的值。这就得到了下面的结果： Cache Lab summary:Points Max pts MissesTrans perf 32x32 8.0 8 287Trans perf 64x64 0.0 8 4611Trans perf 61x67 10.0 10 1997 也还算不错吧，毕竟 32x32 和 61x67 都满分了。唯一的问题是 64x64 的性能奇差无比。 分析 64x64 矩阵的 miss 次数这时候就要理论分析了。对 64x64 的矩阵，按我们之前的做法，每个 8x8 的块大约发生了多少次 miss 呢？ 答案是 72 次。A 提供了 8 次 miss，B 提供了 64 次 miss 验证一下结果对不对：64x64 的矩阵共有 64 个 8x8 的块，64 个块每个块 72 次 miss，总计约 $64*72&#x3D;4608$ 次 miss，和结果 4611 次 miss 相差无几。 这个 miss 是怎么算出来的呢？让我们看看下图： 对 64x64 的矩阵来说，B[x][y] 和 B[x+4][y] 的 setIdx 相同，这就导致我们之前的方法不断驱逐旧 line. 定量地说，每读 A 的块的一行，大约是 1 个 miss，A 的块共有 8 行，所以 A 的每个块提供 8 次 miss；每对 B 的块写入一个值，都驱逐了一次旧 line（因为 B[x+4][y] 会驱逐 B[x][y]），所以 B 的每个块提供 64 次 miss. 之后的工作就是找到方法来避免这种驱逐了。 对 64x64 矩阵的第一次优化——1699一开始我的思路是直接用 4x4 的块，这确实有不小优化，但离满分还很远。读者可以试着做一个理论分析看看 4x4 的结果大概是多少 miss。我分析出来会得到 1536 个 miss，实际结果是 1699 个 miss，也差不多吧。 好吧，这个理论分析看起来值得详细讲解一下。不过在写之前，希望读者自己分析一下，看看得到的结果是不是 2048，并想想哪里出错了： 如果块的大小是 4x4，每个块发生 4 次 miss，每个矩阵 256 个块，一共 2048 次 miss，看起来很合理。但这是理论最优解，为什么理论最优（2048）比实际结果（1699）还差呢？难道说数学的大厦崩塌了？ 并非如此。事实上，在我们把某个 4x4 的块放入 cache 时，我们也同时把它的右边的那个 4x4 的块放入了 cache。这是因为 cache 的每个 line 能装 8 个 int. 也就是说，我们可以认为我们实际上是在处理 4x8 的块。对每个 4x8 的块，A 提供了 4 次 miss，B 提供了 8 次 miss，总计 $64 * 4 + 64 * 8 &#x3D; 1536$ 次 miss. 对 64x64 矩阵的第二次优化——1411分析了那么多，还是没拿到满分。我的后续思路是把 8x8 的块再分成四个小块，并按下面的顺序来写入 B： 理论分析一下，把 A1 写入 B1 时，A miss 4 次，B miss 4 次； 把 A2 写入 B2 时，A miss 4 次，B 没有 miss（因为写入 B1 时把 B2 放进了 cache）； 把 A3 写入 B3 时，A 没有 miss，B miss 4 次；（因为读 A2 时把 A3 放入了 cache）； 把 A4 写入 B4 时，A miss 4 次，B 没有 miss（因为写入 B3 时把 B4 放进了 cache） 总计 20 次 miss，理论最优解 1280，实际结果 1411，我猜问题出在对角线上，我也懒得在这个基础上继续优化了。优化对角线这种事情看起来就很麻烦，而且感觉现实里几乎不会遇见这种情况。 对 64x64 矩阵的第二次优化——1179没什么好说的，直接看 CSAPP - Cache Lab 的更(最)优秀的解法 - 知乎 和代码吧。这篇文章的作者拿到了 64x64 的理论最优解，非常强大。不过我没有在对角线上做微调，而是只参考了作者对一般块的读写顺序。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374void transpose_submit_64x64(int M, int N, int A[N][M], int B[M][N])&#123; int blockSize = 8; int rowBlock, colBlock, i, j; int rowBlocks = (N + blockSize - 1) / blockSize; int colBlocks = (M + blockSize - 1) / blockSize; int tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7; for (rowBlock = 0; rowBlock &lt; rowBlocks; rowBlock++) &#123; for (colBlock = 0; colBlock &lt; colBlocks; colBlock++) &#123; // A上 for (i = rowBlock * blockSize; i &lt; rowBlock * blockSize + blockSize / 2 &amp;&amp; i &lt; N; i++) &#123; // 读取A的一行 tmp0 = A[i][colBlock * blockSize]; tmp1 = A[i][colBlock * blockSize + 1]; tmp2 = A[i][colBlock * blockSize + 2]; tmp3 = A[i][colBlock * blockSize + 3]; tmp4 = A[i][colBlock * blockSize + 4]; tmp5 = A[i][colBlock * blockSize + 5]; tmp6 = A[i][colBlock * blockSize + 6]; tmp7 = A[i][colBlock * blockSize + 7]; // 填充B左上 B[colBlock * blockSize][i] = tmp0; B[colBlock * blockSize + 1][i] = tmp1; B[colBlock * blockSize + 2][i] = tmp2; B[colBlock * blockSize + 3][i] = tmp3; // 填充B右上, 这一部分未来会被放到B左下 B[colBlock * blockSize][i + blockSize / 2] = tmp4; B[colBlock * blockSize + 1][i + blockSize / 2] = tmp5; B[colBlock * blockSize + 2][i + blockSize / 2] = tmp6; B[colBlock * blockSize + 3][i + blockSize / 2] = tmp7; &#125; // A左下, 注意这里按列遍历 for (j = colBlock * blockSize; j &lt; colBlock * blockSize + blockSize / 2 &amp;&amp; j &lt; M; j++) &#123; // 读取 A 的左下小块的一列 tmp0 = A[rowBlock * blockSize + blockSize / 2][j]; tmp1 = A[rowBlock * blockSize + blockSize / 2 + 1][j]; tmp2 = A[rowBlock * blockSize + blockSize / 2 + 2][j]; tmp3 = A[rowBlock * blockSize + blockSize / 2 + 3][j]; // 读取 B 的右上小块的一行 tmp4 = B[j][rowBlock * blockSize + blockSize / 2]; tmp5 = B[j][rowBlock * blockSize + blockSize / 2 + 1]; tmp6 = B[j][rowBlock * blockSize + blockSize / 2 + 2]; tmp7 = B[j][rowBlock * blockSize + blockSize / 2 + 3]; // 把从 A 左下读到的内容写到 B 右上 B[j][rowBlock * blockSize + blockSize / 2] = tmp0; B[j][rowBlock * blockSize + blockSize / 2 + 1] = tmp1; B[j][rowBlock * blockSize + blockSize / 2 + 2] = tmp2; B[j][rowBlock * blockSize + blockSize / 2 + 3] = tmp3; // 把 B 右上的内容写到 B 左下 B[j + blockSize / 2][rowBlock * blockSize] = tmp4; B[j + blockSize / 2][rowBlock * blockSize + 1] = tmp5; B[j + blockSize / 2][rowBlock * blockSize + 2] = tmp6; B[j + blockSize / 2][rowBlock * blockSize + 3] = tmp7; &#125; // A右下 for (i = rowBlock * blockSize + blockSize / 2; i &lt; (rowBlock + 1) * blockSize &amp;&amp; i &lt; N; i++) &#123; // 读取A的一行 tmp0 = A[i][colBlock * blockSize + blockSize / 2]; tmp1 = A[i][colBlock * blockSize + blockSize / 2 + 1]; tmp2 = A[i][colBlock * blockSize + blockSize / 2 + 2]; tmp3 = A[i][colBlock * blockSize + blockSize / 2 + 3]; // 填充B B[colBlock * blockSize + blockSize / 2][i] = tmp0; B[colBlock * blockSize + blockSize / 2 + 1][i] = tmp1; B[colBlock * blockSize + blockSize / 2 + 2][i] = tmp2; B[colBlock * blockSize + blockSize / 2 + 3][i] = tmp3; &#125; &#125; &#125;&#125; Future work写文章的时候突然想到我们似乎可以分长方形的 16x8 的块，因为 $1682 &#x3D; 256$ 可以完全填满 cache. 简单写了下代码得到了下面的结果： [16x8]Points Max pts MissesTrans perf 32x32 8.0 8 287Trans perf 61x67 10.0 10 1811看起来效果出乎意料地不错？甚至比我的 8x8 分块效果更好。这里没有放进来 64x64 转置的结果，因为我没有做分小块的优化。所以说，这种方法说不定还有不小探索空间？ 下面是我的 8x8 分块的结果，可以用来和上面的结果做比较。两个代码都只用了简单的分块和 8 个 tmp 变量，没有额外优化。 [8x8] Points Max pts MissesTrans perf 32x32 8.0 8 287Trans perf 61x67 10.0 10 1997 这里是我使用的 16x8 的分块代码： 1234567891011121314151617181920212223242526272829303132333435363738void transpose_submit(int M, int N, int A[N][M], int B[M][N])&#123; int blockRow = 16; // 块的行数 int blockCol = 8; // 块的列数 int rowBlock, colBlock, i, j; // 向上取整, 计算出总 block 数 int rowBlocks = (N + blockRow - 1) / blockRow; int colBlocks = (M + blockCol - 1) / blockCol; int tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7; for (rowBlock = 0; rowBlock &lt; rowBlocks; rowBlock++) &#123; for (colBlock = 0; colBlock &lt; colBlocks; colBlock++) &#123; for (i = rowBlock * blockRow; i &lt; (rowBlock + 1) * blockRow &amp;&amp; i &lt; N; i++) &#123; // 展开j循环，每次处理8个元素 j = colBlock * blockCol; if (j &lt; M) tmp0 = A[i][j]; if (j + 1 &lt; M) tmp1 = A[i][j + 1]; if (j + 2 &lt; M) tmp2 = A[i][j + 2]; if (j + 3 &lt; M) tmp3 = A[i][j + 3]; if (j + 4 &lt; M) tmp4 = A[i][j + 4]; if (j + 5 &lt; M) tmp5 = A[i][j + 5]; if (j + 6 &lt; M) tmp6 = A[i][j + 6]; if (j + 7 &lt; M) tmp7 = A[i][j + 7]; // 写入B矩阵 if (j &lt; M) B[j][i] = tmp0; if (j + 1 &lt; M) B[j + 1][i] = tmp1; if (j + 2 &lt; M) B[j + 2][i] = tmp2; if (j + 3 &lt; M) B[j + 3][i] = tmp3; if (j + 4 &lt; M) B[j + 4][i] = tmp4; if (j + 5 &lt; M) B[j + 5][i] = tmp5; if (j + 6 &lt; M) B[j + 6][i] = tmp6; if (j + 7 &lt; M) B[j + 7][i] = tmp7; &#125; &#125; &#125;&#125;","categories":[{"name":"学习","slug":"学习","permalink":"http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"公开课","slug":"学习/公开课","permalink":"http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"CMU-15-213","slug":"学习/公开课/CMU-15-213","permalink":"http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/"},{"name":"Labs","slug":"学习/公开课/CMU-15-213/Labs","permalink":"http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/Labs/"}],"tags":[]},{"title":"玩乐的人","slug":"others/thoughts/玩乐的人","date":"2025-03-24T11:09:30.000Z","updated":"2025-03-24T11:08:37.615Z","comments":true,"path":"wiki/others/thoughts/玩乐的人/","permalink":"http://rinevard.github.io/wiki/others/thoughts/%E7%8E%A9%E4%B9%90%E7%9A%84%E4%BA%BA/","excerpt":"","text":"故事之前最近在学查理老师的编剧课，课很有趣，不过信息密度似乎有点低，我就当单口相声听了。这篇文章记录了第五课老师布置的作业，故事的八要素、支点和大纲是我自己写的，具体内容是 AI 填充的，我把 AI 生成的多个版本拼拼凑凑得到了下面的故事（什么拼好文）。 最近的思绪挺乱的。前两天做了个游戏原型，感觉大体上还算值得做，暂命名叫《翻命师》。这样的话，想做的事情实在是有点多了。想参加 GSoC 来接触下开发，顺便提升下 cpp 水平；想继续学公开课，了解下底层知识；还想花 100 天完整地做一个能放到 itch 甚至 steam 上的小游戏，跑一遍流程。 说来有些凡尔赛，但上学期的成绩好得有点莫名其妙，以至于我真的开始考虑外保之类的事情。这就导致我们真的陷入了一个奇怪的“保研开发两手抓”的境地，但我的水平却不足以支持我把它们全部抓牢，于是便深感时间紧张。全抓牢真的不可能吗？如果是我的话说不定也能做到呢，但这样的生活是否缺乏了一抹奇幻色彩呢？比起把绝大多数时间都花在自我实现和提升自己的水平上，我还是想抽出时间来学学新东西，看看番剧，打打游戏。再说了，现在的社交水平仍然是负的，是不是该去提升一下？原本想着靠找人来试玩来和人们交流，但这又回到了开发上。虽然这看起来是条可行的路，但感觉有点点奇怪。 人生短则二十年，长则一百年，我们究竟想做什么，想去往何方，想成为什么样的人？ 前路未定却仍试图看向未来，自会焦虑。不过我喜欢的一个虚拟角色在这种情况下想必会说：“焦虑也是一种不可多得的体验呢”。喜悦和平静自然是大家都喜欢的体验，但焦虑、悲伤这些负面情绪似乎也是奇妙的体验。人类，很神奇吧。 话说回来，翻命师这个名字听起来就很有趣吧。听说为自己摆个”过路牌阵”，一行三牌，便能解一时之困。我回去摆一下试试。 在 101 发了个没那么凡尔赛的版本。我在认真思考，BIT101 对我来说究竟意味着什么。我从未想过立一个很厉害的人设，但我在发帖时总会不自觉地只展示看起来不错的一面，于是渐渐地就只写出了一些“局部的真实”。 那我是怎么发现这个版本有点凡尔赛的呢？答案是让 AI 写了一个翻版。我要求 AI 把和游戏、编程相关的内容换成别的领域的内容，就得到了本文中“故事之后——AI 的凡尔赛”那一节的内容。看了看，感觉真的好凡尔赛啊&#x3D;) 于是就改了改。如果我真的很厉害就好了，可惜我并不。但我会变强的。 故事——玩乐的人“姓名？” “李明。” “年龄？” “呃……十七岁？” 检票员扫了他一眼，最后只是叹了口气，挥手放行。 李明现年 32 岁，身高 169 厘米，体重 61.5 公斤，没有女朋友，没有宠物，没有不良嗜好。在李明居住的城市里，所有 20 岁以上的成年人都按照同样的程序生活：起床、工作、吃饭、睡觉，偶尔参加培训、会议和团建活动。政府颁布的《成年人行为准则》明确规定，成年人的首要任务是工作，次要任务是为国家培养合格公民，第三任务是照顾老人，第四任务是自我提升。第十七条特别强调：成年人严禁进入游乐设施。 现在他站在游乐园入口处，身上裹着一件印着卡通恐龙的 T 恤，下半身穿着一条明显短了一截的背带裤，脚上是一双带灯的运动鞋。他的脸上贴着两块大号创可贴，试图掩盖胡茬的痕迹。 李明小心翼翼地走进游乐园，手里握着一根棒棒糖，时不时紧张地舔一口，假装自己对糖果很感兴趣。实际上，他上一次吃棒棒糖还是在十三岁那年。 “嘿！你在这里干嘛呀？你家大人呢？”一个游乐园工作人员走过来问道。 “我爸爸去买饮料了，让我在这里等他。”李明背了五遍的标准答案脱口而出。 工作人员上下打量了他几眼：”你多大了？看起来挺高的。” “我发育得早，十七岁。”李明掏出事先准备好的学生证，那是他从网上特意定制的。 工作人员勉强相信了他的说法，转身离开。李明松了一口气，迅速往旋转木马方向走去。 旋转木马上，李明紧紧抓住金色的扶手，感受着上下起伏的节奏。音乐响起，木马开始旋转，李明的心跳加速，一种奇怪的快感从脚底蔓延到全身。他已经记不清上一次有这种感觉是什么时候了。 “你也是一个人来的吗？”旁边的木马上，一个大约九岁的小女孩问道。 李明僵硬地点点头。 “我也是！我妈妈在那边，”小女孩指着远处一个看手机的女人，”她说自己太忙了，没时间陪我玩。大人们总是很忙。” 李明想起自己的父母。他们在李明八岁时就告诉他：”玩是没有出息的表现。”十二岁时，他们卖掉了他所有的玩具，换成了各种学习资料。十八岁时，他们为他制定了”成功人生规划表”，上面没有一项与娱乐有关。三十岁时，他们送给他一套”友爱公寓”的首付款，条件是他必须在十年内获得三次职位晋升。 木马停下来后，李明迫不及待地跑向过山车。排队时，他故意弯着腰，装作比实际身高矮一些。轮到他时，检查身高的工作人员狐疑地看了他一眼：”你确定要玩吗？看起来有点紧张。” “我当然要玩！”李明用他练习过的童声说，声音因为紧张而有些发抖。 过山车启动了，缓缓爬升。李明死死抓住安全杆，心脏几乎要跳出胸膛。风呼啸着掠过耳边，李明感到一种前所未有的自由。当车厢俯冲而下时，他放声尖叫，那是他 32 年人生中第一次如此肆无忌惮地尖叫。 下了过山车，李明头晕目眩，但脸上挂着难以抑制的笑容。他感觉脖子有点僵硬，下意识地左右轻轻晃动了一下，缓解那股熟悉的酸痛。这是他工作十年养成的习惯——每天盯着电脑十小时，颈椎早已不堪重负。 李明决定接着去玩碰碰车。坐进小车里，他像个真正的十七岁少年一样兴奋地抓紧方向盘。电流接通，车子启动，李明猛踩油门冲向前方。左冲右撞间，他又感到脖子一阵刺痛。他条件反射地做起了办公室保健操第三式：双手托住后脑勺，缓慢向后拉伸。 一位游乐园的医护人员恰好路过，看到了李明标准的颈椎操动作。她驻足观察了几秒，然后走到碰碰车场地边缘。 “这套颈椎病保健操做得不错啊，先生。”医护人员在李明经过时大声说道，”是职业医师教的吧？” 李明一惊，猛地回头，车子失控撞上了场地边缘。 “什么？不不不，我只是……”李明慌乱地摆手，”我……”他张了张嘴，最终还是像泄了气的气球一样瘫在碰碰车里，放弃了辩解。 医护人员按下对讲机：”安保部，A 区有一位违规进入的成年人。” 两名保安赶到，架起李明就往外走。路过旋转木马时，李明忍不住回头看了一眼，那些五颜六色的小马依然在音乐声中旋转，仿佛在向他告别。他的真实身份被确认：”李明，32 岁，工程师，违反《成年人行为准则》第十七条。” 两个小时后，他被直接送往了”成年人再教育中心”。 在那里，他被迫学习如何做一个”成熟的大人”：每天工作十小时，严肃阅读财经新闻，周末必须去公园遛狗或者喝咖啡，以塑造”符合社会期待的成年形象”。 故事之后——AI 的凡尔赛最近在学余老师的诗歌创作课，课很有趣，不过信息密度似乎有点低，我就当单口相声听了。这篇文章记录了第五课老师布置的作业，诗歌的意象、结构和情感是我自己构思的，具体内容是借助写作软件润色的，我把几个版本拼拼凑凑得到了下面的作品（什么拼好诗）。 最近的思绪挺乱的。前两天构思了个摄影专辑创意，感觉大体上还算值得做，暂命名叫《时光师》。这样的话，想做的事情实在是有点多了。想投稿一些文学期刊来接触文坛，顺便提升下文笔水平；想继续研读一些经典著作，了解下文学理论；还想花 100 天完整地做一个能放到豆瓣甚至出版社投稿的诗集，跑一遍流程。 说来有些凡尔赛，但上学期的文学竞赛成绩意外地好，以至于我真的开始考虑考研中文系或者去杂志社实习之类的事情。这就导致我们真的陷入了一个奇怪的”学术与创作两手抓”的境地，但我的水平却不足以支持我把它们全部抓牢，于是便深感时间紧张。全抓牢真的不可能吗？如果是我的话说不定也能做到呢，但这样的生活是否缺乏了一抹奇幻色彩呢？比起把绝大多数时间都花在自我实现和提升自己的水平上，我还是想抽出时间来阅读新书，看看番剧，去咖啡馆发呆。再说了，现在的社交水平仍然是负的，是不是该去提升一下？原本想着靠办读书会来和人们交流，但这又回到了文学上。虽然这看起来是条可行的路，但感觉有点点奇怪。 人生短则二十年，长则一百年，我们究竟想做什么，想去往何方，想成为什么样的人？ 前路未定却仍试图看向未来，自会焦虑。不过我喜欢的一个虚拟角色在这种情况下想必会说：”焦虑也是一种不可多得的体验呢”。喜悦和平静自然是大家都喜欢的体验，但焦虑、悲伤这些负面情绪似乎也是奇妙的体验。人类，很神奇吧。 话说回来，时光师这个名字听起来就很有诗意吧。听说为自己摆个”诗意三行”，记录三个瞬间，便能解一时之困。我回去试试。 翻命师这江湖之上，有一门玄门奇术，叫做”翻命一术”，修习此术之人，世人唤作”翻命师”。 这翻命师不比寻常江湖术士，既不是掐指一算的算命先生，也不是敲盆问卦的游方道人。他们修的，乃是上古传下来的翻命秘术。但凡有人求问命途，这翻命师便能施展异术，将那人前程化作一张张命运符牌，一一摆在案上。 这牌阵大小不一，全看机缘深浅。小则一行三牌，称为”过路牌阵”，多解一时之困；中则三行五牌，名唤”三星照命”，为那命途多舛之人寻觅转机；若遇命格复杂之人，或是牵连多人的大事，定要摆下五行七列的”天罗地网阵”，方能窥得命运全貌。 却说这符牌玄妙非常。翻开一张，或显凶险，或现吉祥。翻命师观之，便知那人命中该有何等机缘。其技高者，还能将那不利的命数重新封回牌中，暂时封住那眼看就要降临的灾祸！ 江湖传闻，翻命师之术，非是逆天改命，乃是巧借天机。如同棋盘残局，看似已无生路，翻命师却能寻那缝隙间微妙一着，引得命运暗流转向。明是命中注定，实则皆由人心一念之差。高明的翻命师，不过是将那本就存在的可能，向明处轻推罢了。 无论如何在做原型之前都不应该写剧情。不过我做了原型！所以我可以写一点点剧情了吧，虽然这段背景故事也大多是 AI 写的。","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/"},{"name":"碎碎念","slug":"杂谈/碎碎念","permalink":"http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}],"tags":[]},{"title":"第六章——存储器层次结构","slug":"learning/open-course/CMU-15-213/Notes/Chapter6-memory-and-cache","date":"2025-03-20T03:26:01.000Z","updated":"2025-03-20T03:32:19.785Z","comments":true,"path":"wiki/learning/open-course/CMU-15-213/Notes/Chapter6-memory-and-cache/","permalink":"http://rinevard.github.io/wiki/learning/open-course/CMU-15-213/Notes/Chapter6-memory-and-cache/","excerpt":"","text":"存储器层次结构存储器有多种类型，我们可以根据访问速度把他们排成金字塔结构。靠近上面的访问速度快，靠近下面的访问速度慢。每一层都作为下面一层的缓存（cache），即从下面一层读取数据来加快访问速度： 下图比较了不同存储器的访问速度 局部性局部性分为空间局部性和时间局部性。前者指如果一个内存位置被引用，程序可能在将来引用附近的一个内存位置；后者指如果一个内存位置被引用，程序可能在将来再次引用它。 为什么我们希望程序有较好的局部性呢？这是因为访问 cache 比访问 cache 下面一层要快，而 cache 的大小有限，因此我们希望尽可能访问 cache 里的数据。而 cache 存储的数据在空间上和时间上都有一定连续性（参考下面的“高速缓存”一节），所以我们希望程序的局部性好。 如果我们引用了不在 cache 中的数据，这就被称作“缓存不命中”（命中为 “hit”，不命中为“miss”），从而要把 cache 下面一层的数据复制到 cache 中，这是很慢的。 举个例子，一般来说，数组的局部性比链表好，因为链表的地址往往是碎片化的。 高速缓存高速缓存的结构如图所示： 让我们推测一下 line 和 set 是怎么设计出来的。 我们的核心思路是尽量减少高速缓存和主存间交换数据的次数。如果我们能预知未来，我们只要根据未来尽可能把高速缓存填满未来会读的值，然后在需要新值时再读一次就好了。 显然我们不能预知未来，所以我们希望每次的数据交换都尽可能多带来一些“未来可能用到的数据”。所以我们把高速缓存划分成若干个 line，每个 line 都存储一组连续的地址的数据。毕竟如果读到了一个地址，有理由认为它附近的地址在将来会被读到。 上图给出了 line 的可视化，我们把数据存储在 data 段中，共存储 B 个 bytes. 但只是读取连续的一段是不够的。在下图中，我们把主存中需要用到的地址标红。这两种情况中，我们认为右边那种情况更可能在运行时发生，所以我们希望实现多个 set. 如果每个 set 只有一个 line，就实现了直接映射高速缓存。如果每个 set 有多个 line，就实现了组相联高速缓存。 读接下来我们讲讲如何读取数据，我们以组相联高速缓存为例，毕竟直接映射是组相联的特殊情况。 这里的思路是根据地址找到高速缓冲中对应的 set，然后检查 set 的 line 中是否有当前地址。 我们把每个地址划分为三个部分，tag 部分、组索引部分、偏移部分。组索引部分在中间，耗费 $\\log_2 S$ 个位，用于定位对应的组；tag 部分在最前，占据地址剩下的位置，用于和每个 line 的 tag 作比较从而确定是否有与地址对应的 line；偏移部分在最后，耗费 $\\log_2 B$ 个位，用于在找到对应的 line 以后找到对应的数据位置。 所以，对给定的地址，我们先找到它的组索引部分，从而定位对应的组，然后把组里的所有 line 的 tag 和地址的 tag 比较，找到相同的 tag 以后就算是成功命中，然后根据偏移获取对应的值。 如果没找到相同的 tag 呢？这就是不命中了，这时就要让主存和 cache 间交换数据，选一个 line（一般是一组间最久没有被使用的那个）把它替换掉。 写写比读复杂很多，书上没详细讲，所以我们只是简要提一下。 一个比较靠谱的思路是检查要写的地址是否在 cache 中，如果在就直接写 cache，并标记那个位置为“已修改”。如果不在 cache 中，就像读一样，把那个地址拿到 cache 里来，然后覆写。在 cache 的任何一个地址被覆盖掉时，检查那个地址的值是否已修改，如果修改则覆写主存上的值。 这种做法叫做写回（write-back），尽可能地推迟更新。 要注意的是，由于写是可以推迟的，所以写一般比读要快。 性能例子Memory Mountain——数组大小和访问步长影响性能 这张图是对一个大小为 size 的数组以 stride 为步长求和的性能比较。 注意到随着 size 增大，我们愈发往存储器层次结构下面走（比如说，L1 不足以装下所有数据了，我们就不得不走到 L2），同时每走一层时间都有一个猛增。 随着 stride 增大，缓存命中率越来越低，耗时越来越大，直到某个临界点，每次都不命中。 缓存命中影响性能——以矩阵乘法为例假设我们在做矩阵乘法，我们的高速缓存的每个 line 的 block 能装下 $K$ 个值。 循环顺序对性能的影响版本 1 是 ijk 循环，a 是行遍历，b 是列遍历，c 不在最内存循环内所以不计性能损耗。对 a 来说，每经过 K 个值，就有一次不命中；对 b 来说，每次都不命中。我们可以认为有这样的缓存不命中率： a b c 1 &#x2F; K 1 0 123456789// 版本1for (i=0; i&lt;n; i++) &#123; for (j=0; j&lt;n; j++) &#123; sum = 0.0; for (k=0; k&lt;n; k++) sum += a[i][k] * b[k][j]; c[i][j] = sum; &#125;&#125; 如果把循环顺序改成 ikj，就能得到更好的性能。 这时 a 不在最内层循环，不计性能损耗，b 是行遍历，c 也是行遍历，我们可以认为有这样的缓存不命中率： a b c 0 1 &#x2F; K 1 &#x2F; K 1234567for (i=0; i&lt;n; i++) &#123; for (k=0; k&lt;n; k++) &#123; r = a[i][k]; for (j=0; j&lt;n; j++) c[i][j] += r * b[k][j]; &#125;&#125; 下图展示了六种循环顺序带来的不同效率： 最好的是 ikj 循环，我们可以简单地算出它的大概的总不命中次数。共有 $n^2$ 个值要算，没算一个值大概会不命中 $\\frac{n}{K} \\frac{n}{K}$次，因此总不命中次数大约为： $$n^2 \\times (\\frac{n}{K} + \\frac{n}{K})&#x3D;\\frac{2n^3}{K}$$ blocking 对性能的影响其实我们还有更好的优化手段——矩阵分块乘法： 结果里的每个 block 的计算需要访问 $\\frac{2n}{B}$ 个小 blck，每个小 block 大概会不命中 $\\frac{B^2}{K}$ 次，因此总不命中次数大约为： $$(\\frac{n}{B})^2 \\times \\frac{B^2}{K}\\times \\frac{2n}{B}&#x3D;\\frac{2n^3}{BK}$$ 当然，我们不能无限地增大 $B$. 对于矩阵乘法 C&#x3D;A×B，我们要同时在缓存中保存 A 的一个块、B 的一个块和 C 的一个块，从而希望有类似 $3B^2 &lt; C$ 的限制（这里的 $C$ 是 cache 的 capacity）。所以尽可能选大的 block，但保证不过大就好。","categories":[{"name":"学习","slug":"学习","permalink":"http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"公开课","slug":"学习/公开课","permalink":"http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"CMU-15-213","slug":"学习/公开课/CMU-15-213","permalink":"http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/"},{"name":"Notes","slug":"学习/公开课/CMU-15-213/Notes","permalink":"http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/Notes/"}],"tags":[]},{"title":"第五章——性能优化","slug":"learning/open-course/CMU-15-213/Notes/Chapter5-optimization","date":"2025-03-18T07:30:28.000Z","updated":"2025-03-18T07:37:40.194Z","comments":true,"path":"wiki/learning/open-course/CMU-15-213/Notes/Chapter5-optimization/","permalink":"http://rinevard.github.io/wiki/learning/open-course/CMU-15-213/Notes/Chapter5-optimization/","excerpt":"","text":"15213 里没讲第四章，我看了下感觉太硬件了于是就跳过了。我们从第五章继续—— 一些常见的优化手段我们就不详细说了，简单提一下有这些： 用代码剖析程序找到性能瓶颈 选好的算法 外提循环不变式 减少不必要的内存读写 循环展开技巧性太强，牺牲了可读性，而且说实话性能也没好太多，所以也不详谈。而且大多数编译器在把优化等级设得比较高时会自动做循环展开。 我们主要聊聊——编译器的局限；用 CPE 表示程序性能；指令级并行。 编译器的局限性编译器对程序只使用安全的优化，因此有些我们脑补编译器会优化的东西实际上不会被优化。 1234567void add1(long *x1, long *x2) &#123; *x1 += *x2; *x1 += *x2;&#125;void add2(long *x1, long *x2) &#123; *x1 += *x2 * 2;&#125; 乍一看这两个函数功能相同，且下面那种读写内存次数更少，或许我们会期望编译器把上面的版本优化成下面的版本。 可其实两者功能并不完全相同。考虑两个指针指向同一个对象的情况。 因此，要很仔细才能写出编译器能顺利优化的代码。 用 CPE 表示程序性能CPE 即 Cycles Per Element，计算方法如下： CPE &#x3D; Total Cycles &#x2F; Number of Elements，即总周期数 &#x2F; 元素数量。 实际的 CPE 值很难仅通过代码分析准确预测，需要在特定硬件、编译器配置下通过实际测试获得准确值。一般来说，我们通过性能分析工具来得到总周期数，然后根据任务得出其元素数量，从而算出 CPE。 指令级并行现代处理器并不是顺序执行指令的，顺序执行只是一种抽象。指令执行的顺序不一定要与它们在机器级程序中的顺序一致。这让我们实现了指令级并行。 这里的内容太多太硬核了，我也没理解，就只讲讲指令级并行的大体概念和流水线吧。 大体来说，处理器会分析程序里每条指令的依赖关系，从而并行执行没有依赖关系的指令。 例子： 假设我们有指令序列: 1234561. mov eax, [mem1] # 从内存加载数据到eax2. add ebx, ecx # 将ebx和ecx相加，结果存入ebx3. mul eax, 4 # 将eax乘以44. add edx, ebx # 将ebx和edx相加，结果存入edx5. mov [mem2], eax # 将eax存入内存 依赖关系图: 1234567891011 指令1 指令2 (mov eax, [mem1]) (add ebx, ecx) | | v v 指令3 指令4 (mul eax, 4) (add edx, ebx) | v 指令5(mov [mem2], eax) 这时我们可能就会并行执行指令 1 和指令 2. 流水线(Pipeline)流水线将单条指令的执行阶段（取指、解码、执行、访存、写回）拆分成多个步骤，每个步骤由不同的硬件单元处理，从而可以同时处理多条处于不同步骤的指令。例如，一个典型的浮点加法器包含三个阶段：一个阶段处理指数值，一个阶段将小数相加，另一个阶段对结果进行舍人。这种技术增加了吞吐量（Throughput），但单个指令的执行延迟并不会减少。 数据流图我们可以通过程序的数据流图来粗糙地分析程序的指令级并行程度。这里举一个例子应该就足够了。假设我们想算 $\\sum_{k&#x3D;0}^{n}a_kx^k$，下面有两种算法： 在 poly 中，我们共做了 n 次加法，2n 次乘法 1234567891011double poly(double a[], double x, long degree)&#123; long i; double result = a[0]; double xpwr = x; /* Equals x^i at start of loop */ for (i = 1; i &lt;= degree; i++) &#123; result += a[i] * xpwr; xpwr = x * xpwr; &#125; return result;&#125; 在 polyh 中，我们共做了 n 次加法，n 次乘法 123456789/* Apply Horner&#x27;s method */double polyh(double a[], double x, long degree)&#123; long i; double result = a[degree]; for (i = degree-1; i &gt;= 0; i--) result = a[i] + x*result; return result;&#125; 然而实际上 poly 速度更快，为什么呢？因为 poly 有更好的指令级并行度。 poly 的关键路径是 mul，polyh 的关键路径则是 mul → add. 实践之前做 leetcode 还遇到了一则趣事（3356. Zero Array TransformationⅡ） 那题的解法里需要构造这样的函数： 1234567891011121314151617181920bool iskZeroArray(vector&lt;int&gt; &amp;nums, vector&lt;vector&lt;int&gt;&gt; &amp;queries, int k) &#123; vector&lt;int&gt; ops(nums.size() + 1, 0); for (int i = 0; i &lt; k; i++) &#123; int l = queries[i][0]; int r = queries[i][1]; int val = queries[i][2]; ops[l] += val; ops[r + 1] -= val; &#125; int n = nums.size(); int op = 0; for (int i = 0; i &lt; n; i++) &#123; op += ops[i]; if (op &lt; nums[i]) &#123; return false; &#125; &#125; return true;&#125; 在 iskZeroArray 的第一个 for 循环中, 我写的原本是 1234vector&lt;int&gt; query = queries[i];int l = query[0];int r = query[1];int val = query[2]; 但是这样的程序耗时 1000 ms. 换成 123int l = queries[i][0];int r = queries[i][1];int val = queries[i][2]; 后，50ms. 两者甚至都是 O(N)的，前者之所以如此慢应该是因为不断分配内存给 query 吧.","categories":[{"name":"学习","slug":"学习","permalink":"http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"公开课","slug":"学习/公开课","permalink":"http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"CMU-15-213","slug":"学习/公开课/CMU-15-213","permalink":"http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/"},{"name":"Notes","slug":"学习/公开课/CMU-15-213/Notes","permalink":"http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/Notes/"}],"tags":[]},{"title":"第三章——程序的机器级别表示","slug":"learning/open-course/CMU-15-213/Notes/Chapter3-machine-level-program","date":"2025-03-14T08:41:28.000Z","updated":"2025-03-14T08:47:55.347Z","comments":true,"path":"wiki/learning/open-course/CMU-15-213/Notes/Chapter3-machine-level-program/","permalink":"http://rinevard.github.io/wiki/learning/open-course/CMU-15-213/Notes/Chapter3-machine-level-program/","excerpt":"","text":"img{ width: 75%; } 汇编简介CSAPP 教的是 x86-64 汇编语言，使用的是 AT&amp;T 语法风格。 下图概述了程序的工作方式，即从内存中读取指令，CPU 根据指令在寄存器上执行操作来修改内存里的数据： 下图描述了借助 gcc 进行编译的过程，其中 .s 就是汇编文件： 一些汇编指令示例： movq 7(%rdx, %rsi, 2), %rax 表示把 2 * %rsi + %rdx + 7 指向的地址的值复制到 %rax 中 leaq 7(%rdx, %rsi, 2), %rax 表示把 2 * %rsi + %rdx + 7 复制到 %rax 中，leaq 常被编译器用来做一些聪明的快速计算，不过 leaq 的第三个项只能是 1, 2, 4, 8. salq $n, %rax 表示把 %rax 中的值左移 n 位 (sal 是 shift arithmetic left 的缩写) imulq %rdx, %rax 表示把 %rdx 中的值与 %rax 中的值相乘，结果存入 %rax (有符号整数乘法) 操作很多，我们不再列举更多，随便找个书查一查就好。 我们可以注意到这些操作都以 ‘q’ 结尾，那如果我不喜欢 ‘q’，我可以用 ‘r’ 结尾吗？不行，因为这里的 ‘q’ 实际上是在指定操作的大小。还记得寄存器长什么样吗： 后缀 全称 大小(字节) 位数 指令示例 描述 b byte 1 8 位 movb 移动单字节(8 位)数据 w word 2 16 位 movw 移动字(16 位)数据 l long 4 32 位 movl 移动双字(32 位)数据 q quadword 8 64 位 movq 移动四字(64 位)数据 我们也有 pushq 和 popq 之类的和栈相关的操作。栈是什么？请看下集——函数和栈。（在“控制”这一节后面） 控制我已经会加减乘除了，那你能教教我怎么写条件（if）和循环（for, while）吗？ 乐意效劳。😎 if，while，do-while无论是条件还是循环，我们都在做两件事——判断条件是否满足和根据条件跳到某个地方执行语句。 让我们先来看看汇编里的一个典型的 do-while 循环： 12345678910long fact_do(long n)n in %rdi1 fact_do:2 movl $1, %eax Set result = 13 .L2: loop:4 imulq %rdi, %rax Compute result *= n5 subq $1, %rdi Decrement n6 cmpq $1, %rdi Compare n:17 jg .L2 If &gt;, goto loop8 rep ; ret Return 在这里，我们通过“cmpq”和“jg”来判断条件是否满足，通过“jg”来跳转以执行循环。那么，cmpq 实际上是在做什么呢？ 在汇编中，我们有几个特殊的标志寄存器 CF、ZF、SF、OF 来记录最近的操作是否产生了 unsigned 的溢出、产生 0、产生负数、产生了补码溢出。cmp 和 test 两个指令假装执行减法和按位与并修改这些标志寄存器。 在上面的代码中，cmpq $1, %rdi 就是在假装做 %rdi - 1，并根据计算结果修改标志寄存器。而 jg 则根据标志寄存器的值来进行跳转。jg 的效果是，如果 ~(SF ^ OF) &amp; ~ZF 为真，就进行跳转。 jg 的跳转条件看起来很复杂，但它和 cmpq x, y 联动的效果是——如果 y &gt; x，跳转，因此它叫做 jg. 下表是 CMP 和 TEST 的概述： Instruction Based on Description CMP S₁, S₂ S₂ - S₁ Compare TEST S₁, S₂ S₁ &amp; S₂ Test 这里是一些跳转语句示例： Instruction Synonym Jump condition Description jmp Label 1 Direct jump例：jmp 0x400123直接跳转到具体地址 jmp *Operand 1 Indirect jump例：jmp *%rax跳转目标在运行时才能确定 je Label jz ZF Equal &#x2F; zero js Label SF Negative jg Label jnle ~(SF ^ OF) &amp; ~ZF Greater (signed &gt;) jge Label jnl ~(SF ^ OF) Greater or equal (signed &gt;&#x3D;) switch要注意的是，switch 和 if 的汇编有本质区别。switch 基于跳转表（类似哈希表），它先把 case 同时增减一个值来让最小的 case 变为 0，然后建立跳转表，并根据 case 的值来计算合适的跳转地址。 以这个 C 代码为例，它可能被编译成下面的汇编代码： 12345switch(n) &#123; case 1: return &quot;one&quot;; case 3: return &quot;three&quot;; default: return &quot;other&quot;;&#125; 1234567891011cmpl $2, %eax # 检查是否超出范围(&gt;2), 这里%eax = x-1, # 因为最小case是1 ja .L_default # 如果超出范围则跳转到default jmp *.L_table(,%rax,4) # 使用跳转表: base + index*4.section .rodata.align 4.L_table: .long .L_case1 # case 1, %eax = 0 .long .L_default # case 2, %eax = 1 .long .L_case2 # case 3, %eax = 2 函数和栈啊哈哈，我们又要讨论寄存器了。还记得 %rsp 吗？它就是存储栈指针的寄存器。下图左边是栈的结构，右边是寄存器： 那么，栈和函数有什么关系呢？ 借助栈来控制转移栈的第一个作用是“passing control“，即控制转移。 调用函数（callq）本质上就是让程序计数器跳转（jmp）到了函数所在的汇编地址，并把调用完成后应该执行的指令地址压入栈中（pushq）。而函数返回（retq）本质上就是把调用完成后应该执行的指令地址 pop 出来（popq），并跳转回去（jmp）。 借助栈来存储数据栈的另一个作用是存储数据。 在函数被调用时，栈指针会移动并为这个函数分配一些栈空间用于存储寄存器的值、存储本地变量、传入的参数之类的东西。我们一个一个解释。 寄存器：在上图的右边可以看到有 caller saved 和 callee saved 的寄存器，标注 caller saved 的寄存器由调用者负责保存，标注 callee saved 的寄存器由被调用者负责保存。比如说，在被调用的函数返回时，被调用者要确保 callee saved 的寄存器和调用前没有区别。 本地变量：有时候寄存器不足以保存所有本地变量，就要放到栈中。 传入的参数：参数确实可以存在寄存器中，但有时候寄存器不够存，也就只能放到栈中了。我们可以用类似 movl -4(%rsp), %edx 的指令来获取传入的参数。 12345678910高地址 | 参数7 | | 参数8 | | ... | ← 调用前push | 返回地址 | ← call指令自动push | 保存的寄存器值 | ← 刚进入函数时push | 本地变量1 | | 本地变量2 | | ... | ← 当前rsp指向这里低地址 对了，根据上面的描述，递归就成了自然涌现出的结果，真神奇！ 数据结构我们来聊聊 array、struct、union 都是怎么表示在内存中的。 array 和寻址先说 Array，二维 array 如下图： 简单易懂。假设我们有 T A[R][C]，那么&amp;D[i][j] &#x3D; x0 + L(C * i + j). 其中 x0 为数组的起始地址，L 是 sizeof(T). 编译器在寻址时也就是这么做的。不过编译器会做一些聪明的优化来避免乘法，比如用 leaq 来加快计算： 12345# A in %rdi, i in %rsi, and j in %rdx1 leaq (%rsi,%rsi,2), %rax # Compute 3i2 leaq (%rdi,%rax,4), %rax # Compute xA + 12i3 movl (%rax,%rdx,4), %eax # Read from M[xA + 12i + 4] struct 和对齐再来聊聊 struct，看看这张图就差不多了： 12345struct rec &#123; int i; int a[2]; int *p;&#125;; 上图中，12 到 16 的“填充”是出于数据对齐的需要，对齐原则是——任何 K 字节的基本对象的地址必须是 K 的倍数。 K type 1 char 2 short 4 int, float 8 long, double, char * unionunion 允许我们用不同方式解释同一段位表示，常用于节省内存。 最常见的应用是，union 中的东西互斥，比如实现比较基础的动态类型： 123456789struct DynamicValue &#123; enum Type &#123; INT, DOUBLE, STRING &#125; type; union Data &#123; int i; double d; char* s; &#125; data;&#125;; 变长栈帧和%rbp有时我们会用到长度不定的数组，比如 12345int coolArr(int n) &#123; int A[n]; // 做一些cool things return A[0];&#125; 这时我们在调用函数前是无法确定要为函数分配多少栈空间的，编译出来的函数会形如 123456collArr: pushq %rbp movq %rsp, %rbp ... # 做一些cool things leave # 等价于 movq %rbp, %rsp; popq %rbp retq 编译器会用 %rbp 作为基指针（base pointer）来记录进入函数前的栈指针位置，并在返回时复位 %rsp 和 %rbp 的状态。 攻击与防御攻击最常见的攻击是缓冲区溢出攻击，CSAPP 里讲了栈溢出攻击，具体可以看看 attacklab. 这可以分为植入恶意代码和 ROP 攻击。 防御对栈溢出的防御手段主要有栈破坏检测、栈随机化、限制可执行代码区域。 最有效的手段是栈破坏检测，只要你破坏不了栈，自然就没办法攻击了。常用的手段是金丝雀值，即在调用允许用户修改栈的函数时，在栈里放一个随机值，然后在函数返回时判断这个值是否被改变。 栈随机化是指每次运行代码时，栈的地址都不一样。 限制可执行代码区域可以防御植入恶意代码到栈里，只要不允许执行栈里的代码就行了。","categories":[{"name":"学习","slug":"学习","permalink":"http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"公开课","slug":"学习/公开课","permalink":"http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"CMU-15-213","slug":"学习/公开课/CMU-15-213","permalink":"http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/"},{"name":"Notes","slug":"学习/公开课/CMU-15-213/Notes","permalink":"http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/Notes/"}],"tags":[]},{"title":"Attackblab记录","slug":"learning/open-course/CMU-15-213/Labs/Attacklab","date":"2025-03-13T03:18:38.000Z","updated":"2025-03-13T03:24:56.863Z","comments":true,"path":"wiki/learning/open-course/CMU-15-213/Labs/Attacklab/","permalink":"http://rinevard.github.io/wiki/learning/open-course/CMU-15-213/Labs/Attacklab/","excerpt":"","text":"img{ width: 40%; } 写在前面非常有趣的 lab！做了一大半以后感觉自己已经是 super 嗨客了。我不打算做最后一个，毕竟读汇编来做 ROP 攻击挺麻烦的，我感觉这对我的水平提升也不大（而且拿到 95&#x2F;100 我已经很满足了） “Why good people can only do good things and bad people can only do bad things? We bad people can do whatever we want.——Evil Neuro” 攻击attacklab 的攻击主要分为植入攻击代码和 ROP 攻击。 植入攻击代码攻击 1攻击 1 只是简单地让我们熟悉一下工作流程，我们只要覆写掉返回地址就好了。 大致的攻击流程是——跑一下 ctarget 看看我们写入的内容会被放在栈的哪个位置，熟悉位置以后把十六进制的攻击内容写到某个 txt 文件里，再用 hex2raw 转换为输入值，最后把输入值传到 ctarget 就实现了攻击。 下面给一些小 hints。 用 ./hex2raw &lt; rinevinput.txt &gt; evil 来把内容从十六进制转换为输入值, 并把输入值写入 evil（我把攻击文件叫做 evil） 注意, 不要把内容写入形如 evil.txt 这样的有格式的文件里! 这可能修改一些特殊字符。我之前就踩了这个坑。 使用 ./ctarget -q &lt; evil 来运行，因为我们不能连接到 CMU 服务器（唉，CMU）. 攻击 2攻击 2 就是典型的“植入攻击代码”了。一开始我的思路如下图： 这确实能跑，也确实顺利执行了 touch2，但执行完之后发生了segmentation fault！这是为什么？我至今没有搞清楚，如果有朋友知道可以跟我说一下。但我可以排除一些疑点。 首先，segmentation fault 不是因为栈指针跑到了预期位置之外。因为在 phase-2-level2 中，我们的栈指针跑得老远了。 segmentation fault 的发生大概率是因为栈指针没有对齐。给能通过的 phase2-level2 再加一句 ret，就造成了 segmentation fault。再在造成了 segmentation fault 的基础上多 ret 一次就又没有 segmentation fault 了。 所以我觉得大概率是栈指针的对齐问题。那栈指针，你究竟该在哪里呢？ 回到攻击 2，既然我们猜测是栈指针对齐问题，只要让它对齐就行了。我们微调一下，通过 push 让栈指针的位置偏移 8，然后就通过了。 攻击 3攻击 3 和攻击 2 差不多，唯一要注意的是 hexmatch 和 strncmp 会覆写栈，所以我们要把字符串藏在更下面的位置（即栈地址比较大的位置）。造成了 segmentation fault 怎么办？我们已经有了攻击 2 的经验，所以借助 pop，push，ret 来微调一下栈指针位置就行。 作业 PDF 里还提到，”Make position of check string unpredictable”。这有什么意义？我猜是为了防止我们把 sval 指向 cbuf 来实现攻击，这或许不符合 attacklab 的世界观，因为连字符串都不用注入了。 ROP 攻击攻击 4我是笨蛋，又踩了一个坑。考虑指令4017fc: 3b 3d e2 3c 20 00 cmp 0x203ce2(%rip),%edi # 6054e4 401802: 75 20 jne 401824 &lt;touch2+0x38&gt;在执行 cmp 指令时：RIP 的值是 0x401802，而不是 0x4017fc。我之前还想了半天为什么我们能指向 cookie。 回到题目上来，根据提示，我们要用 mov，pop，ret，那么思路是写入 cookie 到栈中，pop 它到某个地方（addval_219 有 pop %rax），最后移动到 rdi 中（addval_273 有 movl %eax %edi） 我们在攻击 2 里已经讨论过 segmentation fault 的发生原因，最合理的猜测是栈指针的对齐问题。所以如果发生了 segmentation fault，找个 ret 再用一下就行了。 攻击 5没做，we bad people can do whatever we want！","categories":[{"name":"学习","slug":"学习","permalink":"http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"公开课","slug":"学习/公开课","permalink":"http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"CMU-15-213","slug":"学习/公开课/CMU-15-213","permalink":"http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/"},{"name":"Labs","slug":"学习/公开课/CMU-15-213/Labs","permalink":"http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/Labs/"}],"tags":[]},{"title":"技巧的分类，冰山之下的深度","slug":"game-design/冰山之下的深度","date":"2025-03-08T04:22:38.000Z","updated":"2025-03-13T03:25:48.212Z","comments":true,"path":"wiki/game-design/冰山之下的深度/","permalink":"http://rinevard.github.io/wiki/game-design/%E5%86%B0%E5%B1%B1%E4%B9%8B%E4%B8%8B%E7%9A%84%E6%B7%B1%E5%BA%A6/","excerpt":"","text":"img{ width: 70%; } 《体验引擎》里提到，“深度游戏能够通过高水平的技巧创造有意义的玩法。深度（depth）这个概念用于描述游戏中需要学习的内容有多少。”在这里，我们将探讨一下如何对技巧的类型进行区分，以及如何创造这些技巧来提高游戏深度，同时不让游戏门槛过高。 既然要求有深度，那游戏里必然有很多技巧。我们有必要对技巧做一个区分——技巧可以被分为“规则涌现的技巧”和“预设的技巧”。围棋的各种技巧就是前者的一个很好的例子（uh actually☝️🤓 数学是更好的例子），而“炸弹能炸开有裂缝的墙”就是后者的一个例子。 基于规则的技巧创造“基于规则的技巧”是相对困难的，因为这要求我们创造能涌现出许多技巧的规则。这种纯粹的创造性活动恐怕没有什么经验可以写，我能说的也只是多去学学不同领域的知识。如果要做出有灵性的规则，当然不能只是玩各个游戏并尝试“学习经验”（你学的都是别人做过的规则！），而是要更多去看看自己从未见过的领域。比如说，比起盯着《baba is you》学，不如去学学编程。编程的“赋值”被 baba 做掉了，但编程的“语句执行顺序”是不是就可以做成 noita 的魔杖？编程的“抽象”思想会不会也可以做成另一个有趣的规则？ 虽然说“这种创造性活动恐怕没什么经验可写”，但还是写了一堆东西。我确实对基于规则的技巧更感兴趣，这完美实现了“冰山之下的深度”（我在这里点题了！）。不过接下来我们还是聊聊没有灵感时也能做的东西吧。 预设的技巧比起创造基于规则的技巧，创造预设的技巧则简单很多。我们可以随便口胡一些预设的技巧，比如“土狼跳”、“攻击过程中按冲刺能取消攻击”、“在开启技能的前摇时移动来消除前摇而直接开启技能”（唉，取消），实际上为了保证手感，几乎所有游戏都用了大量的预设的技巧。对预设的技巧来说，实际难点在于如何把深度藏在冰山之下，不让玩家因直面大量技巧而感到无所适从。 把深度藏在冰山之下听着很高大上，实际上最好用的藏深度的做法就是把预设的技巧逐渐呈现给玩家。每过几关给玩家一个新能力就是这种做法。更巧妙的做法是把多个预设的技巧融入到同一个操作之中，用恰当的关卡设计让技巧逐渐呈现出来。典型的例子是《闰跃之年》，开局跳一下就死了，那怎样跳才能活下来呢？这就是被藏在冰山下的预设的技巧了。 有的游戏还会把预设的技巧伪装成规则涌现的技巧，这让技巧显得更优雅，但实际上不是很本质的改进。围绕一个摸棱两可的主题设计一些预设的技巧，就能做到这一点。我能想到的最好的例子就是《蔚蓝》。蔚蓝把蹭墙跳、凌波微步这些预设的技巧藏在了“惯性”的后面，让各个技巧看起来都是涌现的。虽然这些技巧看起来都和惯性有联系，但实际上玩家并不能根据规则本身推理出这些技巧的存在，因此这是”把预设的技巧伪装成规则涌现的技巧“。 结尾基于规则的技巧和预设的技巧并非截然对立。大多数情况下，我们都逐渐学到所有的预设的技巧，再把预设的技巧作为规则组合起来形成基于规则的技巧。 还要注意的是，这种技巧的区分是在呈现给玩家的层面上，而非在实现层面上。如果你硬编码出 noita 的所有可能的法术搭配并写出对应效果，这在实现层面上显然是“预设”的，但对玩家来说，这仍然是“基于规则”的，毕竟玩家可以基于规则推理出可能的技巧。相较而言，如果我们设计一个和法术相关的游戏，每个法术在代码层面上都是几个小法术的组合，但玩家看到的只是组合好的各个法术而不能自己去组合法术，这在实现层面上是“基于规则”的，但对玩家来说是“预设”的。 多说一句，“在实现层面上基于规则，但呈现出来的效果是预设的”实际上是很适合做成探索类游戏的。核心思路是，首先把大量的预设的现象呈现给玩家，再让玩家逐步探索现象背后的规则。这种思路在别的游戏里也有，不过全是解谜游戏，我们完全可以做一个更有趣的探索类游戏。比如说玩家看到了火球术，之后我们逐渐引导玩家发现火球术本质上是火焰魔法+移动魔法，玩家就能进而基于规则构建出新魔法了。","categories":[{"name":"游戏设计","slug":"游戏设计","permalink":"http://rinevard.github.io/categories/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/"},{"name":"技巧","slug":"游戏设计/技巧","permalink":"http://rinevard.github.io/categories/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E6%8A%80%E5%B7%A7/"}],"tags":[]},{"title":"第二章——计算机内的信息表示","slug":"learning/open-course/CMU-15-213/Notes/Chapter2-data-representation","date":"2025-03-03T10:36:28.000Z","updated":"2025-03-11T07:17:37.410Z","comments":true,"path":"wiki/learning/open-course/CMU-15-213/Notes/Chapter2-data-representation/","permalink":"http://rinevard.github.io/wiki/learning/open-course/CMU-15-213/Notes/Chapter2-data-representation/","excerpt":"","text":"我们知道，在 32 位机器上和 64 位机器上，相同的 C 语言数据类型可能占用不同的字节数： C declaration Bytes Signed Unsigned 32-bit 64-bit [signed] char unsigned char 1 1 short unsigned short 2 2 int unsigned 4 4 long unsigned long 4 8 int32_t uint32_t 4 4 int64_t uint64_t 8 8 char * 4 8 float 4 4 double 8 8 整数表示这里真的有什么值得记笔记的吗？总之整数的表示可以分为 unsigned 和 signed，前者只能表示非负数，后者可以表示整数。下面是各个整数类型占用的字节数： C declaration Bytes Signed Unsigned 32-bit 64-bit short unsigned short 2 2 int unsigned 4 4 long unsigned long 4 8 众所周知，signed 的表示采用补码表示，就是模 $2^m$ 意义下对应的最小正数的二进制表示，其中 $m$ 是耗费的 bits 数。听起来有点抽象？这是写给自己看的笔记，我不觉得自己应该忘掉这个！ 不过考虑到失忆的可能，我还是再讲解一下。 下面的例子中类型是 signed short，$15213$ 的表示就是它的二进制表示，而 $-15213$ 的表示实际上是 $-15213 + 2^{16}$ 的二进制表示。 Decimal Hex Binary x 15213 3B 6D 00111011 01101101 y -15213 C4 93 11000100 10010011 让我们假设二进制表示为 $b_{w-1},b_{w-2},…,b_1,b_0$，那么如果是 unsigned，其值为 $$\\sum_{k&#x3D;0}^{w-1}2^{k}b_k$$ 如果是 signed，当 $b_{w-1}$ 即最高位不为 1 时，把二进制转换成十进制即可。 当最高位为 1 时，其值为 $$-2^{w}+\\sum_{k&#x3D;0}^{w-1}2^{k}b_k$$ 不难注意到能表示的整数有上下限，参考下表： Signed Unsigned 64-bit short [-32768, 32767] unsigned short [0, 65535] 2 int [-2^31, 2^31-1] unsigned int [0, 2^32-1] 4 long [-2^63, 2^63-1] unsigned long [0, 2^64-1] 8 加法，乘法，左右移加法和乘法就是模意义下的加法和乘法，所以你喜欢的运算规律都符合。“溢出”也只是模了一下。 而左右移呢？左移不难理解，把它的表示统一往左边移动，移出范围了就扔掉，最低位填充 0. x &lt;&lt; m 实际上是在做 $2^{m}x(\\text{mod $2^w$})$. 右移则分为逻辑右移和算术右移，前者是在右移后在最高位上填充 0，后者在最高位上填充符号位。 对 unsigned 来说它们没有区别，毕竟 unsigned 不考虑符号，但对 signed 来说就不一样了。 大多数 C 编译器对有符号整数实现的是算术右移，x &gt;&gt; m 实际上是在做 $\\lfloor \\frac{x}{2^m} \\rfloor$. 不同类型的整数一起运算会发生什么？核心思想是，在尽量保证值不变的前提下把数进行扩展。 把一个 signed short 整数和 signed int 相加会发生什么呢？我们会进行“符号扩展”，把 signed short 扩展成 signed int 再做加法，返回一个 signed int。 那，什么是符号扩展呢？如果 short 值是正数，高位会用 0 填充；如果是负数，高位会用 1 填充（符号扩展）。uh actually 🤓☝️ 这是在保证值不变的前提下把 short 转换成 int。 把一个 unsigned int 整数和 signed long 相加会发生什么呢？我们会把 unsigned int 扩展为 signed long（即在前面加 0）再做加法，返回一个 signed long。 当然，也有不能保证值不变的情况。比如 unsigned int 和 signed int 相加时，我们会把 signed 转换成 unsigned 再求和。 所以说，拜托不要写这种奇怪的代码： 12345678signed int a = -1;unsigned int b = 1;if (a &lt; b) &#123; printf(&quot;a &lt; b\\n&quot;);&#125; else &#123; printf(&quot;a &gt;= b\\n&quot;);&#125; 上面的代码会输出 $a\\geq b$，你这是在破坏数学的世界观！ 注意事项unsigned 很可能造成错误。对下面的代码，你觉得哪个是对的？ 123unsigned i;for (i = cnt-2; i &lt; cnt; i--) a[i] += a[i+1] 123unsigned i;for (i = cnt-2; i &gt;= 0; i--) a[i] += a[i+1] 答案是前者，因为对后者来说，i = 0 以后 i-- 会让 i 溢出变为正数，导致无限循环。不过能不能过编译我不确定，我这里是能过的。 反正不要写这样的代码，你这是在破坏数学的世界观！ 浮点数表示按照 IEEE 标准，浮点数的表示如下： 其中 s 是符号位，0 表示正数，1 表示负数 计算方式大致为 $$(-1)^s \\times 2^{\\text{exp}-\\text{bias}}\\times(1\\text{.frac})$$ 之所以说是“大致”，是因为还存在几种特殊情况。 如果 exp 全是 0，我们称其为非规格化数（denormalized），使用下面的公式计算： $$(-1)^s \\times 2^{1-\\text{bias}}\\times(1\\text{.frac})$$ 如果 exp 全是 1，frac 全是 0，我们认为表示的是 infin. 至于是 $+\\inf$ 还是 $-\\inf$ 由符号位决定。 如果 exp 全是 1，frac 不为 0，表示 NaN（not a number）. 看起来确实是很奇怪的标准！这涌现出的结果是，能表示的值在靠近 0 的位置比较密集，在远离 0 的位置比较稀疏。（下图以 exp 占 3 bits，frac 占 2 bits 为例） 舍入（四舍五入）既然浮点数的表示这么奇怪，那如果我把两个浮点数相加，是不是可能得到不精确的结果？真聪明，确实如此！我们一般采取“round-to-even”的策略，即先考虑舍入到更近的那个数，如果两个数一样近，把得到的结果向着更“偶数”的方向去舍入，对二进制表示来说，就是希望它被舍入到结尾为 0 的那个数上. 来个例子： 10.000112 10.002 (&lt;1&#x2F;2—down)10.001102 10.012 (&gt;1&#x2F;2—up)10.111002 11.002 ( 1&#x2F;2—up)10.101002 10.102 ( 1&#x2F;2—down) 主要好处是减少统计偏差。如果我们采取 round up，在统计时统计出的值可能偏高；如果选择 round down，统计出的值可能偏低。 加法，乘法浮点数的加法和乘法性质并不良好，我直接把课件复制过来吧： 浮点数加法： 封闭性：是 但可能生成无穷大(infinity)或非数值(NaN) 交换律：是 a + b &#x3D; b + a 结合律：否 由于溢出和舍入的不精确性 例如：(3.14+1e10)-1e10 &#x3D; 0，而 3.14+(1e10-1e10) &#x3D; 3.14 零元素：是 0 是加法单位元 逆元素：几乎是 除了无穷大和 NaN 外，每个元素都有加法逆元 单调性：几乎是 a ≥ b ⇒ a+c ≥ b+c 但对无穷大和 NaN 例外 浮点数乘法： 封闭性：是 但可能生成无穷大或 NaN 乘法交换律：是 a × b &#x3D; b × a 乘法结合律：否 由于溢出和舍入的不精确性 例如：(1e20×1e20)×1e-20 &#x3D; inf，而 1e20×(1e20×1e-20) &#x3D; 1e20 单位元：是 1 是乘法单位元 分配律：否 由于溢出和舍入的不精确性 例如：1e20×(1e20-1e20) &#x3D; 0.0，而 1e20×1e20 - 1e20×1e20 &#x3D; NaN 单调性：几乎是 a ≥ b 且 c ≥ 0 ⇒ a×c ≥ b×c 但对无穷大和 NaN 例外 类型转换double&#x2F;float → int：对浮点数（无论是单精度还是双精度）来说，把它们转换成 int 相当于 rounding toward zero，即舍去小数后面的部分。我觉得这应该主要是实现起来方便，我们在 datalab 里实现了这种转换。如果转换后超出了 int 的可表示范围，这种转换行为未定义（一般会设为 TMin，type minimum，能表示的最小值）。 int → float：根据 rounding mode 进行四舍五入，毕竟存在一些 float 不能表示的 int 值。 int → double：精确转换，毕竟 double 的 frac 有 52 个 bits，能够表示所有可能的 int 值。 杂项大端法和小端法多字节对象在内部存储的字节顺序表示上也有大端法和小端法之分，即最高有效字节在前面还是后面。比如把十六进制的 0x01234567 存储为 01 23 45 67 还是 67 45 23 01。 我们可以用下面的代码检查自己的机器使用的是大端法还是小端法。 123456789101112131415161718#include &lt;stdio.h&gt;int is_little_endian() &#123; unsigned int x = 1; // 将整数的地址转换为字符指针，访问其第一个字节 char *c = (char*) &amp;x; // 如果第一个字节是1，则为小端；如果是0，则为大端 return *c;&#125;int main() &#123; if (is_little_endian()) &#123; printf(&quot;系统是小端(Little Endian)\\n&quot;); &#125; else &#123; printf(&quot;系统是大端(Big Endian)\\n&quot;); &#125; return 0;&#125;","categories":[{"name":"学习","slug":"学习","permalink":"http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"公开课","slug":"学习/公开课","permalink":"http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"CMU-15-213","slug":"学习/公开课/CMU-15-213","permalink":"http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/"},{"name":"Notes","slug":"学习/公开课/CMU-15-213/Notes","permalink":"http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/Notes/"}],"tags":[]},{"title":"这里有什么？","slug":"learning/这是哪里","date":"2025-03-02T06:28:38.000Z","updated":"2025-03-05T11:04:37.397Z","comments":true,"path":"wiki/learning/这是哪里/","permalink":"http://rinevard.github.io/wiki/learning/%E8%BF%99%E6%98%AF%E5%93%AA%E9%87%8C/","excerpt":"","text":"本来只打算在博客里写杂谈和游戏设计相关文章的，不过想想看把学习笔记在这里记一记似乎也不错。那这里就是学习记录了，主要是写给未来的自己用的。🫠 应该只有朋友们（cyber friends）会看到这个网站，所以记录一下也是在表明我还在认真学习，没有进入摸鱼态。读者也别忘了终身学习。 更新（2025.3.5），今天试着加了篇笔记上来，但似乎浏览效果很一般，总之就把这些笔记当作我在学习的证明吧！","categories":[{"name":"学习","slug":"学习","permalink":"http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"Bomblab感想","slug":"learning/open-course/CMU-15-213/Labs/Bomblab","date":"2025-03-02T06:28:38.000Z","updated":"2025-03-05T10:57:21.211Z","comments":true,"path":"wiki/learning/open-course/CMU-15-213/Labs/Bomblab/","permalink":"http://rinevard.github.io/wiki/learning/open-course/CMU-15-213/Labs/Bomblab/","excerpt":"","text":"写在前面bomblab 比起 datalab 更友好一些，除了考察对汇编代码的理解以外，也在锻炼我们的 gdb 调试技能。用时共计 2+2+0.8+0.5+1.5+4 &#x3D; 10.8h，比 datalab 用时略少一点。刚开始拆弹的时候是很兴奋的，做到后面倒是感觉有点无聊了，我感觉 attacklab 可能更有趣一些（虽然我还没做）。 拆弹记录首先肯定要对 bomb 进行反汇编，我是用 objdump 来反汇编，并把结果保存到了 txt 文件中。拿到汇编以后随便翻翻找到 phase 们，之后就进入拆弹阶段了。 第一个炸弹phase_1 简单易懂，只是判断输入是否与某个字符串相等。我一开始以为字符串就是“0x402400”，后面才想到这是那个字符串的地址。用 gdb 设置断点即可得知字符串。（别看我说得那么轻松，也是折腾了两小时多，毕竟完全没有 gdb 经验 🫠） 第二个炸弹这也是一个不难的炸弹，把汇编代码往下读就能解决，喜欢的话可以加点注释帮助自己理解。不过我仍然做了两个小时，主要在疑惑 read_six_numbers 后数字被读到了哪里。还有个有趣的犯蠢的地方，我一开始把 400f35 处的 0x18 当成了十进制 18，疑惑了很久 4n 怎么可能等于 18，后面猛然惊醒发现那是十六进制。🤣 在这里我用到了这些新指令： 12345si # 单步执行x/10xw $sp # 查看栈指针(sp)处的10个字(word)，以十六进制(x)显示x/10i $pc # 查看当前位置之后的10条指令i registers eax # 查看寄存器值 第三个炸弹用时 50 分钟（有进步！），这次有了更系统的拆弹方法——先把代码分段，然后分析代码提出若干个猜测和问题，随着解答问题就逐渐做掉了。🫠我们可以轻松注意到输入的数字不能少于一个，再往下读就会 400f75 这一行，算一算就会很自然地猜测：输入要求我们选一个选项，跳过去然后 cmp。 这里是我拆弹时提出的问题以及解答： 输入按怎样的格式存储起来？存储在哪里？分析栈后发现，看起来是读取了两个数字，存储在栈中 400f6a 那行是怎么比较的？0x8(%rsp)是什么，输入值吗？猜测这是要求输入的选项值只能在 0-7 之间？设一个断点就能回答这个问题了。 400f75 跳到了哪里？是根据选项跳跃吗？根据选项跳跃 从选项跳到了 400fbe 后，0xc(%rsp)是定值还是会根据输入变化？0xc(%rsp)是输入的第二个值。由于 8 对齐，我们需要用 0xc(%rsp)而非 0x10(%rsp)来得到第二个值。 第四个炸弹用时半小时，我连 func4 都不想读，直接用 gdb 来执行 func4，找到返回 0 的输入就行了。这种解法感觉有逃课的嫌疑，不过你就说快不快吧！在这里我用到了这个新指令： 12(gdb) call (int)func4(11, 0, 14) 第五个炸弹用时 1.5h，做到这里，我比起刚开始时已经对汇编代码熟悉不少了。首先把代码分成若干个小部分，然后猜测并验证每个部分的功能就能解决这个炸弹。比较有趣的地方是这里加入了一个金丝雀，我还疑惑了一阵子这是什么，后来才想到这是书上讲的金丝雀。 第六个炸弹用时 4h，对这个炸弹，我感觉“根据运行时的状况猜代码的作用”比“分析代码”更加重要。一开始同样是把代码分成多个小局部，然后分段猜作用。这里引入了链表，还挺有趣。 彩蛋？什么彩弹？","categories":[{"name":"学习","slug":"学习","permalink":"http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"公开课","slug":"学习/公开课","permalink":"http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"CMU-15-213","slug":"学习/公开课/CMU-15-213","permalink":"http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/"},{"name":"Labs","slug":"学习/公开课/CMU-15-213/Labs","permalink":"http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/Labs/"}],"tags":[]},{"title":"Datalab解析","slug":"learning/open-course/CMU-15-213/Labs/Datalab","date":"2025-02-21T12:14:28.000Z","updated":"2025-03-26T10:36:41.165Z","comments":true,"path":"wiki/learning/open-course/CMU-15-213/Labs/Datalab/","permalink":"http://rinevard.github.io/wiki/learning/open-course/CMU-15-213/Labs/Datalab/","excerpt":"","text":"img{ width: 40%; } 写在前面Datalab 的难度很高。它的难度主要体现在技巧性上，这在整数部分尤其明显。整数部分至少有一半题目我花了一小时以上才做出来，相较而言，浮点数的题目虽然分类讨论起来更麻烦，但更为平易近人，每道我花了四十分钟左右。 如果有某道题做不出来，不建议一直死磕。我们可以换一道题或是离开屏幕散散心，我相信这会有帮助。 做完以后，感觉自己已经是位运算领域大神了！ 整数部分整数部分的技巧性很强，不建议在某道题上死磕，做不出来就换一道，以后再来。 bitXor本题要求用 ‘~’ 和 ‘&amp;’ 实现 ‘^’，简单列个关于 ‘^’ 的真值表： x y x^y 0 0 0 0 1 1 1 0 1 1 1 0 关注 x^y 为 1 时 x 和 y 的取值，可以发现 x^y &#x3D;&#x3D; ((x) &amp; y) | (x &amp; (y))，再用德摩根律把 ‘|’ 换成 ‘~’ 和 ‘&amp;’ 即可。 1234567891011121314/* * bitXor - x^y using only ~ and &amp; * Example: bitXor(4, 5) = 1 * Legal ops: ~ &amp; * Max ops: 14 * Rating: 1 */int bitXor(int x, int y)&#123; /* x Xor y = (~x &amp; y) | (x &amp; ~y) a | b = ~(~a &amp; ~b) */ return ~(~(x &amp; ~y) &amp; ~(~x &amp; y));&#125; tmin这是熟知的结论，tmin &#x3D; $-2^{31}$ &#x3D; 1 &lt;&lt; 31 1234567891011/* * tmin - return minimum two&#x27;s complement integer * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 4 * Rating: 1 */int tmin(void)&#123; /* use left shift to compute tmin */ return 1 &lt;&lt; 31;&#125; isTmax这种“判断 x 是否等于 y”的题目的做法有很多种： 创建一个 y，把 x 和 y 相减（x - y &#x3D;&#x3D; x + ((~y) + 1)），然后判断结果是否为 0. 创建一个 y，return !(x^y) 我这里是直接构建了 -Tmax &#x3D; 100…01，然后检查 x-Tmax 是否为 0. 12345678910111213// 2/* * isTmax - returns 1 if x is the maximum, two&#x27;s complement number, * and 0 otherwise * Legal ops: ! ~ &amp; ^ | + * Max ops: 10 * Rating: 1 */int isTmax(int x)&#123; /* create a &#x27;0&#x27; and use &#x27;!&#x27; */ return !(x + 1 + (1 &lt;&lt; 31));&#125; allOddBits这道题我想了很久。后来根据尝试性地构造了 1010…1010，然后试出了 (x &amp; mask) ^ mask 的写法。大致的思路是，既然我们只在乎奇数位的值，就先用 &amp; 把偶数位的值去掉，后来惊奇地发现再做个 ‘^’ 和 ‘!’ 就能得到结果了。 123456789101112131415/* * allOddBits - return 1 if all odd-numbered bits in word set to 1 * where bits are numbered from 0 (least significant) to 31 (most significant) * Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 12 * Rating: 2 */int allOddBits(int x)&#123; /* (x^y) == 0 &lt;=&gt; x == y */ int y = 0xAA; // 0xAA 就是二进制的 1010 1010 int mask = y + (y &lt;&lt; 8) + (y &lt;&lt; 16) + (y &lt;&lt; 24); return !((x &amp; mask) ^ mask);&#125; negate这是熟知的结果，本质是 $x + \\sim x + 1 \\equiv 0(\\text{mod $2^{32}$})$ 123456789101112/* * negate - return -x * Example: negate(1) = -1. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 5 * Rating: 2 */int negate(int x)&#123; /* well known result */ return ~x + 1;&#125; isAsciiDigit这道题我想了很久。后来分析了输入的形式，发现它只能形如 0000 … 0011 0yyy 或是 0000 … 0011 100y，于是决定把自由的位置右移掉，然后用 mask。 做完后复盘发现还有一种基于比较的方法，直接计算 x - 0x30 和 x - 0x39 并判断其符号位。 12345678910111213141516171819202122/* * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters &#x27;0&#x27; to &#x27;9&#x27;) * Example: isAsciiDigit(0x35) = 1. * isAsciiDigit(0x3a) = 0. * isAsciiDigit(0x05) = 0. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 15 * Rating: 3 */int isAsciiDigit(int x)&#123; /* x 只能形如下面两种形式： * 1. 0000 ... 0011 0yyy * 2. 0000 ... 0011 100y * 这里的 y 可以是 0 或 1 * 我们用右移去掉未知的 y, 然后用 mask即可 * 构造两个 mask, 一个是 0000 ... 0000 0110, 另一个是 0000 ... 0001 1100 */ int mask1 = 0x06; int mask2 = 0x1C; return !((x &gt;&gt; 3) ^ mask1) | !((x &gt;&gt; 1) ^ mask2);&#125; conditional这道题我也想了好久。一开始为了方便，我先用 !!x 把 x 归到了 0 或 1. 之后的思路是想构造满足类似 f(0, y) &#x3D; 0，f(1, y) &#x3D; y 的条件的函数 f，然后返回 f(x, y) + f(!x, z). 稍加思考，便发现 ‘&amp;’ 和这里的 f 很像，于是就写下去了。 123456789101112131415161718/* * conditional - same as x ? y : z * Example: conditional(2,4,5) = 4 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 16 * Rating: 3 */int conditional(int x, int y, int z)&#123; /* 为了方便, 先限制 x 只取 0 或 1 * 我们一开始的思路是找到函数满足 f(x, b) = b if x == 1, 0 if x == 0 * 然后用 f(x, y) + f(!x, z) 即可得到结果 * 中途发现 11...1 &amp; b = b, 0 &amp; b = 0, 和我们希望的结果很像 * 于是就这么写了 */ int mask = (~(!x)) + 1; // x为0时得到全1，x非0时得到0 return ((~mask) &amp; y) + (mask &amp; z);&#125; isLessOrEqual好吧，这道题我还是想了很久，毕竟我在做之前对位运算几乎一无所知。这道题更多是分类讨论，分为 xy 同号和 xy 异号的两种情况就行，连溢出都不会有。 12345678910111213141516171819202122/* * isLessOrEqual - if x &lt;= y then return 1, else return 0 * Example: isLessOrEqual(4,5) = 1. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 24 * Rating: 3 */int isLessOrEqual(int x, int y)&#123; /* 若xy同号(最高位相同), return 1 if y - x &gt;= 0 else 0 * 若xy异号, return 1 if y的二进制表示最高位为0 else 0 */ int signX = x &gt;&gt; 31; int signY = y &gt;&gt; 31; int diffSign = (signX &amp; !signY); // (异号且 y &gt;= 0, x &lt; 0) ? 1 : 0 int diff = y + (~x + 1); // y - x int sameSign = (!(signX ^ signY)) &amp; ((diff &gt;&gt; 31) + 1); // (同号且 y - x &gt;= 0) ? 1 : 0 return diffSign | sameSign;&#125; logicalNeg这道题是我感觉第二难的题目，我的核心思路是“非 0 的 x 的二进制表示中至少有一个 1”，于是我就构造了 11…1 即 -1 这个特殊值，并期盼它能给我一些有趣的结果。 对正数 x 来说，x + (-1) 的最高位必然是 0，这能把正数和 0 区分开来，因为 0 + (-1) 的最高位是 1. 但负数怎么办呢？负数要分类讨论，很麻烦。于是我就想取输入值的绝对值，然后用 abs + (-1) 来区分非 0 值和 0. 我这里的代码采用的是类似的思路，不过当时没想到怎么求 abs，就写得更复杂了一些。 后来复盘时发现非 0 值 x 一定满足 (x | (~x)) 的最高位为 1，用这个方法更简单。 12345678910111213141516171819202122232425262728/* * logicalNeg - implement the ! operator, using all of * the legal operators except ! * Examples: logicalNeg(3) = 0, logicalNeg(0) = 1 * Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 12 * Rating: 4 */int logicalNeg(int x)&#123; /* * 先思考怎么表示 &#x27;x非0&#x27;, 注意到 x非0 &lt;=&gt; x的二进制表示中至少有一个1 * 考虑用 -1(它的二进制表示全是1) + x 来得到一些中间量 * 接下来分类讨论, 如果 x为0, 则 -1 + x = -1, * 如果 x为正数, -1 + x 的二进制表示以 0 开头 * 如果 x为负数, 要分类讨论 Tmin的情况, 处理起来不方便 * 至此, 正数和 0 就能通过 (-1 + x) &gt;&gt; 31 区分开来了, 正数得到 0, 0 得到 -1 * 接下来把负数整合进来 * 考虑到负数的负是正数, 我们自然就会考虑把负数转化成正数，再用 | 或者 &amp; 来连接 * ((((~0) + x) &gt;&gt; 31)) &amp; ((((~0) + negtivex) &gt;&gt; 31)) 就能把正数和负数都变成0, 0变成 -1 * 再 &amp; 1 就能得到 !x 了 * 代码里又进一步简化了一下结果, 不过核心思路还是&quot;把负数和正数统一起来&quot; * 这里的 (((~0) + x) &amp; ((~0) + negtivex)) 把 &amp; 提前到了移位前, * 直接 &amp; 了二进制表示的最高位(之前的先 &gt;&gt; 再 &amp; 是 &amp; 了二进制表示的最低位) */ int negtivex = (~x) + 1; return ((((((~0) + x) &amp; ((~0) + negtivex)) &gt;&gt; 31)) &amp; 1);&#125; howManyBits这道题是我感觉最难的题目。首先我们画出这个函数的图像（留给读者作为练习），会发现它关于 -0.5 对称，这表明 x 和 -x-1 耗费的位数相同，接下来我们就只要考虑非负数就行了。 找到非负数的最小 bits 数倒是不难，稍微写几个非负数就能发现，只要找到它值为 1 的最高位数，设其为 k，k + 1 即为结果。 之后的难点就是，如何找到这个非负数的“值为 1 的最高位数”了。线性搜索显然是可行的，我们可以用 $\\sum_{m&#x3D;0}^{31}!!(x &gt;&gt; m)$ 来得到这个位数，然而这样做耗费的操作数超出了限制。既然线性耗费的操作数太多，那我们自然就会想到二分。 但怎么做二分呢？这里的代码更多是我试出来的，没有什么清晰的理论指导，我们直接看图吧。 怎么做到“砍掉一半”呢？砍掉右边半段用右移就行，所以我们会从 x &gt;&gt; 16 开始，再用 !!(x &gt;&gt; 16) 是 0 还是 1 来判断 1 在右半边还是左半边。 之后的代码就真的纯粹是试出来的了，我们肯定能在数学上解释我们的操作，但具体的构思纯粹是试错+直觉试出来的，没什么好说的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/* howManyBits - return the minimum number of bits required to represent x in * two&#x27;s complement * Examples: howManyBits(12) = 5 * howManyBits(298) = 10 * howManyBits(-5) = 4 * howManyBits(0) = 1 * howManyBits(-1) = 1 * howManyBits(0x80000000) = 32 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 90 * Rating: 4 */int howManyBits(int x)&#123; /* 简单画下这个函数的图像, 注意到 x 与 -x - 1(即~x) 耗费位数相同, 那就先统一转换成非负数, * 然后找到最高的值为1的位数, 设其为 k, k + 1 即为结果 * 比如 0000 ... 0010 0110 的结果为 6 + 1 = 7 * * 那怎么找到最高的值为1的位数呢? * 一种想法是 sum([!!(alternatex &gt;&gt; k) for k in range(32)]), 但这样用的操作就超过限制了 * 所以我们借助二分的思想 * 让我们举个例子, 假设我们在处理 0010 1101, * 我们可以先把它右移4, 发现仍然大于0, 就令ans += 4, 此时值为 0010 (扔掉右半部分) * 然后右移2, 发现等于0, 则不在数据上真正移动, 值为 10 (扔掉左半部分) * 再右移1, 发现大于0, 令 ans += 1, 此时值为 1 (扔掉右半部分) * 当前的值不为0, ans +=1 (ans之前加了&quot;被移除的部分的长度&quot;, 这里还要加上&quot;剩余的部分的长度&quot;) * 综上, 0010 1101 的最高的值为1的位数为6 * * 首先我们要能够检查右移后值是否为0, 用!!(x &gt;&gt; k) 即可, !!(x &gt;&gt; k) == (x 右移后值为0) ? 0 : 1 * 然后为了方便在值上进行移动, 我们希望有 f(x) = (x 右移后值为0) ? 0 : 右移长度 * 因此使用形如 !!(x &gt;&gt; (2**k)) &lt;&lt; k 的东西 */ int signX = x &gt;&gt; 31; // (x &gt;= 0) ? 00...0 : 11...1 int alternatex = ((~(signX)) &amp; x) + ((signX) &amp; (~x)); // (x &gt;= 0) ? x : -x-1 int bit16 = (!!(alternatex &gt;&gt; 16)) &lt;&lt; 4; // (alternatex &gt;= 2**16) ? 16 : 0 alternatex = alternatex &gt;&gt; bit16; int bit8 = (!!(alternatex &gt;&gt; 8)) &lt;&lt; 3; alternatex = alternatex &gt;&gt; bit8; int bit4 = (!!(alternatex &gt;&gt; 4)) &lt;&lt; 2; alternatex = alternatex &gt;&gt; bit4; int bit2 = (!!(alternatex &gt;&gt; 2)) &lt;&lt; 1; alternatex = alternatex &gt;&gt; bit2; int bit1 = (!!(alternatex &gt;&gt; 1)); alternatex = alternatex &gt;&gt; bit1; int bit0 = (!!alternatex); return bit16 + bit8 + bit4 + bit2 + bit1 + bit0 + 1;&#125; 浮点数部分浮点数部分比起整数部分简单得多，只要仔细地分类讨论就行了。 floatScale2分类讨论即可。这里比较有趣的是 exp &#x3D;&#x3D; 0（denormalized case）的情况，无论 frac 部分是否超过 23 位，处理的代码都是一样的。 12345678910111213141516171819202122232425262728293031323334353637383940414243/* * floatScale2 - Return bit-level equivalent of expression 2*f for * floating point argument f. * Both the argument and result are passed as unsigned int&#x27;s, but * they are to be interpreted as the bit-level representation of * single-precision floating point values. * When argument is NaN, return argument * Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while * Max ops: 30 * Rating: 4 */unsigned floatScale2(unsigned uf)&#123; /* 取出 exp 的部分, 分三种情况讨论. * 1. NaN or infin, 直接返回输入值 * 2. denormalized case, 主要修改 frac 部分, 如果修改导致 frac * 部分多于 23 位, 还要修改 exp 部分 * 3. normalized case, 修改 exp 部分 */ unsigned exp = (uf &gt;&gt; 23) &amp; 0xFF; // 00...0 exp // 如果 exp == 二进制(1111 1111), uf为 NaN 或 infin, 直接返回uf if (exp == 0xFF) &#123; return uf; &#125; // 如果 exp == 0, 就是 denormalized case else if (exp == 0) &#123; unsigned frac = (uf &lt;&lt; 9) &gt;&gt; 9; // 0 00000000 frac // 如果 frac 部分最高值为1, 进位; 如果不为1, 把 frac 部分乘二即可 // 两种情况都能用下面的代码来表示 frac = frac &lt;&lt; 1; return ((uf &gt;&gt; 23) &lt;&lt; 23) + frac; // (s exp 00...0) + (0 00000000 frac) &#125; // normalized case else &#123; // exp不会溢出8位, 因为前面的 if 分支已经处理了 exp == 0xFF的情况 exp += 1; unsigned expmask = (~0) ^ (0xFF &lt;&lt; 23); // 1 00000000 11...1 return (uf &amp; expmask) + (exp &lt;&lt; 23); &#125;&#125; floatFloat2Int同样是分类讨论。一开始我把 NaN、infin 单独写了一种情况处理，后面发现操作数太多超出了限制，于是把它和绝对值太大的情况统一了起来，毕竟它们的返回值一样。 这里要仔细考虑的是 Tmin 落入的分支，在我的代码里，Tmin 落入了第一个 if 分支。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/* * floatFloat2Int - Return bit-level equivalent of expression (int) f * for floating point argument f. * Argument is passed as unsigned int, but * it is to be interpreted as the bit-level representation of a * single-precision floating point value. * Anything out of range (including NaN and infinity) should return * 0x80000000u. * Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while * Max ops: 30 * Rating: 4 */#include &lt;stdio.h&gt;int floatFloat2Int(unsigned uf)&#123; int exp = (uf &gt;&gt; 23) &amp; 0xFF; // 00...0 exp unsigned frac = (uf &lt;&lt; 9) &gt;&gt; 9; // 00...0 frac // 绝对值太大的情况 // 注意 NaN, infin也在这种情况中, 此时 exp == 0xFF // -2^(31) 也在这种情况中, 此时 exp == 127 + 31, frac == 0 if (exp &gt;= 127 + 31) &#123; return (1 &lt;&lt; 31); &#125; // 绝对值太小的情况 else if (exp &lt; 127) &#123; return 0; &#125; // 绝对值位于 [0, 2^(31) - 1] 的情况 // 该分支中, 0 &lt;= exp - 127 &lt; 31 else &#123; int e = exp - 127; int abs; frac += (1 &lt;&lt; 23); // 如果 e 足够大, 保留 frac 里的所有数字, 否则舍弃后几位数字 if (e &gt;= 23) &#123; abs = frac &lt;&lt; (e - 23); &#125; else &#123; abs = frac &gt;&gt; (23 - e); &#125; // 根据正负返回不同值 // positive case if ((uf &gt;&gt; 31) == 0) &#123; return abs; &#125; // negative case else &#123; return (~abs) + 1; &#125; &#125;&#125; floatPower2还是分类讨论，不多说了。 1234567891011121314151617181920212223242526272829303132333435363738/* * floatPower2 - Return bit-level equivalent of the expression 2.0^x * (2.0 raised to the power x) for any 32-bit integer x. * * The unsigned value that is returned should have the identical bit * representation as the single-precision floating-point number 2.0^x. * If the result is too small to be represented as a denorm, return * 0. If too large, return +INF. * * Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while * Max ops: 30 * Rating: 4 */unsigned floatPower2(int x)&#123; /* float 可以表示的 2的幂次的范围为 [2^(-149), 2^(127)], * 其中 [2^(-149), 2^(-127)] 由 denormalized case 表示, * [2^(-126), 2^(127)] 由 normalized case 表示 */ if (x &lt; -149) &#123; return 0; &#125; // denormalized case else if (x &lt;= -127) &#123; return 1 &lt;&lt; (x + 149); // 只处理 frac 部分 &#125; // normalized case else if (x &lt;= 127) &#123; return (x + 127) &lt;&lt; 23; // 只处理 exp 部分 &#125; else &#123; return (0xFF &lt;&lt; 23); // +INF &#125;&#125;","categories":[{"name":"学习","slug":"学习","permalink":"http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"公开课","slug":"学习/公开课","permalink":"http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"CMU-15-213","slug":"学习/公开课/CMU-15-213","permalink":"http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/"},{"name":"Labs","slug":"学习/公开课/CMU-15-213/Labs","permalink":"http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/Labs/"}],"tags":[]},{"title":"写完了datalab，突然感觉好孤单","slug":"others/thoughts/datalab和我","date":"2025-02-21T11:49:30.000Z","updated":"2025-03-24T09:06:23.660Z","comments":true,"path":"wiki/others/thoughts/datalab和我/","permalink":"http://rinevard.github.io/wiki/others/thoughts/datalab%E5%92%8C%E6%88%91/","excerpt":"","text":"一个寒假过去，把手头上最喜欢的设计简单做了个原型，确实不错。不过由于代码水平太低，另一个同样喜欢的设计没能实现出来。原本想在这学期做一个比较完整的游戏的，但认真想了想，凭我现在的代码水平，恐怕根本做不了。还是要提高一下自己的代码水平才行，于是这学期打算认真打打基础，从 15213 开始。 今天写掉了 datalab。凭借自己的努力做完了一个很难的作业，当然会感到很欢喜，可站起来准备回寝时，突然感到很孤单。“没有学分，没有绩点，没有老师，没有同学，只有一个信念 —— 你在变强。”或许吧，我在变强。变强之后呢？应该就能写出更漂亮的代码，不带妥协地实现自己的想法了吧。 更新：今天（2025.3.1）在寝室写完了 bomblab，感觉很开心，并没有什么孤单的感觉。顺便看了看母鸡卡的新假药，萌战吧的吧友们即使在滑坡大环境下也坚持造药，这就是我们的黄金精神！ /* 隐藏草书 */ .hidden-text { font-size: 18px; text-align: center; margin: 20px 0; /* padding: 20px; */ line-height: 1.5; color: transparent; cursor: default } .hidden-fancy-text::selection { color: black; background: white; } 凝视我曾凝视的光芒，触摸你将触摸的远方。","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/"},{"name":"碎碎念","slug":"杂谈/碎碎念","permalink":"http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}],"tags":[]},{"title":"母鸡卡的各种神奇假药","slug":"others/animation/母鸡卡的各种神奇假药","date":"2025-02-15T13:31:31.000Z","updated":"2025-03-21T02:41:30.767Z","comments":true,"path":"wiki/others/animation/母鸡卡的各种神奇假药/","permalink":"http://rinevard.github.io/wiki/others/animation/%E6%AF%8D%E9%B8%A1%E5%8D%A1%E7%9A%84%E5%90%84%E7%A7%8D%E7%A5%9E%E5%A5%87%E5%81%87%E8%8D%AF/","excerpt":"","text":"img{ width: 50%; } 整理一下我觉得很有趣的假药，太真的和我不感兴趣的就不放进来了。 你知道的，母鸡卡已经烂完了，但追番过程中看吧友假药的体验还是很有趣的。追番时的怒气值从第九集开始积累，在第十二集达到巅峰，也有了删掉这篇文章的想法。但想了想看假药的体验确实足够有趣，于是就这样吧。释怀是不太能释怀的，整部动画的割裂感实在令人感到恶心。（2025.3.21 更新） 关于整体走向的假药时间轮回说时间轮回 是第九集出现的假药 第九集灾难般的爆爆爆让许多假药的讨论度都大幅下降，不过时间乱序说重新登场，更是出现了时间轮回说。（致敬传奇第十话——我的战场不在这里） 我感觉时间轮回不太可能，不过这个想法太酷了！至于时间乱序，最明显的证据是第九集 18:40 和第二集 13:34 能连起来。或许可以结合瞳孔变化说来看看第二集是 mortis 还是睦头？ 那么贯穿全剧，把时间重排起来的线索是什么呢？一种说法是手机电量 叙诡说叙诡说 是第二集出现的假药，在三四集得到完善，第五集后讨论度大幅下降。 前四集剧情跳跃、旁白由初华声优念出是因为这是初华在叙述故事！那么，是在对谁讲述呢？ 一种假药是初华对失忆的祥子讲述故事，在叙述中美化自己，好让祥子待在自己身边。理由是祥子在前四集唯独对初华态度比较好，这是初华对自己的美化。 另一种是初华对自己讲述故事，只是在自我欺骗“乐队依然存在”，因此剧本漏洞百出。但无论叙述多少次，乐队都逃不掉解散的结局。 上面的蓝色链接是“初华对自己讲述故事”。 内鬼内鬼说 是第四集出现的假药，主要用于解释观感奇怪的解散。 母鸡卡解散的剧情逻辑混乱，这是因为队里有内鬼，内鬼只要把队解散掉就行了。由于我比较喜欢祥子，所以我接下来讲全队内鬼，祥子 1vn 的剧情。 整个事务所都是丰川家族安排的内鬼，上到其他乐队成员下到工作人员，都对“丰川家希望祥子回家”这件事或多或少有了解，因此工作人员浑水摸鱼，除了祥子以外的乐队成员都不在乎乐队。祥子 1vn 硬生生把母鸡卡带到了武道馆，不愧是美强惨大女主，数值太高了。 这太数值怪啦，不合理的！不过内鬼说还是很有趣而且很靠谱的，我觉得比较真的是初华喵梦内鬼，睦和海玲知情。 人偶人偶说 是第七集出现的假药。 mujica 结尾全员人偶化。“在 mujica 的短暂月光下，五个人偶短暂的复活了，在舞台上高歌一曲。给出了一场完美 live。” 关于个人的假药初华蜘蛛侠蜘蛛侠 其实初华的真实身份是蜘蛛侠，各种蜘蛛意象是暗示初华被蜘蛛咬过。能力越大，责任越大，蜘蛛侠要打击犯罪，所以既不去 Mujica 排练，也不去 sumimi 排练，还说自己忙。初华让祥子在门口等 10 秒其实是在藏蜘蛛战衣，她 10 秒就能收拾好房间、第三集隔着几十米听到祥子和睦的对话都是因为她有超能力。众所周知祥子是蓝色章鱼，初华把祥子带到自己家实际上是为了监视章鱼博士。而且，既然有双面人睦、企鹅人高松灯、章鱼博士祥子，有蜘蛛侠初华也不奇怪。 叙诡叙诡说 之前已经提过，这里的链接是第二集播出后的初版假药。 之前已经说过了，旁白由初华的声优念出、前几集逻辑诡异，都是因为这是初华讲述的故事。初华是母鸡卡故事的叙述者。 缓存不足缓存不足说 是第四集出现的假药。 “初华对某些记忆的深刻程度，可能不会被时间冲淡，而一些日常记忆可能会被很快的忘却。在她心目中，自己和心爱的祥子度过的每个夏天、出道时祥子发来的短信鼓励可能一直占据着她脑内非常非常多的缓存。这些和祥子一起的快乐的记忆对初华来说可能就像是刚刚经历的一样，那份喜悦、甜蜜、饥渴就像冰一样无时无刻不在侵蚀初华的大脑，所以初华才会给人一种难以形容的超重女印象。” 认知障碍初华认知障碍说 是第一集出现的假药。 初华的眼里一直都只有祥子，别人的形象在她眼里是扭曲的。众所周知，MyGO 第八集里有初华的回忆，回忆里明显能看出初华见过祥子的人偶。然而在母鸡卡第二集里，她却好像是不认识人偶的样子。答案是初华在小时候将睦认知成了人偶。 失忆初华失忆说 是第二集出现的假药。 为什么初华如此空洞？为什么初华的童年记忆和祥子有偏差？为什么初华忘了祥子的玩偶？因为初华经历过一次失忆。初华拿着以前的日记本，努力扮演“真正的初华”。 祥子⭐ 压抑丰川祥子 ⭐ 压抑说 祥子对大雷情有独钟，组乐队是为了接近大雷。 人偶祥子人偶说 是第七集出现的假药，主要用于解释第七集祥子的形象变化。 第 7 集的祥子为了睦成为了舍弃自我的人偶，她装出了白祥的样子，因为“只要睦能回来就好了”。 祥爹演戏祥爹演戏说 是第五集出现的假药。 祥爹演戏把祥子气走，让祥子回归家族。 睦装双重人格睦装双重人格说 是第四集出现的假药。 如题，主要依据是第四集睦在初华车上的第一句“嗯”是睦的声线。 mortis 小小祥mortis 小小祥说 应该是第六集出现的假药。 睦小时候只有祥子一个朋友，mortis 是睦以白祥为模板塑造的人格，扮演小祥。 写文章时整理的假药链接 叙诡 内鬼说 人偶说 睦祥黑手说 圣经说 元素说 蜘蛛侠 叙诡说 缓存不足说 初华认知障碍说 初华失忆说 祥子失聪说 祥子人偶说 祥爹演戏说 睦装双重人格说 mortis 小小祥说 mortis 锡兵说 雨伞颜色 祥睦姐妹说 天天吃假药吃傻了做出来的冰山图 四演 mortis 四演祥子 歌剧魅影说","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/"},{"name":"二次元","slug":"杂谈/二次元","permalink":"http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/%E4%BA%8C%E6%AC%A1%E5%85%83/"}],"tags":[]},{"title":"探索","slug":"game-design/对探索类游戏的思考","date":"2025-02-14T12:36:38.000Z","updated":"2025-03-13T03:27:14.048Z","comments":true,"path":"wiki/game-design/对探索类游戏的思考/","permalink":"http://rinevard.github.io/wiki/game-design/%E5%AF%B9%E6%8E%A2%E7%B4%A2%E7%B1%BB%E6%B8%B8%E6%88%8F%E7%9A%84%E6%80%9D%E8%80%83/","excerpt":"","text":"为什么要探索呢？设想一下，如果我们乘上了飞船，飞入太空，忽然发现一颗行星朝着反方向转动了。这时你会不会想去那里？如果我们在网上发现了一个网站，点开第一个链接发现里面是你的家庭住址（我超，盒！），你会不会想继续翻别的链接？人类探索的动力被命名为好奇心，好奇驱动探索。 好吧，我们不妨把话说得更明白一些，好奇驱动探索的意思就是：“我相信那里有值得关注的东西，但不确切知道是什么，所以我要去探索。” 这听起来真的是再平凡不过的事情了，那就来分析一下怎么激发玩家的好奇心，再让好奇驱动探索吧。 相信有值得关注的东西在探索之前，首先要让玩家相信“那里有值得关注的东西”。值得关注的东西并不难做，它们可以是奇观、奖励乃至挑战，关键是怎样让玩家相信“那里有东西”。 做法很多，我们来找几个例子，看看关注探索感的游戏都是怎么做到这一点的。 首先来看类银河城游戏，对有经验的玩家，获得新能力就自然想到“以前有个过不去的路能靠这个能力过去”，然后也就想到“那里有值得关注的东西”；看到墙就自然想到假墙，然后就想到“那里有值得关注的东西”了。然而，这种做法过度依赖玩家的先验知识。对一个新接触类银河城的玩家来说，到处迷路才是更可能发生的事情，他们根本不知道“哪里有值得关注的东西”。 我想这也是类银河城游戏相对小众的原因，它只给有经验的玩家提供了探索感，而给新玩家提供了迷路感。能力锁尚且好说，假墙就实在是不利于探索感的塑造了，毕竟大多数玩家的先验知识是“墙体不可破坏”，根本就不会想到“墙后面有值得关注的东西”。不过假墙并非一无是处，它能给玩家一种“秘密”的感觉，这就是题外话了。所以说如果做类银河城，起码要提醒一下玩家这些设计的存在，而不是盲目地抄别的银河城的做法。在空洞骑士开局的时候，我们必须打碎一面墙才能前进，这就是一个不错的提醒。 接下来看看清单式开放世界。虽然在地图上到处塞问号的方法为人诟病，但这也确实非常清晰地把“那里有东西”传达给了玩家。那为什么为人诟病呢？主要是因为问号里的东西千篇一律，连“值得关注的东西”都没做到。那如果把每个问号都塞一个精美的支线，会好点吗？恐怕也不一定，因为被动地接受问号和主动发现问号带来的“值得关注感”是不一样的。自己找到的东西，就算再无聊也会想看完。 这里就不谈塞尔达了。说起来不太好意思，但我在玩的时候确实没感到什么探索欲望。一是我没感觉到哪里有东西，二是因为我也没感觉有什么值得我关注的东西。（球球了，不要开除我的玩家籍） 然后谈谈星际拓荒吧，这篇文章可以说就是为了星际拓荒而写的。星际拓荒的做法主要有两种，一种是奇观，另一种是非常直白地用文字告诉你“那里有东西”。前者不必多说，后者的文字描述本身也足以让玩家觉得那里“值得关注”。 不确切知道有什么这一点看起来不难实现，但和前一点结合起来就很难了。玩家玩了一段时间游戏后，很快就会对奖励有一定预期，如果做不到打破这种预期，就会让玩家丧失好奇心，丧失探索欲。 这一点在有经验的玩家身上体现的尤其明显。对一个普普通通的探索类游戏，他们对一切几乎都有预期，因此也会丧失探索欲。 其实，绝大多数游戏都让玩家丧失了探索欲，让我们以清单式开放世界为例，看看问号是如何让玩家失去探索欲的。 假设我们面前有一个玩家在玩游戏，我们看看会发生什么。玩家到了第一个问号，是一个有趣的战斗！玩家很开心。玩家到了第二个问号，是一个高级武器！玩家很开心。……玩家到了第 16 个问号，是一个已经重复过不知道多少遍的的战斗，在战斗结尾还奖励了一个高级武器！玩家对此早有预期，不再想去下一个问号了。 看见了吗，玩家就是这样丧失探索欲，沦为清问号机器的。 开放世界里的问号这么说来，把每个问号的内容都换成一个玩家猜不到是什么的精美的支线就能激发探索欲？这确实能改善现状，但也并非全然如此。问号始终没有完全做到让玩家觉得那个地方“值得关注”，毕竟问号是设计师在地图上标出来的，而不是玩家主动标出的。 许多类银河城里也提供了在地图上打标记的功能，我们可以横向对比一下。很明显，一张全是自己标出的问号的地图和一张全是游戏自带的问号的地图相比，前者更能激发探索欲。究其根本，就在于前者的每个问号都真的让玩家相信“那里有值得关注的东西”。 那么怎么改进开放世界里的问号呢？我也不确定。说到底问号这个东西根本就没让玩家觉得“那里有值得关注的东西”不是吗？终究要让玩家觉得自己是主动关注到那里的才行，问号还是太被动了。 文末写到这里，关于探索的内容就基本写完了，最后是一些让探索更有趣的小技巧，我随便列一些，不再详谈。 能力软锁：常见于类银河城。能力软锁不仅是关卡设计手段，也是控制可选路线数量的工具。限制选项数量的重要性不必多说。 线索：好的秘密需要提示，而非随机乱逛。我实在是欣赏不了到处乱藏东西的银河城。这还会涉及到电波式谜题（我感觉比“点击式谜题”更好理解）和逻辑谜题的差异，不详谈。 知识积累：游戏应该逐步教会玩家识别探索机会的能力，也被称作“知识锁”。 一个相当有趣的体验是“新视角”，即发现了过去没有发现的探索机会。能力成长、环境变化、知识积累都能带来新视角。其中我最喜欢的是环境变化和知识积累带来的新视角，大概是因为不常见吧。 让我们试试一个简单的传达探索的体验的 demo 。我们看到了下面的东西： 所以，这就是探索了？ 你好奇那里有什么吗？既然你读完了文章，希望你也会好奇作者还能整出什么新活吧。我本来应该在里面放置一些有趣的东西来满足你的好奇心，不过考虑到时间有限，就只能放个普通的彩蛋了。 /* 隐藏草书 */ .hidden-fancy-text { font-family: 'Brush Script MT', cursive; font-size: 20px; /* text-align: center; */ margin: 20px 0; /* padding: 20px; */ line-height: 1.5; color: transparent; cursor: default } .hidden-fancy-text::selection { color: darkred; background: white; } 如果作者在认真做游戏的话，我们也应该会见面的。","categories":[{"name":"游戏设计","slug":"游戏设计","permalink":"http://rinevard.github.io/categories/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/"},{"name":"体验","slug":"游戏设计/体验","permalink":"http://rinevard.github.io/categories/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E4%BD%93%E9%AA%8C/"}],"tags":[]},{"title":"建站过程","slug":"about-blog/建站过程","date":"2025-02-06T02:34:53.000Z","updated":"2025-02-06T05:01:57.758Z","comments":true,"path":"wiki/about-blog/建站过程/","permalink":"http://rinevard.github.io/wiki/about-blog/%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B/","excerpt":"","text":"本站成功搭建的最大功臣是 Claude-3.5-sonnet，在这类复杂但并不困难的任务上，和 AI 合作真是再合适不过了。本文简要复盘一下整个网站的搭建过程，顺便提醒一下未来的自己一些 Hexo 的基本操作。 网站搭建写完 2024 年度总结之后，就有了重新搭建博客的想法。随便翻了翻几个同学的博客，感觉挺不错的，于是决定去问 Claude 怎么搭博客。这次肯定不会像第一次建站一样随便挑个主题就用上去，也不会像（这次之前的）最后一次建站一样从头开始自己写。认真找找合适的主题，然后用上就好了。 我的主要诉求是：写作方便、用树状结构收纳文章，小克推荐了 Hexo 的 NexT.Pisces 和 Wikitten 两个主题以及 VitePress。由于有 Hexo 的使用经验，就选了 Hexo。由于一时半会没找到 NexT.Pisces 是什么，就用了 Wikitten. 写得我都困了，我们的建站过程没有什么奇幻色彩吗？ 有的有的，今天早上断网了，把路由器复位了一下才重新开始建站。 选好了方案之后，就可以按部就班地和 Claude 一起建站了。不懂的就去问 Claude，它都懂的。 基本操作最常用的三件套： 123hexo clean # 清理缓存，似乎在修改了配置文件以后可以用一用hexo g # g 是 generate 的缩写。生成静态文件hexo s # s 是 server 的缩写。服务器，启动！ 增删文章、文件夹设置、部署到 GitHub page： 删除文章 直接删除 source/_posts 目录下的对应 .md 文件即可 新增文章 1hexo new post &quot;我是一只鲤鱼。我是一只鲤鱼吗？我觉得我是。&quot; 这会生成一个标题为”我是一只鲤鱼。我是一只鲤鱼吗？我觉得我是。”的文章。 设置多层文件夹 在文章头部这样写： 123456---title: 睡觉入门到精通categories: - 生活 - 睡觉技巧--- 生成和部署 123hexo cleanhexo generatehexo deploy 如果是新建的站，部署前要修改配置文件的 deploy 部分哦，修改过一次以后就不用再改了。不懂问 Claude。 可以在根目录的 _config.yml 和的 themes 的 _config.yml 里调整配置文件。 （可能的）后续改进我比较关心的改进是侧边栏收缩来全屏浏览笔记、配色调整。","categories":[{"name":"关于本站","slug":"关于本站","permalink":"http://rinevard.github.io/categories/%E5%85%B3%E4%BA%8E%E6%9C%AC%E7%AB%99/"}],"tags":[]},{"title":"欢迎！","slug":"欢迎！","date":"2025-02-06T02:25:53.000Z","updated":"2025-02-06T13:41:24.805Z","comments":true,"path":"wiki/欢迎！/","permalink":"http://rinevard.github.io/wiki/%E6%AC%A2%E8%BF%8E%EF%BC%81/","excerpt":"","text":"这是一篇欢迎文章，欢迎来到我的网站！ 网站好像不是很漂亮？我承诺会改改的！让我先为你介绍一下网站的基本布局。 如你所见，左边是网站的文章列表，以文件夹的形式排布；左上方是几个按钮，“关于”是我的自我介绍，“历史”记录了文章的诞生时间线，如果迷路了，点击“首页”或者左上角的“Rinevard”就能回到这里了。在很多博客里，文章的诞生时间线被叫做“归档”，不过我觉得这个名字并不清晰，于是改成了“历史”。 本网站使用了 Hexo 的 Wikitten 主题，在我看来，其最大优点是以文件夹的形式排布文章。博客的文章应当成体系且便于检索，而非一篇一篇堆积在网站上，构成凌乱的山。这一功能值得放在最高优先级，因此外表稍微简陋一点也无所谓了。 我应该主要会在这里放一些杂谈和游戏相关的文章，欢迎来看！","categories":[],"tags":[]}],"categories":[{"name":"gamejam","slug":"gamejam","permalink":"http://rinevard.github.io/categories/gamejam/"},{"name":"学习","slug":"学习","permalink":"http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"公开课","slug":"学习/公开课","permalink":"http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"CMU-15-213","slug":"学习/公开课/CMU-15-213","permalink":"http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/"},{"name":"Notes","slug":"学习/公开课/CMU-15-213/Notes","permalink":"http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/Notes/"},{"name":"Labs","slug":"学习/公开课/CMU-15-213/Labs","permalink":"http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/Labs/"},{"name":"杂谈","slug":"杂谈","permalink":"http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/"},{"name":"碎碎念","slug":"杂谈/碎碎念","permalink":"http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"},{"name":"游戏设计","slug":"游戏设计","permalink":"http://rinevard.github.io/categories/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/"},{"name":"技巧","slug":"游戏设计/技巧","permalink":"http://rinevard.github.io/categories/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E6%8A%80%E5%B7%A7/"},{"name":"二次元","slug":"杂谈/二次元","permalink":"http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/%E4%BA%8C%E6%AC%A1%E5%85%83/"},{"name":"体验","slug":"游戏设计/体验","permalink":"http://rinevard.github.io/categories/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E4%BD%93%E9%AA%8C/"},{"name":"关于本站","slug":"关于本站","permalink":"http://rinevard.github.io/categories/%E5%85%B3%E4%BA%8E%E6%9C%AC%E7%AB%99/"}],"tags":[]}