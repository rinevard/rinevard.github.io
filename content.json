{"meta":{"title":"Rinevard","subtitle":"","description":"","author":"Rinevard","url":"http://rinevard.github.io","root":"/"},"pages":[{"title":"Tags","date":"2025-02-06T02:37:47.887Z","updated":"2025-02-06T02:37:47.887Z","comments":true,"path":"tags/index.html","permalink":"http://rinevard.github.io/tags/index.html","excerpt":"","text":"这里什么也没有哦~文件夹已经很方便了，为什么还要用标签呢？"},{"title":"About","date":"2025-02-07T13:52:21.292Z","updated":"2025-02-07T13:52:21.292Z","comments":true,"path":"about/index.html","permalink":"http://rinevard.github.io/about/index.html","excerpt":"","text":"这里是 Rinevard. 喜欢独立游戏之类的新鲜事物。我应该主要会在站里放一些杂谈和游戏相关的文章，欢迎来看！ 偶尔会出现的爱好是取名，我还用过 Lyraine、鲤鱼、江知鹤（读起来和 rinevard 蛮像的）之类的名字。 如果想和我联系，欢迎发邮件到 rinevard@outlook.com！（不过不一定会看） 我的 Github 账号: Rinevard"},{"title":"探索的奖励","date":"2025-02-11T02:04:52.000Z","updated":"2025-02-14T07:33:52.506Z","comments":true,"path":"secret/index.html","permalink":"http://rinevard.github.io/secret/index.html","excerpt":"","text":"/* 隐藏文本相关样式 */ .secret-text::selection { color: white; background: black; } .secret-text { background: transparent; cursor: default; /* 鼠标样式保持默认 */ } #output { white-space: pre; font-family: monospace; font-size: 12px; line-height: 12px; letter-spacing: unset; transform: unset; overflow-y: hidden; background: transparent; cursor: default; /* 鼠标样式保持默认 */ } /* 草书效果相关样式 */ .cursive-text { font-family: 'Brush Script MT', cursive; font-size: 20px; color: darkred; /* text-align: center; */ margin: 20px 0; /* padding: 20px; */ line-height: 1.5; cursor: default; } /* 草书效果相关样式 */ .center-cursive-text { font-family: 'Brush Script MT', cursive; font-size: 20px; color: darkred; text-align: center; margin: 20px 0; /* padding: 20px; */ line-height: 1.5; cursor: default; } /* 隐藏草书 */ .hidden-fancy-text { font-family: 'Brush Script MT', cursive; font-size: 22px; /* text-align: center; */ margin: 20px 0; /* padding: 20px; */ line-height: 1.5; color: transparent; cursor: default; } .hidden-fancy-text::selection { color: darkred; background: white; } /* 人迹罕至的路 */ .paths-container { display: flex; justify-content: center; margin: 20px 0; font-family: 'Brush Script MT', cursive; font-size: 20px; } /* 修改链接样式 */ .paths-container a.path { padding: 15px; text-decoration: none !important; border: none; /* 移除可能的边框 */ background: none; /* 移除可能的背景 */ } /* 有人的路径样式 */ .paths-container a.path-visible { color: #5a3921 !important; /* 使用 !important 来确保优先级 */ } /* 隐藏的路径样式 */ .paths-container a.path-hidden { color: transparent !important; /* 使用 !important 来确保优先级 */ } /* 悬停效果 */ .paths-container a.path-hidden:hover { color: #5a3921 !important; transition: color 0.3s ease; } /* visited状态 */ .paths-container a.path-visible:visited { color: #5a3921 !important; } .paths-container a.path-hidden:visited { color: transparent !important; } .paths-container a.path-hidden:hover:visited { color: #5a3921 !important; } 对不起骗了大家这么久，其实我是一条鲤鱼。 ..-*=. ......:::....... .:=*****:. ..:=++*++=---------=++**+=:.. .:+********-. ...+*+:.. ..:=*+:.-***************-. ..:-*+.. .=***************: .:=+*=**: .:***************+. ..-=- +*: .:****************: ..:+ +*: .:****************- .+* ** +*: .:****************- .-** +*: .:****************: +...+ +*: .:****************. :.:=****-. .:***************- ..:-++-.. ..-++-*************=. ..:=**+=:..... .....:-+**+:....-**********=.. ...:-===++++++==-:... .-*******=. ..=***+. ..-*:. 嗯，实在是太敷衍了，所以我稍微加了点东西。 祝你好运，也祝你玩得开心。 黄昏的树林里分出两条路， 所幸在此我能同时去涉足 人来人往的路 人迹罕至的路 或许哪天还会再来看看这里的变化？启程了，再见啦。"},{"title":"人迹罕至的路","date":"2025-02-14T06:12:25.238Z","updated":"2025-02-14T06:12:25.238Z","comments":true,"path":"secret/jurora-path.html","permalink":"http://rinevard.github.io/secret/jurora-path.html","excerpt":"","text":"/* 草书效果相关样式 */ .center-cursive-text { font-family: 'Brush Script MT', cursive; font-size: 24px; color: darkred; text-align: center; margin: 20px 0; /* padding: 20px; */ line-height: 1.5; cursor: default; } /* 隐藏草书 */ .hidden-fancy-text { font-family: 'Brush Script MT', cursive; font-size: 24px; text-align: center; margin: 20px 0; /* padding: 20px; */ line-height: 1.5; color: transparent; } .hidden-fancy-text::selection { color: darkred; background: white; } /* 人迹罕至的路 */ .secret-message { color: transparent; cursor: default; font-family: 'Brush Script MT', cursive; /* 使用草书字体 */ font-size: 24px; text-align: center; margin: 20px 0; line-height: 1.5; } .secret-message:hover { color: darkred; transition: color 0.5s ease; /* 稍微延长过渡时间 */ } 一片树林里分出两条路—— 而我选择了人迹更少的一条， &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 从此决定了我一生的道路。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"},{"title":"人来人往的路","date":"2025-02-14T06:44:57.617Z","updated":"2025-02-14T06:44:57.617Z","comments":true,"path":"secret/many-people-path.html","permalink":"http://rinevard.github.io/secret/many-people-path.html","excerpt":"","text":"/* 草书效果相关样式 */ .center-cursive-text { font-family: 'Brush Script MT', cursive; font-size: 24px; color: black; text-align: center; margin: 20px 0; line-height: 1.5; cursor: default; } /* 重叠文字效果 */ .text-overlay-container { position: relative; height: 100px; margin: 20px 0; } .overlapping-text { position: absolute; width: 100%; font-family: 'Brush Script MT', cursive; font-size: 24px; text-align: center; color: black; opacity: 0.15; cursor: default; } /* 为每行文字设置不同的位置和透明度 */ .text-1 { top: 0; opacity: 0.8; } .text-2 { top: 12px; opacity: 0.6; } .text-3 { top: 24px; opacity: 0.4; } .text-4 { top: 36px; opacity: 0.2; } .text-5 { top: 48px; opacity: 0.1; } .text-6 { top: 60px; color: transparent; } 一片树林里分出两条路—— 而我选择了人来人往的一条， 只看到了六道印迹。 脚印 脚印 脚印 脚印 脚印 脚印"},{"title":"Categories","date":"2025-02-06T02:38:03.136Z","updated":"2025-02-06T02:38:03.136Z","comments":true,"path":"categories/index.html","permalink":"http://rinevard.github.io/categories/index.html","excerpt":"","text":"这里什么也没有哦~文件夹已经很方便了，为什么还要用分类呢？"}],"posts":[{"title":"第二章——计算机内的信息表示","slug":"learning/open-course/CMU-15-213/Notes/Chapter2-data-representation","date":"2025-03-25T10:36:28.000Z","updated":"2025-03-05T11:02:56.578Z","comments":true,"path":"wiki/learning/open-course/CMU-15-213/Notes/Chapter2-data-representation/","permalink":"http://rinevard.github.io/wiki/learning/open-course/CMU-15-213/Notes/Chapter2-data-representation/","excerpt":"","text":"我们知道，在32位机器上和64位机器上，相同的C语言数据类型可能占用不同的字节数： C declaration Bytes Signed Unsigned 32-bit 64-bit [signed] char unsigned char 1 1 short unsigned short 2 2 int unsigned 4 4 long unsigned long 4 8 int32_t uint32_t 4 4 int64_t uint64_t 8 8 char * 4 8 float 4 4 double 8 8 整数表示这里真的有什么值得记笔记的吗？总之整数的表示可以分为unsigned和signed，前者只能表示非负数，后者可以表示整数。下面是各个整数类型占用的字节数： C declaration Bytes Signed Unsigned 32-bit 64-bit short unsigned short 2 2 int unsigned 4 4 long unsigned long 4 8 众所周知，signed的表示采用补码表示，就是模 $2^m$ 意义下对应的最小正数的二进制表示，其中 $m$ 是耗费的 bits 数。听起来有点抽象？这是写给自己看的笔记，我不觉得自己应该忘掉这个！ 不过考虑到失忆的可能，我还是再讲解一下。 下面的例子中类型是signed short，$15213$ 的表示就是它的二进制表示，而 $-15213$ 的表示实际上是 $-15213 + 2^{16}$ 的二进制表示。 Decimal Hex Binary x 15213 3B 6D 00111011 01101101 y -15213 C4 93 11000100 10010011 让我们假设二进制表示为 $b_{w-1},b_{w-2},…,b_1,b_0$，那么如果是unsigned，其值为 $$\\sum_{k&#x3D;0}^{w-1}2^{k}b_k$$ 如果是signed，当 $b_{w-1}$ 即最高位不为 1 时，把二进制转换成十进制即可。 当最高位为 1 时，其值为 $$-2^{w}+\\sum_{k&#x3D;0}^{w-1}2^{k}b_k$$ 不难注意到能表示的整数有上下限，参考下表： Signed Unsigned 64-bit short [-32768, 32767] unsigned short [0, 65535] 2 int [-2^31, 2^31-1] unsigned int [0, 2^32-1] 4 long [-2^63, 2^63-1] unsigned long [0, 2^64-1] 8 加法，乘法，左右移加法和乘法就是模意义下的加法和乘法，所以你喜欢的运算规律都符合。“溢出”也只是模了一下。 而左右移呢？左移不难理解，把它的表示统一往左边移动，移出范围了就扔掉，最低位填充0. x &lt;&lt; m 实际上是在做 $2^{m}x(\\text{mod $2^w$})$. 右移则分为逻辑右移和算术右移，前者是在右移后在最高位上填充0，后者在最高位上填充符号位。 对unsigned来说它们没有区别，毕竟unsigned不考虑符号，但对signed来说就不一样了。 大多数C编译器对有符号整数实现的是算术右移，x &gt;&gt; m 实际上是在做 $\\lfloor \\frac{x}{2^m} \\rfloor$. 不同类型的整数一起运算会发生什么？核心思想是，在尽量保证值不变的前提下把数进行扩展。 把一个signed short整数和signed int相加会发生什么呢？我们会进行“符号扩展”，把signed short扩展成signed int再做加法，返回一个signed int。 那，什么是符号扩展呢？如果short值是正数，高位会用0填充；如果是负数，高位会用1填充（符号扩展）。uh actually 🤓☝️这是在保证值不变的前提下把short转换成int。 把一个unsigned int整数和signed long相加会发生什么呢？我们会把unsigned int扩展为 signed long（即在前面加0）再做加法，返回一个signed long。 当然，也有不能保证值不变的情况。比如unsigned int和signed int相加时，我们会把signed转换成unsigned再求和。 所以说，拜托不要写这种奇怪的代码： 12345678signed int a = -1;unsigned int b = 1;if (a &lt; b) &#123; printf(&quot;a &lt; b\\n&quot;);&#125; else &#123; printf(&quot;a &gt;= b\\n&quot;);&#125; 上面的代码会输出 $a\\geq b$，你这是在破坏数学的世界观！ 注意事项unsigned很可能造成错误。对下面的代码，你觉得哪个是对的？ 123unsigned i; for (i = cnt-2; i &lt; cnt; i--) a[i] += a[i+1] 123unsigned i; for (i = cnt-2; i &gt;= 0; i--) a[i] += a[i+1] 答案是前者，因为对后者来说，i = 0 以后 i-- 会让 i 溢出变为正数，导致无限循环。不过能不能过编译我不确定，我这里是能过的。 反正不要写这样的代码，你这是在破坏数学的世界观！ 浮点数表示按照 IEEE 标准，浮点数的表示如下： 其中 s 是符号位，0表示正数，1表示负数 计算方式大致为 $$(-1)^s \\times 2^{\\text{exp}-\\text{bias}}\\times(1\\text{.frac})$$ 之所以说是“大致”，是因为还存在几种特殊情况。 如果 exp 全是 0，我们称其为非规格化数（denormalized），使用下面的公式计算： $$(-1)^s \\times 2^{1-\\text{bias}}\\times(1\\text{.frac})$$ 如果 exp 全是 1，frac全是0，我们认为表示的是infin. 至于是 $+\\inf$ 还是 $-\\inf$ 由符号位决定。 如果 exp 全是 1，frac不为0，表示NaN（not a number）. 看起来确实是很奇怪的标准！这涌现出的结果是，能表示的值在靠近 0 的位置比较密集，在远离 0 的位置比较稀疏。（下图以 exp 占 3 bits，frac占 2 bits为例） 舍入（四舍五入）既然浮点数的表示这么奇怪，那如果我把两个浮点数相加，是不是可能得到不精确的结果？真聪明，确实如此！我们一般采取“round-to-even”的策略，即先考虑舍入到更近的那个数，如果两个数一样近，把得到的结果向着更“偶数”的方向去舍入，对二进制表示来说，就是希望它被舍入到结尾为0的那个数上. 来个例子： 10.000112 10.002 (&lt;1&#x2F;2—down)10.001102 10.012 (&gt;1&#x2F;2—up)10.111002 11.002 ( 1&#x2F;2—up)10.101002 10.102 ( 1&#x2F;2—down) 主要好处是减少统计偏差。如果我们采取round up，在统计时统计出的值可能偏高；如果选择round down，统计出的值可能偏低。 加法，乘法浮点数的加法和乘法性质并不良好，我直接把课件复制过来吧： 浮点数加法： 封闭性：是 但可能生成无穷大(infinity)或非数值(NaN) 交换律：是 a + b &#x3D; b + a 结合律：否 由于溢出和舍入的不精确性 例如：(3.14+1e10)-1e10 &#x3D; 0，而3.14+(1e10-1e10) &#x3D; 3.14 零元素：是 0是加法单位元 逆元素：几乎是 除了无穷大和NaN外，每个元素都有加法逆元 单调性：几乎是 a ≥ b ⇒ a+c ≥ b+c 但对无穷大和NaN例外 浮点数乘法： 封闭性：是 但可能生成无穷大或NaN 乘法交换律：是 a × b &#x3D; b × a 乘法结合律：否 由于溢出和舍入的不精确性 例如：(1e20×1e20)×1e-20 &#x3D; inf，而1e20×(1e20×1e-20) &#x3D; 1e20 单位元：是 1是乘法单位元 分配律：否 由于溢出和舍入的不精确性 例如：1e20×(1e20-1e20) &#x3D; 0.0，而1e20×1e20 - 1e20×1e20 &#x3D; NaN 单调性：几乎是 a ≥ b 且 c ≥ 0 ⇒ a×c ≥ b×c 但对无穷大和NaN例外 类型转换double&#x2F;float → int：对浮点数（无论是单精度还是双精度）来说，把它们转换成int相当于 rounding toward zero，即舍去小数后面的部分。我觉得这应该主要是实现起来方便，我们在datalab里实现了这种转换。如果转换后超出了int的可表示范围，这种转换行为未定义（一般会设为TMin，type minimum，能表示的最小值）。 int → float：根据rounding mode进行四舍五入，毕竟存在一些float不能表示的int值。 int → double：精确转换，毕竟double的frac有52个bits，能够表示所有可能的int值。 杂项大端法和小端法多字节对象在内部存储的字节顺序表示上也有大端法和小端法之分，即最高有效字节在前面还是后面。比如把十六进制的0x01234567存储为01 23 45 67还是67 45 23 01。 我们可以用下面的代码检查自己的机器使用的是大端法还是小端法。 123456789101112131415161718#include &lt;stdio.h&gt;int is_little_endian() &#123; unsigned int x = 1; // 将整数的地址转换为字符指针，访问其第一个字节 char *c = (char*) &amp;x; // 如果第一个字节是1，则为小端；如果是0，则为大端 return *c;&#125;int main() &#123; if (is_little_endian()) &#123; printf(&quot;系统是小端(Little Endian)\\n&quot;); &#125; else &#123; printf(&quot;系统是大端(Big Endian)\\n&quot;); &#125; return 0;&#125;","categories":[{"name":"学习","slug":"学习","permalink":"http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"公开课","slug":"学习/公开课","permalink":"http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"CMU-15-213","slug":"学习/公开课/CMU-15-213","permalink":"http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/"},{"name":"Notes","slug":"学习/公开课/CMU-15-213/Notes","permalink":"http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/Notes/"}],"tags":[]},{"title":"这里有什么？","slug":"learning/这是哪里","date":"2025-03-02T06:28:38.000Z","updated":"2025-03-05T11:04:37.397Z","comments":true,"path":"wiki/learning/这是哪里/","permalink":"http://rinevard.github.io/wiki/learning/%E8%BF%99%E6%98%AF%E5%93%AA%E9%87%8C/","excerpt":"","text":"本来只打算在博客里写杂谈和游戏设计相关文章的，不过想想看把学习笔记在这里记一记似乎也不错。那这里就是学习记录了，主要是写给未来的自己用的。🫠 应该只有朋友们（cyber friends）会看到这个网站，所以记录一下也是在表明我还在认真学习，没有进入摸鱼态。读者也别忘了终身学习。 更新（2025.3.5），今天试着加了篇笔记上来，但似乎浏览效果很一般，总之就把这些笔记当作我在学习的证明吧！","categories":[{"name":"学习","slug":"学习","permalink":"http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"Bomblab感想","slug":"learning/open-course/CMU-15-213/Labs/Bomblab","date":"2025-03-02T06:28:38.000Z","updated":"2025-03-05T10:57:21.211Z","comments":true,"path":"wiki/learning/open-course/CMU-15-213/Labs/Bomblab/","permalink":"http://rinevard.github.io/wiki/learning/open-course/CMU-15-213/Labs/Bomblab/","excerpt":"","text":"写在前面bomblab 比起 datalab 更友好一些，除了考察对汇编代码的理解以外，也在锻炼我们的 gdb 调试技能。用时共计 2+2+0.8+0.5+1.5+4 &#x3D; 10.8h，比 datalab 用时略少一点。刚开始拆弹的时候是很兴奋的，做到后面倒是感觉有点无聊了，我感觉 attacklab 可能更有趣一些（虽然我还没做）。 拆弹记录首先肯定要对 bomb 进行反汇编，我是用 objdump 来反汇编，并把结果保存到了 txt 文件中。拿到汇编以后随便翻翻找到 phase 们，之后就进入拆弹阶段了。 第一个炸弹phase_1 简单易懂，只是判断输入是否与某个字符串相等。我一开始以为字符串就是“0x402400”，后面才想到这是那个字符串的地址。用 gdb 设置断点即可得知字符串。（别看我说得那么轻松，也是折腾了两小时多，毕竟完全没有 gdb 经验 🫠） 第二个炸弹这也是一个不难的炸弹，把汇编代码往下读就能解决，喜欢的话可以加点注释帮助自己理解。不过我仍然做了两个小时，主要在疑惑 read_six_numbers 后数字被读到了哪里。还有个有趣的犯蠢的地方，我一开始把 400f35 处的 0x18 当成了十进制 18，疑惑了很久 4n 怎么可能等于 18，后面猛然惊醒发现那是十六进制。🤣 在这里我用到了这些新指令： 12345si # 单步执行x/10xw $sp # 查看栈指针(sp)处的10个字(word)，以十六进制(x)显示x/10i $pc # 查看当前位置之后的10条指令i registers eax # 查看寄存器值 第三个炸弹用时 50 分钟（有进步！），这次有了更系统的拆弹方法——先把代码分段，然后分析代码提出若干个猜测和问题，随着解答问题就逐渐做掉了。🫠我们可以轻松注意到输入的数字不能少于一个，再往下读就会 400f75 这一行，算一算就会很自然地猜测：输入要求我们选一个选项，跳过去然后 cmp。 这里是我拆弹时提出的问题以及解答： 输入按怎样的格式存储起来？存储在哪里？分析栈后发现，看起来是读取了两个数字，存储在栈中 400f6a 那行是怎么比较的？0x8(%rsp)是什么，输入值吗？猜测这是要求输入的选项值只能在 0-7 之间？设一个断点就能回答这个问题了。 400f75 跳到了哪里？是根据选项跳跃吗？根据选项跳跃 从选项跳到了 400fbe 后，0xc(%rsp)是定值还是会根据输入变化？0xc(%rsp)是输入的第二个值。由于 8 对齐，我们需要用 0xc(%rsp)而非 0x10(%rsp)来得到第二个值。 第四个炸弹用时半小时，我连 func4 都不想读，直接用 gdb 来执行 func4，找到返回 0 的输入就行了。这种解法感觉有逃课的嫌疑，不过你就说快不快吧！在这里我用到了这个新指令： 12(gdb) call (int)func4(11, 0, 14) 第五个炸弹用时 1.5h，做到这里，我比起刚开始时已经对汇编代码熟悉不少了。首先把代码分成若干个小部分，然后猜测并验证每个部分的功能就能解决这个炸弹。比较有趣的地方是这里加入了一个金丝雀，我还疑惑了一阵子这是什么，后来才想到这是书上讲的金丝雀。 第六个炸弹用时 4h，对这个炸弹，我感觉“根据运行时的状况猜代码的作用”比“分析代码”更加重要。一开始同样是把代码分成多个小局部，然后分段猜作用。这里引入了链表，还挺有趣。 彩蛋？什么彩弹？","categories":[{"name":"学习","slug":"学习","permalink":"http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"公开课","slug":"学习/公开课","permalink":"http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"CMU-15-213","slug":"学习/公开课/CMU-15-213","permalink":"http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/"},{"name":"Labs","slug":"学习/公开课/CMU-15-213/Labs","permalink":"http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/Labs/"}],"tags":[]},{"title":"Datalab解析","slug":"learning/open-course/CMU-15-213/Labs/Datalab","date":"2025-02-21T12:14:28.000Z","updated":"2025-03-05T10:57:17.451Z","comments":true,"path":"wiki/learning/open-course/CMU-15-213/Labs/Datalab/","permalink":"http://rinevard.github.io/wiki/learning/open-course/CMU-15-213/Labs/Datalab/","excerpt":"","text":"写在前面Datalab 的难度很高。它的难度主要体现在技巧性上，这在整数部分尤其明显。整数部分至少有一半题目我花了一小时以上才做出来，相较而言，浮点数的题目虽然分类讨论起来更麻烦，但更为平易近人，每道我花了四十分钟左右。 如果有某道题做不出来，不建议一直死磕。我们可以换一道题或是离开屏幕散散心，我相信这会有帮助。 做完以后，感觉自己已经是位运算领域大神了！ 整数部分整数部分的技巧性很强，不建议在某道题上死磕，做不出来就换一道，以后再来。 bitXor本题要求用 ‘~’ 和 ‘&amp;’ 实现 ‘^’，简单列个关于 ‘^’ 的真值表： x y x^y 0 0 0 0 1 1 1 0 1 1 1 0 关注 x^y 为 1 时 x 和 y 的取值，可以发现 x^y &#x3D;&#x3D; ((x) &amp; y) | (x &amp; (y))，再用德摩根律把 ‘|’ 换成 ‘~’ 和 ‘&amp;’ 即可。 1234567891011121314/* * bitXor - x^y using only ~ and &amp; * Example: bitXor(4, 5) = 1 * Legal ops: ~ &amp; * Max ops: 14 * Rating: 1 */int bitXor(int x, int y)&#123; /* x Xor y = (~x &amp; y) | (x &amp; ~y) a | b = ~(~a &amp; ~b) */ return ~(~(x &amp; ~y) &amp; ~(~x &amp; y));&#125; tmin这是熟知的结论，tmin &#x3D; $-2^{31}$ &#x3D; 1 &lt;&lt; 31 1234567891011/* * tmin - return minimum two&#x27;s complement integer * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 4 * Rating: 1 */int tmin(void)&#123; /* use left shift to compute tmin */ return 1 &lt;&lt; 31;&#125; isTmax这种“判断 x 是否等于 y”的题目的做法有很多种： 创建一个 y，把 x 和 y 相减（x - y &#x3D;&#x3D; x + ((~y) + 1)），然后判断结果是否为 0. 创建一个 y，return !(x^y) 我这里是直接构建了 -Tmax &#x3D; 100…01，然后检查 x-Tmax 是否为 0. 12345678910111213// 2/* * isTmax - returns 1 if x is the maximum, two&#x27;s complement number, * and 0 otherwise * Legal ops: ! ~ &amp; ^ | + * Max ops: 10 * Rating: 1 */int isTmax(int x)&#123; /* create a &#x27;0&#x27; and use &#x27;!&#x27; */ return !(x + 1 + (1 &lt;&lt; 31));&#125; allOddBits这道题我想了很久。后来根据尝试性地构造了 1010…1010，然后试出了 (x &amp; mask) ^ mask 的写法。大致的思路是，既然我们只在乎奇数位的值，就先用 &amp; 把偶数位的值去掉，后来惊奇地发现再做个 ‘^’ 和 ‘!’ 就能得到结果了。 123456789101112131415/* * allOddBits - return 1 if all odd-numbered bits in word set to 1 * where bits are numbered from 0 (least significant) to 31 (most significant) * Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 12 * Rating: 2 */int allOddBits(int x)&#123; /* (x^y) == 0 &lt;=&gt; x == y */ int y = 0xAA; // 0xAA 就是二进制的 1010 1010 int mask = y + (y &lt;&lt; 8) + (y &lt;&lt; 16) + (y &lt;&lt; 24); return !((x &amp; mask) ^ mask);&#125; negate这是熟知的结果，本质是 $x + \\sim x + 1 \\equiv 0(\\text{mod $2^{32}$})$ 123456789101112/* * negate - return -x * Example: negate(1) = -1. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 5 * Rating: 2 */int negate(int x)&#123; /* well known result */ return ~x + 1;&#125; isAsciiDigit这道题我想了很久。后来分析了输入的形式，发现它只能形如 0000 … 0011 0yyy 或是 0000 … 0011 100y，于是决定把自由的位置右移掉，然后用 mask。 做完后复盘发现还有一种基于比较的方法，直接计算 x - 0x30 和 x - 0x39 并判断其符号位。 12345678910111213141516171819202122/* * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters &#x27;0&#x27; to &#x27;9&#x27;) * Example: isAsciiDigit(0x35) = 1. * isAsciiDigit(0x3a) = 0. * isAsciiDigit(0x05) = 0. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 15 * Rating: 3 */int isAsciiDigit(int x)&#123; /* x 只能形如下面两种形式： * 1. 0000 ... 0011 0yyy * 2. 0000 ... 0011 100y * 这里的 y 可以是 0 或 1 * 我们用右移去掉未知的 y, 然后用 mask即可 * 构造两个 mask, 一个是 0000 ... 0000 0110, 另一个是 0000 ... 0001 1100 */ int mask1 = 0x06; int mask2 = 0x1C; return !((x &gt;&gt; 3) ^ mask1) | !((x &gt;&gt; 1) ^ mask2);&#125; conditional这道题我也想了好久。一开始为了方便，我先用 !!x 把 x 归到了 0 或 1. 之后的思路是想构造满足类似 f(0, y) &#x3D; 0，f(1, y) &#x3D; y 的条件的函数 f，然后返回 f(x, y) + f(!x, z). 稍加思考，便发现 ‘&amp;’ 和这里的 f 很像，于是就写下去了。 123456789101112131415161718/* * conditional - same as x ? y : z * Example: conditional(2,4,5) = 4 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 16 * Rating: 3 */int conditional(int x, int y, int z)&#123; /* 为了方便, 先限制 x 只取 0 或 1 * 我们一开始的思路是找到函数满足 f(x, b) = b if x == 1, 0 if x == 0 * 然后用 f(x, y) + f(!x, z) 即可得到结果 * 中途发现 11...1 &amp; b = b, 0 &amp; b = 0, 和我们希望的结果很像 * 于是就这么写了 */ int mask = (~(!x)) + 1; // x为0时得到全1，x非0时得到0 return ((~mask) &amp; y) + (mask &amp; z);&#125; isLessOrEqual好吧，这道题我还是想了很久，毕竟我在做之前对位运算几乎一无所知。这道题更多是分类讨论，分为 xy 同号和 xy 异号的两种情况就行，连溢出都不会有。 12345678910111213141516171819202122/* * isLessOrEqual - if x &lt;= y then return 1, else return 0 * Example: isLessOrEqual(4,5) = 1. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 24 * Rating: 3 */int isLessOrEqual(int x, int y)&#123; /* 若xy同号(最高位相同), return 1 if y - x &gt;= 0 else 0 * 若xy异号, return 1 if y的二进制表示最高位为0 else 0 */ int signX = x &gt;&gt; 31; int signY = y &gt;&gt; 31; int diffSign = (signX &amp; !signY); // (异号且 y &gt;= 0, x &lt; 0) ? 1 : 0 int diff = y + (~x + 1); // y - x int sameSign = (!(signX ^ signY)) &amp; ((diff &gt;&gt; 31) + 1); // (同号且 y - x &gt;= 0) ? 1 : 0 return diffSign | sameSign;&#125; logicalNeg这道题是我感觉第二难的题目，我的核心思路是“非 0 的 x 的二进制表示中至少有一个 1”，于是我就构造了 11…1 即 -1 这个特殊值，并期盼它能给我一些有趣的结果。 对正数 x 来说，x + (-1) 的最高位必然是 0，这能把正数和 0 区分开来，因为 0 + (-1) 的最高位是 1. 但负数怎么办呢？负数要分类讨论，很麻烦。于是我就想取输入值的绝对值，然后用 abs + (-1) 来区分非 0 值和 0. 我这里的代码采用的是类似的思路，不过当时没想到怎么求 abs，就写得更复杂了一些。 后来复盘时发现非 0 值 x 一定满足 (x | (~x)) 的最高位为 1，用这个方法更简单。 12345678910111213141516171819202122232425262728/* * logicalNeg - implement the ! operator, using all of * the legal operators except ! * Examples: logicalNeg(3) = 0, logicalNeg(0) = 1 * Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 12 * Rating: 4 */int logicalNeg(int x)&#123; /* * 先思考怎么表示 &#x27;x非0&#x27;, 注意到 x非0 &lt;=&gt; x的二进制表示中至少有一个1 * 考虑用 -1(它的二进制表示全是1) + x 来得到一些中间量 * 接下来分类讨论, 如果 x为0, 则 -1 + x = -1, * 如果 x为正数, -1 + x 的二进制表示以 0 开头 * 如果 x为负数, 要分类讨论 Tmin的情况, 处理起来不方便 * 至此, 正数和 0 就能通过 (-1 + x) &gt;&gt; 31 区分开来了, 正数得到 0, 0 得到 -1 * 接下来把负数整合进来 * 考虑到负数的负是正数, 我们自然就会考虑把负数转化成正数，再用 | 或者 &amp; 来连接 * ((((~0) + x) &gt;&gt; 31)) &amp; ((((~0) + negtivex) &gt;&gt; 31)) 就能把正数和负数都变成0, 0变成 -1 * 再 &amp; 1 就能得到 !x 了 * 代码里又进一步简化了一下结果, 不过核心思路还是&quot;把负数和正数统一起来&quot; * 这里的 (((~0) + x) &amp; ((~0) + negtivex)) 把 &amp; 提前到了移位前, * 直接 &amp; 了二进制表示的最高位(之前的先 &gt;&gt; 再 &amp; 是 &amp; 了二进制表示的最低位) */ int negtivex = (~x) + 1; return ((((((~0) + x) &amp; ((~0) + negtivex)) &gt;&gt; 31)) &amp; 1);&#125; howManyBits这道题是我感觉最难的题目。首先我们画出这个函数的图像（留给读者作为练习），会发现它关于 -0.5 对称，这表明 x 和 -x-1 耗费的位数相同，接下来我们就只要考虑非负数就行了。 找到非负数的最小 bits 数倒是不难，稍微写几个非负数就能发现，只要找到它值为 1 的最高位数，设其为 k，k + 1 即为结果。 之后的难点就是，如何找到这个非负数的“值为 1 的最高位数”了。线性搜索显然是可行的，我们可以用 $\\sum_{m&#x3D;0}^{31}!!(x &gt;&gt; m)$ 来得到这个位数，然而这样做耗费的操作数超出了限制。既然线性耗费的操作数太多，那我们自然就会想到二分。 但怎么做二分呢？这里的代码更多是我试出来的，没有什么清晰的理论指导，我们直接看图吧。 怎么做到“砍掉一半”呢？砍掉右边半段用右移就行，所以我们会从 x &gt;&gt; 16 开始，再用 !!(x &gt;&gt; 16) 是 0 还是 1 来判断 1 在右半边还是左半边。 之后的代码就真的纯粹是试出来的了，我们肯定能在数学上解释我们的操作，但具体的构思纯粹是试错+直觉试出来的，没什么好说的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/* howManyBits - return the minimum number of bits required to represent x in * two&#x27;s complement * Examples: howManyBits(12) = 5 * howManyBits(298) = 10 * howManyBits(-5) = 4 * howManyBits(0) = 1 * howManyBits(-1) = 1 * howManyBits(0x80000000) = 32 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 90 * Rating: 4 */int howManyBits(int x)&#123; /* 简单画下这个函数的图像, 注意到 x 与 -x - 1(即~x) 耗费位数相同, 那就先统一转换成非负数, * 然后找到最高的值为1的位数, 设其为 k, k + 1 即为结果 * 比如 0000 ... 0010 0110 的结果为 6 + 1 = 7 * * 那怎么找到最高的值为1的位数呢? * 一种想法是 sum([!!(alternatex &gt;&gt; k) for k in range(32)]), 但这样用的操作就超过限制了 * 所以我们借助二分的思想 * 让我们举个例子, 假设我们在处理 0010 1101, * 我们可以先把它右移4, 发现仍然大于0, 就令ans += 4, 此时值为 0010 (扔掉右半部分) * 然后右移2, 发现等于0, 则不在数据上真正移动, 值为 10 (扔掉左半部分) * 再右移1, 发现大于0, 令 ans += 1, 此时值为 1 (扔掉右半部分) * 当前的值不为0, ans +=1 (ans之前加了&quot;被移除的部分的长度&quot;, 这里还要加上&quot;剩余的部分的长度&quot;) * 综上, 0010 1101 的最高的值为1的位数为6 * * 首先我们要能够检查右移后值是否为0, 用!!(x &gt;&gt; k) 即可, !!(x &gt;&gt; k) == (x 右移后值为0) ? 0 : 1 * 然后为了方便在值上进行移动, 我们希望有 f(x) = (x 右移后值为0) ? 0 : 右移长度 * 因此使用形如 !!(x &gt;&gt; (2**k)) &lt;&lt; k 的东西 */ int signX = x &gt;&gt; 31; // (x &gt;= 0) ? 00...0 : 11...1 int alternatex = ((~(signX)) &amp; x) + ((signX) &amp; (~x)); // (x &gt;= 0) ? x : -x-1 int bit16 = (!!(alternatex &gt;&gt; 16)) &lt;&lt; 4; // (alternatex &gt;= 2**16) ? 16 : 0 alternatex = alternatex &gt;&gt; bit16; int bit8 = (!!(alternatex &gt;&gt; 8)) &lt;&lt; 3; alternatex = alternatex &gt;&gt; bit8; int bit4 = (!!(alternatex &gt;&gt; 4)) &lt;&lt; 2; alternatex = alternatex &gt;&gt; bit4; int bit2 = (!!(alternatex &gt;&gt; 2)) &lt;&lt; 1; alternatex = alternatex &gt;&gt; bit2; int bit1 = (!!(alternatex &gt;&gt; 1)); alternatex = alternatex &gt;&gt; bit1; int bit0 = (!!alternatex); return bit16 + bit8 + bit4 + bit2 + bit1 + bit0 + 1;&#125; 浮点数部分浮点数部分比起整数部分简单得多，只要仔细地分类讨论就行了。 floatScale2分类讨论即可。这里比较有趣的是 exp &#x3D;&#x3D; 0（denormalized case）的情况，无论 frac 部分是否超过 23 位，处理的代码都是一样的。 12345678910111213141516171819202122232425262728293031323334353637383940414243/* * floatScale2 - Return bit-level equivalent of expression 2*f for * floating point argument f. * Both the argument and result are passed as unsigned int&#x27;s, but * they are to be interpreted as the bit-level representation of * single-precision floating point values. * When argument is NaN, return argument * Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while * Max ops: 30 * Rating: 4 */unsigned floatScale2(unsigned uf)&#123; /* 取出 exp 的部分, 分三种情况讨论. * 1. NaN or infin, 直接返回输入值 * 2. denormalized case, 主要修改 frac 部分, 如果修改导致 frac * 部分多于 23 位, 还要修改 exp 部分 * 3. normalized case, 修改 exp 部分 */ unsigned exp = (uf &gt;&gt; 23) &amp; 0xFF; // 00...0 exp // 如果 exp == 二进制(1111 1111), uf为 NaN 或 infin, 直接返回uf if (exp == 0xFF) &#123; return uf; &#125; // 如果 exp == 0, 就是 denormalized case else if (exp == 0) &#123; unsigned frac = (uf &lt;&lt; 9) &gt;&gt; 9; // 0 00000000 frac // 如果 frac 部分最高值为1, 进位; 如果不为1, 把 frac 部分乘二即可 // 两种情况都能用下面的代码来表示 frac = frac &lt;&lt; 1; return ((uf &gt;&gt; 23) &lt;&lt; 23) + frac; // (s exp 00...0) + (0 00000000 frac) &#125; // normalized case else &#123; // exp不会溢出8位, 因为前面的 if 分支已经处理了 exp == 0xFF的情况 exp += 1; unsigned expmask = (~0) ^ (0xFF &lt;&lt; 23); // 1 00000000 11...1 return (uf &amp; expmask) + (exp &lt;&lt; 23); &#125;&#125; floatFloat2Int同样是分类讨论。一开始我把 NaN、infin 单独写了一种情况处理，后面发现操作数太多超出了限制，于是把它和绝对值太大的情况统一了起来，毕竟它们的返回值一样。 这里要仔细考虑的是 Tmin 落入的分支，在我的代码里，Tmin 落入了第一个 if 分支。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/* * floatFloat2Int - Return bit-level equivalent of expression (int) f * for floating point argument f. * Argument is passed as unsigned int, but * it is to be interpreted as the bit-level representation of a * single-precision floating point value. * Anything out of range (including NaN and infinity) should return * 0x80000000u. * Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while * Max ops: 30 * Rating: 4 */#include &lt;stdio.h&gt;int floatFloat2Int(unsigned uf)&#123; int exp = (uf &gt;&gt; 23) &amp; 0xFF; // 00...0 exp unsigned frac = (uf &lt;&lt; 9) &gt;&gt; 9; // 00...0 frac // 绝对值太大的情况 // 注意 NaN, infin也在这种情况中, 此时 exp == 0xFF // -2^(31) 也在这种情况中, 此时 exp == 127 + 31, frac == 0 if (exp &gt;= 127 + 31) &#123; return (1 &lt;&lt; 31); &#125; // 绝对值太小的情况 else if (exp &lt; 127) &#123; return 0; &#125; // 绝对值位于 [0, 2^(31) - 1] 的情况 // 该分支中, 0 &lt;= exp - 127 &lt; 31 else &#123; int e = exp - 127; int abs; frac += (1 &lt;&lt; 23); // 如果 e 足够大, 保留 frac 里的所有数字, 否则舍弃后几位数字 if (e &gt;= 23) &#123; abs = frac &lt;&lt; (e - 23); &#125; else &#123; abs = frac &gt;&gt; (23 - e); &#125; // 根据正负返回不同值 // positive case if ((uf &gt;&gt; 31) == 0) &#123; return abs; &#125; // negative case else &#123; return (~abs) + 1; &#125; &#125;&#125; floatPower2还是分类讨论，不多说了。 1234567891011121314151617181920212223242526272829303132333435363738/* * floatPower2 - Return bit-level equivalent of the expression 2.0^x * (2.0 raised to the power x) for any 32-bit integer x. * * The unsigned value that is returned should have the identical bit * representation as the single-precision floating-point number 2.0^x. * If the result is too small to be represented as a denorm, return * 0. If too large, return +INF. * * Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while * Max ops: 30 * Rating: 4 */unsigned floatPower2(int x)&#123; /* float 可以表示的 2的幂次的范围为 [2^(-149), 2^(127)], * 其中 [2^(-149), 2^(-127)] 由 denormalized case 表示, * [2^(-126), 2^(127)] 由 normalized case 表示 */ if (x &lt; -149) &#123; return 0; &#125; // denormalized case else if (x &lt;= -127) &#123; return 1 &lt;&lt; (x + 149); // 只处理 frac 部分 &#125; // normalized case else if (x &lt;= 127) &#123; return (x + 127) &lt;&lt; 23; // 只处理 exp 部分 &#125; else &#123; return (0xFF &lt;&lt; 23); // +INF &#125;&#125;","categories":[{"name":"学习","slug":"学习","permalink":"http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"公开课","slug":"学习/公开课","permalink":"http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"CMU-15-213","slug":"学习/公开课/CMU-15-213","permalink":"http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/"},{"name":"Labs","slug":"学习/公开课/CMU-15-213/Labs","permalink":"http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/Labs/"}],"tags":[]},{"title":"写完了datalab，突然感觉好孤单","slug":"others/thoughts/写完了datalab，突然感觉好孤单","date":"2025-02-21T11:49:30.000Z","updated":"2025-03-01T10:08:57.724Z","comments":true,"path":"wiki/others/thoughts/写完了datalab，突然感觉好孤单/","permalink":"http://rinevard.github.io/wiki/others/thoughts/%E5%86%99%E5%AE%8C%E4%BA%86datalab%EF%BC%8C%E7%AA%81%E7%84%B6%E6%84%9F%E8%A7%89%E5%A5%BD%E5%AD%A4%E5%8D%95/","excerpt":"","text":"一个寒假过去，把手头上最喜欢的设计简单做了个原型，确实不错。不过由于代码水平太低，另一个同样喜欢的设计没能实现出来。原本想在这学期做一个比较完整的游戏的，但认真想了想，凭我现在的代码水平，恐怕根本做不了。还是要提高一下自己的代码水平才行，于是这学期打算认真打打基础，从 15213 开始。 今天写掉了 datalab。凭借自己的努力做完了一个很难的作业，当然会感到很欢喜，可站起来准备回寝时，突然感到很孤单。“没有学分，没有绩点，没有老师，没有同学，只有一个信念 —— 你在变强。”或许吧，我在变强。变强之后呢？应该就能写出更漂亮的代码，不带妥协地实现自己的想法了吧。 更新：今天（2025.3.1）在寝室写完了 bomblab，感觉很开心，并没有什么孤单的感觉。顺便看了看母鸡卡的新假药，萌战吧的吧友们即使在滑坡大环境下也坚持造药，这就是我们的黄金精神！ /* 隐藏草书 */ .hidden-text { font-size: 18px; text-align: center; margin: 20px 0; /* padding: 20px; */ line-height: 1.5; color: transparent; cursor: default } .hidden-fancy-text::selection { color: black; background: white; } 凝视我曾凝视的光芒，触摸你将触摸的远方。","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/"},{"name":"碎碎念","slug":"杂谈/碎碎念","permalink":"http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}],"tags":[]},{"title":"母鸡卡的各种神奇假药","slug":"others/animation/母鸡卡的各种神奇假药","date":"2025-02-15T13:31:31.000Z","updated":"2025-03-02T06:39:33.065Z","comments":true,"path":"wiki/others/animation/母鸡卡的各种神奇假药/","permalink":"http://rinevard.github.io/wiki/others/animation/%E6%AF%8D%E9%B8%A1%E5%8D%A1%E7%9A%84%E5%90%84%E7%A7%8D%E7%A5%9E%E5%A5%87%E5%81%87%E8%8D%AF/","excerpt":"","text":"整理一下我觉得很有趣的假药，太真的和我不感兴趣的就不放进来了。 关于整体走向的假药时间轮回说时间轮回 是第九集出现的假药 第九集灾难般的爆爆爆让许多假药的讨论度都大幅下降，不过时间乱序说重新登场，更是出现了时间轮回说。（致敬传奇第十话——我的战场不在这里） 我感觉时间轮回不太可能，不过这个想法太酷了！至于时间乱序，最明显的证据是第九集 18:40 和第二集 13:34 能连起来。或许可以结合瞳孔变化说来看看第二集是 mortis 还是睦头？ 那么贯穿全剧，把时间重排起来的线索是什么呢？一种说法是手机电量 叙诡说叙诡说 是第二集出现的假药，在三四集得到完善，第五集后讨论度大幅下降。 前四集剧情跳跃、旁白由初华声优念出是因为这是初华在叙述故事！那么，是在对谁讲述呢？ 一种假药是初华对失忆的祥子讲述故事，在叙述中美化自己，好让祥子待在自己身边。理由是祥子在前四集唯独对初华态度比较好，这是初华对自己的美化。 另一种是初华对自己讲述故事，只是在自我欺骗“乐队依然存在”，因此剧本漏洞百出。但无论叙述多少次，乐队都逃不掉解散的结局。 上面的蓝色链接是“初华对自己讲述故事”。 内鬼内鬼说 是第四集出现的假药，主要用于解释观感奇怪的解散。 母鸡卡解散的剧情逻辑混乱，这是因为队里有内鬼，内鬼只要把队解散掉就行了。由于我比较喜欢祥子，所以我接下来讲全队内鬼，祥子 1vn 的剧情。 整个事务所都是丰川家族安排的内鬼，上到其他乐队成员下到工作人员，都对“丰川家希望祥子回家”这件事或多或少有了解，因此工作人员浑水摸鱼，除了祥子以外的乐队成员都不在乎乐队。祥子 1vn 硬生生把母鸡卡带到了武道馆，不愧是美强惨大女主，数值太高了。 这太数值怪啦，不合理的！不过内鬼说还是很有趣而且很靠谱的，我觉得比较真的是初华喵梦内鬼，睦和海玲知情。 人偶人偶说 是第七集出现的假药。 mujica 结尾全员人偶化。“在 mujica 的短暂月光下，五个人偶短暂的复活了，在舞台上高歌一曲。给出了一场完美 live。” 关于个人的假药初华蜘蛛侠蜘蛛侠 其实初华的真实身份是蜘蛛侠，各种蜘蛛意象是暗示初华被蜘蛛咬过。能力越大，责任越大，蜘蛛侠要打击犯罪，所以既不去 Mujica 排练，也不去 sumimi 排练，还说自己忙。初华让祥子在门口等 10 秒其实是在藏蜘蛛战衣，她 10 秒就能收拾好房间、第三集隔着几十米听到祥子和睦的对话都是因为她有超能力。众所周知祥子是蓝色章鱼，初华把祥子带到自己家实际上是为了监视章鱼博士。而且，既然有双面人睦、企鹅人高松灯、章鱼博士祥子，有蜘蛛侠初华也不奇怪。 叙诡叙诡说 之前已经提过，这里的链接是第二集播出后的初版假药。 之前已经说过了，旁白由初华的声优念出、前几集逻辑诡异，都是因为这是初华讲述的故事。初华是母鸡卡故事的叙述者。 缓存不足缓存不足说 是第四集出现的假药。 “初华对某些记忆的深刻程度，可能不会被时间冲淡，而一些日常记忆可能会被很快的忘却。在她心目中，自己和心爱的祥子度过的每个夏天、出道时祥子发来的短信鼓励可能一直占据着她脑内非常非常多的缓存。这些和祥子一起的快乐的记忆对初华来说可能就像是刚刚经历的一样，那份喜悦、甜蜜、饥渴就像冰一样无时无刻不在侵蚀初华的大脑，所以初华才会给人一种难以形容的超重女印象。” 认知障碍初华认知障碍说 是第一集出现的假药。 初华的眼里一直都只有祥子，别人的形象在她眼里是扭曲的。众所周知，MyGO 第八集里有初华的回忆，回忆里明显能看出初华见过祥子的人偶。然而在母鸡卡第二集里，她却好像是不认识人偶的样子。答案是初华在小时候将睦认知成了人偶。 失忆初华失忆说 是第二集出现的假药。 为什么初华如此空洞？为什么初华的童年记忆和祥子有偏差？为什么初华忘了祥子的玩偶？因为初华经历过一次失忆。初华拿着以前的日记本，努力扮演“真正的初华”。 祥子⭐ 压抑丰川祥子 ⭐ 压抑说 祥子对大雷情有独钟，组乐队是为了接近大雷。 人偶祥子人偶说 是第七集出现的假药，主要用于解释第七集祥子的形象变化。 第 7 集的祥子为了睦成为了舍弃自我的人偶，她装出了白祥的样子，因为“只要睦能回来就好了”。 祥爹演戏祥爹演戏说 是第五集出现的假药。 祥爹演戏把祥子气走，让祥子回归家族。 睦装双重人格睦装双重人格说 是第四集出现的假药。 如题，主要依据是第四集睦在初华车上的第一句“嗯”是睦的声线。 mortis 小小祥mortis 小小祥说 应该是第六集出现的假药。 睦小时候只有祥子一个朋友，mortis 是睦以白祥为模板塑造的人格，扮演小祥。 写文章时整理的假药链接 叙诡 内鬼说 人偶说 睦祥黑手说 圣经说 元素说 蜘蛛侠 叙诡说 缓存不足说 初华认知障碍说 初华失忆说 祥子失聪说 祥子人偶说 祥爹演戏说 睦装双重人格说 mortis 小小祥说 mortis 锡兵说 雨伞颜色 祥睦姐妹说 天天吃假药吃傻了做出来的冰山图 四演 mortis 四演祥子 歌剧魅影说","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/"},{"name":"二次元","slug":"杂谈/二次元","permalink":"http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/%E4%BA%8C%E6%AC%A1%E5%85%83/"}],"tags":[]},{"title":"探索","slug":"game-design/对探索类游戏的思考","date":"2025-02-14T12:36:38.000Z","updated":"2025-02-15T02:27:03.436Z","comments":true,"path":"wiki/game-design/对探索类游戏的思考/","permalink":"http://rinevard.github.io/wiki/game-design/%E5%AF%B9%E6%8E%A2%E7%B4%A2%E7%B1%BB%E6%B8%B8%E6%88%8F%E7%9A%84%E6%80%9D%E8%80%83/","excerpt":"","text":"为什么要探索呢？设想一下，如果我们乘上了飞船，飞入太空，忽然发现一颗行星朝着反方向转动了。这时你会不会想去那里？如果我们在网上发现了一个网站，点开第一个链接发现里面是你的家庭住址（我超，盒！），你会不会想继续翻别的链接？人类探索的动力被命名为好奇心，好奇驱动探索。 好吧，我们不妨把话说得更明白一些，好奇驱动探索的意思就是：“我相信那里有值得关注的东西，但不确切知道是什么，所以我要去探索。” 这听起来真的是再平凡不过的事情了，那就来分析一下怎么激发玩家的好奇心，再让好奇驱动探索吧。 相信有值得关注的东西在探索之前，首先要让玩家相信“那里有值得关注的东西”。值得关注的东西并不难做，它们可以是奇观、奖励乃至挑战，关键是怎样让玩家相信“那里有东西”。 做法很多，我们来找几个例子，看看关注探索感的游戏都是怎么做到这一点的。 首先来看类银河城游戏，对有经验的玩家，获得新能力就自然想到“以前有个过不去的路能靠这个能力过去”，然后也就想到“那里有值得关注的东西”；看到墙就自然想到假墙，然后就想到“那里有值得关注的东西”了。然而，这种做法过度依赖玩家的先验知识。对一个新接触类银河城的玩家来说，到处迷路才是更可能发生的事情，他们根本不知道“哪里有值得关注的东西”。 我想这也是类银河城游戏相对小众的原因，它只给有经验的玩家提供了探索感，而给新玩家提供了迷路感。能力锁尚且好说，假墙就实在是不利于探索感的塑造了，毕竟大多数玩家的先验知识是“墙体不可破坏”，根本就不会想到“墙后面有值得关注的东西”。不过假墙并非一无是处，它能给玩家一种“秘密”的感觉，这就是题外话了。所以说如果做类银河城，起码要提醒一下玩家这些设计的存在，而不是盲目地抄别的银河城的做法。在空洞骑士开局的时候，我们必须打碎一面墙才能前进，这就是一个不错的提醒。 接下来看看清单式开放世界。虽然在地图上到处塞问号的方法为人诟病，但这也确实非常清晰地把“那里有东西”传达给了玩家。那为什么为人诟病呢？主要是因为问号里的东西千篇一律，连“值得关注的东西”都没做到。那如果把每个问号都塞一个精美的支线，会好点吗？恐怕也不一定，因为被动地接受问号和主动发现问号带来的“值得关注感”是不一样的。自己找到的东西，就算再无聊也会想看完。 这里就不谈塞尔达了。说起来不太好意思，但我在玩的时候确实没感到什么探索欲望。一是我没感觉到哪里有东西，二是因为我也没感觉有什么值得我关注的东西。（球球了，不要开除我的玩家籍） 然后谈谈星际拓荒吧，这篇文章可以说就是为了星际拓荒而写的。星际拓荒的做法主要有两种，一种是奇观，另一种是非常直白地用文字告诉你“那里有东西”。前者不必多说，后者的文字描述本身也足以让玩家觉得那里“值得关注”。 不确切知道有什么这一点看起来不难实现，但和前一点结合起来就很难了。玩家玩了一段时间游戏后，很快就会对奖励有一定预期，如果做不到打破这种预期，就会让玩家丧失好奇心，丧失探索欲。 这一点在有经验的玩家身上体现的尤其明显。对一个普普通通的探索类游戏，他们对一切几乎都有预期，因此也会丧失探索欲。 其实，绝大多数游戏都让玩家丧失了探索欲，让我们以清单式开放世界为例，看看问号是如何让玩家失去探索欲的。 假设我们面前有一个玩家在玩游戏，我们看看会发生什么。玩家到了第一个问号，是一个有趣的战斗！玩家很开心。玩家到了第二个问号，是一个高级武器！玩家很开心。……玩家到了第 16 个问号，是一个已经重复过不知道多少遍的的战斗，在战斗结尾还奖励了一个高级武器！玩家对此早有预期，不再想去下一个问号了。 看见了吗，玩家就是这样丧失探索欲，沦为清问号机器的。 开放世界里的问号这么说来，把每个问号的内容都换成一个玩家猜不到是什么的精美的支线就能激发探索欲？这确实能改善现状，但也并非全然如此。问号始终没有完全做到让玩家觉得那个地方“值得关注”，毕竟问号是设计师在地图上标出来的，而不是玩家主动标出的。 许多类银河城里也提供了在地图上打标记的功能，我们可以横向对比一下。很明显，一张全是自己标出的问号的地图和一张全是游戏自带的问号的地图相比，前者更能激发探索欲。究其根本，就在于前者的每个问号都真的让玩家相信“那里有值得关注的东西”。 那么怎么改进开放世界里的问号呢？我也不确定。说到底问号这个东西根本就没让玩家觉得“那里有值得关注的东西”不是吗？终究要让玩家觉得自己是主动关注到那里的才行，问号还是太被动了。 文末写到这里，关于探索的内容就基本写完了，最后是一些让探索更有趣的小技巧，我随便列一些，不再详谈。 能力软锁：常见于类银河城。能力软锁不仅是关卡设计手段，也是控制可选路线数量的工具。限制选项数量的重要性不必多说。 线索：好的秘密需要提示，而非随机乱逛。我实在是欣赏不了到处乱藏东西的银河城。这还会涉及到电波式谜题（我感觉比“点击式谜题”更好理解）和逻辑谜题的差异，不详谈。 知识积累：游戏应该逐步教会玩家识别探索机会的能力，也被称作“知识锁”。 一个相当有趣的体验是“新视角”，即发现了过去没有发现的探索机会。能力成长、环境变化、知识积累都能带来新视角。其中我最喜欢的是环境变化和知识积累带来的新视角，大概是因为不常见吧。 让我们试试一个简单的传达探索的体验的 demo 。我们看到了下面的东西： 所以，这就是探索了？ 你好奇那里有什么吗？既然你读完了文章，希望你也会好奇作者还能整出什么新活吧。我本来应该在里面放置一些有趣的东西来满足你的好奇心，不过考虑到时间有限，就只能放个普通的彩蛋了。 /* 隐藏草书 */ .hidden-fancy-text { font-family: 'Brush Script MT', cursive; font-size: 20px; /* text-align: center; */ margin: 20px 0; /* padding: 20px; */ line-height: 1.5; color: transparent; cursor: default } .hidden-fancy-text::selection { color: darkred; background: white; } 如果作者在认真做游戏的话，我们也应该会见面的。","categories":[{"name":"游戏设计","slug":"游戏设计","permalink":"http://rinevard.github.io/categories/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/"},{"name":"体验","slug":"游戏设计/体验","permalink":"http://rinevard.github.io/categories/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E4%BD%93%E9%AA%8C/"}],"tags":[]},{"title":"建站过程","slug":"about-blog/建站过程","date":"2025-02-06T02:34:53.000Z","updated":"2025-02-06T05:01:57.758Z","comments":true,"path":"wiki/about-blog/建站过程/","permalink":"http://rinevard.github.io/wiki/about-blog/%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B/","excerpt":"","text":"本站成功搭建的最大功臣是 Claude-3.5-sonnet，在这类复杂但并不困难的任务上，和 AI 合作真是再合适不过了。本文简要复盘一下整个网站的搭建过程，顺便提醒一下未来的自己一些 Hexo 的基本操作。 网站搭建写完 2024 年度总结之后，就有了重新搭建博客的想法。随便翻了翻几个同学的博客，感觉挺不错的，于是决定去问 Claude 怎么搭博客。这次肯定不会像第一次建站一样随便挑个主题就用上去，也不会像（这次之前的）最后一次建站一样从头开始自己写。认真找找合适的主题，然后用上就好了。 我的主要诉求是：写作方便、用树状结构收纳文章，小克推荐了 Hexo 的 NexT.Pisces 和 Wikitten 两个主题以及 VitePress。由于有 Hexo 的使用经验，就选了 Hexo。由于一时半会没找到 NexT.Pisces 是什么，就用了 Wikitten. 写得我都困了，我们的建站过程没有什么奇幻色彩吗？ 有的有的，今天早上断网了，把路由器复位了一下才重新开始建站。 选好了方案之后，就可以按部就班地和 Claude 一起建站了。不懂的就去问 Claude，它都懂的。 基本操作最常用的三件套： 123hexo clean # 清理缓存，似乎在修改了配置文件以后可以用一用hexo g # g 是 generate 的缩写。生成静态文件hexo s # s 是 server 的缩写。服务器，启动！ 增删文章、文件夹设置、部署到 GitHub page： 删除文章 直接删除 source/_posts 目录下的对应 .md 文件即可 新增文章 1hexo new post &quot;我是一只鲤鱼。我是一只鲤鱼吗？我觉得我是。&quot; 这会生成一个标题为”我是一只鲤鱼。我是一只鲤鱼吗？我觉得我是。”的文章。 设置多层文件夹 在文章头部这样写： 123456---title: 睡觉入门到精通categories: - 生活 - 睡觉技巧--- 生成和部署 123hexo cleanhexo generatehexo deploy 如果是新建的站，部署前要修改配置文件的 deploy 部分哦，修改过一次以后就不用再改了。不懂问 Claude。 可以在根目录的 _config.yml 和的 themes 的 _config.yml 里调整配置文件。 （可能的）后续改进我比较关心的改进是侧边栏收缩来全屏浏览笔记、配色调整。","categories":[{"name":"关于本站","slug":"关于本站","permalink":"http://rinevard.github.io/categories/%E5%85%B3%E4%BA%8E%E6%9C%AC%E7%AB%99/"}],"tags":[]},{"title":"欢迎！","slug":"欢迎！","date":"2025-02-06T02:25:53.000Z","updated":"2025-02-06T13:41:24.805Z","comments":true,"path":"wiki/欢迎！/","permalink":"http://rinevard.github.io/wiki/%E6%AC%A2%E8%BF%8E%EF%BC%81/","excerpt":"","text":"这是一篇欢迎文章，欢迎来到我的网站！ 网站好像不是很漂亮？我承诺会改改的！让我先为你介绍一下网站的基本布局。 如你所见，左边是网站的文章列表，以文件夹的形式排布；左上方是几个按钮，“关于”是我的自我介绍，“历史”记录了文章的诞生时间线，如果迷路了，点击“首页”或者左上角的“Rinevard”就能回到这里了。在很多博客里，文章的诞生时间线被叫做“归档”，不过我觉得这个名字并不清晰，于是改成了“历史”。 本网站使用了 Hexo 的 Wikitten 主题，在我看来，其最大优点是以文件夹的形式排布文章。博客的文章应当成体系且便于检索，而非一篇一篇堆积在网站上，构成凌乱的山。这一功能值得放在最高优先级，因此外表稍微简陋一点也无所谓了。 我应该主要会在这里放一些杂谈和游戏相关的文章，欢迎来看！","categories":[],"tags":[]}],"categories":[{"name":"学习","slug":"学习","permalink":"http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"公开课","slug":"学习/公开课","permalink":"http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"CMU-15-213","slug":"学习/公开课/CMU-15-213","permalink":"http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/"},{"name":"Notes","slug":"学习/公开课/CMU-15-213/Notes","permalink":"http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/Notes/"},{"name":"Labs","slug":"学习/公开课/CMU-15-213/Labs","permalink":"http://rinevard.github.io/categories/%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%80%E8%AF%BE/CMU-15-213/Labs/"},{"name":"杂谈","slug":"杂谈","permalink":"http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/"},{"name":"碎碎念","slug":"杂谈/碎碎念","permalink":"http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"},{"name":"二次元","slug":"杂谈/二次元","permalink":"http://rinevard.github.io/categories/%E6%9D%82%E8%B0%88/%E4%BA%8C%E6%AC%A1%E5%85%83/"},{"name":"游戏设计","slug":"游戏设计","permalink":"http://rinevard.github.io/categories/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/"},{"name":"体验","slug":"游戏设计/体验","permalink":"http://rinevard.github.io/categories/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E4%BD%93%E9%AA%8C/"},{"name":"关于本站","slug":"关于本站","permalink":"http://rinevard.github.io/categories/%E5%85%B3%E4%BA%8E%E6%9C%AC%E7%AB%99/"}],"tags":[]}